<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神奇小站</title>
  
  <subtitle>这里总有神奇的东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://colalinn.github.io/"/>
  <updated>2020-01-28T14:59:59.167Z</updated>
  <id>https://colalinn.github.io/</id>
  
  <author>
    <name>ColaLinN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020-1-28-leetcode</title>
    <link href="https://colalinn.github.io/2020/01/28/2020-1-28-leetcode/"/>
    <id>https://colalinn.github.io/2020/01/28/2020-1-28-leetcode/</id>
    <published>2020-01-28T14:59:59.000Z</published>
    <updated>2020-01-28T14:59:59.167Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2020-1-27-leetcode</title>
    <link href="https://colalinn.github.io/2020/01/28/2020-1-27-leetcode/"/>
    <id>https://colalinn.github.io/2020/01/28/2020-1-27-leetcode/</id>
    <published>2020-01-28T14:59:41.000Z</published>
    <updated>2020-01-28T14:59:41.028Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2020-1-26-leetcode</title>
    <link href="https://colalinn.github.io/2020/01/26/2020-1-26-leetcode/"/>
    <id>https://colalinn.github.io/2020/01/26/2020-1-26-leetcode/</id>
    <published>2020-01-26T12:10:26.000Z</published>
    <updated>2020-01-29T04:17:45.683Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. Longest Palindromic Substring</a></h4><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length_s=s.length(),length_Palin=<span class="number">1</span>;</span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> first,second,first_next,second_next;</span><br><span class="line">        <span class="keyword">if</span>(length_s==<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(length_s&gt;<span class="number">1</span>) result=s.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(first=<span class="number">0</span>,second=<span class="number">1</span>;second&lt;length_s;first++,second++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(first)==s.charAt(second))&#123;</span><br><span class="line">                first_next=first;second_next=second;</span><br><span class="line">                <span class="keyword">while</span>(first_next-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; second_next+<span class="number">1</span>&lt;length_s &amp;&amp; s.charAt(first_next-<span class="number">1</span>)==s.charAt(second_next+<span class="number">1</span>))&#123;</span><br><span class="line">                    first_next--;</span><br><span class="line">                    second_next++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result.length()&lt;second_next-first_next+<span class="number">1</span>)&#123;</span><br><span class="line">                    result=s.substring(first_next, second_next+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(second&lt;=length_s-<span class="number">2</span>&amp;&amp;s.charAt(second-<span class="number">1</span>)==s.charAt(second+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                first_next=second-<span class="number">1</span>;second_next=second+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(first_next-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; second_next+<span class="number">1</span>&lt;length_s &amp;&amp; s.charAt(first_next-<span class="number">1</span>)==s.charAt(second_next+<span class="number">1</span>))&#123;</span><br><span class="line">                    first_next--;</span><br><span class="line">                    second_next++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result.length()&lt;second_next-first_next+<span class="number">1</span>)&#123;</span><br><span class="line">                    result=s.substring(first_next, second_next+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5-Longest-Palindromic-Substring&quot;&gt;&lt;a href=&quot;#5-Longest-Palindromic-Substring&quot; class=&quot;headerlink&quot; title=&quot;5. Longest Palindromic Substri
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://colalinn.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://colalinn.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>搭建机场简易教程shadowsocks centos7 vutlr bbr</title>
    <link href="https://colalinn.github.io/2020/01/26/shadowsocks-centos7-vutlr-bbr/"/>
    <id>https://colalinn.github.io/2020/01/26/shadowsocks-centos7-vutlr-bbr/</id>
    <published>2020-01-26T11:40:57.000Z</published>
    <updated>2020-01-26T12:14:37.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）"><a href="#1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）" class="headerlink" title="1.获得vutlr服务器后(包含ip、用户名和密码)使用Xshell连接（其他连接器请自行百度）"></a>1.获得vutlr服务器后(包含ip、用户名和密码)使用Xshell连接（其他连接器请自行百度）</h2><h2 id="2-依次输入以下代码安装shadowsocks"><a href="#2-依次输入以下代码安装shadowsocks" class="headerlink" title="2.依次输入以下代码安装shadowsocks"></a>2.依次输入以下代码安装shadowsocks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><h4 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget –no-check-certificate -O shadowsocks.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.sh</span><br></pre></td></tr></table></figure><h4 id="获取shadowsocks-sh读取权限"><a href="#获取shadowsocks-sh读取权限" class="headerlink" title="获取shadowsocks.sh读取权限"></a>获取shadowsocks.sh读取权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shadowsocks.sh</span><br></pre></td></tr></table></figure><h4 id="设置个人shadowsocks密码和端口号"><a href="#设置个人shadowsocks密码和端口号" class="headerlink" title="设置个人shadowsocks密码和端口号"></a>设置个人shadowsocks密码和端口号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p>然后依次输入你的密码password、端口号(就是ss服务的端口号，后面连接使用)、加密模式(很多人推荐7 aes-256-cfb)</p><p>按任意键开始配置press any key to start，如果是第一次配置需要几分钟</p><h4 id="配置完之后可以看到用四行红字"><a href="#配置完之后可以看到用四行红字" class="headerlink" title="配置完之后可以看到用四行红字"></a>配置完之后可以看到用四行红字</h4><p>这个就是我们shadowsocks的连接信息了,其中除了ip是服务器自带的，端口、密码、加密模式都是我们自选的</p><h2 id="3-安装拥塞控制BBR加速上网"><a href="#3-安装拥塞控制BBR加速上网" class="headerlink" title="3.安装拥塞控制BBR加速上网"></a>3.安装拥塞控制BBR加速上网</h2><h4 id="安装BBR"><a href="#安装BBR" class="headerlink" title="安装BBR"></a>安装BBR</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br></pre></td></tr></table></figure><h4 id="获得读取权限"><a href="#获得读取权限" class="headerlink" title="获得读取权限"></a>获得读取权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x bbr.sh</span><br></pre></td></tr></table></figure><h4 id="启动BBR安装"><a href="#启动BBR安装" class="headerlink" title="启动BBR安装"></a>启动BBR安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bbr.sh</span><br></pre></td></tr></table></figure><p>这步安装也蛮久的</p><p>按任意键安装，完成之后提示是否重启，输入y确定重启</p><p>重启之后</p><p>输入以下的指令查看BBR是否启动，若提示tcp_bbr则成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><h2 id="4-在客户端配置ss，享受你的丝滑ss吧"><a href="#4-在客户端配置ss，享受你的丝滑ss吧" class="headerlink" title="4.在客户端配置ss，享受你的丝滑ss吧"></a>4.在客户端配置ss，享受你的丝滑ss吧</h2><hr><p>参考链接</p><p>1.使用vultr(vps)搭建ss并开启BBR快速上网教程 超简单10分钟搞定</p><p><a href="https://wistbean.github.io/vultr-vps-bbr-ss.html" target="_blank" rel="noopener">https://wistbean.github.io/vultr-vps-bbr-ss.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）&quot;&gt;&lt;a href=&quot;#1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="shadowsocks" scheme="https://colalinn.github.io/categories/shadowsocks/"/>
    
    
      <category term="shadowsocks" scheme="https://colalinn.github.io/tags/shadowsocks/"/>
    
      <category term="vpn" scheme="https://colalinn.github.io/tags/vpn/"/>
    
      <category term="centos" scheme="https://colalinn.github.io/tags/centos/"/>
    
      <category term="vutlr" scheme="https://colalinn.github.io/tags/vutlr/"/>
    
  </entry>
  
  <entry>
    <title>pRide具体方案</title>
    <link href="https://colalinn.github.io/2020/01/23/2020-1-23-pRide-optimized-construction/"/>
    <id>https://colalinn.github.io/2020/01/23/2020-1-23-pRide-optimized-construction/</id>
    <published>2020-01-23T08:05:04.000Z</published>
    <updated>2020-01-31T09:18:44.518Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/23/2020-1-23-pRide-optimized-construction/image-20200123162426100.png" alt="图1"></p><p>这是一篇pRide具体方案的翻译简化版。</p><a id="more"></a><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>初始方案暂且不谈，先说优化方案。</p><p>一：地图分块，减少计算量</p><p>二：把路网嵌入向量打包起来，使得加密等操作可以一步完成</p><h3 id="步骤：Setup、Location-update、Ride-request、Ride-matching"><a href="#步骤：Setup、Location-update、Ride-request、Ride-matching" class="headerlink" title="步骤：Setup、Location-update、Ride-request、Ride-matching"></a>步骤：Setup、Location-update、Ride-request、Ride-matching</h3><p>为了保证分块后的精度，我们首先寻找与乘客所处区域α的最近司机，再以乘客到该司机的距离为半径来判断区域α周围的区域是否划入范围（就是看以该距离为半径的圆是否“触”到了周围区域）</p><h3 id="使用技术："><a href="#使用技术：" class="headerlink" title="使用技术："></a>使用技术：</h3><p>路网嵌入（ROAD NETWORK ENBEDDING），用于提高最短距离计算效率</p><p>同态加密 （Homomorphic），用于提供密文状态下的加法（及乘法）同步到明文中</p><p>混淆电路（Garbled Circuit），用于提供CP（Crypto Provider）和ORH服务器的安全两方计算、有点像零知识证明</p><h3 id="一、初始化-Setup"><a href="#一、初始化-Setup" class="headerlink" title="一、初始化   Setup"></a>一、初始化   Setup</h3><p>1.ORH   地图分块(如图1所示)</p><p><img src="/2020/01/23/2020-1-23-pRide-optimized-construction/image-20200123162426100.png" alt="图1"></p><p>​                                                                                  图  1</p><p>2.ORH   计算  地图道路的   路网嵌入向量</p><p>3.CP   初始化同态加密公钥并分发</p><h3 id="二、司机-位置更新-Location-update"><a href="#二、司机-位置更新-Location-update" class="headerlink" title="二、司机 位置更新   Location-update"></a>二、司机 位置更新   Location-update</h3><p>此步骤主要用于司机上传自己的位置信息（在pRide里是上传自己的路网嵌入信息）</p><p>1.司机端   计算自己的路网嵌入变量S</p><p>根据从服务器获取的地图道路路网嵌入向量、来在本地计算自己的路网嵌入向量S（这在路网嵌入已经讲过了）</p><p>2.司机端   把S打包成一个变量P</p><p>就是像进制位一样叠加维度S(如图2)</p><p><img src="/2020/01/23/2020-1-23-pRide-optimized-construction/image-20200123162003661.png" alt="图2"></p><p>​                                                                                  图  2</p><p>3.司机端   把P用从CP获得的公钥加密成[P(b)]，把这个[P(b)]和所处区域Zα上传到ORH</p><p>4.ORH   随机生成一个路网嵌入向量u，并加密之成[P(u)]</p><p>5.ORH   使用[P(b)]-[P(u)]=&gt;[P(b‘)]</p><h3 id="三、乘客-乘车请求-Ride-request"><a href="#三、乘客-乘车请求-Ride-request" class="headerlink" title="三、乘客 乘车请求   Ride-request"></a>三、乘客 乘车请求   Ride-request</h3><p>1.乘客端   把自己的坐标x、y加密为[x]、[y]</p><p>2.乘客端   计算自己的路网嵌入向量S、打包、加密之得到[P(a)]</p><p>3.乘客端 上传[P(a)]、[x]、[y]、所处区域Zα给ORH</p><p>4.ORH   随机生成两随机数ηx、ηy，把其当做一个坐标值，计算其的网嵌入向量S、打包、加密之得到[P(η)]</p><p>5.ORH   计算    [P(η)]-[P(a)]=》[P(a’)]       ;        [x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]</p><p>《第五步是为了在4.2提高匹配精度的阶段判断坐标，所以把坐标也放到了距离向量中[P(a)]》</p><h3 id="四、ORH-乘车匹配-Ride-matching"><a href="#四、ORH-乘车匹配-Ride-matching" class="headerlink" title="四、ORH 乘车匹配   Ride-matching"></a>四、ORH 乘车匹配   Ride-matching</h3><h4 id="4-1-乘客所属区域zα匹配-Local-Zone-matching"><a href="#4-1-乘客所属区域zα匹配-Local-Zone-matching" class="headerlink" title="4.1.乘客所属区域zα匹配    Local Zone matching"></a>4.1.乘客所属区域zα匹配    Local Zone matching</h4><p>1.ORH   计算   [P(d)’]=[P(a)]-[P(b‘)]=[P(a)]-[P(b)]+[P(u)]</p><p>2.ORH   将 [P(d)’]发给CP</p><p>3.CP   解密 [P(d)’]得到 P(d)’、并且获得其混淆值 ~P(d)’   《这里的混淆电路还不太明白怎么操作的》</p><p>4.ORH   通过1-out-of-2 OT protocol 获得[P(u)]的混淆值  ~[P(u)]</p><p>5.通过算法2(如图3)判断两个司机哪个离乘客近</p><p>算法注释：</p><p>第一、二步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p><p>第三、四步同上计算第二个司机到该乘客的最近距离</p><p>第五步是判断哪个司机离乘客近</p><p><img src="/2020/01/23/2020-1-23-pRide-optimized-construction/image-20200123170731309.png" alt="图3"></p><p>​                                                            图  3   上为算法、下为混淆电路</p><h4 id="4-2-提高匹配精度-Refinement"><a href="#4-2-提高匹配精度-Refinement" class="headerlink" title="4.2.提高匹配精度   Refinement"></a>4.2.提高匹配精度   Refinement</h4><p>1.ORH   把4.1中计算出来的，乘客所处区域zα与最近司机的[P(d)’] (4.1.1中计算)、</p><p>与[x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]都发给CP</p><p>2.CP   将其解密并获得混淆值 <del>P(d)’、</del>[x’]、~[y’]</p><p>3.ORH   通过1-out-of-2 OT protocol 获得~[P(η)]    ;        ~[ηx]    ;        ~[ηy]</p><p>4.通过如下图算法3(如图4)判断其他八块区域za1, za2, za3, za4, za5, za6, za7,za8（具体见图1）是否有需要计算的必要</p><p>算法注释：</p><p>第四步是计算乘客的坐标x、y</p><p>第五、六步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p><p>第七步是计算Γ   Γ是一个8位的二进制数，每一位指示一个区域是否该计算（就是看以该距离为半径的圆是否“触”到了周围区域，具体看图1）</p><p>第八步是判断 区域zα4是否该计算，后面9到15步同理，是很简单的距离判断（见图一）</p><p><img src="/2020/01/23/2020-1-23-pRide-optimized-construction/image-20200123171733353.png" alt="图4"></p><p><img src="/2020/01/23/2020-1-23-pRide-optimized-construction/image-20200123171824965.png" alt="图4"></p><p>​                                                            图  4   上为算法、下为混淆电路</p><p>5.通过算法3获得有需要计算得必要的其他区域、</p><p>然后通过4.1Local Zone matching算法计算该区域中离乘客最近的司机，若该司机到乘客的距离B比乘客到本区域最短距离A小，就刷新最短距离A。最终我们得到距离最近的司机，并且将乘客位置信息发送给他………</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/01/23/2020-1-23-pRide-optimized-construction/image-20200123162426100.png&quot; alt=&quot;图1&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是一篇pRide具体方案的翻译简化版。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大创" scheme="https://colalinn.github.io/categories/%E5%A4%A7%E5%88%9B/"/>
    
    
      <category term="pRide" scheme="https://colalinn.github.io/tags/pRide/"/>
    
  </entry>
  
  <entry>
    <title>路网嵌入 ROAD NETWORK EMBEDDING</title>
    <link href="https://colalinn.github.io/2020/01/22/2020-1-22-ROAD-NETWORK-EMBEDDING/"/>
    <id>https://colalinn.github.io/2020/01/22/2020-1-22-ROAD-NETWORK-EMBEDDING/</id>
    <published>2020-01-22T09:51:25.000Z</published>
    <updated>2020-01-29T03:26:23.521Z</updated>
    
    <content type="html"><![CDATA[<p>路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。</p><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。</p><blockquote><p>Road Network Embedding (RNE), proposed by Shahabi et al.* [12], is an approach to compute shortest path distance in road networks, which bases on the LLR embedding techniques [19]. RNE transforms a road network into a higher dimensional space by assigning a sketch (i.e., a vector) to every node such that the distance between any two nodes can be efficiently approximated using only their sketches.</p></blockquote><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>(1) 设G=(V,E)为路网（road network）</p><p>V代表道路之间的交叉节点，E（edge）代表道路。</p><p>(2)  V有n个，把V分成<strong>n个子集</strong>如下</p><p>V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}</p><blockquote><p>Let n = |V | be the size of the node set V . Define R as a set of O(log2n) reference sets, which are subsets of V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}, where α = O(log n) and β = O(log n).</p><p> Each subset Vi,ji is defined as a random subset of <em>V</em> with 2<em>i</em> nodes randomly chosen from <em>V</em> . </p></blockquote><p>(3) 一个节点到一个子集Vij的距离即该节点到这个子集的最近距离所有节点距离的最小值</p><blockquote><p>The distance between node v and subset Vi,j is defined as dist(v, Vi,j ) = minw∈Vi,j dist(v, w)</p></blockquote><p>(4) 对于一个节点，把其到每个子集的最短距离记录下来，构成一个S集，这个S集就是该节点的<strong>路网嵌入向量</strong>，然后我们把所有的向量放在一起，构成路网嵌入数据集。</p><p><img src="/2020/01/22/2020-1-22-ROAD-NETWORK-EMBEDDING/image-20200122212143074.png" alt="4图"></p><p>(5) 假设一个点u，处于节点s和t之间，该节点u到某个子集Vij之间的距离可以如下公式计算，</p><p>dist(u，s)为点u到节点s的距离,dist(u,t)同理。</p><p><img src="/2020/01/22/2020-1-22-ROAD-NETWORK-EMBEDDING/image-20200122212358662.png" alt="aaa"></p><p>(6) 根据上面的分析，对于该点u，我们也可以得到一个<strong>路网嵌入向量</strong>如下</p><p><img src="/2020/01/22/2020-1-22-ROAD-NETWORK-EMBEDDING/image-20200122212654581.png" alt="6图"></p><p>(7) 最终，我们可以计算任意两点a,b的最短距离</p><p><img src="/2020/01/22/2020-1-22-ROAD-NETWORK-EMBEDDING/image-20200122212907442.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大创" scheme="https://colalinn.github.io/categories/%E5%A4%A7%E5%88%9B/"/>
    
    
      <category term="pRide" scheme="https://colalinn.github.io/tags/pRide/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用配置记录</title>
    <link href="https://colalinn.github.io/2020/01/20/20-1-20/"/>
    <id>https://colalinn.github.io/2020/01/20/20-1-20/</id>
    <published>2020-01-20T02:31:50.000Z</published>
    <updated>2020-01-29T04:12:19.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的hexo命令"><a href="#简单的hexo命令" class="headerlink" title="简单的hexo命令"></a>简单的hexo命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.文章的生成及编辑</span><br><span class="line">hexo new “文章标题”</span><br><span class="line">博客所在路径\source_posts\”下生成一个md文件，文件名称为上面命令行所输入的文章标题</span><br><span class="line"></span><br><span class="line">2.文件发布</span><br><span class="line">hexo g generate</span><br><span class="line"></span><br><span class="line">3.本地测试</span><br><span class="line">hexo s </span><br><span class="line">访问localhost:4000来查看变化</span><br><span class="line"></span><br><span class="line">4.同步到github</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line">5.Hexo更换主题并发布到github</span><br><span class="line">安装hexo-deployer-git自动部署发布工具</span><br><span class="line">npm install hexo-deployer-git  --save</span><br><span class="line">发布到GitHub</span><br><span class="line">输入如下命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line">6.如何一键式发布</span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br><span class="line">可用以下简化（注意事项：下面的命令中 C:\blog_backup 是我博客的文件夹路径，请替换为你自己博客的路径，在git bash中输入命令）以后可以用hexo fuck来发布了</span><br><span class="line">git config --global alias.fuck &#39;!cd C:\blog_backup;hexo clean;hexo g -d&#39;</span><br><span class="line">git fuck</span><br><span class="line">取消别名</span><br><span class="line">git config --global --unset alias.fuck</span><br></pre></td></tr></table></figure><h1 id="简单的markdown语法"><a href="#简单的markdown语法" class="headerlink" title="简单的markdown语法"></a>简单的markdown语法</h1><p><img src="/2020/01/20/20-1-20/markdown-program.jpg" alt="markdown语法"></p><hr><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>1.GitHub+Hexo搭建个人博客（包括更改主题）真·从git、node.js从头教起必看</p><p><a href="https://blog.csdn.net/qq_37651252/article/details/97024874" target="_blank" rel="noopener">https://blog.csdn.net/qq_37651252/article/details/97024874</a> </p><p>2.通过hexo更新github pages博客</p><p><a href="https://www.jianshu.com/p/5fe8e618002d" target="_blank" rel="noopener">https://www.jianshu.com/p/5fe8e618002d</a></p><p>3.更换主题并且发布</p><p><a href="https://www.jianshu.com/p/20e1431abb83" target="_blank" rel="noopener">https://www.jianshu.com/p/20e1431abb83</a></p><p>4.Hexo的Next主题详细配置</p><p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p><p>5.初级看板娘</p><p><a href="https://blog.csdn.net/weixin_33738982/article/details/89621120" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33738982/article/details/89621120</a></p><p>6.进阶版看板娘</p><p><a href="https://blog.csdn.net/qq_39610915/article/details/90679768" target="_blank" rel="noopener">https://blog.csdn.net/qq_39610915/article/details/90679768</a></p><p>7.Hexo NexT 代码块复制功能</p><p><a href="https://www.jianshu.com/p/3e9d614c1e77" target="_blank" rel="noopener">https://www.jianshu.com/p/3e9d614c1e77</a></p><p>8.Hexo写博客时的图片问题</p><p><a href="https://blog.csdn.net/TimeJjc/article/details/86707165" target="_blank" rel="noopener">https://blog.csdn.net/TimeJjc/article/details/86707165</a></p><p>9.Hexo NexT主题中集成gitalk评论系统</p><p><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/01/20/gitalk/</a></p><p>10.Hexo博客提交百度和Google收录</p><p><a href="https://www.jianshu.com/p/f8ec422ebd52" target="_blank" rel="noopener">https://www.jianshu.com/p/f8ec422ebd52</a></p><p>Hexo优化:创建sitemap站点地图并向Google站长工具提交</p><p><a href="https://blog.csdn.net/MobiusStrip/article/details/87258612" target="_blank" rel="noopener">https://blog.csdn.net/MobiusStrip/article/details/87258612</a></p><p>Google sitemap 不允许的网址的解决办法</p><p><a href="https://alanlee.fun/2017/12/30/google-sitemap/" target="_blank" rel="noopener">https://alanlee.fun/2017/12/30/google-sitemap/</a></p><p>11.markdown语法简介</p><p><a href="http://www.markdown.cn/" target="_blank" rel="noopener">http://www.markdown.cn/</a></p><p>12.更多优化如加载进度条等</p><p><a href="https://zhuanlan.zhihu.com/p/85037898" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85037898</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单的hexo命令&quot;&gt;&lt;a href=&quot;#简单的hexo命令&quot; class=&quot;headerlink&quot; title=&quot;简单的hexo命令&quot;&gt;&lt;/a&gt;简单的hexo命令&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://colalinn.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://colalinn.github.io/tags/hexo/"/>
    
      <category term="others" scheme="https://colalinn.github.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>test2</title>
    <link href="https://colalinn.github.io/2020/01/15/%E2%80%98test2/"/>
    <id>https://colalinn.github.io/2020/01/15/%E2%80%98test2/</id>
    <published>2020-01-15T11:40:22.000Z</published>
    <updated>2020-01-30T15:56:05.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二篇测试"><a href="#第二篇测试" class="headerlink" title="第二篇测试"></a>第二篇测试</h1><p>别来无恙啊</p><h3 id="2020-1-21"><a href="#2020-1-21" class="headerlink" title="2020.1.21"></a>2020.1.21</h3><p>今天武汉不明肺炎又进一步扩散了，讨论甚多</p><h3 id="2020-1-25-“大年初一，百病不侵”"><a href="#2020-1-25-“大年初一，百病不侵”" class="headerlink" title="2020.1.25  “大年初一，百病不侵”"></a>2020.1.25  “大年初一，百病不侵”</h3><p>大年初一，2019ncov已经严重到湖北禁省，各省份一级公共卫生响应。武汉将建两座“小汤山”医院，火神山、雷神山，今年春节愿我们百病不侵</p><h3 id="2020-1-27"><a href="#2020-1-27" class="headerlink" title="2020.1.27"></a>2020.1.27</h3><p>今天做了一道leetcode的最长回文子串</p><h3 id="2020-1-28-“成固欣然、败亦可喜”"><a href="#2020-1-28-“成固欣然、败亦可喜”" class="headerlink" title="2020.1.28  “成固欣然、败亦可喜”"></a>2020.1.28  “成固欣然、败亦可喜”</h3><p>今天疫情确诊人数突增2000+人，应该是试剂盒增加的原因，我有预感很快就能控制住。</p><p>今天Hexo做好了文章的图片，还有评论功能，leetcode做了一道Z”字符串”</p><h3 id="2020-1-30"><a href="#2020-1-30" class="headerlink" title="2020.1.30"></a>2020.1.30</h3><p>今天突增3000+人，今日配tensorflow环境，刷了两道题，无事发生</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二篇测试&quot;&gt;&lt;a href=&quot;#第二篇测试&quot; class=&quot;headerlink&quot; title=&quot;第二篇测试&quot;&gt;&lt;/a&gt;第二篇测试&lt;/h1&gt;&lt;p&gt;别来无恙啊&lt;/p&gt;
&lt;h3 id=&quot;2020-1-21&quot;&gt;&lt;a href=&quot;#2020-1-21&quot; class=&quot;h
      
    
    </summary>
    
    
    
      <category term="test-tag" scheme="https://colalinn.github.io/tags/test-tag/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="https://colalinn.github.io/2020/01/15/hello-world/"/>
    <id>https://colalinn.github.io/2020/01/15/hello-world/</id>
    <published>2020-01-15T08:46:23.000Z</published>
    <updated>2020-01-20T03:08:42.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world!"></a>hello world!</h1><h1 id="github-ColaLinN"><a href="#github-ColaLinN" class="headerlink" title="github: ColaLinN"></a>github: ColaLinN</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello world!&quot;&gt;&lt;/a&gt;hello world!&lt;/h1&gt;&lt;h1 id=&quot;github-ColaLinN&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="hello world!" scheme="https://colalinn.github.io/categories/hello-world/"/>
    
    
      <category term="hello world!" scheme="https://colalinn.github.io/tags/hello-world/"/>
    
  </entry>
  
</feed>
