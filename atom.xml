<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神奇小站</title>
  
  <subtitle>这里总有神奇的东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shenqiy.cn/"/>
  <updated>2020-10-21T08:45:24.609Z</updated>
  <id>https://shenqiy.cn/</id>
  
  <author>
    <name>ColaLinN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020-10-21-leetcode-p1</title>
    <link href="https://shenqiy.cn/2020/10/21/2020-10-21-leetcode-p1/"/>
    <id>https://shenqiy.cn/2020/10/21/2020-10-21-leetcode-p1/</id>
    <published>2020-10-21T08:44:46.000Z</published>
    <updated>2020-10-21T08:45:24.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-链表相加"><a href="#2-链表相加" class="headerlink" title="2. 链表相加"></a>2. 链表相加</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head=dummy;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> || l2!=<span class="keyword">null</span> || carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                carry+=l1.val;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                carry+=l2.val;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head.next=<span class="keyword">new</span> ListNode(carry%<span class="number">10</span>);</span><br><span class="line">            head=head.next;</span><br><span class="line">            carry=carry/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-两个正序数组的中位数"><a href="#4-两个正序数组的中位数" class="headerlink" title="4.两个正序数组的中位数"></a>4.两个正序数组的中位数</h1><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>这道题其实可以扩展成，在O(log(m + n))    的时间复杂度内，找到第K大的数</p><ol><li><p>为了计算第K位的数，先判断两数组A、B在第k//2的数的大小，<em>如果A的该数比B大</em>，则可以判断，B在第K//2之前的数肯定不是我们要找的target，则把这些数删掉，将K减去K//2，继续递归遍历。</p></li><li><p>要处理一些边界条件：</p><p>我们需要始终保持A比B长。</p><p>当B长度为零时就可以直接返回，减少了递归深度。</p><p>如果寻找的K为排在第1位的数，则比较两数组的第1位数，并返回</p></li><li><p>对于中位数而言，我们可以分别计算第    length//2+1、length//2+2  的值</p><p>总长度奇数条件下，前者后者都是中间的值</p><p>总长度偶数条件下，前者是第一个中位数，后者是第二个。两者之均，正好是中位数的值</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(nums1,nums2,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(nums1)&lt;len(nums2): </span><br><span class="line">                nums2,nums1=nums1,nums2</span><br><span class="line">            <span class="keyword">if</span> len(nums2)==<span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> nums1[k<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">1</span>: </span><br><span class="line">                <span class="keyword">return</span> min(nums1[<span class="number">0</span>],nums2[<span class="number">0</span>])</span><br><span class="line">            ksub=min(k//<span class="number">2</span>,len(nums2))</span><br><span class="line">            <span class="keyword">if</span> nums1[ksub<span class="number">-1</span>]&gt;=nums2[ksub<span class="number">-1</span>]: </span><br><span class="line">                <span class="keyword">return</span> helper(nums1,nums2[ksub:],k-ksub)</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> helper(nums1[ksub:],nums2,k-ksub)</span><br><span class="line">        left=(len(nums1)+len(nums2)+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        right=(len(nums1)+len(nums2)+<span class="number">2</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> (helper(nums1,nums2,left)+helper(nums1,nums2,right))/<span class="number">2</span></span><br></pre></td></tr></table></figure><p>其实上面的比较A、B的长度，并且交换，是可以避免的。</p><p>开局先判断两个数组是否为空，然后判断k==1</p><p>接下来就比较两数组的k//2的大小，来进一步缩小查找范围：</p><ul><li>只可能有一个数组的长度不到k//2，因为k从一开始就是被约束好的</li><li>如果B数组长度不为K/2，那么一定可以把A数组的前K/2个数去掉，因为这K/2个数必不是target</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=(nums1.length+nums2.length+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right=(nums1.length+nums2.length+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (findKNum(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left)+findKNum(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,right))/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKNum</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> i,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=nums1.length) <span class="keyword">return</span> nums2[j+k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=nums2.length) <span class="keyword">return</span> nums1[i+k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[i],nums2[j]);<span class="comment">//两个数组此时都不为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nums1mid=(i+k/<span class="number">2</span>-<span class="number">1</span>&lt;nums1.length)?nums1[i+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> nums2mid=(j+k/<span class="number">2</span>-<span class="number">1</span>&lt;nums2.length)?nums2[j+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(nums1mid&lt;nums2mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> findKNum(nums1,i+k/<span class="number">2</span>,nums2,j,k-k/<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findKNum(nums1,i,nums2,j+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) dp[i][i]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//Arrays.fill(dp[0],true);</span></span><br><span class="line">        <span class="comment">//System.out.printf("%b,%b,%b",dp[0][1],dp[0][1],dp[0][1]);</span></span><br><span class="line">        <span class="comment">//System.out.println(dp[0][1]);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i&lt;=<span class="number">2</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]==<span class="keyword">true</span>)&#123;</span><br><span class="line">                        dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(maxLen&lt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                            left=i;</span><br><span class="line">                            right=j;</span><br><span class="line">                            maxLen=j-i+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//System.out.printf("\n%d,%d,%d",1,i,j);</span></span><br><span class="line">                        <span class="comment">//System.out.printf("\n%d,%d,%d",left,right,maxLen);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return text.matches("^"+pattern+"$");</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str=text.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] ptr=pattern.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[str.length+<span class="number">1</span>][ptr.length+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;ptr.length+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr[j-<span class="number">1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;<span class="number">1</span>) dp[i][j]=dp[i][j-<span class="number">2</span>]; <span class="comment">//*匹配为空，这是很重要的初始化步骤</span></span><br><span class="line">                    <span class="comment">//*匹配一个到多个字符，最后会落到空上</span></span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; (str[i-<span class="number">1</span>]==ptr[j-<span class="number">2</span>] || ptr[j-<span class="number">2</span>]==<span class="string">'.'</span>)) dp[i][j]=dp[i][j] | dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//正常匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>  &amp;&amp; (str[i-<span class="number">1</span>]==ptr[j-<span class="number">1</span>] || ptr[j-<span class="number">1</span>]==<span class="string">'.'</span>)) dp[i][j]=dp[i][j] | dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[str.length][ptr.length];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="11.盛水最多的容器"></a>11.盛水最多的容器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            res=Math.max(res,Math.min(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j])&#123;</span><br><span class="line">                i+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || len&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> len(digits)==<span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        tmp=[]</span><br><span class="line">        d=&#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">               <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">               <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">               <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">               <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">               <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">               <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">               <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traceback</span><span class="params">(digits,index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index==len(digits):</span><br><span class="line">                res.append(<span class="string">""</span>.join(tmp))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dt=d[digits[index]]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dt)):</span><br><span class="line">                tmp.append(dt[i])</span><br><span class="line">                traceback(digits,index+<span class="number">1</span>)</span><br><span class="line">                tmp.pop()</span><br><span class="line">        traceback(digits,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>Java</strong></p><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></p><p>回溯法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        map.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        map.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        map.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        map.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        map.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        map.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        map.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        backTrack(list, digits, map, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(List&lt;String&gt; list, String digits, Map&lt;Character, String&gt; map, <span class="keyword">int</span> index, StringBuilder sb)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sb.length() == digits.length()) &#123;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String value = map.get(digits.charAt(index));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; value.length(); j++) &#123;</span><br><span class="line">            backTrack(list, digits, map, index + <span class="number">1</span>, sb.append(value.charAt(j)));</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        map.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        map.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        map.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        map.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        map.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        map.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        map.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        backTrack(list, digits, map, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(List&lt;String&gt; list, String digits, Map&lt;Character, String&gt; map, <span class="keyword">int</span> index, StringBuilder sb)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sb.length() == digits.length()) &#123;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String value = map.get(digits.charAt(index));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; value.length(); j++) &#123;</span><br><span class="line">            backTrack(list, digits, map, index + <span class="number">1</span>, sb.append(value.charAt(j)));</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h1><p>在处理的时候，可以使用哑巴节点，</p><ul><li>来规避链表只有一个节点的情况，</li><li>并且可以保持在 <code>target</code> 前一位，用于删除节点</li></ul><p>然后，想摘掉快节点移动的步数，其实是有组合的：</p><ul><li>如果快节点只先移动 <code>k-1</code> 步，那么我们在一起移动时，需要时刻注意 <code>f.next</code> 是否为空</li><li>如果快节点只先移动 <code>k</code> 步，那么我们在一起移动时，需要时刻注意 <code>f</code> 是否为空</li></ul><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode f=head;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span> &amp;&amp; f.next!=<span class="keyword">null</span>)&#123;<span class="comment">//快指针</span></span><br><span class="line">            f=f.next;</span><br><span class="line">            n=n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res=<span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//哑巴节点</span></span><br><span class="line">        res.next=head;</span><br><span class="line">        ListNode tmp=res;<span class="comment">//tmp用于移动，删除</span></span><br><span class="line">        <span class="keyword">while</span>(f.next!=<span class="keyword">null</span>)&#123;<span class="comment">//快慢指针一起移动</span></span><br><span class="line">            tmp=tmp.next;</span><br><span class="line">            f=f.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.next!=<span class="keyword">null</span>)</span><br><span class="line">            tmp.next=tmp.next.next;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">"&#123;&#125;"</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">"()"</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">"[]"</span> <span class="keyword">in</span> s:</span><br><span class="line">            s=s.replace(<span class="string">"&#123;&#125;"</span>,<span class="string">""</span>)</span><br><span class="line">            s=s.replace(<span class="string">"[]"</span>,<span class="string">""</span>)</span><br><span class="line">            s=s.replace(<span class="string">"()"</span>,<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> s==<span class="string">""</span></span><br></pre></td></tr></table></figure><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h1><p><a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/" target="_blank" rel="noopener">下一个排列</a></p><p>对于这种题：大于此数的下一个数（情况1）、小于此数的上一个数（情况2） 都可以用统一的套路求解</p><p><img src="/2020/10/21/2020-10-21-leetcode-p1/image-20200930153614180.png" alt="image-20200930153614180"></p><p>取第一种情况讨论：</p><ul><li>目标是，找到一个逆序对，<code>A[i] &lt; A[j]</code> ，交换其，然后将 <code>A[i:]</code>  做一个升序排列<ul><li><code>A[j]</code> 必须尽可能的靠后</li><li>先从后往前找到一个相邻的逆序对，<code>A[i]&lt; A[j]</code> ，其中跳过的 <code>A[j:]</code> 肯定是降序排列</li><li>然后从后往前找到第一个大于 <code>A[i]</code> 的 <code>A[k]</code> ，交换 <code>A[k]、A[i]</code> </li><li>然后将 <code>A[i+1:]</code> 升序排列（因为我们要找的是在交换 <code>A[k]、A[i]</code>  后的最大的数）</li><li>如果没有找到逆序对，就直接跳到 <code>升序排列</code>  </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> i=nums.length-<span class="number">2</span>,j=nums.length-<span class="number">1</span>,k=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[j])&#123; <span class="comment">//找到第一个逆序对</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">while</span>(nums[k]&lt;=nums[i])&#123; <span class="comment">// 找到第一个大于nums[i]的数，等于是不行的，没有效果</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp=nums[k];</span><br><span class="line">            nums[k]=nums[i];</span><br><span class="line">            nums[i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=j,r=nums.length-<span class="number">1</span>;l&lt;r;l++,r--)&#123; <span class="comment">//后面都是升序的，需要调成降序排序</span></span><br><span class="line">            <span class="keyword">int</span> tmp=nums[l];</span><br><span class="line">            nums[l]=nums[r];</span><br><span class="line">            nums[r]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32.最长有效括号"></a>32.最长有效括号</h1><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/submissions/" target="_blank" rel="noopener">最长有效括号</a></p><ul><li><p>当<code>【i】</code>是 <code>右括号</code> 时</p><ul><li><p>先判断它左边是不是 <code>左括号</code> ，是的话 <code>dp[i]+2</code></p></li><li><p>上面的情况不对的话，判断它左边的 <code>dp[i-1]</code> 是否大于零（代表左边有有效括号组），并且跳过这个dp[i-1]的长度之后，能找到一个 <code>左括号</code>  与其匹配，dp[i]=d[i-1]+2</p></li><li><p>最后判断，<code>i-dp[i]&gt;0</code> 与 <code>i-dp[i]</code> 处的 dp 值是否大于零，这代表着 <code>dp[i]</code> 为代表的括号组左边还有有效的括号组。</p><p>如果大于零（其实等于零也可以直接加哈哈哈），<code>dp[i]+=dp[i-dp[i]]</code></p></li></ul></li><li><p>左括号，直接continue</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] sc=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[sc.length];</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.println(dp[0]);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sc.length;i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; sc[i]==<span class="string">')'</span>)&#123; <span class="comment">//判断是否是右括号</span></span><br><span class="line">                <span class="keyword">if</span>(sc[i-<span class="number">1</span>]==<span class="string">'('</span>)&#123;<span class="comment">//左边直接就是一个左括号？</span></span><br><span class="line">                    dp[i]=<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; i-dp[i-<span class="number">1</span>]-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; sc[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                        dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//其他情况直接跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这边做一个判断，判断是否可以加上之前的值</span></span><br><span class="line">                <span class="keyword">if</span>(i-dp[i]&gt;=<span class="number">1</span> &amp;&amp; dp[i-dp[i]]&gt;<span class="number">0</span>) dp[i]+=dp[i-dp[i]];</span><br><span class="line">                max=Math.max(max,dp[i]);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(dp));</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        left=<span class="number">-1</span></span><br><span class="line">        right=<span class="number">-1</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            mid=(i+j)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;=target: j=mid</span><br><span class="line">            <span class="keyword">else</span>: i=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]==target: left=i</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            mid=(i+j)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;=target: i=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j=mid</span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]!=target <span class="keyword">and</span> nums[i<span class="number">-1</span>]==target: i=i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]==target: right=i </span><br><span class="line">        <span class="keyword">return</span> [left,right]</span><br></pre></td></tr></table></figure><h1 id="42-接雨水-单调栈经典题"><a href="#42-接雨水-单调栈经典题" class="headerlink" title="42.接雨水__单调栈经典题"></a>42.接雨水__单调栈经典题</h1><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42接雨水</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[stack[<span class="number">-1</span>]]&lt;height[i]:</span><br><span class="line">                top=stack.pop()</span><br><span class="line">                <span class="keyword">if</span> len(stack)==<span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">                l=stack[<span class="number">-1</span>]</span><br><span class="line">                r=i </span><br><span class="line">                h=min(height[l],height[r])-height[top]</span><br><span class="line">                res+=h*(r-l<span class="number">-1</span>)</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="46-全排列-回溯经典题"><a href="#46-全排列-回溯经典题" class="headerlink" title="46. 全排列__回溯经典题"></a>46. 全排列__回溯经典题</h1><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        d=dict()</span><br><span class="line">        tmp=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(d,tmp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(tmp)==len(nums):</span><br><span class="line">                res.append(tmp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> d.get(nums[i]): <span class="keyword">continue</span></span><br><span class="line">                d[nums[i]]=<span class="literal">True</span></span><br><span class="line">                tmp.append(nums[i])</span><br><span class="line">                backtrace(d,tmp)</span><br><span class="line">                d[nums[i]]=<span class="literal">False</span></span><br><span class="line">                tmp.pop()</span><br><span class="line">        backtrace(d,tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h1><p><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48.旋转图像</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix.length!=matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> layer=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(layer&lt;=(len&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> lalen=len-(layer&lt;&lt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lalen-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=matrix[layer][layer+i];</span><br><span class="line">                matrix[layer][layer+i]=matrix[layer+lalen-i-<span class="number">1</span>][layer];</span><br><span class="line">                matrix[layer+lalen-<span class="number">1</span>-i][layer]=matrix[layer+lalen-<span class="number">1</span>][layer+lalen-<span class="number">1</span>-i];</span><br><span class="line">                matrix[layer+lalen-<span class="number">1</span>][layer+lalen-<span class="number">1</span>-i]=matrix[layer+i][layer+lalen-<span class="number">1</span>];</span><br><span class="line">                matrix[layer+i][layer+lalen-<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            layer++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h1><p><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String,ArrayList&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] ch=s.toCharArray();</span><br><span class="line">            Arrays.sort(ch);</span><br><span class="line">            String key=String.valueOf(ch);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(key)) map.put(key,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums==[]: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        maxV=nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            nums[i]=max(nums[i<span class="number">-1</span>]+nums[i],nums[i])</span><br><span class="line">            maxV=max(maxV,nums[i])</span><br><span class="line">        <span class="keyword">return</span> maxV</span><br></pre></td></tr></table></figure><h1 id="55-跳跃游戏-扩展-最少跳数"><a href="#55-跳跃游戏-扩展-最少跳数" class="headerlink" title="55. 跳跃游戏_扩展:最少跳数"></a>55. 跳跃游戏_扩展:最少跳数</h1><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxp=<span class="number">0</span>; <span class="comment">//维护一个最大值</span></span><br><span class="line">        <span class="keyword">int</span> nowmp=<span class="number">0</span>; <span class="comment">//上一阶段的最大值</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.length &amp;&amp; i&lt;=nowmp)&#123;</span><br><span class="line">            maxp=Math.max(nums[i]+i,maxp);</span><br><span class="line">            <span class="keyword">if</span>(i==nowmp) nowmp=maxp; <span class="comment">//更新当前阶段最大值</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxp&gt;=nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></p><p><a href="https://leetcode-cn.com/u/mruster/" target="_blank" rel="noopener">@Mruster</a> </p><p><code>Arrays.sort(intervals, (v1, v2) -&gt; v1[0] - v2[0]);</code> 假设传来两个值，<code>v1</code> 与 <code>v2</code>，那么他们的先后顺序以 <code>v1[0]</code> 比 <code>v2[0]</code> 的结果为准，即：若 <code>v1[0] &lt; v2[0]</code> 则 <code>v1 &lt; v2</code>，若 <code>=</code> 则 <code>=</code>，若 <code>&gt;</code> 则 <code>&gt;</code></p><p>举一反三：<code>Arrays.sort(intervals, (v1, v2) -&gt; v1[0] == v2[0] ? v2[1] - v1[1] : v1[0] - v2[0]);</code> 表示：传来两个值 <code>v1</code> 与 <code>v2</code>，若 <code>[0]</code> 相同，则按 <code>[1]</code> 降序；若不同则按 <code>[0]</code> 升序。</p><p>趁热打铁题目 <a href="https://leetcode-.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃的信封问题</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals,(v1,v2)-&gt;v1[<span class="number">0</span>]-v2[<span class="number">0</span>]); <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">int</span> idx=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(idx==-<span class="number">1</span>|| interval[<span class="number">0</span>]&gt;intervals[idx][<span class="number">1</span>])&#123;<span class="comment">//判断是否合并</span></span><br><span class="line">                intervals[++idx]=interval;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intervals[idx][<span class="number">1</span>]=Math.max(intervals[idx][<span class="number">1</span>],interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(intervals,idx+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="62-不同路径-二维动规easy"><a href="#62-不同路径-二维动规easy" class="headerlink" title="62. 不同路径__二维动规easy"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a>__二维动规easy</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int[][] res=new int[m][n];</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            res[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                res[i][j]=res[i<span class="number">-1</span>][j]+res[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="64-最小路径和-二维动规easy"><a href="#64-最小路径和-二维动规easy" class="headerlink" title="64. 最小路径和__二维动规easy"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a>__二维动规easy</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid[<span class="number">0</span>].length;i++) grid[<span class="number">0</span>][i]+=grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++) grid[i][<span class="number">0</span>]+=grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                grid[i][j]+=Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="70-爬楼梯-一维动规easy"><a href="#70-爬楼梯-一维动规easy" class="headerlink" title="70. 爬楼梯__一维动规easy"></a>70. 爬楼梯__一维动规easy</h1><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="72-编辑距离-⭐"><a href="#72-编辑距离-⭐" class="headerlink" title="72. 编辑距离__⭐"></a>72. 编辑距离__⭐</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        dp=[[j <span class="keyword">for</span> j <span class="keyword">in</span> range(len(word2)+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1)+<span class="number">1</span>): dp[i][<span class="number">0</span>]=i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word2)+<span class="number">1</span>): dp[<span class="number">0</span>][i]=i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(word1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(word2)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=min(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(dp[i][j])</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(word1)][len(word2)]</span><br></pre></td></tr></table></figure><h1 id="75-颜色分类-三维动规⭐"><a href="#75-颜色分类-三维动规⭐" class="headerlink" title="75. 颜色分类__三维动规⭐"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a>__三维动规⭐</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, tail = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tail; i++)&#123; <span class="comment">//注意：tail后面都是交换过的数字，不用判断</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                temp = nums[head];<span class="comment">//交换nums[i]与nums[head]</span></span><br><span class="line">                nums[head] = <span class="number">0</span>;</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                head++; <span class="comment">// head指针后移一位</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">2</span>)&#123;</span><br><span class="line">                temp = nums[tail];<span class="comment">//交换nums[i]与nums[tail]</span></span><br><span class="line">                nums[tail] = <span class="number">2</span>;</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                tail--; <span class="comment">//tail指针前移一位</span></span><br><span class="line">                i--; <span class="comment">//这里要注意！，保证下次判断的是</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="76-最小覆盖子串-经典滑动窗口⭐"><a href="#76-最小覆盖子串-经典滑动窗口⭐" class="headerlink" title="76. 最小覆盖子串__经典滑动窗口⭐"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a>__经典滑动窗口⭐</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] sc=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> cnt=t.length();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> x:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(x)==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(x,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(x,map.get(x)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmpcnt=<span class="number">0</span>,minlen= Integer.MAX_VALUE,minl=<span class="number">0</span>,minr=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;sc.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(sc[j])!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(sc[j])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    tmpcnt+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(sc[j],map.get(sc[j])-<span class="number">1</span>); </span><br><span class="line">                <span class="keyword">while</span>(i&lt;sc.length &amp;&amp; tmpcnt==cnt)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(minlen&gt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                        minlen=j-i+<span class="number">1</span>;</span><br><span class="line">                        minl=i;</span><br><span class="line">                        minr=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(map.get(sc[i])!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map.get(sc[i])==<span class="number">0</span>)&#123;</span><br><span class="line">                            tmpcnt--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        map.put(sc[i],map.get(sc[i])+<span class="number">1</span>); </span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minlen==Integer.MAX_VALUE) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substring(minl,minr+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="79-单词搜索-经典图回溯⭐"><a href="#79-单词搜索-经典图回溯⭐" class="headerlink" title="79. 单词搜索 经典图回溯⭐"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a> 经典图回溯⭐</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (search(board, word, i, j,<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] board,String word,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=board.length||j&lt;<span class="number">0</span>||j&gt;=board[<span class="number">0</span>].length||board[i][j]!=word.charAt(k)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[i][j]+=<span class="number">256</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result=search(board,word,i-<span class="number">1</span>,j,k+<span class="number">1</span>) || search(board,word,i+<span class="number">1</span>,j,k+<span class="number">1</span>) || search(board,word,i,j-<span class="number">1</span>,k+<span class="number">1</span>) || search(board,word,i,j+<span class="number">1</span>,k+<span class="number">1</span>);</span><br><span class="line">        board[i][j]-=<span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="78-子集-经典回溯"><a href="#78-子集-经典回溯" class="headerlink" title="78. 子集__经典回溯"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a>__经典回溯</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//res.add(new ArrayList&lt;&gt;());</span></span><br><span class="line">        backtrace(res,<span class="number">0</span>,nums,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,<span class="keyword">int</span> pos,<span class="keyword">int</span>[] nums,List&lt;Integer&gt; tmp)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;nums.length;i++)&#123;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            backtrace(res,i+<span class="number">1</span>,nums,tmp);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="84-柱状图中最大的矩形-单调栈经典⭐⭐"><a href="#84-柱状图中最大的矩形-单调栈经典⭐⭐" class="headerlink" title="84. 柱状图中最大的矩形__单调栈经典⭐⭐"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a>__单调栈经典⭐⭐</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        heights=[<span class="number">0</span>]+heights+[<span class="number">0</span>] <span class="comment">#第一个零是为了stack[-1]时必退出while循环，第二个零时把最后栈中的元素全部弹出计算</span></span><br><span class="line">        stack=[]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]]&gt;heights[i]:</span><br><span class="line">                tmp=stack.pop()</span><br><span class="line">                res=max(res,(i-stack[<span class="number">-1</span>]<span class="number">-1</span>)*heights[tmp]) <span class="comment">#其实就是左右找到tmp的小界</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nh=<span class="keyword">new</span> <span class="keyword">int</span>[heights.length+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nh.length-<span class="number">1</span>;i++) nh[i]=heights[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nh.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nh[stack.peek()]&gt;nh[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=stack.pop();</span><br><span class="line">                res=Math.max(res,(i-stack.peek()-<span class="number">1</span>)*nh[tmp]);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="85-最大矩形-在上一题之上的改进"><a href="#85-最大矩形-在上一题之上的改进" class="headerlink" title="85. 最大矩形__在上一题之上的改进"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a>__在上一题之上的改进</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        heights=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">"0"</span>:</span><br><span class="line">                    heights[j]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>: heights[j]+=<span class="number">1</span></span><br><span class="line">            res=max(res,self.largestRectangleArea(heights))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights)</span>:</span></span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">                s = stack.pop()</span><br><span class="line">                res = max(res, heights[s] * ((i - stack[<span class="number">-1</span>] - <span class="number">1</span>) <span class="keyword">if</span> stack <span class="keyword">else</span> i))</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="94-二叉树的中序遍历-非递归中序"><a href="#94-二叉树的中序遍历-非递归中序" class="headerlink" title="94. 二叉树的中序遍历__非递归中序"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a>__非递归中序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>]=dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">                dp[i]+=dp[j<span class="number">-1</span>]*dp[i-j]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">        <span class="comment"># dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2]+...+dp[n-1]*dp[0]</span></span><br></pre></td></tr></table></figure><h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">return</span> root==null || cmp(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean cmp(TreeNode l,TreeNode r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==null &amp;&amp; r==null) <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">if</span>(l==null || r==null) <span class="keyword">return</span> false;</span><br><span class="line">        <span class="keyword">return</span> l.val==r.val &amp;&amp; cmp(l.right,r.left) &amp;&amp; cmp(l.left,r.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="keyword">null</span>?<span class="number">0</span>:Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="105-从前序与中序遍历序列构造二叉树-常见的分治"><a href="#105-从前序与中序遍历序列构造二叉树-常见的分治" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树__常见的分治"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a>__常见的分治</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">0</span>||inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode (preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;preorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>]==inorder[i])&#123;</span><br><span class="line">                root.left=buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                root.right=buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="128-最长连续序列-神奇的处理⭐"><a href="#128-最长连续序列-神奇的处理⭐" class="headerlink" title="128. 最长连续序列__神奇的处理⭐"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a>__神奇的处理⭐</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        d=dict()</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                left=d.get(num<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">                right=d.get(num+<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                maxv=left+right+<span class="number">1</span></span><br><span class="line">                res=max(res,maxv)</span><br><span class="line">                d[num]=maxv</span><br><span class="line">                d[num-left]=maxv</span><br><span class="line">                d[num+right]=maxv <span class="comment">#这里处理的很妙，顺延长度</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="155-最小栈-单调递减栈的基础应用"><a href="#155-最小栈-单调递减栈的基础应用" class="headerlink" title="155. 最小栈__单调递减栈的基础应用"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a>__单调递减栈的基础应用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack=[]</span><br><span class="line">        self.s2=[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.s2)==<span class="number">0</span> <span class="keyword">or</span> (self.s2 <span class="keyword">and</span> self.s2[<span class="number">-1</span>]&gt;=x): self.s2.append(x)</span><br><span class="line">        self.stack.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> self.stack[<span class="number">-1</span>]==self.s2[<span class="number">-1</span>]: self.s2.pop()</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.s2: <span class="keyword">return</span> self.s2[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure><h1 id="160-相交链表-简单的数学"><a href="#160-相交链表-简单的数学" class="headerlink" title="160. 相交链表__简单的数学"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a>__简单的数学</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="keyword">null</span>||headB==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pA=headA,pB=headB;</span><br><span class="line">        <span class="keyword">while</span>(pA!=pB)&#123;</span><br><span class="line">            pA=pA!=<span class="keyword">null</span>?pA.next:headB;</span><br><span class="line">            pB=pB!=<span class="keyword">null</span>?pB.next:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="617-合并二叉树-简单递归"><a href="#617-合并二叉树-简单递归" class="headerlink" title="617. 合并二叉树__简单递归"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a>__简单递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span> &amp;&amp; t2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        t2.val+=t1.val;</span><br><span class="line">        t2.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">        t2.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="169-多数元素-众数问题，摩根投票法"><a href="#169-多数元素-众数问题，摩根投票法" class="headerlink" title="169. 多数元素__众数问题，摩根投票法"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a>__众数问题，摩根投票法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res=nums[<span class="number">0</span>]</span><br><span class="line">        cnt=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num==res: cnt+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: cnt-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt==<span class="number">0</span>:</span><br><span class="line">                res=num</span><br><span class="line">                cnt=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="牛客高频-链表内指定区间反转"><a href="#牛客高频-链表内指定区间反转" class="headerlink" title="牛客高频-链表内指定区间反转"></a>牛客高频-链表内指定区间反转</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head ListNode类 </span></span><br><span class="line"><span class="comment"># @param m int整型 </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return ListNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self , head , m , n )</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dummy=ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next=head</span><br><span class="line">        pre=dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">            pre=pre.next</span><br><span class="line">        pre2=pre.next</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n-m):</span><br><span class="line">            nextNode=pre2.next</span><br><span class="line">            pre2.next=nextNode.next</span><br><span class="line">            nextNode.next=pre.next</span><br><span class="line">            pre.next=nextNode</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h1 id="插入-amp-希尔排序-缩小增量排序"><a href="#插入-amp-希尔排序-缩小增量排序" class="headerlink" title="插入&amp;希尔排序(缩小增量排序)"></a>插入&amp;希尔排序(缩小增量排序)</h1><p><a href="https://blog.csdn.net/weixin_37818081/article/details/79202115" target="_blank" rel="noopener">介绍比较完整</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span><span class="params">(num:[])</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</span><br><span class="line">        tmp=num[i]</span><br><span class="line">        j=i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> num[j]&gt;tmp:</span><br><span class="line">            num[j+<span class="number">1</span>]=num[j]</span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        num[j+<span class="number">1</span>]=tmp</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span><span class="params">(num:[])</span>-&gt;[]</span></span><br><span class="line"><span class="function">gap=len(num)//2</span></span><br><span class="line"><span class="function">    while gap&gt;0:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,len(num)):</span><br><span class="line">            tmp=num[i]</span><br><span class="line">            j=i-gap</span><br><span class="line">            <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> num[j]&gt;num[j+<span class="number">1</span>]:</span><br><span class="line">                num[j+<span class="number">1</span>],num[j]=num[j].num[j+<span class="number">1</span>]</span><br><span class="line">                j+=gap</span><br><span class="line">    <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;/a&gt;1.两数之和&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2020-09-26-baoyan</title>
    <link href="https://shenqiy.cn/2020/09/26/2020-09-26-baoyan/"/>
    <id>https://shenqiy.cn/2020/09/26/2020-09-26-baoyan/</id>
    <published>2020-09-25T16:08:58.000Z</published>
    <updated>2020-10-19T13:32:51.620Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="86585b3d94f20823170d70362866a30c641377c5007de19d0db6582e63798d6a">5c1e806a49f4d355deabb11886b1a9e3a3b56b302ae81ab64eee471c4f29e2548ec4848890943f2ad2082e82e01ee05ab46c935e0bc9b4e4691a0481cd9290dcc41f61a53edf930a320c3b266747afa16ec947b7ea2b5b1ed135c69e5a8e9a87c109cc1ddc1f6d98102375a72b6ddeaa405d0547ef5e8ee4256ed77065ea3e9b332f4d28960988de7100606c4691911e1ff5c952b84fb48f70e815208156369e8599fce177d907fb73ae423732af3556edf8350e89fc291da5bd94b72fc9508efe32f763a3a3fc646222a152bc0ffc28258deaad86779e6e1e56cabba8bcd27276cce3f44f98f250501b476f5c934762fe57e87eb3f2d0e71f87e8124b3ea31fcc5b0d77dc2197df61fc24664b0a13c892416000a0d264a58f03034cd613a1797a8522ca4bbc69d43a352585bed51a981db883461bd005c778377fef5bae37c58f35e414d1d111008284d493e410df31e142958c82d4b60899f7d33cd4afd29a4b654b9dbc1e6e538e4c9647c1a69538b4273baf870aa116410e2232cd989ecaf93d4df30d106ced5adba1d566d219f5e6d8f89fc3acce9c173765281b59b0e186ec3ac6c33a8e0d267203c2e55403b5f9eb4264fefe810ad876ef20dd5c3aad412c6b0f3ee1e9502cdddef9176f85254cda89839eb9eeef5b4272680a8388e5733694c0d8962677e118a6aed04e1c84ee5e23f7ee99482531d1a5d73805e27d8932e8c535ba015f497002d9da696e0b55a21a2c39fa26b896cfcaad1fd45cebee884a02d0583d57d7fb0432faf190ea858ccd03e0d3d568f40cb9571b01bf53faf52c663579ed0486ca22cd9eebf179c7d3709177540e3ddd129ad5559c6668a759a4d77159cd3a08e39ad2cc5aecfe54b8877f5423bcdff4fbd4b258237d1280cae99602700c1c28544f169aa46e2ebb48fbb580f0dcd12fbd165593031c8963a095a21ab611b18f8bab232d58a27deb82aad9b5747e89743d320beb9b56e4ceaad85910ed84b8c3d907c699dd2cb2474c8492f1ad80720cb9e3afc9b6305af1cf8eaf4529e340477458f0e062a4af738a37b6254e284327299681a5bb7b85f22a092a8774e92f32fc5c84f5505e8dd5697277132cf1b098bc2379e51a4128465fb2f55c5a1137a541f168b77001cff2c9bad85703dacb4ad7c2eeb65c1f5b117a335576ebec14599a08d9cea81545034ba49e7f0f490f297d3c53d4be5c384b73da54400d53160ba5a1bb6d765ada2c20f174827857103a1cb4caaaece1afacb0cdf8b7a7bfabecef6604491e3bd29da5b7bbf5991e59864dc816a682d0971bb9afa7f059df8f11b67e92ca72393aea4595684226358c572646df9790a1733c8b7c4ccadbdabd609467b26d598f06aaa5f6c0697556a0da0a9fc931408424a77fe4d5a643bca7c87c4124b4f3f51745dbc6b1e7a2cd9a67db3241d40f016d77a8a7d237a0e0bb0aa2ccf0f68bb9bdaca5425b723eb9b83e95a9379fc9fefe6f309bdca673af72a883b2898393d756f0278f67de3c8b30c4bb2ac7672275970c1f2e7dce08aa6e9c62f8e48dc425f910d28f205fb226bc3326fba0d047555e39f8d2c14f9da80781422951664f20b60160b9e074c8adbf9baf39cde3710c747f178cfe360664d7f65e25c2e6b45d4ecf751dcdde37cbfa870a7cefe5b24e2f6fb1a4b41d66476fcb4f02f3512c433ce98a425d7ee04145ae27f37b3d7603a900d9d532b0221d5f72a81a8c55ebcebb05e8b2134e1244ad79cec5cfe38d22fb1649e5b56bda4f506f82b52437c22c8b9d49d6e3ead8ec400c0c109abd4d7ca4cb5281ce5e44e85b38169c929bfca5f70dc5830e5a1d78437acda464713c3084a759f7405e81742b9b9284bba540f76a398e6d00ef09c74466b9393955f1a092d80a346535e3fa23d3dd92e8a33b2f4cb0f2c9bd5caf2fa983bad6b442f7e004dc6482680e34b3d66e01913fce4677a155853812d9ba6c04c5dc47d51845de7de9bcb35239107edb948b6ee1e6686bdfb61f026018f99c2d4034181e05f1397775b01330c21f110c064ddd4adeb3c994f1a542e9328ae055b84a0c7339dbb474b565d4e3658af725eb9b32de38609a6868b97d3387d3f613f12360cb2bd4750687a92f313cf087eb7815387ed3f7c33a6f873e2fa5c4551e881cdada2cbe64cf79af66aa86ba40f4abaabb1475f2e276cb28413d468535eef9fdf84e7530e0a2003f2844818cb3b8d3a1dc0170e6a370b2ce16aa81056053f2fc92bd7b9aa9d7668a219285a237ff1f3f00915812b5afb54320f1d4f9fdc503036d03239af9c04d71ba561df8a2cfdc5469fe305f5c3dd36fc746f3e3359f3c49a4281119eb93725ad35d0d9474d69b0c1f96ecb57b28749c5e00a87ba3c7e036642d4764a16721f13b14acc284d88da5451faa46f0b09fbb3d3135a685c8bffbf2d9974bfcacd1224819e3e0b1e5a4f23f461d60261bf240bebc4e3a455770edf969dd6935f44ac09e29af0593eeb9831fbe21b787b103394c3b8ee13a82b94cdf2aeb6e4237f6954c607fc2e5a873045b5d2f33c777160e996cb38e66815564c4902ca2bbb9db17d9ad9fc0a4d4b24c3ff5584f919c8ad192552e96d660eb43d01aa2756dafd400cf7c8d54afa957d9887ff8f1d24af57e7dd08a632417a8380bb86e589162e78d82ff918c8ad8c3c1c84f8d11822f77c2a858972e41936e2142a988b513162ddd0e9bab96644aea3ffd4942dd8505fd79f819fd34b83562f8599be56a24623addc559b1c3cf6e310c0474482aff28cbcf6d12b4effccb2ad2d88d5c362de754377ed9bae624b468ba28cc1e357fe95635f1494b686dbb55c77c2b9fcd600c7acc1cb05238faa742ce0a1cf71e80542418dd14f1c2116ef6c34aebfcb04dea9d89c3e48321d6f57170f0b21cf438ee4291a8701d82a227e261ff98e5e020548c0346564c5c60e8ba02a1513687e0875dd8c6ed4b3cf21bb3e408179ffac200e1d1d2842d23036adf56ed538dc440adf0c64218dff6f784b06322ab88700514c0e1db01531f22097d61356cc126c23449812c4f6cc5b01254731ff4cebb32a5a7b483e15b3eeed9489fb8fd19e8f2d5881910d0dc91e91e0fcc8853e19d56fc60f7908ed6222802bcb425dba22dc207c8563fe1e839ca5616710d711a63123208943fc61988cfdf33201d0f66598c629917f6d7ed795a8e50c775123ccd31c51c7caea8a84fd8d91b54388cdc4c92f61576f61b3330e6d6a528eea9bde0bba4e895858487e8e0513af2f588fc3e3671d435e78d981c2f37542728c9c2112c5ee4397df51803937fc436ad23b41fa9e8c7986dbee41a30b66fe600da653423769a22d1f351e28885931a37d64d93ce17bb4d482a17a28b86d55c24f9630c4a50a8e5a030ae0acdc5dd77b90207d5a5cbb55cfefd479060fa03fdc97d6aa5097d19b886eeafd6977697f585838139fe8ab2f2012ea649faf371e67025441e662ca4dbe8396bcf01d33d6b791af196387bbe86d070979ccf4f8b0e568a3e6af6fff6b50aeaa6818e9af4b717c05b9292462657ecc95ce013b9e3b997dd28015063f4250edf6922eabd9898cb6a76af37fa668100f5666480456f4e27b62468cbffeffe2adb05a63b3204c67382ee5748691bf1eb9976ec6a173cf8f6302b6adeab39ddb524fd79bfd22281df16c6109a7718e26bd2ca4eca71f803c94dfe4be13a394ab0b9db661c0b568e263a3c7395483da2fdde167e902e136ea787ec13180bb1bae366c4cc6b889eb34e426a4847594ff8f9d4d36439677fe33f407916642faa8563b191d18b5d1b09ef35bfff7748df164702c56efe62502e290cc8f94b14a63a59b991e95cb941864a5e5354f2a0a250e8597a7ce226fa8dfe3fda11cca3410d6a9c29d9e69213c89d29b7b08244b8a6f9fad0d920fdf13bfd80e671e66dc4cb7c32cbc5fd29172e2c6bc2919ada6d20c125d18cf63f5e85617188bc78562f978aa38a4eaaa01cb336e806f22588ac8564c4244e07542a35879a980acccfd9f21610b72519967027979b659a787e40a877e45b3200d36e6bd5dabd8c2f4ff5ea85d8d72943f8857eae9294b8c0860e683e620544e4af6ff5c52bffadf38a4aee9642b8c6ca91d7a5ddd885cef9fd174e1c4c7dc68e97f34263bba3b1c3acfc2f6938c452c15dec12ea5e614253c6dca4f63d6cb1b6a5e0ad5c5917a71bcee5c29f690663fee120420d36e4853afefe6c40e4ce14cc9ee3ac311cc50e7d2906add1c04978d8804e4224776d6bd9adb3e84e8d83da40e6bbe28ea9d8c4e76b1bcd7a5226cf462bbc6102c45ba723f788ef2bcbda3ee48e156bdececfdcdaac33bb83cf428ed46469c0ec1493bbf817dc7fdee8c6e1d25b7a6064700a7da5d2d176ab9bd6166b19ca67856627d5533ac43375427fd4ba5cf14654ef87a9ae46eb2ba097f82cee70ae2845324f08c007ca5d47d0a7d9199ae4a3bb93a5d9d10cc2d69eca601bb047743e1e7e23e25b10</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这篇文章加密了，请输入密码访问。&lt;/br&gt; Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="生活" scheme="https://shenqiy.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="密文" scheme="https://shenqiy.cn/tags/%E5%AF%86%E6%96%87/"/>
    
      <category term="生活" scheme="https://shenqiy.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>算法 回溯练习</title>
    <link href="https://shenqiy.cn/2020/08/02/2020-08-02-Backtrace-1/"/>
    <id>https://shenqiy.cn/2020/08/02/2020-08-02-Backtrace-1/</id>
    <published>2020-08-02T15:20:23.000Z</published>
    <updated>2020-08-02T15:27:08.020Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/</a></p><p>上面的题解中，有个题解很有意思，讲了很多回溯的通用类似题</p><p>今天：回溯、DP</p><p>明天：堆栈、</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result=[]</span><br><span class="line">listTmp=[] <span class="comment">#用于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(选择列表，路径)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> 选择列表:</span><br><span class="line">        路径.append(i) <span class="comment">#做选择</span></span><br><span class="line">        bcaktree(选择列表，路径) <span class="comment">#下一轮回溯</span></span><br><span class="line">        路径.pop() <span class="comment">#撤销选择</span></span><br></pre></td></tr></table></figure><p>如果需要全排列，我们需要用visited解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    visited=&#123;&#125; <span class="comment">#哈希字典，检测是否visited</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,result,listTmp,visited)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(listTmp)==len(nums):</span><br><span class="line">        result.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        ---------------</span><br><span class="line">        <span class="keyword">if</span> visited.get(i): <span class="comment">#可以这样get检测，如果没有就返回None。也可以用 i in dict来判断</span></span><br><span class="line">        <span class="comment"># if i in visited:                </span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ---------------</span><br><span class="line">        listTmp.append(i)</span><br><span class="line">        visited[i]=<span class="literal">True</span></span><br><span class="line">        self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">        ---------------</span><br><span class="line">        visited[i]=<span class="literal">False</span> <span class="comment">#如果上面用 i in dict来判断，这里就要改成dict.pop(i)</span></span><br><span class="line">        <span class="comment"># visited.pop(i)</span></span><br><span class="line">        ---------------</span><br><span class="line">        listTmp.pop()</span><br></pre></td></tr></table></figure><p>如果要给的nums有重复元素，要求返回时没有重复的元素</p><p>我们需要先sort排列。</p><p>然后跳过重复的数；或者直接检测在不在result中（效率可能低）</p><p>遇事不决，就用 <code>in</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums.sort() <span class="comment">#需要排序</span></span><br><span class="line">------------------</span><br><span class="line"><span class="keyword">if</span> listTmp <span class="keyword">not</span> <span class="keyword">in</span> result:  <span class="comment">#方法1，直接检测在不在result中。</span></span><br><span class="line">    result.append(copy.copy(listTmp)) <span class="comment">#方法1</span></span><br><span class="line">------------------</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(pos,len(nums)): </span><br><span class="line">    <span class="keyword">if</span> i!=pos <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]: <span class="comment">#方法2，跳过相同的数</span></span><br><span class="line">        <span class="keyword">continue</span>   方法<span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="求子集"><a href="#求子集" class="headerlink" title="求子集"></a>求子集</h1><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        self.backtrace(nums,<span class="number">0</span>,listTmp,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,pos,listTmp,result)</span>:</span></span><br><span class="line">        result.append(copy.copy(listTmp))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(pos,len(nums)):</span><br><span class="line">            listTmp.append(nums[i])</span><br><span class="line">            self.backtrace(nums,i+<span class="number">1</span>,listTmp,result)</span><br><span class="line">            listTmp.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h1 id="求子集-ii-去重复"><a href="#求子集-ii-去重复" class="headerlink" title="求子集-ii 去重复"></a>求子集-ii 去重复</h1><p>重点是在上一个的基础上</p><ul><li>对nums排序</li><li>或检测是否存在于result，或跳过相同的数（开销可能小）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        nums.sort() <span class="comment">#需要排序</span></span><br><span class="line">        self.backtrace(nums,<span class="number">0</span>,result,listTmp)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,pos,result,lista)</span>:</span></span><br><span class="line">        <span class="comment"># if listTmp not in result:  #方法1，直接检测在不在result中</span></span><br><span class="line">        <span class="comment">#    result.append(copy.copy(listTmp)) #方法1</span></span><br><span class="line"></span><br><span class="line">        result.append(copy.copy(listTmp))  <span class="comment">#方法2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(pos,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i!=pos <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]: <span class="comment">#方法2，跳过相同的数</span></span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            listTmp.append(nums[i])</span><br><span class="line">            self.backtrace(nums,i+<span class="number">1</span>,result,listTmp)</span><br><span class="line">            listTmp.pop()</span><br></pre></td></tr></table></figure><h1 id="求全排列"><a href="#求全排列" class="headerlink" title="求全排列"></a>求全排列</h1><p>可以用数组就不要用字典了，性能不好</p><p>主要是要有一个 <code>visited</code> 数组\哈希字典 来保存已经加入的数，然后大胆遍历就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        visited=&#123;&#125; <span class="comment">#哈希字典，检测是否visited</span></span><br><span class="line">        self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,result,listTmp,visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(listTmp)==len(nums): <span class="comment">#长度相等就返回</span></span><br><span class="line">            result.append(copy.copy(listTmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> visited.get(i): <span class="comment">#可以这样get检测，如果没有就返回None。也可以用 i in dict来判断</span></span><br><span class="line">            <span class="comment"># if i in visited:                </span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            listTmp.append(i)</span><br><span class="line">            visited[i]=<span class="literal">True</span></span><br><span class="line">            self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">            visited[i]=<span class="literal">False</span> <span class="comment">#如果上面用 i in dict来判断，这里就要改成dict.pop(i)</span></span><br><span class="line">            <span class="comment"># visited.pop(i)</span></span><br><span class="line">            listTmp.pop()</span><br></pre></td></tr></table></figure><h1 id="求全排列-ii-去重复"><a href="#求全排列-ii-去重复" class="headerlink" title="求全排列-ii 去重复"></a>求全排列-ii 去重复</h1><p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列-ii</a></p><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>方法1，加上 and listTmp not in result</li><li>方法2，当上一个元素和当前元素相同，而上一个元素未visited，</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        visited=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        nums.sort() <span class="comment">#排序是为了</span></span><br><span class="line">        self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,result,listTmp,visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(listTmp)==len(nums): <span class="comment">#方法1，这里加上 and listTmp not in result</span></span><br><span class="line">            result.append(copy.copy(listTmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> visited[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#方法2，当上一个元素和当前元素相同，而上一个元素未visited，（剪枝）</span></span><br><span class="line">            <span class="comment">#说米上一个元素已经作为当前位置遍历过了</span></span><br><span class="line">            <span class="comment">#当前的元素不能选择了，会引发冲突</span></span><br><span class="line">            <span class="comment">#因为上个元素已经选了它产生了结果了，现在又选就会产生冲突</span></span><br><span class="line">            <span class="keyword">if</span> i!=<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> visited[i<span class="number">-1</span>]==<span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited[i]=<span class="literal">True</span></span><br><span class="line">            listTmp.append(nums[i])</span><br><span class="line">            self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">            listTmp.pop()</span><br><span class="line">            visited[i]=<span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="剑指-全排列字符串"><a href="#剑指-全排列字符串" class="headerlink" title="剑指-全排列字符串"></a>剑指-全排列字符串</h1><p>下面是我写的思路比较清晰的 <code>visited</code> 回溯写法</p><p>由于字符串不能排序，所以只能用 <code>listTmp not in result</code> 来判断，明显效率低了很多。</p><p>最后 <strong>47 / 52</strong> 个通过测试用例 ，就超时了，所以还是借鉴网上老哥的清爽写法吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> []</span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=<span class="string">""</span></span><br><span class="line">        visited=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        self.backtrace(s,result,listTmp,visited)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,s,result,listTmp,visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(listTmp)==len(s) <span class="keyword">and</span> listTmp <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">            result.append(copy.copy(listTmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> visited[i]: </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited[i]=<span class="literal">True</span></span><br><span class="line">            listTmp+=s[i]</span><br><span class="line">            self.backtrace(s,result,listTmp,visited)</span><br><span class="line">            listTmp=listTmp[:<span class="number">-1</span>]</span><br><span class="line">            visited[i]=<span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这个 <code>DFS</code> 有剪枝，所以时间复杂度还过的过去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        result,c=[],list(s)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span> <span class="comment">#遍历第x位的固定</span></span><br><span class="line">            <span class="keyword">if</span> x==len(c)<span class="number">-1</span>: <span class="comment">#如果遍历到倒数第二位，最后一位其实也固定了</span></span><br><span class="line">                result.append(<span class="string">""</span>.join(c)) </span><br><span class="line">            <span class="comment"># setA=set()</span></span><br><span class="line">            setA=dict()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x,len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> setA: <span class="keyword">continue</span> <span class="comment">#如果值已经固定过了，剪枝</span></span><br><span class="line">                setA[c[i]]=<span class="number">1</span> <span class="comment">#添加</span></span><br><span class="line">                c[i],c[x]=c[x],c[i] <span class="comment">#把i的值固定到第x位上</span></span><br><span class="line">                dfs(x+<span class="number">1</span>) <span class="comment">#遍历下一位</span></span><br><span class="line">                c[i],c[x]=c[x],c[i] <span class="comment">#换回</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></p><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        size=len(candidates)</span><br><span class="line">        <span class="keyword">if</span> size==<span class="number">0</span>: <span class="keyword">return</span> []        </span><br><span class="line">        <span class="comment"># result=listTmp=[] #这是不能的，引用一样了！！！</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(target,listTmp,begin)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># print(listTmp)</span></span><br><span class="line">                result.append(listTmp.copy()) <span class="comment">#listTmp[:] == copy.copy(listTmp)</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, size):</span><br><span class="line">                residue=target-candidates[index]</span><br><span class="line">                <span class="comment"># 剪枝，不必递归到下一层，并且后面的分支也不必执行</span></span><br><span class="line">                <span class="comment"># 因为后面的指定会大于当前的值，没必要计算了</span></span><br><span class="line">                <span class="keyword">if</span> residue&lt;<span class="number">0</span>: <span class="keyword">break</span> </span><br><span class="line">                listTmp.append(candidates[index]) </span><br><span class="line">                <span class="comment"># 因为下一层不能比上一层还小，起始索引还从 index 开始</span></span><br><span class="line">                <span class="comment"># 防止出现重复的答案</span></span><br><span class="line">                dfs(residue,listTmp,index) </span><br><span class="line">                listTmp.pop()</span><br><span class="line">        dfs(target,listTmp,<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># self.__dfs(candidates,0,size,listTmp,result,target)</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 17. 打印从1到最大的n位数</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> [] <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">else</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>**n)]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-c
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 滑动窗口练习</title>
    <link href="https://shenqiy.cn/2020/08/02/2020-08-02-Sliding-Window-1/"/>
    <id>https://shenqiy.cn/2020/08/02/2020-08-02-Sliding-Window-1/</id>
    <published>2020-08-02T15:20:09.000Z</published>
    <updated>2020-08-02T15:29:45.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line">void slidingWindow(<span class="keyword">string</span> s, <span class="keyword">string</span> t) &#123;</span><br><span class="line">    unordered_map&lt;char, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (char c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    while (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        char c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        printf(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        while (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            char d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要变化的地方</p><ul><li>1、右指针右移之后窗口数据更新</li><li>2、判断窗口是否要收缩</li><li>3、左指针右移之后窗口数据更新</li><li>4、根据题意计算结果</li></ul><h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a></p><p>用need收集字符</p><p>用win收集窗口内字符</p><p>用match==len(need)判断每类字符是否满足t串的需求</p><p>用win[c]==need[c]来找最小的满足窗口</p><p>用right-left&lt;minLen来更新最小窗口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        win=&#123;&#125;</span><br><span class="line">        need=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t: </span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> need: need[i]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: need[i]=<span class="number">1</span></span><br><span class="line">        left=right=<span class="number">0</span></span><br><span class="line">        start=end=<span class="number">0</span> <span class="comment">#当前匹配成功的窗口范围</span></span><br><span class="line">        match=<span class="number">0</span> <span class="comment">#字符匹配的次数</span></span><br><span class="line">        minLen=sys.maxsize <span class="comment">#最大值</span></span><br><span class="line">        c=<span class="string">""</span> <span class="comment">#字符串</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;len(s):</span><br><span class="line">            c=s[right]</span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need: <span class="comment">#如果这个字符在need中</span></span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> win: win[c]+=<span class="number">1</span> <span class="comment">#win[c]加一</span></span><br><span class="line">                <span class="keyword">else</span>: win[c]=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> win[c]==need[c]: </span><br><span class="line">                    match+=<span class="number">1</span> <span class="comment">#如果win中的这个c字符数量与need中一样，</span></span><br><span class="line">                             <span class="comment">#就匹配成功一个字符（超出小于都不加一）</span></span><br><span class="line">            <span class="keyword">while</span> match==len(need): <span class="comment">#如果match的字符种数等同于need中字符种数</span></span><br><span class="line">                <span class="keyword">if</span> right-left&lt;minLen:  <span class="comment">#最小长度的更新</span></span><br><span class="line">                    minLen=right-left</span><br><span class="line">                    start=left</span><br><span class="line">                    end=right</span><br><span class="line">                c=s[left] <span class="comment">#这是取left所指的字符</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> need: <span class="comment">#如果当前字符属于need中，、并且退处</span></span><br><span class="line">                    <span class="keyword">if</span> win[c]==need[c]:  <span class="comment">#如果当前字符的数量相同，将match减一（关闭匹配）</span></span><br><span class="line">                        match-=<span class="number">1</span></span><br><span class="line">                    win[c]-=<span class="number">1</span> <span class="comment">#left移动了，减少当前字符，不管match减不减，这里都要过一个字符</span></span><br><span class="line">        <span class="keyword">if</span> minLen==sys.maxsize: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://shenqiy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法 二进制练习</title>
    <link href="https://shenqiy.cn/2020/08/02/2020-08-02-Binary-1/"/>
    <id>https://shenqiy.cn/2020/08/02/2020-08-02-Binary-1/</id>
    <published>2020-08-02T15:19:51.000Z</published>
    <updated>2020-08-02T15:28:19.224Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting" target="_blank" rel="noopener">位运算总结</a></p><h1 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h1><p><strong>加法非进位</strong></p><p>n=a^b</p><p><strong>加法进位</strong></p><p>c=a&amp;b</p><p><strong>加法</strong></p><p>a+b=n+c=sum</p><p>n+c可以进一步递归，直到c为0时，返回n</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>a=0^a = a^0</p><p>0=a ^ a</p><p>由上面两个推导出：a=a^ b ^b</p><h1 id="没有加减乘除的加法"><a href="#没有加减乘除的加法" class="headerlink" title="没有加减乘除的加法"></a>没有加减乘除的加法</h1><p>python写这道题有些复杂</p><p><img src="/2020/08/02/2020-08-02-Binary-1/image-20200730190241516.png" alt="image-20200730190241516"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">        x=<span class="number">0xffffffff</span></span><br><span class="line">        a,b=a&amp;x,b&amp;x <span class="comment">#取32位以内的二进制</span></span><br><span class="line">        <span class="keyword">while</span> b!=<span class="number">0</span>:</span><br><span class="line">            a,b=(a^b),(a&amp;b)&lt;&lt;<span class="number">1</span>&amp;x</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a&lt;=<span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a^x) <span class="comment">#若补码 aa 为负数,需要还原将32位以上取反</span></span><br></pre></td></tr></table></figure><p>更推荐用C / C++ / JAVA</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : add((a ^ b),(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="只出现一次的数"><a href="#只出现一次的数" class="headerlink" title="只出现一次的数"></a>只出现一次的数</h1><pre><code>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</code></pre><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>用的定律就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        result=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            result^=num</span><br><span class="line">        print(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;位运算总结&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;常识&quot;&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://shenqiy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法 二分搜索练习</title>
    <link href="https://shenqiy.cn/2020/08/02/2020-08-02-Binary-Search-1/"/>
    <id>https://shenqiy.cn/2020/08/02/2020-08-02-Binary-Search-1/</id>
    <published>2020-08-02T15:19:37.000Z</published>
    <updated>2020-08-02T15:28:11.166Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/08/02/2020-08-02-Binary-Search-1/image-20200801203404830.png" alt="image-20200801203404830"></p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">二分查找</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>使用了模板3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(end+start)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target: <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&lt;target: start=mid</span><br><span class="line">            <span class="keyword">else</span>: end=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]==target: <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end]==target: <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="搜索区间-LintCode"><a href="#搜索区间-LintCode" class="headerlink" title="搜索区间 LintCode"></a>搜索区间 <code>LintCode</code></h1><p>给定一个包含 <em>n</em> 个整数的排序数组，找出给定目标值 <em>target</em> 的起始和结束位置。</p><p>如果目标值不在数组中，则返回<code>[-1, -1]</code></p><p>思路：</p><ul><li>用模板三</li><li>先用二分搜索，搜第一次出现的</li><li>再二分搜索，搜最后一次出现的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span> <span class="params">(A []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(A) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> start+<span class="number">1</span> &lt; end &#123;</span><br><span class="line">        mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] &gt; target &#123;</span><br><span class="line">            end = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> A[mid] &lt; target &#123;</span><br><span class="line">            start = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果相等，应该继续向左找，就能找到第一个目标值的位置</span></span><br><span class="line">            end = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索左边的索引</span></span><br><span class="line">    <span class="keyword">if</span> A[start] == target &#123;</span><br><span class="line">        result[<span class="number">0</span>] = start</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> A[end] == target &#123;</span><br><span class="line">        result[<span class="number">0</span>] = end</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> start+<span class="number">1</span> &lt; end &#123;</span><br><span class="line">        mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] &gt; target &#123;</span><br><span class="line">            end = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> A[mid] &lt; target &#123;</span><br><span class="line">            start = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果相等，应该继续向右找，就能找到最后一个目标值的位置</span></span><br><span class="line">            start = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索右边的索引</span></span><br><span class="line">    <span class="keyword">if</span> A[end] == target &#123;</span><br><span class="line">        result[<span class="number">1</span>] = end</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> A[start] == target &#123;</span><br><span class="line">        result[<span class="number">1</span>] = start</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>主要思路：</p><ul><li>依旧是用模板3</li><li>题目其实是找第一个能插入的位置，所以有相同的值的话，需要插在这个值的第一个出现的位置</li><li>如果没有相同值，就按情况找start、end、end+1其中的一个返回即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;target: end=mid</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]&lt;target <span class="keyword">and</span> nums[end]&lt;target: <span class="keyword">return</span> end+<span class="number">1</span> <span class="comment">#target比s\e都大</span></span><br><span class="line">        <span class="keyword">if</span> nums[start]&gt;=target <span class="keyword">and</span> nums[end]&gt;target: <span class="keyword">return</span> start <span class="comment">#target应该放在s处</span></span><br><span class="line">        <span class="keyword">return</span> end <span class="comment">#应该放在中间</span></span><br></pre></td></tr></table></figure><h1 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h1><p>很简单的思路</p><ul><li>把二维化为一维</li><li>再二分搜索（可以用模板1、也可以用模板3）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix)==<span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>])==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        matrixN=len(matrix)</span><br><span class="line">        matrixM=len(matrix[<span class="number">0</span>])</span><br><span class="line">        search=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(matrixN*matrixM)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(matrixN):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(matrixM):</span><br><span class="line">                search[i*matrixM+j]=matrix[i][j]</span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(search)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;=end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="comment"># print(search[mid])</span></span><br><span class="line">            <span class="keyword">if</span> search[mid]==target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> search[mid]&gt;target: end=mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>: start=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="第一个错误的版本号"><a href="#第一个错误的版本号" class="headerlink" title="第一个错误的版本号"></a>第一个错误的版本号</h1><p>仍然是用模板3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">1</span></span><br><span class="line">        end=n</span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid)==<span class="literal">True</span>: end=mid</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> isBadVersion(start): <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> end</span><br></pre></td></tr></table></figure><h1 id="搜索旋转排序数组最小值"><a href="#搜索旋转排序数组最小值" class="headerlink" title="搜索旋转排序数组最小值"></a>搜索旋转排序数组最小值</h1><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></p><p><img src="/2020/08/02/2020-08-02-Binary-Search-1/image-20200801182956889.png" alt="image-20200801182956889"></p><p>思路如上，主要是要用nums[end]这个分界点来做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        target=nums[end]</span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;=target: end=mid</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]&lt;nums[end]: <span class="keyword">return</span> nums[start]</span><br><span class="line">        <span class="keyword">return</span> nums[end]</span><br><span class="line"><span class="comment"># 其实不用设target</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># target=nums[end] &lt;--删掉</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;=nums[end]: end=mid &lt;--nums[end]作比较，看mid落在哪里</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]&lt;nums[end]: <span class="keyword">return</span> nums[start]</span><br><span class="line">        <span class="keyword">return</span> nums[end]</span><br></pre></td></tr></table></figure><h1 id="搜索旋转排序数组最小值-ii-有重复元素"><a href="#搜索旋转排序数组最小值-ii-有重复元素" class="headerlink" title="搜索旋转排序数组最小值-ii(有重复元素)"></a>搜索旋转排序数组最小值-ii(有重复元素)</h1><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 II</a></p><p>比之前的题多了一个跳过重复元素的操作</p><p><code>while start+1&lt;end and nums[end]==nums[end-1]: end-=1 #重点，要跳过重复的元素</code><br><code>while start+1&lt;end and nums[start]==nums[start+1]: start+=1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            <span class="keyword">while</span> start+<span class="number">1</span>&lt;end <span class="keyword">and</span> nums[end]==nums[end<span class="number">-1</span>]: end-=<span class="number">1</span> <span class="comment">#重点，要跳过重复的元素</span></span><br><span class="line">            <span class="keyword">while</span> start+<span class="number">1</span>&lt;end <span class="keyword">and</span> nums[start]==nums[start+<span class="number">1</span>]: start+=<span class="number">1</span></span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;=nums[end]: end=mid</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]&lt;nums[end]: <span class="keyword">return</span> nums[start]</span><br><span class="line">        <span class="keyword">return</span> nums[end]</span><br></pre></td></tr></table></figure><h1 id="搜索旋转排序数组中某个值"><a href="#搜索旋转排序数组中某个值" class="headerlink" title="搜索旋转排序数组中某个值"></a>搜索旋转排序数组中某个值</h1><p>主要是要对两条线的，start\mid\end的四种情况有分析</p><ul><li>相等直接返回</li><li>如果左半部分是连续的<ul><li>如果target是在左半部分内的，往左缩圈</li><li>如果target不在，往右缩圈</li></ul></li><li>如果右半部分是连续的<ul><li>如果target是在右半部分内，往右缩圈</li><li>如果target不在，往左缩圈</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target: <span class="keyword">return</span> mid <span class="comment">#相等直接返回</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&gt;nums[start]: <span class="comment">#如果左半部分是连续的</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid]&gt;target <span class="keyword">and</span> nums[start]&lt;=target: end=mid  <span class="comment">#如果target是在左半部分内的</span></span><br><span class="line">                <span class="keyword">else</span>: start=mid</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#nums[mid]&lt;nums[end] #如果右半部分是连续的</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid]&lt;target <span class="keyword">and</span> nums[end]&gt;=target: start=mid <span class="comment">#如果target是在右半部分内的</span></span><br><span class="line">                <span class="keyword">else</span>: end=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]==target: <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end]==target: <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="搜索旋转排序数组中某个值-ii"><a href="#搜索旋转排序数组中某个值-ii" class="headerlink" title="搜索旋转排序数组中某个值-ii"></a>搜索旋转排序数组中某个值-ii</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">搜索旋转排序数组 II</a></p><ul><li><p>跳过重复元素</p></li><li><p>算mid值</p></li><li><p>对两条线的，start\mid\end的四种情况有分析</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[start]==nums[start+<span class="number">1</span>]: start+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[end]==nums[end<span class="number">-1</span>]: end-=<span class="number">1</span></span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> nums[start]&lt;=nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[start]&lt;=target <span class="keyword">and</span> target&lt;nums[mid]:end=mid</span><br><span class="line">                <span class="keyword">else</span>: start=mid</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> nums[mid]&lt;target <span class="keyword">and</span>  target&lt;=nums[end]: start=mid</span><br><span class="line">                <span class="keyword">else</span>: end=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]==target <span class="keyword">or</span> nums[end]==target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/08/02/2020-08-02-Binary-Search-1/image-20200801203404830.png&quot; alt=&quot;image-20200801203404830&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://shenqiy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法 二叉搜索树练习</title>
    <link href="https://shenqiy.cn/2020/08/02/2020-08-02-Binary-Search-Tree-1/"/>
    <id>https://shenqiy.cn/2020/08/02/2020-08-02-Binary-Search-Tree-1/</id>
    <published>2020-08-02T15:19:17.000Z</published>
    <updated>2020-08-02T15:27:28.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的检查"><a href="#二叉搜索树的检查" class="headerlink" title="二叉搜索树的检查"></a>二叉搜索树的检查</h1><p>三种方法：</p><ul><li>递归DFS中序遍历进行<ul><li>得到结果res，检查 <code>res.sort()==res and len(set(res))==len(res)</code> </li><li>保证中序结果是排好序的，并且没有重复值</li></ul></li><li>迭代中序DFS遍历进行，在迭代中检测 <code>pre&lt;current.val</code></li><li>递归中序DFS遍历进行，如下，每次都要带入<code>maxV,minV</code> 两个参数往下走</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#用递归法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root,float(<span class="string">"inf"</span>),float(<span class="string">"-inf"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,maxV,minV)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root.val&gt;=maxV <span class="keyword">or</span> root.val&lt;=minV:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left=self.dfs(root.left,root.val,minV) </span><br><span class="line">        right=self.dfs(root.right,maxV,root.val)</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的插入新节点"><a href="#二叉搜索树的插入新节点" class="headerlink" title="二叉搜索树的插入新节点"></a>二叉搜索树的插入新节点</h1><p>思路：</p><p>总有一个NULL节点放新的val节点</p><p>所以只要看val与root.val的大小关系，然后选左右子树递归插入就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val&gt;val: root.left=self.insertIntoBST(root.left,val)</span><br><span class="line">        <span class="keyword">else</span>: root.right=self.insertIntoBST(root.right,val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的删除节点"><a href="#二叉搜索树的删除节点" class="headerlink" title="二叉搜索树的删除节点"></a>二叉搜索树的删除节点</h1><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></p><p>主要是各种情况的判断：</p><ul><li>root为空，直接返回root</li><li>root节点值小于key</li><li>root节点值大于key</li><li>root节点值等同key<ul><li>右子树为空</li><li>左子树为空</li><li>左右子树都不为空<ul><li>找到右子树的最小值\最左的节点，把左子树接到右子树上</li></ul></li><li>都为空的情况没有考虑。。。。。。。。（但是测试例子没有这种例子）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, root: TreeNode, key: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val&lt;key:  <span class="comment">#root节点值小于key</span></span><br><span class="line">            root.right=self.deleteNode(root.right,key)</span><br><span class="line">        <span class="keyword">elif</span> root.val&gt;key: <span class="comment">#root节点值大于key</span></span><br><span class="line">            root.left=self.deleteNode(root.left,key)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#root节点值等同key</span></span><br><span class="line">            <span class="keyword">if</span> root.right==<span class="literal">None</span>: <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">elif</span> root.left==<span class="literal">None</span>: <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#左右子树都不为空。都为空的情况没有考虑。。。。。。。。</span></span><br><span class="line">                curNode=root.right</span><br><span class="line">                <span class="keyword">while</span> curNode.left!=<span class="literal">None</span>: <span class="comment">#找到右子树的最小值</span></span><br><span class="line">                    curNode=curNode.left</span><br><span class="line">                curNode.left=root.left <span class="comment">#把左子树接到右子树上</span></span><br><span class="line">                root=root.right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> self.compare(root)&lt;<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left=self.compare(root.left)</span><br><span class="line">        right=self.compare(root.right)</span><br><span class="line">        <span class="keyword">if</span> left&gt;=<span class="number">0</span> <span class="keyword">and</span> right&gt;=<span class="number">0</span> <span class="keyword">and</span> abs(left-right)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="二叉搜索树与双向循环链表"><a href="#二叉搜索树与双向循环链表" class="headerlink" title="二叉搜索树与双向循环链表"></a>二叉搜索树与双向循环链表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">        stack=[]</span><br><span class="line">        prev=<span class="literal">None</span></span><br><span class="line">        head=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root=root.left</span><br><span class="line">            node=stack.pop()</span><br><span class="line">            root=node.right</span><br><span class="line">            <span class="keyword">if</span> prev==<span class="literal">None</span>:</span><br><span class="line">                head=node</span><br><span class="line">                prev=head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.right=node</span><br><span class="line">                node.left=prev</span><br><span class="line">                prev=node</span><br><span class="line">        head.left=prev</span><br><span class="line">        prev.right=head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉搜索树的检查&quot;&gt;&lt;a href=&quot;#二叉搜索树的检查&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的检查&quot;&gt;&lt;/a&gt;二叉搜索树的检查&lt;/h1&gt;&lt;p&gt;三种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归DFS中序遍历进行&lt;ul&gt;
&lt;li&gt;得到结果res
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://shenqiy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法 动态规划练习</title>
    <link href="https://shenqiy.cn/2020/08/02/2020-08-02-DP-1/"/>
    <id>https://shenqiy.cn/2020/08/02/2020-08-02-DP-1/</id>
    <published>2020-08-02T15:18:33.000Z</published>
    <updated>2020-08-02T15:28:54.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三角形入门"><a href="#三角形入门" class="headerlink" title="三角形入门"></a>三角形入门</h1><p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">三角形最小路径和</a></p><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点    。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''方法1=深搜'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> triangle==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        minmum=<span class="number">0</span></span><br><span class="line">        l=len(triangle)<span class="number">-1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j,suma)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i==l <span class="keyword">and</span> suma&lt;minmum:</span><br><span class="line">                minmum=suma</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(i+<span class="number">1</span>,j,suma+triangle[i][j])</span><br><span class="line">            dfs(i+<span class="number">1</span>,j+<span class="number">1</span>,suma+triangle[i][j])</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> minmum</span><br><span class="line"><span class="string">'''方法2=分治法'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> triangle==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        l=len(triangle)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i==l: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> min(dfs(i+<span class="number">1</span>,j),dfs(i+<span class="number">1</span>,j+<span class="number">1</span>))+triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>动态规划，自底向上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> triangle==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                triangle[i][j]=min(triangle[i+<span class="number">1</span>][j],triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])+triangle[i][j]</span><br><span class="line">        <span class="comment"># print(triangle)</span></span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>动态规划，自顶向下（不比自底向上优雅）</p><ul><li>从上往下走，算到最后一层</li><li>由于下面一层比上面一层大，所以需要考虑左右的边界情况</li><li>然后遍历最后一层，找最小值返回</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> triangle==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(triangle)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                <span class="keyword">if</span> j<span class="number">-1</span>&lt;<span class="number">0</span>:</span><br><span class="line">                    triangle[i][j]=triangle[i<span class="number">-1</span>][j]+triangle[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j+<span class="number">1</span>&gt;=len(triangle[i]):</span><br><span class="line">                    triangle[i][j]=triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]+triangle[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    triangle[i][j]=min(triangle[i<span class="number">-1</span>][j],triangle[i<span class="number">-1</span>][j<span class="number">-1</span>])+triangle[i][j]</span><br><span class="line">        len_trangle=len(triangle)</span><br><span class="line">        len_trangle2=len(triangle[len_trangle<span class="number">-1</span>])</span><br><span class="line">        res=triangle[len_trangle<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_trangle2):</span><br><span class="line">            res=min(res,triangle[len_trangle<span class="number">-1</span>][i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>满足两个条件</p><ul><li>满足以下条件之一<ul><li>求最大/最小值（Maximum/Minimum ）</li><li>求是否可行（Yes/No ）</li><li>求可行个数（Count(*) ）</li></ul></li><li>满足不能排序或者交换（Can not sort / swap ）</li></ul><h1 id="四个要素"><a href="#四个要素" class="headerlink" title="四个要素"></a>四个要素</h1><ul><li>状态：存储小规模问题的结果</li><li>方程：状态之间的转移计算</li><li>初始化：开始的状态，可以把能算的先算了</li><li>答案：最后的状态在哪里？</li></ul><h1 id="常见四种类型"><a href="#常见四种类型" class="headerlink" title="常见四种类型"></a>常见四种类型</h1><ol><li>Matrix DP (10%)</li><li>Sequence (40%)</li><li>Two Sequences DP (40%)</li><li>Backpack (10%)</li></ol><h1 id="编写时注意事项"><a href="#编写时注意事项" class="headerlink" title="编写时注意事项"></a>编写时注意事项</h1><ul><li>可以先创建 dp[n+1] [m+1] 然后，将 dp[0] [i]  dp[i] [0]先设初值了</li><li>在算的时候，要做好条件</li><li>要注意看是什么类型的dp：矩阵、单序列、双序列、零花钱和背包？</li></ul><h1 id="1、矩阵类型（10-）"><a href="#1、矩阵类型（10-）" class="headerlink" title="1、矩阵类型（10%）"></a>1、矩阵类型（10%）</h1><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">最小路径和</a></p><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p>使用动态规划</p><ul><li>由于每次只能向下或者向右移动一步，所以先初始化边缘值</li><li>然后从第二行开始，一行行往下刷新</li><li>也可以从第二列开始，一行行往下刷新（都能保证某点值依赖的点都备算过）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n=len(grid)</span><br><span class="line">        m=len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> m==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n): <span class="comment">#初始化边缘值</span></span><br><span class="line">            grid[i][<span class="number">0</span>]=grid[i][<span class="number">0</span>]+grid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m): <span class="comment">#初始化边缘值</span></span><br><span class="line">            grid[<span class="number">0</span>][j]=grid[<span class="number">0</span>][j]+grid[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                grid[i][j]=grid[i][j]+min(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># print(grid)</span></span><br><span class="line">        <span class="keyword">return</span> grid[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人<strong>每次只能向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="/2020/08/02/2020-08-02-DP-1/image-20200731163955686.png" alt="image-20200731163955686"></p><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>解题思路：</strong></p><ul><li>初始化第一行、第一列为1，因为走到他们都只有一种走法</li><li>然后从第二行第二行开始遍历，每个走到这些方块的走法，由前两个方块的走法加起来</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp=[[<span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="不同路径-ii"><a href="#不同路径-ii" class="headerlink" title="不同路径-ii"></a>不同路径-ii</h2><p>在上一题基础上，增加了障碍</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n=len(obstacleGrid)</span><br><span class="line">        m=len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n): <span class="comment">#从零开始，防止[0][0]位置的1，直接堵住</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,m): <span class="comment">#从零开始，防止[0][0]位置的1，直接堵</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j]==<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]==<span class="number">1</span>: dp[i][j]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>: dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="2、单序列类型（40-）"><a href="#2、单序列类型（40-）" class="headerlink" title="2、单序列类型（40%）"></a>2、单序列类型（40%）</h1><h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p>解：从前到后遍历计算</p><p>要注意的初值：0、1、2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p><p>示例 1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 <span class="number">1</span> 步，从位置 <span class="number">0</span> 到达 位置 <span class="number">1</span>, 然后再从位置 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个位置。</span><br></pre></td></tr></table></figure><p>解：</p><ul><li>遍历每个元素</li><li>对于一个元素，要遍历其前面所有元素才能判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        dp=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> dp[j]==<span class="literal">True</span> <span class="keyword">and</span> nums[j]+j==i:</span><br><span class="line">                    dp[i]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>但是这样这道题会超时</p><p>我们更推荐下面的做法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        k=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i&gt;k: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            k=max(k,nums[i]+i)</span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure><h2 id="跳跃游戏-ii"><a href="#跳跃游戏-ii" class="headerlink" title="跳跃游戏-ii"></a>跳跃游戏-ii</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p>说明:</p><p>假设你总是可以到达数组的最后一个位置。</p><p>解法：还是用动态规划，超时了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        lenL=len(nums)</span><br><span class="line">        <span class="keyword">if</span> lenL==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(lenL)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenL):</span><br><span class="line">            dp[i]=i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]+j&gt;=i:</span><br><span class="line">                    dp[i]=min(dp[i],dp[j]+<span class="number">1</span>) <span class="comment">#这里要判断的是，找最小的</span></span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[lenL<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>于是我们挨着跳，这叫DP？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        end=<span class="number">0</span></span><br><span class="line">        maxPos=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>): <span class="comment">#遍历</span></span><br><span class="line">            print(i)</span><br><span class="line">            maxPos=max(nums[i]+i,maxPos)<span class="comment">#找最大的区间</span></span><br><span class="line">            <span class="keyword">if</span> i==end: <span class="comment">#如果等于end就自加1</span></span><br><span class="line">                end=maxPos</span><br><span class="line">                ans+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>动态规划加贪心算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v2 动态规划+贪心优化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    f := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// 取第一个能跳到当前位置的点即可</span></span><br><span class="line">        <span class="comment">// 因为跳跃次数的结果集是单调递增的，所以贪心思路是正确的</span></span><br><span class="line">        idx:=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx&lt;n&amp;&amp;idx+nums[idx]&lt;i&#123;</span><br><span class="line">            idx++</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]=f[idx]+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分割回文串-ii"><a href="#分割回文串-ii" class="headerlink" title="分割回文串-ii"></a>分割回文串-ii</h2><p><a href="https://leetcode-cn.com/problems/word-break" target="_blank" rel="noopener">分割回文串-ii</a></p><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>首选做初值，dp[0]=True，这样保证之后的可以好好遍历</li><li>最重要的是要有 <code>dp[j] and s[j:i] in wordDict</code> 这个条件的设置能力</li><li>然后要会计算 <code>maxLen</code> ，这个是wordDict中最长字符的长度，所以要遍历也要从 <code>i-maxLen</code> 开始（如果i-maxLen不小于零的话）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        dp=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">True</span></span><br><span class="line">        maxLen=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> len(word)&gt;maxLen: maxLen=len(word)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(max(<span class="number">0</span>,i-maxLen),i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(s)]</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/comments/" target="_blank" rel="noopener">最长上升子序列</a></p><p>序列类型，大同小异</p><p>要注意是这里的上升是严格上升，相同的不算上升</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums==[]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        lenN=len(nums)</span><br><span class="line">        dp=[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(lenN)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenN):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;nums[i]:</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print()</span></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h1 id="3、双序列类型（40-）"><a href="#3、双序列类型（40-）" class="headerlink" title="3、双序列类型（40%）"></a>3、双序列类型（40%）</h1><p>主要用于两个字符串恶的比较</p><p>两个字符串组成矩阵</p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></p><p>和背包问题差不多，但是有些难想到</p><p>需要有动态规划的思维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">        lenA=len(text1)</span><br><span class="line">        lenB=len(text2)</span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(lenB+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(lenA+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,lenA+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,lenB+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[lenA][lenB]</span><br></pre></td></tr></table></figure><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a></p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        dp=[[j <span class="keyword">for</span> j <span class="keyword">in</span> range(len(word2)+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1)+<span class="number">1</span>): dp[i][<span class="number">0</span>]=i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(word1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(word2)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=min(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(dp[i][j])</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(word1)][len(word2)]</span><br></pre></td></tr></table></figure><h1 id="4、零钱与背包"><a href="#4、零钱与背包" class="headerlink" title="4、零钱与背包"></a>4、零钱与背包</h1><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>主要是用一个长度为amount的dp数组来做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        dp=[amount+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(amount+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(coins)):</span><br><span class="line">                <span class="keyword">if</span> i-coins[j]&gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i]=min(dp[i],dp[i-coins[j]]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> dp[amount]&gt;amount: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure><h2 id="0-1背包问题（能装多少）"><a href="#0-1背包问题（能装多少）" class="headerlink" title="0-1背包问题（能装多少）"></a>0-1背包问题（能装多少）</h2><blockquote><p>在 n 个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为 m，每个物品的大小为 A[i]</p></blockquote><p>主要是要做一个矩阵，n个物品作为i , 背包大小m作为j</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backPack</span> <span class="params">(m <span class="keyword">int</span>, A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="comment">// f[i][j] 前i个物品，是否能装j</span></span><br><span class="line">    <span class="comment">// f[i][j] =f[i-1][j] f[i-1][j-a[i] j&gt;a[i]</span></span><br><span class="line">    <span class="comment">// f[0][0]=true f[...][0]=true</span></span><br><span class="line">    <span class="comment">// f[n][X]</span></span><br><span class="line">    f:=<span class="built_in">make</span>([][]<span class="keyword">bool</span>,<span class="built_in">len</span>(A)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=<span class="built_in">len</span>(A);i++&#123;</span><br><span class="line">        f[i]=<span class="built_in">make</span>([]<span class="keyword">bool</span>,m+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="built_in">len</span>(A);i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;=m;j++&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j-A[i<span class="number">-1</span>]&gt;=<span class="number">0</span> &amp;&amp; f[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]&#123; 《--重点</span><br><span class="line">                f[i][j]=<span class="literal">true</span> 《--重点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=m;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        <span class="keyword">if</span> f[<span class="built_in">len</span>(A)][i] &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0-1背包-ii-最大价值"><a href="#0-1背包-ii-最大价值" class="headerlink" title="0-1背包-ii 最大价值"></a>0-1背包-ii 最大价值</h1><blockquote><p>有 <code>n</code> 个物品和一个大小为 <code>m</code> 的背包. 给定数组 <code>A</code> 表示每个物品的大小和数组 <code>V</code> 表示每个物品的价值. 问最多能装入背包的总价值是多大?</p></blockquote><p>思路：f[i] [j] 前 i 个物品，装入 j 背包 最大价值</p><p>做一个矩形的DP，然后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(m,A,V)</span>:</span></span><br><span class="line">    dp=[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)+<span class="number">1</span>)]    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j-A[i<span class="number">-1</span>]&gt;=<span class="number">0</span>: 《--重点</span><br><span class="line">            dp[i][j]=max(dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[A[i<span class="number">-1</span>]],dp[i<span class="number">-1</span>][j]) 《--重点</span><br><span class="line">    <span class="keyword">return</span> dp[len(A)][m]</span><br></pre></td></tr></table></figure><p>go的版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backPackII</span> <span class="params">(m <span class="keyword">int</span>, A []<span class="keyword">int</span>, V []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="comment">// f[i][j] 前i个物品，装入j背包 最大价值</span></span><br><span class="line">    <span class="comment">// f[i][j] =max(f[i-1][j] ,f[i-1][j-A[i]]+V[i]) 是否加入A[i]物品</span></span><br><span class="line">    <span class="comment">// f[0][0]=0 f[0][...]=0 f[...][0]=0</span></span><br><span class="line">    f:=<span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="built_in">len</span>(A)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(A)+<span class="number">1</span>;i++&#123;</span><br><span class="line">        f[i]=<span class="built_in">make</span>([]<span class="keyword">int</span>,m+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="built_in">len</span>(A);i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;=m;j++&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j-A[i<span class="number">-1</span>] &gt;= <span class="number">0</span>&#123;</span><br><span class="line">                f[i][j]=max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="built_in">len</span>(A)][m]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三角形入门&quot;&gt;&lt;a href=&quot;#三角形入门&quot; class=&quot;headerlink&quot; title=&quot;三角形入门&quot;&gt;&lt;/a&gt;三角形入门&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/triangle/&quot; targe
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://shenqiy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法 递归练习</title>
    <link href="https://shenqiy.cn/2020/08/02/2020-08-02-Recursive-1/"/>
    <id>https://shenqiy.cn/2020/08/02/2020-08-02-Recursive-1/</id>
    <published>2020-08-02T15:18:02.000Z</published>
    <updated>2020-08-02T15:29:19.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="递归深度过深出错-超出时间限制"><a href="#递归深度过深出错-超出时间限制" class="headerlink" title="递归深度过深出错(超出时间限制)"></a>递归深度过深出错(超出时间限制)</h2><p>如果提醒递归深度过深出错</p><p>就用如下的代码更改限制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> </span><br><span class="line"><span class="meta">    @functools.lru_cache(maxsize=512)</span></span><br></pre></td></tr></table></figure><h2 id="PS-为什么要模1000000007"><a href="#PS-为什么要模1000000007" class="headerlink" title="PS : 为什么要模1000000007"></a>PS : 为什么要模1000000007</h2><p>（跟我念，一，八个零，七）。参考<a href="https://www.liuchuo.net/archives/645" target="_blank" rel="noopener">https://www.liuchuo.net/archives/645</a></p><ol><li>大数相乘，大数的排列组合等为什么要取模</li></ol><ul><li>1000000007是一个质数（素数），对质数取余能最大程度避免结果冲突/重复</li><li>int32位的最大值为2147483647，所以对于int32位来说1000000007足够大。</li><li>int64位的最大值为2^63-1，用最大值模1000000007的结果求平方，不会在int64中溢出。</li><li>所以在大数相乘问题中，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出。</li></ul><ol><li>这道题为什么要取模，取模前后的值不就变了吗？</li></ol><ul><li>确实：取模前 f(43) = 701408733, f(44) = 1134903170, f(45) = 1836311903, 但是 f(46) &gt; 2147483647结果就溢出了。</li><li>_____，取模后 f(43) = 701408733, f(44) = 134903163 , f(45) = 836311896, f(46) = 971215059没有溢出。</li><li>取模之后能够计算更多的情况，如 f(46)</li><li>这道题的测试答案与取模后的结果一致。</li><li>总结一下，这道题要模1000000007的根本原因是标准答案模了1000000007。不过大数情况下为了防止溢出，模1000000007是通用做法，原因见第一点。</li></ul><h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            s[i],s[j]=s[j],s[i]</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">    <span class="comment">#     result=[]</span></span><br><span class="line">    <span class="comment">#     self.reverse(s,result,0)</span></span><br><span class="line">    <span class="comment">#     print(result)</span></span><br><span class="line">    <span class="comment">#     s=result.copy() #这样子是不算改s的</span></span><br><span class="line">    <span class="comment">#     # print(s)</span></span><br><span class="line">    <span class="comment"># def reverse(self,s,result,index):</span></span><br><span class="line">    <span class="comment">#     if index==len(s): return</span></span><br><span class="line">    <span class="comment">#     self.reverse(s,result,index+1)</span></span><br><span class="line">    <span class="comment">#     result.append(s[index])</span></span><br></pre></td></tr></table></figure><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>虽然简单，但是也花了时间调，主要是因为递归的时候，python中递归会超出最大的长度，需要用 <code>@functools.lru_cache(maxsize=512)</code> 来关闭限制。</p><p><strong>迭代型</strong>：需要做好初值：res[0] , res[1] ，一般都需要两个初值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(maxsize=512)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> n <span class="comment">#递归型</span></span><br><span class="line">        <span class="keyword">return</span> (self.fib(n<span class="number">-1</span>) + self.fib(n<span class="number">-2</span>))%<span class="number">1000000007</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># res=[i for i in range(n+1)] #迭代型</span></span><br><span class="line">        <span class="comment"># for i in range(2,n+1): res[i]=(res[i-1]+res[i-2])%1000000007</span></span><br><span class="line">        <span class="comment"># return res[n]</span></span><br></pre></td></tr></table></figure><h1 id="跳台阶-ii"><a href="#跳台阶-ii" class="headerlink" title="跳台阶-ii"></a>跳台阶-ii</h1><p>用迭代型，还是要做好两个初值：res[1]、res[2]</p><p>PS：当台阶为零时，值为1 <code>？？</code> 这个特殊情况，我们不算在两个初值中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        res[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        res[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            res[i]=(res[i<span class="number">-1</span>]+res[i<span class="number">-2</span>])%<span class="number">1000000007</span></span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(maxsize=512)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> (self.numWays(n<span class="number">-1</span>)+self.numWays(n<span class="number">-2</span>))%<span class="number">1000000007</span></span><br></pre></td></tr></table></figure><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/" target="_blank" rel="noopener">两两交换链表中的节点</a></p><p>主要要用tmp把暂时无关的节点存好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        tmpnext=head.next.next</span><br><span class="line">        tmp=head.next</span><br><span class="line">        tmp.next=head</span><br><span class="line">        head.next=self.swapPairs(tmpnext)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure><h1 id="不同的二叉搜索树-ii"><a href="#不同的二叉搜索树-ii" class="headerlink" title="不同的二叉搜索树-ii"></a>不同的二叉搜索树-ii</h1><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p>主要是</p><ul><li>遍历选取不同的根节点</li><li>然后递归获得左子树的根节点数组，右子树的根节点数组</li><li>然后创建根节点，遍历左右子树两个for循环，连上根节点，添加到list中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>,n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,start,end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start&gt;end: <span class="keyword">return</span> [TreeNode(<span class="literal">None</span>)] <span class="comment">#这里要注意</span></span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,end+<span class="number">1</span>): <span class="comment">#从零开始遍历</span></span><br><span class="line">            left=self.helper(start,i<span class="number">-1</span>)</span><br><span class="line">            right=self.helper(i+<span class="number">1</span>,end)</span><br><span class="line">            <span class="keyword">for</span> leftNode <span class="keyword">in</span> left: <span class="comment">#遍历左节点</span></span><br><span class="line">                <span class="keyword">for</span> rightNode <span class="keyword">in</span> right: <span class="comment">#遍历右节点</span></span><br><span class="line">                    root=TreeNode(i)</span><br><span class="line">                    <span class="keyword">if</span> leftNode.val!=<span class="literal">None</span>:root.left=leftNode</span><br><span class="line">                    <span class="keyword">if</span> rightNode.val!=<span class="literal">None</span>:root.right=rightNode</span><br><span class="line">                    ans.append(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h1&gt;&lt;h2 id=&quot;递归深度过深出错-超出时间限制&quot;&gt;&lt;a href=&quot;#递归深度过深出错-超出时间限制&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://shenqiy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法 栈与队列练习</title>
    <link href="https://shenqiy.cn/2020/08/02/2020-08-02-stack-queue-1/"/>
    <id>https://shenqiy.cn/2020/08/02/2020-08-02-stack-queue-1/</id>
    <published>2020-08-02T14:21:03.000Z</published>
    <updated>2020-08-02T15:30:32.162Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://shenqiy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法 二叉树练习</title>
    <link href="https://shenqiy.cn/2020/07/30/2020-07-30-Binary-Tree-1/"/>
    <id>https://shenqiy.cn/2020/07/30/2020-07-30-Binary-Tree-1/</id>
    <published>2020-07-30T07:41:28.000Z</published>
    <updated>2020-08-02T15:27:17.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>利用前序和后序的关系来构建</p><p><img src="/2020/07/30/2020-07-30-Binary-Tree-1/image-20200726005338718.png" alt="image-20200726005338718"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root=TreeNode(pre.pop(<span class="number">0</span>))</span><br><span class="line">        tin_root_index=tin.index(root.val)</span><br><span class="line">        root.left=self.reConstructBinaryTree(pre,tin[<span class="number">0</span>:tin_root_index])</span><br><span class="line">        root.right=self.reConstructBinaryTree(pre,tin[tin_root_index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    s=Solution()</span><br><span class="line">    pre=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">    tin=[<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">    root=s.reConstructBinaryTree(pre,tin)</span><br><span class="line">    s.PreOrderTraversal(root)</span><br></pre></td></tr></table></figure><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="comment"># root=None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">"[]"</span> <span class="comment">#返回字符串</span></span><br><span class="line">        result=[]</span><br><span class="line">        queue=deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node=queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                result.append(str(node.val))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">"null"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span>+<span class="string">","</span>.join(result)+<span class="string">"]"</span></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> data==<span class="string">"[]"</span>: <span class="keyword">return</span></span><br><span class="line">        vals,i=data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">","</span>),<span class="number">1</span></span><br><span class="line">        root=TreeNode(int(vals[<span class="number">0</span>]))</span><br><span class="line">        queue=deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node=queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> vals[i]!=<span class="string">"null"</span>:</span><br><span class="line">                node.left=TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            i=i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vals[i]!=<span class="string">"null"</span>:</span><br><span class="line">                node.right=TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            i=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure><h2 id="公共祖先"><a href="#公共祖先" class="headerlink" title="公共祖先"></a>公共祖先</h2><p>主要是突出一个思想：</p><p>（<strong>一个节点也可以是它自己的祖先</strong>）</p><p>所以一旦看到当前节点root是p、q其中一个，立刻返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root==p <span class="keyword">or</span> root==q: <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        left_node=self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right_node=self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left_node <span class="keyword">and</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> left_node <span class="keyword">and</span> <span class="keyword">not</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> left_node</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left_node <span class="keyword">and</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> right_node</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="二叉树的子结构相同"><a href="#二叉树的子结构相同" class="headerlink" title="二叉树的子结构相同"></a>二叉树的子结构相同</h2><p>主要是用深搜DFS来做</p><p>只要懂如何用深搜比较两棵树，然后对A的每个节点都这样做就ok了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> A==<span class="literal">None</span> <span class="keyword">or</span> B==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment">#题目规定，两个初始必不为空</span></span><br><span class="line">        flag=self.dfs(A,B) <span class="keyword">or</span> self.isSubStructure(A.left,B) <span class="keyword">or</span> self.isSubStructure(A.right,B)</span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,A,B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> B==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment">#b为空了</span></span><br><span class="line">        <span class="keyword">if</span> A==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment">#</span></span><br><span class="line">        <span class="keyword">return</span> A.val==B.val <span class="keyword">and</span> self.dfs(A.left,B.left) <span class="keyword">and</span> self.dfs(A.right,B.right)</span><br></pre></td></tr></table></figure><h2 id="交换左右节点——二叉树镜像"><a href="#交换左右节点——二叉树镜像" class="headerlink" title="交换左右节点——二叉树镜像"></a>交换左右节点——二叉树镜像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment">#递归</span></span><br><span class="line">        <span class="comment"># if root==None: return root </span></span><br><span class="line">        <span class="comment"># if root.left: self.mirrorTree(root.left)</span></span><br><span class="line">        <span class="comment"># if root.right: self.mirrorTree(root.right)</span></span><br><span class="line">        <span class="comment"># root.left,root.right=root.right,root.left</span></span><br><span class="line">        <span class="comment"># return root</span></span><br><span class="line">        <span class="comment">#栈</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> root </span><br><span class="line">        stack=[root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node=stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node!=<span class="literal">None</span>:</span><br><span class="line">                node.left,node.right=node.right,node.left</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#我的做法，内存占用和时间消耗与下一法差不多</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp_depth</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span>,<span class="literal">True</span></span><br><span class="line">            depth_left,flag_left=cmp_depth(root.left)</span><br><span class="line">            depth_right,flag_right=cmp_depth(root.right)</span><br><span class="line">            <span class="keyword">if</span> flag_left==<span class="literal">False</span> <span class="keyword">or</span> flag_right==<span class="literal">False</span>: <span class="keyword">return</span> <span class="number">0</span>,<span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> abs(depth_left-depth_right)&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span>,<span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> max(depth_left,depth_right)+<span class="number">1</span>,<span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> cmp_depth(root)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#参考评论区，改成一个返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp_depth</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            depth_left=cmp_depth(root.left)</span><br><span class="line">            depth_right=cmp_depth(root.right)</span><br><span class="line">            <span class="keyword">if</span> depth_left==<span class="number">-1</span> <span class="keyword">or</span> depth_right==<span class="number">-1</span> <span class="keyword">or</span> abs(depth_left-depth_right)&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> max(depth_left,depth_right)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cmp_depth(root)&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>python的三元表达式</p><p><code>res=&#39;zuo&#39; if x &gt; y else &#39;you&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> root==<span class="literal">None</span> <span class="keyword">else</span> max(self.maxDepth(root.left),self.maxDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="二叉树的子结构"><a href="#二叉树的子结构" class="headerlink" title="二叉树的子结构"></a>二叉树的子结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res,path=[],[] <span class="comment">#result，以及path路径记录</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(root,target)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root==<span class="literal">None</span>:  <span class="comment">#直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            path.append(root.val) <span class="comment">#添加到临时路径中，继续往下前序遍历dfs、回溯</span></span><br><span class="line">            target=target-root.val</span><br><span class="line">            <span class="keyword">if</span> target==<span class="number">0</span> <span class="keyword">and</span> root.left==<span class="literal">None</span> <span class="keyword">and</span> root.right==<span class="literal">None</span>: <span class="comment">#叶子节点满足，添加到res中</span></span><br><span class="line">                res.append(list(path)) </span><br><span class="line">            search(root.left,target) <span class="comment">#继续往下前序遍历dfs、回溯</span></span><br><span class="line">            search(root.right,target) <span class="comment">#继续往下前序遍历dfs、回溯</span></span><br><span class="line">            path.pop()</span><br><span class="line">        search(root,sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>先说结论：切片[::-1] 有返回值， reverse()函数没有返回值</p><p>有返回值的可以 return、赋值。没有的不能 return、赋值。</p><h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l.reverse()</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        queue=collections.deque([root])</span><br><span class="line">        toggle=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            list_tmp=[]</span><br><span class="line">            len_layer=len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len_layer):</span><br><span class="line">                node=queue.popleft()</span><br><span class="line">                list_tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> toggle:</span><br><span class="line">                list_tmp=list_tmp[::<span class="number">-1</span>]</span><br><span class="line">            res.append(list_tmp)</span><br><span class="line">            toggle=toggle^<span class="number">1</span> <span class="comment">#异或 &lt;---</span></span><br><span class="line">            <span class="comment"># toggle=not toggle #取反 &lt;----</span></span><br><span class="line">            <span class="comment"># toggle=(toggle+1)%2 #加一取模&lt;---</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="不同的二叉搜索树-ii"><a href="#不同的二叉搜索树-ii" class="headerlink" title="不同的二叉搜索树-ii"></a>不同的二叉搜索树-ii</h2><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p>主要是</p><ul><li>遍历选取不同的根节点</li><li>然后递归获得左子树的根节点数组，右子树的根节点数组</li><li>然后创建根节点，遍历左右子树两个for循环，连上根节点，添加到list中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>,n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,start,end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start&gt;end: <span class="keyword">return</span> [TreeNode(<span class="literal">None</span>)] <span class="comment">#这里要注意</span></span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,end+<span class="number">1</span>): <span class="comment">#从零开始遍历</span></span><br><span class="line">            left=self.helper(start,i<span class="number">-1</span>)</span><br><span class="line">            right=self.helper(i+<span class="number">1</span>,end)</span><br><span class="line">            <span class="keyword">for</span> leftNode <span class="keyword">in</span> left: <span class="comment">#遍历左节点</span></span><br><span class="line">                <span class="keyword">for</span> rightNode <span class="keyword">in</span> right: <span class="comment">#遍历右节点</span></span><br><span class="line">                    root=TreeNode(i)</span><br><span class="line">                    <span class="keyword">if</span> leftNode.val!=<span class="literal">None</span>:root.left=leftNode</span><br><span class="line">                    <span class="keyword">if</span> rightNode.val!=<span class="literal">None</span>:root.right=rightNode</span><br><span class="line">                    ans.append(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></p><p>给定一个二叉树，<a href="https://baike.baidu.com/item/原地算法/8010757" target="_blank" rel="noopener">原地</a>将它展开为一个单链表。</p><p>前序遍历即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> root</span><br><span class="line">        root_tmp=root</span><br><span class="line">        dummy=TreeNode(<span class="number">0</span>)</span><br><span class="line">        cur=dummy</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                cur.right=TreeNode(root.val)</span><br><span class="line">                cur=cur.right               </span><br><span class="line">                root=root.left</span><br><span class="line">            root=stack.pop().right</span><br><span class="line">        root_tmp.right=dummy.right.right</span><br><span class="line">        root_tmp.left=<span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;h2 id=&quot;重建二叉树&quot;&gt;&lt;a href=&quot;#重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;重建二叉树&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://shenqiy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法 链表练习</title>
    <link href="https://shenqiy.cn/2020/07/30/2020-07-30-Linked-List-1/"/>
    <id>https://shenqiy.cn/2020/07/30/2020-07-30-Linked-List-1/</id>
    <published>2020-07-30T07:41:06.000Z</published>
    <updated>2020-08-02T15:23:24.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h1><p>链表类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">         self.val = x</span><br><span class="line">         self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>创建头指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dummy=ListNode(<span class="number">0</span>)</span><br><span class="line">dummy.next=head</span><br><span class="line">head=dummy</span><br></pre></td></tr></table></figure><p>向前移动指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head=head.next <span class="comment">#移动到下一个指针</span></span><br></pre></td></tr></table></figure><p>删除next节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next=head.next.next <span class="comment">#删除next节点</span></span><br></pre></td></tr></table></figure><p>反转链表，也可以是双指针操作的模板：备改二移</p><p>pre是一个始终在head前的节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pre=<span class="literal">None</span></span><br><span class="line"><span class="keyword">while</span> head!=<span class="literal">None</span>:</span><br><span class="line">     tmp=head.next <span class="comment">#备份节点</span></span><br><span class="line">     head.next=pre <span class="comment">#改变指针</span></span><br><span class="line">     pre=head <span class="comment">#移动指针</span></span><br><span class="line">     head=tmp <span class="comment">#移动指针</span></span><br></pre></td></tr></table></figure><p>用快慢指针找中点&lt;—重要</p><ul><li><p>fast 如果初始化为 head.Next 则中点在 slow.Next</p></li><li><p>fast 初始化为 head,则中点在 slow</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMiddle</span><span class="params">(self,head)</span>:</span></span><br><span class="line">    slow=head</span><br><span class="line">    fast=head.next</span><br><span class="line">    <span class="keyword">while</span> fast!=<span class="literal">None</span> <span class="keyword">and</span> fast.next!=<span class="literal">None</span>:</span><br><span class="line">        fast=fast.next.next</span><br><span class="line">        slow=slow.next <span class="comment">#小fast一倍的速度，最终会在fast达到链表尾时，达到中点</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h1 id="链表去重-i"><a href="#链表去重-i" class="headerlink" title="链表去重-i"></a>链表去重-i</h1><p>思路：遍历链表，使相同元素缩减为1</p><p>主要的困难在于dummy头节点的保持，以及head的next判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummpy=ListNode(<span class="number">0</span>) <span class="comment">#通用操作</span></span><br><span class="line">        dummpy.next=head</span><br><span class="line">        <span class="keyword">while</span> head!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> head.next!=<span class="literal">None</span> <span class="keyword">and</span> head.next.val==head.val: <span class="comment">#这里是while</span></span><br><span class="line">                head.next=head.next.next</span><br><span class="line">            head=head.next</span><br><span class="line">        <span class="keyword">return</span> dummpy.next</span><br></pre></td></tr></table></figure><h2 id="链表去重-ii"><a href="#链表去重-ii" class="headerlink" title="链表去重-ii"></a>链表去重-ii</h2><p>思路：遍历链表，使相同元素缩减为1</p><p>主要的困难在于dummy头节点的保持，以及head的next判断</p><p>重点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#head=head.next #删除的错误操作，这只是移动到下一个指针</span></span><br><span class="line">head.next=head.next.next <span class="comment">#删除的正确操作，这才是删除</span></span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">dummy=ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next=head</span><br><span class="line">        head=dummy</span><br><span class="line">        <span class="keyword">while</span> head.next!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.next.next!=<span class="literal">None</span> <span class="keyword">and</span> head.next.next.val==head.next.val: <span class="comment">#重点是这里的判断之后，就确定有重复了</span></span><br><span class="line">                retain=head.next.val <span class="comment">#然后取出重复的数</span></span><br><span class="line">                <span class="keyword">while</span> head.next <span class="keyword">and</span> head.next.val==retain: <span class="comment">#不断地遍历</span></span><br><span class="line">                    <span class="comment">#head=head.next #删除的错误操作，这只是遍历</span></span><br><span class="line">                    head.next=head.next.next <span class="comment">#删除的正确操作，这才是删除</span></span><br><span class="line">            <span class="keyword">else</span>: head=head.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h1 id="反转单链表——经典"><a href="#反转单链表——经典" class="headerlink" title="反转单链表——经典"></a>反转单链表——经典</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转单链表</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head!=<span class="literal">None</span>:</span><br><span class="line">            tmp=head.next <span class="comment">#备份节点</span></span><br><span class="line">            head.next=pre <span class="comment">#改变指针</span></span><br><span class="line">            pre=head <span class="comment">#移动指针</span></span><br><span class="line">            head=tmp <span class="comment">#移动指针</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h1 id="反转链表（m-n）"><a href="#反转链表（m-n）" class="headerlink" title="反转链表（m,n）"></a>反转链表（m,n）</h1><p>与反转链表差不多</p><p>重点是将 <strong>关键的四个节点：反转的关节点</strong>、<strong>以及链表的头指针Dummy记录好</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        head_dummpy=ListNode(<span class="number">0</span>)</span><br><span class="line">        head_dummpy.next=head</span><br><span class="line">        head=head_dummpy</span><br><span class="line">        pre_node=head <span class="comment">#作为要反转前的第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;m:</span><br><span class="line">            pre_node=head <span class="comment">#pre是这样用的</span></span><br><span class="line">            head=head.next</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        first_node=head <span class="comment">#作为要反转的第一个节点</span></span><br><span class="line">        pre_node2=<span class="literal">None</span>  <span class="comment">#作为反转的最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=n:</span><br><span class="line">            tmp=head.next <span class="comment">#备份</span></span><br><span class="line">            head.next=pre_node2 <span class="comment">#切换</span></span><br><span class="line">            pre_node2=head <span class="comment">#移动</span></span><br><span class="line">            head=tmp <span class="comment">#移动</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        first_node.next=head <span class="comment">#此时head已经是反转链表后的第一个节点了</span></span><br><span class="line">        pre_node.next=pre_node2</span><br><span class="line">        <span class="keyword">return</span> head_dummpy.next</span><br></pre></td></tr></table></figure><h1 id="有序链表合并"><a href="#有序链表合并" class="headerlink" title="有序链表合并"></a>有序链表合并</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/" target="_blank" rel="noopener">有序链表合并</a></p><p>思路：创建新链表，遍历两个旧链表，一个一个连上，与归并排序的合并差不多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, left: ListNode, right: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        lr=ListNode(<span class="number">0</span>)</span><br><span class="line">        lrDummy=lr</span><br><span class="line">        <span class="comment"># if left==None and l2==None: return None</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val&lt;=right.val:</span><br><span class="line">                lr.next=left</span><br><span class="line">                left=left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lr.next=right</span><br><span class="line">                right=right.next</span><br><span class="line">            lr=lr.next <span class="comment">#不要忘了移动</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            lr.next=left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lr.next=right</span><br><span class="line">        <span class="keyword">return</span> lrDummy.next</span><br></pre></td></tr></table></figure><h1 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h1><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>根据题目要求，我们需要使用快排，或者归并排序</p><p>思路就不赘述了</p><p>快排：本意是想用分隔链表的操作来做的，但是没做成功。超时了，需要再测试测试，应该是陷入了死循环或者死递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        pivot=head <span class="comment">#基准值</span></span><br><span class="line">        head=head.next <span class="comment">#移动</span></span><br><span class="line">        leftList=ListNode(<span class="number">0</span>) <span class="comment">#头节点</span></span><br><span class="line">        left_i=leftList</span><br><span class="line">        rightList=ListNode(<span class="number">0</span>) <span class="comment">#头节点</span></span><br><span class="line">        right_i=rightList</span><br><span class="line">        <span class="keyword">while</span> head!=<span class="literal">None</span>:  <span class="comment">#本意是想用分隔链表的操作来做的，但是没做成功</span></span><br><span class="line">            print(head.val)</span><br><span class="line">            <span class="keyword">if</span> head.val&lt;=pivot.val:</span><br><span class="line">                left_i.next=head</span><br><span class="line">                left_i=left_i.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_i.next=head</span><br><span class="line">                right_i=right_i.next</span><br><span class="line">            head=head.next</span><br><span class="line">        leftList=self.sortList(leftList.next) <span class="comment">#左边的</span></span><br><span class="line">        rightList=self.sortList(rightList.next) <span class="comment">#右边的</span></span><br><span class="line">        resultList=pivot</span><br><span class="line">        <span class="keyword">if</span> leftList:</span><br><span class="line">            resultList=leftList</span><br><span class="line">            <span class="keyword">while</span> leftList.next!=<span class="literal">None</span>:</span><br><span class="line">                leftList=leftList.next</span><br><span class="line">            leftList.next=pivot</span><br><span class="line">        pivot.next=rightList</span><br><span class="line">        <span class="keyword">return</span> resultList</span><br></pre></td></tr></table></figure><p>归并：</p><ul><li><strong>用快慢指针找中点&lt;—重要</strong></li><li>用有序链表合并算法合并左右两个链表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span> <span class="comment">#排序总函数</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        middle=self.findMiddle(head)</span><br><span class="line">        tail=middle.next <span class="comment">#右边的链表</span></span><br><span class="line">        middle.next=<span class="literal">None</span> <span class="comment">#分开两个链表</span></span><br><span class="line">        leftL=self.sortList(head)</span><br><span class="line">        rightL=self.sortList(tail)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoList(leftL,rightL)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMiddle</span><span class="params">(self,head)</span>:</span> <span class="comment">#找中点</span></span><br><span class="line">        slow=head</span><br><span class="line">        fast=head.next</span><br><span class="line">        <span class="keyword">while</span> fast!=<span class="literal">None</span> <span class="keyword">and</span> fast.next!=<span class="literal">None</span>:</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next <span class="comment">#小fast一倍的速度，最终会在fast达到链表尾时，达到中点</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoList</span><span class="params">(self,left,right)</span>:</span> <span class="comment">#排序两个链表的函数</span></span><br><span class="line">        lr=ListNode(<span class="number">0</span>)</span><br><span class="line">        lrDummy=lr</span><br><span class="line">        <span class="comment"># if left==None and l2==None: return None</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val&lt;=right.val:</span><br><span class="line">                lr.next=left</span><br><span class="line">                left=left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lr.next=right</span><br><span class="line">                right=right.next</span><br><span class="line">            lr=lr.next <span class="comment">#不要忘了移动</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            lr.next=left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lr.next=right</span><br><span class="line">        <span class="keyword">return</span> lrDummy.next</span><br></pre></td></tr></table></figure><h1 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h1><p><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">leetcode 86题 分隔链表</a></p><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure><p>其实这道题思路蛮简单的，就是代码写起来容易混乱。</p><p><strong>要对链表的增删查改足够清晰</strong></p><p>对于这道题，主要是是删除\跳过的操作一点不清晰，就会写不出来</p><ul><li><p>首先需要一个Dummy节点，这个节点是我们新的头节点，这是创建之后就不能动的</p></li><li><p>然后使 <code>Dummy.next=head</code> ，这一步使得Dummy正式成为头节点</p></li><li><p>然后使 <code>head=Dummy</code> ，这一步使得head从Dummy开始遍历（然后while循环就可以从head.next开始了）</p></li><li><p>然后我们先取出要删除的节点，然后再<code>head.next=head.next.next</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp=head.next <span class="comment">#先备份该节点</span></span><br><span class="line">head.next=head.next.next <span class="comment">#删除一个节点的操作</span></span><br></pre></td></tr></table></figure></li><li><p>然后就删除成功了</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        headDummy=ListNode(<span class="number">0</span>) <span class="comment">#Dummy是作为新的链表的头指针的</span></span><br><span class="line">        headDummy.next=head</span><br><span class="line">        head=headDummy</span><br><span class="line"></span><br><span class="line">        tailDummy=ListNode(<span class="number">0</span>) <span class="comment">#tailDummy是作为第二个链表的头指针的</span></span><br><span class="line">        tail=tailDummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head.next:</span><br><span class="line">            <span class="keyword">if</span> head.next.val&lt;x:</span><br><span class="line">                head=head.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#tmp=head.next #先备份该节点</span></span><br><span class="line">                <span class="comment">#head.next=head.next.next #删除一个节点的操作</span></span><br><span class="line">                <span class="comment">#tail.next=tmp #放到另一个链表</span></span><br><span class="line">                <span class="comment">#tail=tail.next</span></span><br><span class="line">                </span><br><span class="line">                tail.next=head.next<span class="comment">#&lt;--可以先放到tail上，再删除，而不是先删除再放到tial上</span></span><br><span class="line">                tail=tail.next</span><br><span class="line">                head.next=head.next.next                </span><br><span class="line">        tail.next=<span class="literal">None</span></span><br><span class="line">        head.next=tailDummy.next</span><br><span class="line">        <span class="keyword">return</span> headDummy.next</span><br></pre></td></tr></table></figure><h1 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h1><p><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">leetcode 143</a></p><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><ul><li>快慢指针找中点，根据中点拆分链表</li><li>使右链表逆转</li><li>合并两链表，一左一右地合并，最后再合并最后一个不为空的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head: ListNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        midlle=self.findMidlle(head)</span><br><span class="line">        tail=midlle.next</span><br><span class="line">        tail=self.reverse(tail) <span class="comment">#反转后面的链表</span></span><br><span class="line">        midlle.next=<span class="literal">None</span> <span class="comment">#拆分链表</span></span><br><span class="line">        Dummy=ListNode(<span class="number">0</span>) <span class="comment">#创建头节点</span></span><br><span class="line">        List_res=Dummy</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> tail: <span class="comment">#合并两链表，一左一右地合并</span></span><br><span class="line">            List_res.next=head</span><br><span class="line">            List_res=List_res.next</span><br><span class="line">            head=head.next</span><br><span class="line"></span><br><span class="line">            List_res.next=tail</span><br><span class="line">            List_res=List_res.next</span><br><span class="line">            tail=tail.next</span><br><span class="line">        <span class="keyword">if</span> head: <span class="comment">#最后再合并最后一个不为空的</span></span><br><span class="line">            List_res.next=head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            List_res.next=tail</span><br><span class="line">        <span class="keyword">return</span> Dummy.next</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self,head)</span>:</span> <span class="comment">#逆转链表</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        pre=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head!=<span class="literal">None</span>:</span><br><span class="line">            tmp=head.next</span><br><span class="line">            head.next=pre</span><br><span class="line">            pre=head</span><br><span class="line">            head=tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMidlle</span><span class="params">(self,head)</span>:</span> <span class="comment">#找中点</span></span><br><span class="line">        slow=head</span><br><span class="line">        fast=head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h1 id="环形链表-i"><a href="#环形链表-i" class="headerlink" title="环形链表-i"></a>环形链表-i</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表-i</a></p><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>思路</strong></p><p>主要思路还是快慢指针，如果由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow=head</span><br><span class="line">        fast=head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            <span class="keyword">if</span> fast==slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="❓-环形链表-ii"><a href="#❓-环形链表-ii" class="headerlink" title="❓ 环形链表-ii"></a>❓ 环形链表-ii</h1><p>找环的入口点：</p><ul><li>首先快慢指针找到中点</li><li>然后fast会到head节点，slow移动到中点，二者同步向前移动，<strong>最终相遇时即是环的入口点？</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        fast=head.next</span><br><span class="line">        slow=head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            <span class="keyword">if</span> fast==slow:</span><br><span class="line">                fast=head</span><br><span class="line">                slow=slow.next</span><br><span class="line">                <span class="keyword">while</span> fast!=slow:</span><br><span class="line">                    fast=fast.next</span><br><span class="line">                    slow=slow.next</span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="深拷贝链表"><a href="#深拷贝链表" class="headerlink" title="深拷贝链表"></a>深拷贝链表</h1><ul><li>哈希表深拷贝</li><li>有丝分裂法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#DFS哈希表深拷贝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        lookup = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> lookup: <span class="keyword">return</span> lookup[head]</span><br><span class="line">            clone = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            lookup[head] = clone </span><br><span class="line">            clone.next, clone.random = dfs(head.next), dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> clone</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br><span class="line"></span><br><span class="line"><span class="comment">#哈希表深拷贝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        visited=dict()</span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">while</span> cur: <span class="comment">#首先只考虑把所有的节点的值都hash存起来</span></span><br><span class="line">            visited[cur]=Node(cur.val,<span class="literal">None</span>,<span class="literal">None</span>)</span><br><span class="line">            cur=cur.next</span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            visited[cur].next=visited.get(cur.next)</span><br><span class="line">            visited[cur].random=visited.get(cur.random)</span><br><span class="line">            cur=cur.next</span><br><span class="line">        <span class="keyword">return</span> visited[head]</span><br><span class="line"><span class="comment">#有丝分裂法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        current=head</span><br><span class="line">        <span class="keyword">while</span> current!=<span class="literal">None</span>: <span class="comment">#首先先有丝分裂</span></span><br><span class="line">            clone=Node(current.val,current.next)</span><br><span class="line">            temp=current.next</span><br><span class="line">            current.next=clone</span><br><span class="line">            current=temp</span><br><span class="line">        current=head</span><br><span class="line">        <span class="keyword">while</span> current!=<span class="literal">None</span>: <span class="comment">#然后复制random节点</span></span><br><span class="line">            <span class="keyword">if</span> current.random!=<span class="literal">None</span>:</span><br><span class="line">                current.next.random=current.random.next</span><br><span class="line">            current=current.next.next</span><br><span class="line">        current=head</span><br><span class="line">        cloneHead=current.next</span><br><span class="line">        <span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> current.next!=<span class="literal">None</span>: <span class="comment">#最后删除老节点</span></span><br><span class="line">            temp=current.next</span><br><span class="line">            current.next=current.next.next</span><br><span class="line">            current=temp</span><br><span class="line">        <span class="keyword">return</span> cloneHead <span class="comment">#返回</span></span><br><span class="line">        <span class="comment"># visited=dict()</span></span><br><span class="line">        <span class="comment"># Dummy=Node(0)</span></span><br><span class="line">        <span class="comment"># Dummy.next=Node()</span></span><br><span class="line">        <span class="comment"># while head:</span></span><br><span class="line">        <span class="comment">#     if head not in visited:</span></span><br><span class="line">        <span class="comment">#         head</span></span><br></pre></td></tr></table></figure><h1 id="两链表的公共节点"><a href="#两链表的公共节点" class="headerlink" title="两链表的公共节点"></a>两链表的公共节点</h1><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指offer 52</a></p><p>主要是参透了</p><p>a+c+b=b+c+a</p><p>即三者相加距离相同，就可以找到答案</p><p>设交集链表长c,链表1除交集的长度为a，链表2除交集的长度为b，有</p><ul><li>a + c + b = b + c + a</li><li>若无交集，则a + b = b + a</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        h1,h2=headA,headB</span><br><span class="line">        <span class="keyword">while</span> h1!=h2:</span><br><span class="line">            h1=headB <span class="keyword">if</span> h1==<span class="literal">None</span> <span class="keyword">else</span> h1.next</span><br><span class="line">            h2=headA <span class="keyword">if</span> h2==<span class="literal">None</span> <span class="keyword">else</span> h2.next</span><br><span class="line">        <span class="keyword">return</span> h1</span><br></pre></td></tr></table></figure><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/" target="_blank" rel="noopener">两两交换链表中的节点</a></p><p>主要要用tmp把暂时无关的节点存好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        tmpnext=head.next.next</span><br><span class="line">        tmp=head.next</span><br><span class="line">        tmp.next=head</span><br><span class="line">        head.next=self.swapPairs(tmpnext)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通用操作&quot;&gt;&lt;a href=&quot;#通用操作&quot; class=&quot;headerlink&quot; title=&quot;通用操作&quot;&gt;&lt;/a&gt;通用操作&lt;/h1&gt;&lt;p&gt;链表类&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://shenqiy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>密码学复习</title>
    <link href="https://shenqiy.cn/2020/07/30/2020-07-30-review-of-cryptography/"/>
    <id>https://shenqiy.cn/2020/07/30/2020-07-30-review-of-cryptography/</id>
    <published>2020-07-30T07:40:27.000Z</published>
    <updated>2020-08-02T15:25:21.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📚密码学"><a href="#📚密码学" class="headerlink" title="📚密码学"></a>📚密码学</h1><h2 id="1-密钥交换方案"><a href="#1-密钥交换方案" class="headerlink" title="1.密钥交换方案"></a>1.密钥交换方案</h2><h3 id="PKI-Public-KeyInfrastructure-公钥基础设施"><a href="#PKI-Public-KeyInfrastructure-公钥基础设施" class="headerlink" title="PKI (Public KeyInfrastructure)公钥基础设施"></a>PKI (Public KeyInfrastructure)公钥基础设施</h3><p><a href="https://blog.csdn.net/xu2439645715/article/details/88734530" target="_blank" rel="noopener">PKI介绍</a></p><blockquote><p>PKI（Public Key Infrastructure ） 即”公钥基础设施”，是一种遵循既定标准的密钥管理平台,它能够为所有网络应用提供加密和数字签名等密码服务及所必需的密钥和证书管理体系(哈哈，加粗提取主谓宾)，简单来说，PKI就是利用公钥理论和技术建立的提供安全服务的基础设施。PKI技术是信息安全技术的核心，也是电子商务的关键和基础技术。</p></blockquote><p><strong>通俗来讲，PKI 是互联网安全信任的基础</strong></p><p>完整的 PKI 系统必须具有以下五个部分</p><p><strong>CA 认证机构</strong>：提供数字证书的申请签发、是第三方权威机构</p><p><strong>数字证书库：</strong>存放已发放的证书</p><p><strong>密钥备份及恢复系统：</strong>为证书申请方提供服务</p><p><strong>证书作废系统：</strong>过期证书作废</p><p><strong>应用接口（API）：</strong>提供基础的服务应用接口，如加密、数字签名等</p><ol><li>单纯的对称、非对称加密、以及他们的结合都不安全，因为无法在传输密钥时保证保密性、真实性、完整性</li><li>仅仅是加上摘要的数字签名，也可能会遭遇重放攻击、而且无法保证真实性，只能保证完整性、保密性</li><li>如果有了 CA 颁发的证书，就可以确保真实性</li></ol><h3 id="Diffi-Halman-非对称密钥交换"><a href="#Diffi-Halman-非对称密钥交换" class="headerlink" title="Diffi-Halman 非对称密钥交换"></a>Diffi-Halman 非对称密钥交换</h3><p><a href="https://zh.wikipedia.org/wiki/迪菲-赫爾曼密鑰交換" target="_blank" rel="noopener">DH交换</a></p><p>是一个密钥交换的方案，如下图可以容易知道整个过程。</p><p>最后的 K 即是两方交换得到的密钥。</p><p>而基于 <strong>离散对数问题</strong> ，攻击者是无法根据 A \ B \ g \ p 计算出 a \ b \ K 的。</p><p>所以这是一个安全的方案。</p><p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723114719364.png" alt="image-20200723114719364"></p><h2 id="2-DES、AES"><a href="#2-DES、AES" class="headerlink" title="2.DES、AES"></a>2.DES、AES</h2><p><strong>DES结构</strong></p><p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723115834624.png" alt="image-20200723115834624"></p><p><strong>AES结构</strong></p><p>我使用 java 原理复现的 AES 加解密文件程序</p><p><a href="https://github.com/ColaLinN/cryptology_project" target="_blank" rel="noopener">https://github.com/ColaLinN/cryptology_project</a></p><p><img src="https://pic3.zhimg.com/80/v2-38c0d8de4b7b0938709a3c96eef9c17d_720w.jpg" alt="img"></p><h2 id="3-非对称密码-RSA-Elgamal"><a href="#3-非对称密码-RSA-Elgamal" class="headerlink" title="3.非对称密码  RSA Elgamal"></a>3.非对称密码  RSA Elgamal</h2><p><strong>RSA——离散对数问题</strong></p><p><a href="[https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/RSA加密演算法)">RSA维基百科</a></p><p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723121106838.png" alt="image-20200723121106838"></p><p><strong>Elgamal——椭圆曲线离散对数问题</strong></p><p><a href="[https://zh.wikipedia.org/wiki/ElGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/ElGamal加密算法)">Elgamal维基百科</a></p><p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723121842310.png" alt="image-20200723121842310"></p><h2 id="4-hash算法-MD5、SHA、HMAC"><a href="#4-hash算法-MD5、SHA、HMAC" class="headerlink" title="4.hash算法 MD5、SHA、HMAC"></a>4.hash算法 MD5、SHA、HMAC</h2><h3 id="几种实际应用"><a href="#几种实际应用" class="headerlink" title="几种实际应用"></a>几种实际应用</h3><h4 id="hash冲突解决"><a href="#hash冲突解决" class="headerlink" title="hash冲突解决"></a>hash冲突解决</h4><p><a href="https://www.cnblogs.com/higerMan/p/11907117.html" target="_blank" rel="noopener">https://www.cnblogs.com/higerMan/p/11907117.html</a></p><p>由于数据过多，会有数据产生相同的哈希值</p><ol><li>开放地址方法 ：线性探测、再平方探测、伪随机探测 （即尽力找到一个空的）</li><li>链式地址法：相同哈希值下用链表连接</li><li>建立公共溢出区：用多余的空间存放冲突的数据</li><li>再哈希法：再次进行哈希，有点同法一</li></ol><h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p>即链式哈希表</p><h4 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h4><p>在给密码哈希前加入随机数，或者是用户名等<strong>“盐”</strong></p><p>即使得到密码的哈希，也碰撞不出密码加盐后的哈希</p><h2 id="6-隐私保护"><a href="#6-隐私保护" class="headerlink" title="6.隐私保护"></a>6.隐私保护</h2><h3 id="安全多方计算"><a href="#安全多方计算" class="headerlink" title="安全多方计算"></a>安全多方计算</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/31635977" target="_blank" rel="noopener">安全多方计算 Secure Multi-party Computation 初探</a></li><li><a href="https://zhuanlan.zhihu.com/p/31641175" target="_blank" rel="noopener">安全计算方法概览</a></li></ul><p>一句话：安全多方计算即多个用户在不泄露数据的情况下进行计算等操作</p><p>比较经典的问题：</p><p><strong>百万富翁问题</strong>：多个富翁想比较财产多少，但又出于某些考虑不能将财产总价值泄露出来，于是衍生出了安全多方计算问题。</p><p>安全多方计算目前有两大类：基于差分隐私的、不基于差分隐私的。</p><p>不基于差分隐私的主要有三类：混淆电路、同态加密、零知识证明</p><ul><li><a href="https://zhuanlan.zhihu.com/p/40760105" target="_blank" rel="noopener">差分隐私 Differential Privacy 介绍</a></li></ul><p>一句话：保护的是数据源中一点微小的改动导致的隐私泄露问题。</p><p><img src="https://www.zhihu.com/equation?tex=Pr%5C%7BA%28D%29+%3D+O%5C%7D+%E2%89%A4e%5E%5Cepsilon+%5Ccdot+Pr%5C%7BA%28D%E2%80%99%29+%3D+O%5C%7D+" alt="[公式]"></p><p><strong>作用于任何相近的数据集</strong>，得到一个特定输出 <img src="https://www.zhihu.com/equation?tex=O" alt="[公式]"> 的概率应差不多，那么我们就说这个算法能达到差分隐私的效果。也就是说，观察者通过观察输出结果很难察觉出数据集一点微小的变化，从而达到保护隐私的目的。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/41172002" target="_blank" rel="noopener">混淆电路 Garbled Circuit 介绍</a></li></ul><p>一句话：一些人各自拥有其隐私数据，他们想把这些数据合起来算点什么，但又不想把数据交给别人，混淆电路解决的就是此类问题。（即百万富翁问题的解决）</p><p>把计算公式化为门电路图</p><p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723173336210.png" alt="image-20200723173336210"></p><p>Alice和Bob想计算一个与门。该门两个输入线 <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="[公式]"> 和一个输出线 <img src="https://www.zhihu.com/equation?tex=z" alt="[公式]"> ，每条线有0和1两个可能的值。Alice首先给每条线指定两个随机的key，分别对应0和1。</p><p>然后，Alice用这些密钥加密真值表，并将该表打乱后发送给Bob。加密过程就是将真值表中每一行对应的 <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=y+" alt="[公式]"> 的密钥加密 <img src="https://www.zhihu.com/equation?tex=z" alt="[公式]"> 的密钥。这一加密+打乱的过程，就是混淆电路（garbled circuit）的核心思想。</p><p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723173929125.png" alt="image-20200723173929125"></p><p>Bob 收到之后，用 Alice 的输入 Ex，以及自己的输入 Ey 解密四个数据Kz ， 最终成功解密一个kz（密文），Bob将其发给Alice，Alice即可知道比较结果。</p><p><strong>混淆电路+不经意传输 GC+OT</strong></p><p>主要可以如下流程应用，OT是不经意传输，可以保障Bob在Alice不知道的情况下从Alice处得到想要的Ey </p><p><img src="https://img-blog.csdn.net/20180704155455576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1emhlbnl1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><ul><li><a href="https://zhuanlan.zhihu.com/p/44999983" target="_blank" rel="noopener">密钥分享 Secret Sharing 介绍</a></li></ul><p>一句话：密钥分享（secret sharing）可以在数据不被泄露的情况下，将计算任务分布式计算。</p><p>不用混淆电路GC的原因是，一些常见的算术操作（如乘法、乘方等），电路也非常复杂，GC的效率不够高。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/77478956" target="_blank" rel="noopener">同态加密 Homomorphic Encryption 介绍</a></li></ul><p>一句话：密文的运算可以同步到明文中。</p><p>全同态加密：加法、乘法均同态</p><p>半同态加密：加法、乘法只满足其一</p><p>其中，RSA满足乘法同态，Paillier加密方案满足加法同态。</p><p>如下为RSA的同态举例：</p><p><img src="https://www.zhihu.com/equation?tex=%5Bx%5D%E2%89%94x%5Ee" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Bx%5D%E2%8B%85%5By%5D%3D%28xy%29%5Ee" alt="[公式]"></p><ul><li><a href="https://zhuanlan.zhihu.com/p/144847471" target="_blank" rel="noopener">零知识证明 Zero-Knowledge Proof 介绍</a></li></ul><p>一句话：A在不让B知道任何数据的情况下，向B证明某件事是可信的。</p><p><strong>中心化差分隐私、本地化差分隐私</strong></p><p><a href="https://blog.csdn.net/Ano_onA/article/details/100760362" target="_blank" rel="noopener">本地化差分隐私（Local Differential Privacy）浅析</a></p><h3 id="匿名化"><a href="#匿名化" class="headerlink" title="匿名化"></a>匿名化</h3><ul><li>K匿名化和I多样性：通过准标识符可以充分识别唯一一个个体，例如身份证号。K匿名化通过扰动和泛化的方法使得每一个准标识符都至少对应k个实例，这样就不能唯一识别，从而保护了用户的隐私。</li><li>差分隐私：通过添加噪声的方法，确保删除或者添加一个数据集中的记录并不会影响分析的结果;因此，即使攻击者得到了两个仅相差一条记录的数据集，通过分析两者产生的结果都是相同的，也无法推断出隐藏的那一条记录的信息。</li><li>分布式隐私保护：大型的数据集可以在被分割后发布。</li></ul><h3 id="身份脱敏、内容脱敏"><a href="#身份脱敏、内容脱敏" class="headerlink" title="身份脱敏、内容脱敏"></a><strong>身份脱敏、内容脱敏</strong></h3><p>身份证脱敏处理（业务开发中，有时候身份证需要隐藏一部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdCardUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//身份证前三后四脱敏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">idEncrypt</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(id) || (id.length() &lt; <span class="number">11</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id.replaceAll(<span class="string">"(?&lt;=\\w&#123;6&#125;)\\w(?=\\w&#123;4&#125;)"</span>, <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搭建一个安全多方计算的框架——实战、相关的工具"><a href="#搭建一个安全多方计算的框架——实战、相关的工具" class="headerlink" title="搭建一个安全多方计算的框架——实战、相关的工具"></a>搭建一个安全多方计算的框架——实战、相关的工具</h3><h2 id="8-黑盒-白盒-灰盒密码"><a href="#8-黑盒-白盒-灰盒密码" class="headerlink" title="8.黑盒 白盒 灰盒密码"></a>8.黑盒 白盒 灰盒密码</h2><p>一句话概述：密码的加密、解密过程是否可以被公开</p><p><a href="https://zhuanlan.zhihu.com/p/21273220" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21273220</a></p><h2 id="9-商密认证"><a href="#9-商密认证" class="headerlink" title="9.商密认证"></a>9.商密认证</h2><h2 id="10-SGX"><a href="#10-SGX" class="headerlink" title="10.SGX"></a>10.SGX</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;📚密码学&quot;&gt;&lt;a href=&quot;#📚密码学&quot; class=&quot;headerlink&quot; title=&quot;📚密码学&quot;&gt;&lt;/a&gt;📚密码学&lt;/h1&gt;&lt;h2 id=&quot;1-密钥交换方案&quot;&gt;&lt;a href=&quot;#1-密钥交换方案&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="安全" scheme="https://shenqiy.cn/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="https://shenqiy.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="复习" scheme="https://shenqiy.cn/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="安全" scheme="https://shenqiy.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>2020-07-30-python-1</title>
    <link href="https://shenqiy.cn/2020/07/30/2020-07-30-python-1/"/>
    <id>https://shenqiy.cn/2020/07/30/2020-07-30-python-1/</id>
    <published>2020-07-30T07:40:05.000Z</published>
    <updated>2020-08-02T15:24:09.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><p><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Python3 的六个标准数据类型中：</p><ul><li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li><li><strong>可变数据：均为序列（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li></ul><p>python 函数的参数传递：</p><ul><li><strong>不可变类型：</strong>类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li><li><strong>可变类型：</strong>类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li></ul><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a, b, c, d&#x3D; 10,10.0,True,3+4j</span><br><span class="line">print(type(a),type(b),type(c),type(d))</span><br><span class="line"># &lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class &#39;bool&#39;&gt; &lt;class &#39;complex&#39;&gt;</span><br><span class="line"></span><br><span class="line">del(a,...)</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zyqy/p/9240396.html" target="_blank" rel="noopener">python 字符串常用操作方法</a></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p><p>Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p><p>切片一个点是：左起点包含，终点不包含</p><p><strong>[  开始索引,  结束索引,  步长] ** 遵循</strong>左闭右开**原则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"1234567891"</span></span><br><span class="line">print(a[<span class="number">0</span>]) <span class="comment">#1</span></span><br><span class="line">print(a[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment">#345</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">-3</span>]) <span class="comment">#1234567</span></span><br><span class="line">print(a[<span class="number">-5</span>:<span class="number">-1</span>]) <span class="comment">#6789</span></span><br><span class="line">print(a[<span class="number">-2</span>:]) <span class="comment">#91 :代表1</span></span><br><span class="line"></span><br><span class="line">字符串转列表： <span class="keyword">return</span> eval(str) </span><br><span class="line">字符串转数字： <span class="keyword">return</span> int(str) </span><br><span class="line">四则运算： <span class="keyword">return</span> eval(str)</span><br></pre></td></tr></table></figure><p><img src="/2020/07/30/2020-07-30-python-1/image-20200725162752968.png" alt="image-20200725162752968"></p><p>字符串转元组，逆转，再变回来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"baidu"</span></span><br><span class="line">inputWords = a.split(<span class="string">" "</span>) <span class="comment">#['baidu']&lt;---</span></span><br><span class="line">output = <span class="string">''</span>.join(inputWords)&lt;---</span><br><span class="line"></span><br><span class="line">inputWords2 = list(a)&lt;---</span><br><span class="line">inputWords2=inputWords2[<span class="number">-1</span>::<span class="number">-1</span>] <span class="comment">#['u', 'd', 'i', 'a', 'b']</span></span><br><span class="line">output2 = <span class="string">''</span>.join(inputWords2)</span><br><span class="line">print(inputWords)</span><br><span class="line">print(inputWords2)</span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。</p><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(a+a) <span class="comment">#[1, 2, 3, 1, 2, 3]</span></span><br><span class="line">print(a*<span class="number">4</span>) <span class="comment">#[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br><span class="line">print(a[::<span class="number">2</span>]) <span class="comment">#[1, 3]</span></span><br><span class="line"></span><br><span class="line">判断是否为空</span><br><span class="line"><span class="keyword">if</span> list</span><br><span class="line">就好，如此简单</span><br></pre></td></tr></table></figure><p>位置查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a_list = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'hello'</span>]</span><br><span class="line">print(<span class="string">'a'</span> <span class="keyword">in</span> a_list) <span class="comment">#True</span></span><br><span class="line">print(<span class="string">'a'</span> <span class="keyword">not</span> <span class="keyword">in</span> a_list) <span class="comment">#False</span></span><br><span class="line">print(a_list.count(<span class="string">'a'</span>)) <span class="comment">#1</span></span><br><span class="line">print(a_list.index(<span class="string">'a'</span>))<span class="comment">#0</span></span><br><span class="line">print(a_list.index(<span class="string">'a'</span>,<span class="number">0</span>,<span class="number">1</span>)) <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">str.remove(<span class="number">2</span>) <span class="comment">#删除元素</span></span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。元组中的元素类型也可以不相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">print(tup[<span class="number">0</span>]) <span class="comment">#1</span></span><br></pre></td></tr></table></figure><h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a>集合 Set</h3><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sites = &#123;<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Facebook'</span>, <span class="string">'Zhihu'</span>, <span class="string">'Baidu'</span>&#125;</span><br><span class="line">print(sites)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过<strong>键来存取</strong>的，而不是通过偏移存取。</p><p>用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p><p>键(key)必须使用不可变类型。在同一个字典中，键(key)必须是唯一的。</p><p><img src="/2020/07/30/2020-07-30-python-1/image-20200726181213044.png" alt="image-20200726181213044"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;&#125;</span><br><span class="line">dict[<span class="string">'one'</span>] = <span class="string">"1 - 菜鸟教程"</span></span><br><span class="line">dict[<span class="number">2</span>]     = <span class="string">"2 - 菜鸟工具"</span></span><br><span class="line"><span class="keyword">print</span> (dict[<span class="string">'one'</span>])   <span class="comment"># 输出键为 'one' 的值 1 - 菜鸟教程</span></span><br><span class="line"><span class="keyword">print</span> (dict.keys())   <span class="comment"># 输出所有键 dict_keys(['one', 2])</span></span><br><span class="line"><span class="keyword">print</span> (dict.values()) <span class="comment"># 输出所有值 dict_values(['1 - 菜鸟教程', '2 - 菜鸟工具'])</span></span><br><span class="line"></span><br><span class="line"><span class="string">""" 一些操作函数 """</span></span><br><span class="line">dict.get(key, default=<span class="literal">None</span>)<span class="comment"># 返回指定键的值，如果键不在字典中返回 default 设置的默认值</span></span><br><span class="line">key <span class="keyword">in</span> dict <span class="comment">#如果键在字典dict里返回true，否则返回false&lt;---</span></span><br><span class="line">dict.pop(key[,default]) <span class="comment">#删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</span></span><br><span class="line">dict.values() <span class="comment">#返回一个迭代器，可以使用 list() 来转换为列表</span></span><br><span class="line">dict.items() <span class="comment">#以列表返回可遍历的(键, 值) 元组数组</span></span><br><span class="line">dict.keys() <span class="comment">#返回一个迭代器，可以使用 list() 来转换为列表</span></span><br><span class="line">dict.update(dict2) <span class="comment">#把字典dict2的键/值对更新到dict里</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""  实践  """</span></span><br><span class="line">dictA=&#123;x:x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125; <span class="comment">#创建A</span></span><br><span class="line">dictA[<span class="number">9</span>]=<span class="number">666</span> <span class="comment">#更新</span></span><br><span class="line">dictB=&#123;<span class="number">1</span>:<span class="number">11111</span>,&#125; <span class="comment">#创建B 《---</span></span><br><span class="line">dictA.update(dictB) <span class="comment">#用B替换或添加A 《---</span></span><br><span class="line">print(dictA) <span class="comment">#打印</span></span><br><span class="line">print(dictA.get(<span class="string">"22"</span>)) <span class="comment">#尝试获得键22的值，None</span></span><br><span class="line">print(<span class="number">22</span> <span class="keyword">in</span> dictA) <span class="comment">#False 《---</span></span><br><span class="line">print(dictA.pop(<span class="number">2</span>)) <span class="comment">#删除、弹出键值2的值《---</span></span><br><span class="line">print(dictA.items()) <span class="comment">#A字典的项</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dictA.values():</span><br><span class="line">    print(item) <span class="comment">#打印所有项</span></span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int(x [,base])<span class="comment">#将x转换为一个整数</span></span><br><span class="line">float(x)<span class="comment">#将x转换到一个浮点数</span></span><br><span class="line">repr(x) <span class="comment">#将对象 x 转换为表达式字符串</span></span><br><span class="line">eval(str)<span class="comment">#用来计算在字符串中的有效Python表达式,并返回一个对象</span></span><br><span class="line">list(s)<span class="comment">#将序列 s 转换为一个列表</span></span><br><span class="line">dict(d)<span class="comment">#创建一个字典。d 必须是一个 (key, value)元组序列。</span></span><br><span class="line">chr(x)<span class="comment">#将一个整数转换为一个字符</span></span><br><span class="line">ord(x)<span class="comment">#将一个字符转换为它的整数值</span></span><br></pre></td></tr></table></figure><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ** 指数</span></span><br><span class="line">print(<span class="number">5</span>**<span class="number">2</span>) <span class="comment"># 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#// 整除 - 向下取接近商的整数,向低位取整</span></span><br><span class="line">print(<span class="number">9</span>/<span class="number">2</span>) <span class="comment">#4.5</span></span><br><span class="line">print(int(<span class="number">9</span>/<span class="number">2</span>)) <span class="comment">#4</span></span><br><span class="line">print(<span class="number">9</span>//<span class="number">2</span>) <span class="comment">#4</span></span><br><span class="line">print(<span class="number">10</span>//<span class="number">2</span>) <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="comment">#如果在指定的序列中找到值返回True，否则返回 False。</span></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span><span class="comment">#如果在指定的序列中没有找到值返回 True，否则返回 False。</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">逻辑运算符</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">and</span> <span class="comment">#且</span></span><br><span class="line"><span class="keyword">or</span>  <span class="comment">#或</span></span><br><span class="line"><span class="keyword">not</span> <span class="comment">#反</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">位运算符</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">&amp; <span class="comment">#与</span></span><br><span class="line">| <span class="comment">#或</span></span><br><span class="line">^ <span class="comment">#异或</span></span><br><span class="line">~ <span class="comment">#取反</span></span><br><span class="line">&lt;&lt; <span class="comment">#左移动运算符</span></span><br><span class="line">&gt;&gt; <span class="comment">#右移动运算符</span></span><br><span class="line">x&gt;&gt;=<span class="number">1</span></span><br><span class="line">即x=x&gt;&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="队列和栈（队列没有搞好）"><a href="#队列和栈（队列没有搞好）" class="headerlink" title="队列和栈（队列没有搞好）"></a>队列和栈（队列没有搞好）</h1><p><a href="https://blog.csdn.net/yushupan/article/details/82312819" target="_blank" rel="noopener">队列栈</a></p><p>队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">q = Queue()    <span class="comment">#items = []  #定义一个空队列，无参数，返回值是空队列。</span></span><br><span class="line">enqueue(item)  <span class="comment">#items.append(item)  #在队列尾部加入一个数据项，参数是数据项，无返回值。</span></span><br><span class="line">dequeue()      <span class="comment">#items.pop(0) 删除队列头部的数据项，不需要参数，返回值是被删除的数据，队列本身有变化。</span></span><br><span class="line">peek()        <span class="comment">#items[0] 返回栈最顶层的元素，并不删除它。！</span></span><br><span class="line">isEmpty()      <span class="comment">#self.items == [] 检测队列是否为空。无参数，返回布尔值。</span></span><br><span class="line">clear()        <span class="comment">#del(items) 清空队列，无参无返回值</span></span><br><span class="line">size()         <span class="comment">#len(items) 返回队列数据项的数量。无参数，返回一个整</span></span><br><span class="line">print(q)   <span class="comment">#print(self.items)</span></span><br></pre></td></tr></table></figure><p>栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stack()    <span class="comment">#items = [] 建立一个空的栈对象。</span></span><br><span class="line">push(item) <span class="comment">#items.append(item) 把一个元素添加到栈的最顶层。</span></span><br><span class="line">pop()      <span class="comment">#items.pop() 删除栈最顶层的元素，并返回这个元素。！</span></span><br><span class="line">peek()     <span class="comment">#items[-1] 返回栈最顶层的元素，并不删除它。！</span></span><br><span class="line">clear()    <span class="comment">#del(self.items) 清空栈。</span></span><br><span class="line">isEmpty()  <span class="comment">#self.items == [] 判断栈是否为空。</span></span><br><span class="line">size()     <span class="comment">#返回栈中元素的个数。</span></span><br><span class="line">print(q)   <span class="comment">#print(self.items)</span></span><br></pre></td></tr></table></figure><h1 id="python的类，对象"><a href="#python的类，对象" class="headerlink" title="python的类，对象"></a>python的类，对象</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   ___secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">   publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用父类方法'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用子类方法'</span>)</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__foo</span><span class="params">(self)</span>:</span>          <span class="comment"># 私有方法</span></span><br><span class="line">        print(<span class="string">'这是私有方法'</span>)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>            <span class="comment"># 公共方法</span></span><br><span class="line">        print(<span class="string">'这是公共方法'</span>)</span><br><span class="line">        self.__foo()</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br><span class="line">super(Child,c).myMethod() <span class="comment">#用子类对象调用父类已被覆盖的方法</span></span><br><span class="line">c.foo()        <span class="comment"># 正常输出</span></span><br><span class="line">c.__foo()      <span class="comment"># 报错,私有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 树类的三种开头</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment"># class TreeNode():</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="IF-ELSE、While、FOR"><a href="#IF-ELSE、While、FOR" class="headerlink" title="IF\ELSE、While、FOR"></a>IF\ELSE、While、FOR</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 类似if语句的语法，while循环体中只有一条语句，可以将该语句与while写在同一行中</span></span><br><span class="line"><span class="keyword">while</span> (flag): <span class="keyword">print</span> (<span class="string">'欢迎访问菜鸟教程!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">#如下为冒泡排序</span></span><br><span class="line">a=[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a),<span class="number">1</span>,<span class="number">-1</span>): <span class="comment">#遍历10次</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i<span class="number">-1</span>): <span class="comment">#逐渐变小</span></span><br><span class="line">        <span class="keyword">if</span> a[j]&gt;a[j+<span class="number">1</span>]:</span><br><span class="line">            a[j],a[j+<span class="number">1</span>]=a[j+<span class="number">1</span>],a[j]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入</span></span><br><span class="line">str = input(<span class="string">"请输入："</span>);</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"你输入的内容是: "</span>, str)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：</span></span><br><span class="line">print(<span class="string">'常量 PI 的值近似为 &#123;0:.3f&#125;'</span>.format(math.pi)) <span class="comment">#新版</span></span><br><span class="line">print(<span class="string">'常量 PI 的值近似为 %5.3f'</span> % math.pi) <span class="comment">#旧版</span></span><br><span class="line"><span class="comment"># 常量 PI 的值近似为：3.142</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"%d"</span>%<span class="number">1</span>) <span class="comment">#旧版输出1</span></span><br><span class="line">print(<span class="string">"&#123;0&#125;"</span>.format(<span class="number">1</span>)) <span class="comment">#新版输出1</span></span><br><span class="line">print(<span class="number">1</span>) <span class="comment">#;-)</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">'Google'</span></span><br><span class="line">b=<span class="string">'Runoob'</span></span><br><span class="line">print(<span class="string">"法1"</span>,a,<span class="string">"和"</span>,b) <span class="comment">#逗号</span></span><br><span class="line">print(<span class="string">'法2 &#123;Google&#125; 和 &#123;Runoob&#125;'</span>.format(Google=<span class="string">'Google'</span>, Runoob=<span class="string">'Runoob'</span>))<span class="comment"># 如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</span></span><br><span class="line">print(<span class="string">'法3 &#123;0&#125; 和 &#123;1&#125;'</span>.format(<span class="string">'Google'</span>, <span class="string">'Runoob'</span>)) <span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h2><p><a href="https://www.cnblogs.com/xiaxiaoxu/p/9742452.html" target="_blank" rel="noopener">深拷贝与浅拷贝区别</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=copy.copy(a)<span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d=copy.deepcopy(a)<span class="comment">#对象拷贝，深拷贝</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>]]</span><br><span class="line"><span class="comment">#原始对象</span></span><br><span class="line">b=a<span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c=copy.copy(a)<span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d=copy.deepcopy(a)<span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">666</span></span><br><span class="line">print(<span class="string">"a="</span>,a,<span class="string">"    id(a)="</span>,id(a),<span class="string">"id(a[5])="</span>,id(a[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"b="</span>,b,<span class="string">"    id(b)="</span>,id(b),<span class="string">"id(b[5])="</span>,id(b[<span class="number">5</span>]))<span class="comment">#与a相同</span></span><br><span class="line">print(<span class="string">"c="</span>,c,<span class="string">"    id(c)="</span>,id(c),<span class="string">"id(c[5])="</span>,id(c[<span class="number">5</span>]))<span class="comment">#c[5]列表的地址与a相同,其他不同</span></span><br><span class="line">print(<span class="string">"d="</span>,d,<span class="string">"    id(d)="</span>,id(d),<span class="string">"id(d[5])="</span>,id(d[<span class="number">5</span>]))<span class="comment">#</span></span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">a.append(<span class="number">6</span>)<span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">5</span>].append(<span class="string">'c'</span>)<span class="comment">#修改对象a中的['a','b']数组对象</span></span><br><span class="line">print(<span class="string">"a="</span>,a,<span class="string">"    id(a)="</span>,id(a),<span class="string">"id(a[5])="</span>,id(a[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"b="</span>,b,<span class="string">"    id(b)="</span>,id(b),<span class="string">"id(b[5])="</span>,id(b[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"c="</span>,c,<span class="string">"       id(c)="</span>,id(c),<span class="string">"id(c[5])="</span>,id(c[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"d="</span>,d,<span class="string">"            id(d)="</span>,id(d),<span class="string">"id(d[5])="</span>,id(d[<span class="number">5</span>]))</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不可变对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChangeInt</span><span class="params">( a )</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">ChangeInt(b)</span><br><span class="line">print( b ) <span class="comment"># 结果是 2，没变</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeme</span><span class="params">( mylist )</span>:</span></span><br><span class="line">   <span class="string">"修改传入的列表"</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">changeme( mylist )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外取值: "</span>, mylist)<span class="comment">#添加了新值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#必须参数，正确的顺序 </span></span><br><span class="line">fun(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br><span class="line"><span class="comment">#关键字参数</span></span><br><span class="line">fun(ea=<span class="string">"a"</span>,eb=<span class="string">"b"</span>,ec=<span class="string">"c"</span>,ed=<span class="string">"d"</span>)</span><br><span class="line"><span class="comment">#默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(name, age = <span class="number">35</span> )</span></span></span><br><span class="line"><span class="function">#不定长参数</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">functionname</span><span class="params">([formal_args,] *var_args_tuple )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br><span class="line"><span class="comment">#匿名函数lambda</span></span><br><span class="line">sum = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2  <span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"相加后的值为 : "</span>, sum( <span class="number">10</span>, <span class="number">20</span> ))  <span class="comment"># 调用sum函数</span></span><br></pre></td></tr></table></figure><h1 id="迭代器-amp-生成器"><a href="#迭代器-amp-生成器" class="headerlink" title="迭代器&amp;生成器"></a>迭代器&amp;生成器</h1><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：iter() 和 next()。</p><p>字符串，列表或元组对象都可用iter() 创建迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.a = <span class="number">1</span> <span class="comment">#置初值</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">      x = self.a </span><br><span class="line">      self.a += <span class="number">1</span> <span class="comment">#加1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration <span class="comment">#大于20结束 ，StopIteration 异常用于标识迭代的完成</span></span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  print(x)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> (next(f), end=<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br><span class="line">        </span><br><span class="line">&gt;&gt;&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span></span><br></pre></td></tr></table></figure><h2 id="一些简单的操作"><a href="#一些简单的操作" class="headerlink" title="一些简单的操作"></a>一些简单的操作</h2><h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><p>左闭右开区间 [ )，开区间的端点值取不到，而闭区间的端点值就可以取到。</p><p>想要生成list，需要用list()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(start, stop[, step])</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</li><li>stop: <strong>计数到 stop 结束，但不包括 stop</strong>。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</li><li>step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</li></ul><h2 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h2><p><a href="https://www.cnblogs.com/ilovecpp/p/12802178.html" target="_blank" rel="noopener">split详解</a></p><p>1、<code>split()</code> 函数<br>语法：<code>str.split(str=&quot;&quot;,num=string.count(str))[n]</code></p><p>参数说明：<br><code>str</code>: 表示为分隔符，默认为空格，但是不能为空(‘’)。若字符串中没有分隔符，则把整个字符串作为列表的一个元素<br><code>num</code>: 表示分割次数。如果存在参数num，则仅分隔成 num+1 个子字符串，并且每一个子字符串可以赋给新的变量</p><p><code>n</code>：表示选取第n个分片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"www.gziscas.com.cn"</span></span><br><span class="line">print(string.split(<span class="string">'.'</span>))<span class="comment"># ['www', 'gziscas', 'com', 'cn']</span></span><br><span class="line">print(string.split(<span class="string">'.'</span>,<span class="number">2</span>))<span class="comment"># ['www', 'gziscas', 'com.cn']</span></span><br><span class="line">print(string.split(<span class="string">'.'</span>,<span class="number">2</span>)[<span class="number">1</span>])<span class="comment">#gziscas</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(os.path.split(<span class="string">'/dodo/soft/python/'</span>))<span class="comment">#('/dodo/soft/python', '')</span></span><br><span class="line">print(os.path.split(<span class="string">'/dodo/soft/python'</span>))<span class="comment">#('/dodo/soft', 'python')</span></span><br><span class="line">str=<span class="string">"hello boy&lt;[www.baidu.com]&gt;byebye"</span></span><br><span class="line">print(str.split(<span class="string">"["</span>)[<span class="number">1</span>].split(<span class="string">"]"</span>)[<span class="number">0</span>]) <span class="comment"># www.baidu.com</span></span><br></pre></td></tr></table></figure><h2 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">最大值：sys.maxsize  float(<span class="string">"inf"</span>)</span><br><span class="line">最小值：-sys.maxsize  float(<span class="string">"-inf"</span>)</span><br><span class="line"></span><br><span class="line">float(<span class="string">"-inf"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float(<span class="string">"inf"</span>) <span class="comment">#不是int，但是比所有int都大</span></span><br><span class="line">&gt;&gt; inf </span><br><span class="line">print(float(<span class="string">"inf"</span>)&gt;sys.maxsize)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line">-sys.maxsize&gt;float(<span class="string">"-inf"</span>)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="zip-函数：可以用来当list左旋的操作"><a href="#zip-函数：可以用来当list左旋的操作" class="headerlink" title="zip() 函数：可以用来当list左旋的操作"></a>zip() 函数：可以用来当list左旋的操作</h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p><p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c &#x3D; [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped &#x3D; zip(a,b)     # 打包为元组的列表</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span><br><span class="line">[(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure><h2 id="map-函数：list转换器"><a href="#map-函数：list转换器" class="headerlink" title="map() 函数：list转换器"></a>map() 函数：list转换器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果函数是 None，自动假定一个‘identity’函数,这时候就是模仿 zip()函数，</span><br><span class="line">l&#x3D;[1,2,3]</span><br><span class="line">x&#x3D;map(None,l)</span><br><span class="line">print(x)</span><br><span class="line">这时候 None 类型不是一个可以调用的对象。所以他没法返回值。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python基础&quot;&gt;&lt;a href=&quot;#python基础&quot; class=&quot;headerlink&quot; title=&quot;python基础&quot;&gt;&lt;/a&gt;python基础&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/python3/python
      
    
    </summary>
    
    
      <category term="python" scheme="https://shenqiy.cn/categories/python/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="python" scheme="https://shenqiy.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2020-07-22-learn-CPP</title>
    <link href="https://shenqiy.cn/2020/07/22/2020-07-22-learn-CPP/"/>
    <id>https://shenqiy.cn/2020/07/22/2020-07-22-learn-CPP/</id>
    <published>2020-07-22T04:30:35.000Z</published>
    <updated>2020-07-24T16:26:21.867Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/bat67/article/details/76095813" target="_blank" rel="noopener">VScode C/C++环境配置</a></p><p><a href="https://blog.csdn.net/ysz171360154/article/details/84572114" target="_blank" rel="noopener">CodeBlocks 安装</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/bat67/article/details/76095813&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VScode C/C++环境配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://shenqiy.cn/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://shenqiy.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>c语言基础复习</title>
    <link href="https://shenqiy.cn/2020/07/21/2020-07-21-C-Program/"/>
    <id>https://shenqiy.cn/2020/07/21/2020-07-21-C-Program/</id>
    <published>2020-07-21T04:31:09.000Z</published>
    <updated>2020-07-24T16:26:24.299Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yaouser/C" target="_blank" rel="noopener">如何阅读内核代码</a></p><p>简单的基础复习</p><p>C语言：数组、函数、指针、内存对齐模式、大小端问题、野指针、内存泄露、static、register、define、typedef、struct、union 等一些关键字的考察。</p><h1 id="容易忘的基本语法"><a href="#容易忘的基本语法" class="headerlink" title="容易忘的基本语法"></a>容易忘的基本语法</h1><p><a href="https://github.com/Y-Dian/LearnXinYminutes/blob/master/learnc-cn.c#L179" target="_blank" rel="noopener">基本语法一览</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常数： #define 关键词</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DAYS_IN_YEAR 365</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以枚举的方式定义常数</span></span><br><span class="line"><span class="keyword">enum</span> days &#123;SUN = <span class="number">1</span>, MON, TUE, WED, THU, FRI, SAT&#125;;</span><br><span class="line"><span class="comment">// MON自动被定义为2，TUE被定义为3，以此类推。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// include &lt;尖括号&gt;间的文件名是C标准库的头文件。</span></span><br><span class="line"><span class="comment">// 标准库以外的头文件，使用双引号代替尖括号。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_header.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你的程序的入口是一个返回值为整型的main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//argc参数表示了命令行中参数 的个数(注意：文件名本身也算一个参数)</span></span><br><span class="line"><span class="comment">// argv参数是字符串指针数组， 其各元素值为命令行中各字符串 (参数均按字符串处理)的首地址。指针数组的长度即为参数个数。数组元素初值由系统自动赋予。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// char类型一定会占用1个字节，但是其他的类型却会因具体机器的不同而各异</span></span><br><span class="line"><span class="keyword">int</span> x_int = <span class="number">0</span>;<span class="comment">// int型（整型）变量一般占用4个字节</span></span><br><span class="line">short x_short = <span class="number">0</span>;<span class="comment">// short型（短整型）变量一般占用2个字节</span></span><br><span class="line"><span class="keyword">char</span> x_char = <span class="number">0</span>;<span class="comment">// char型（字符型）变量会占用1个字节</span></span><br><span class="line"><span class="keyword">char</span> y_char = <span class="string">'y'</span>; <span class="comment">// 字符变量的字面值需要用单引号包住</span></span><br><span class="line"><span class="keyword">long</span> x_long = <span class="number">0</span>;<span class="comment">// long型（长整型）一般需要4个字节到8个字节; </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x_long_long = <span class="number">0</span>; <span class="comment">//而long long型则至少需要8个字节（64位）</span></span><br><span class="line"><span class="keyword">float</span> x_float = <span class="number">0.0</span>;<span class="comment">// float一般是用32位表示的浮点数字</span></span><br><span class="line"><span class="keyword">double</span> x_double = <span class="number">0.0</span>;<span class="comment">// double一般是用64位表示的浮点数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数类型也可以有无符号的类型表示。这样这些变量就无法表示负数</span></span><br><span class="line"><span class="comment">// 但是无符号整数所能表示的范围就可以比原来的整数大一些</span></span><br><span class="line"><span class="keyword">unsigned</span> short ux_short;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ux_int;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ux_long_long;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size_t是一个无符号整型，表示对象的尺寸，至少2个字节</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(a++); <span class="comment">// a++ 不会被演算,siezeof直接算a的size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组必须要被初始化为具体的长度</span></span><br><span class="line"><span class="comment">// 可以用下面的方法把数组初始化为0:</span></span><br><span class="line"><span class="keyword">char</span> my_array[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 多维数组</span></span><br><span class="line"><span class="keyword">int</span> multi_array[<span class="number">2</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">int</span> array_int = multi_array[<span class="number">0</span>][<span class="number">2</span>]; <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串就是以 NUL (0x00) 这个字符结尾的字符数组,</span></span><br><span class="line"><span class="comment">// NUL可以用'\0'来表示.</span></span><br><span class="line"><span class="comment">// (在字符串字面量中我们不必输入这个字符，编译器会自动添加的)</span></span><br><span class="line"><span class="keyword">char</span> a_string[<span class="number">20</span>] = <span class="string">"This is a string"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a_string); <span class="comment">// %s 可以对字符串进行格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也许你会注意到 a_string 实际上只有16个字节长.</span></span><br><span class="line"><span class="comment">第17个字节是一个空字符(NUL) </span></span><br><span class="line"><span class="comment">而第18, 19 和 20 个字符的值是未定义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 字符串增、减</span></span><br><span class="line"><span class="keyword">char</span> *s = <span class="string">"iLoveC"</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">s[j++]; <span class="comment">// "i" 返回s的第j项，然后增加j的值。</span></span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 操作符</span></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C中没有布尔类型，而是用整形替代</span></span><br><span class="line"><span class="comment">// (C99中有_Bool或bool。)</span></span><br><span class="line"><span class="comment">// 0为假, 其他均为真. (比较操作符的返回值总是返回0或1)</span></span><br><span class="line"><span class="number">3</span> == <span class="number">2</span>; <span class="comment">// =&gt; 0 (false)</span></span><br><span class="line"><span class="number">3</span> != <span class="number">2</span>; <span class="comment">// =&gt; 1 (true)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C不是Python —— 连续比较不合法</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> between_0_and_2 = <span class="number">0</span> &lt; a &lt; <span class="number">2</span>;<span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span> between_0_and_2 = <span class="number">0</span> &lt; a &amp;&amp; a &lt; <span class="number">2</span>;<span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑运算符适用于整数</span></span><br><span class="line">!<span class="number">3</span>; <span class="comment">// =&gt; 0 (非)</span></span><br><span class="line">!<span class="number">0</span>; <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="number">1</span> &amp;&amp; <span class="number">1</span>; <span class="comment">// =&gt; 1 (且)</span></span><br><span class="line"><span class="number">0</span> &amp;&amp; <span class="number">1</span>; <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="number">0</span> || <span class="number">1</span>; <span class="comment">// =&gt; 1 (或)</span></span><br><span class="line"><span class="number">0</span> || <span class="number">0</span>; <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三元式、条件表达式 （ ? : ）</span></span><br><span class="line">z = (a &gt; b) ? a : b; <span class="comment">//  10 “若a &gt; b返回a，否则返回b。”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位运算</span></span><br><span class="line">~<span class="number">0x0F</span>; <span class="comment">// =&gt; 0xF0 (取反)</span></span><br><span class="line"><span class="number">0x0F</span> &amp; <span class="number">0xF0</span>; <span class="comment">// =&gt; 0x00 (和)</span></span><br><span class="line"><span class="number">0x0F</span> | <span class="number">0xF0</span>; <span class="comment">// =&gt; 0xFF (或)</span></span><br><span class="line"><span class="number">0x04</span> ^ <span class="number">0x0F</span>; <span class="comment">// =&gt; 0x0B (异或)</span></span><br><span class="line"><span class="number">0x01</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// =&gt; 0x02 (左移1位)</span></span><br><span class="line"><span class="number">0x02</span> &gt;&gt; <span class="number">1</span>; <span class="comment">// =&gt; 0x01 (右移1位)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对有符号整数进行移位操作要小心 —— 以下未定义：</span></span><br><span class="line"><span class="comment">// 有符号整数位移至符号位 int a = 1 &lt;&lt; 32</span></span><br><span class="line"><span class="comment">// 左移位一个负数 int a = -1 &lt;&lt; 2</span></span><br><span class="line"><span class="comment">// 移位超过或等于该类型数值的长度</span></span><br><span class="line"><span class="comment">// int a = 1 &lt;&lt; 32; // 假定int32位</span></span><br></pre></td></tr></table></figure><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 控制结构</span></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if()&#123;&#125;</span></span><br><span class="line"><span class="comment">// else if()&#123;&#125;</span></span><br><span class="line"><span class="comment">// else&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// While循环</span></span><br><span class="line"><span class="comment">// while()&#123;&#125;</span></span><br><span class="line"><span class="comment">// do&#123;&#125;while()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt;= 5; i++) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重分支：switch()</span></span><br><span class="line"><span class="keyword">switch</span> (some_integral_expression) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 标签必须是整数常量表达式</span></span><br><span class="line">    do_stuff();</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 如果不使用break，控制结构会继续执行下面的标签</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    do_something_else();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 假设 `some_integral_expression` 不匹配任何标签</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"error!\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x_hex = <span class="number">0x01</span>; <span class="comment">// 可以用16进制字面量赋值</span></span><br><span class="line"><span class="comment">// 整数型和浮点型可以互相转换</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, (<span class="keyword">float</span>)<span class="number">100</span>); <span class="comment">// %f 格式化单精度浮点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, (<span class="keyword">double</span>)<span class="number">100</span>); <span class="comment">// %lf 格式化双精度浮点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">char</span>)<span class="number">100.0</span>);</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">;-)</span><br><span class="line">;)</span><br><span class="line">:)</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;x); <span class="comment">// 用 &amp; 来获取变量的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型在声明中以*开头</span></span><br><span class="line"><span class="keyword">int</span>* px, not_a_pointer; <span class="comment">// px是一个指向int型的指针</span></span><br><span class="line">px = &amp;x; <span class="comment">// 把x的地址保存到px中</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (<span class="keyword">void</span> *)px); <span class="comment">// =&gt; 输出内存中的某个地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%zu, %zu\n"</span>, <span class="keyword">sizeof</span>(px), <span class="keyword">sizeof</span>(not_a_pointer));</span><br><span class="line"><span class="comment">// =&gt; 在64位系统上打印“8， 4”。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要得到某个指针指向的内容的值，可以在指针前加一个*来取得（取消引用）</span></span><br><span class="line"><span class="comment">// 注意： 是的，这可能让人困惑，'*'在用来声明一个指针的同时取消引用它。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *px); <span class="comment">// =&gt; 输出 0, 即x的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针的增减多少是依据它本身的类型而定的</span></span><br><span class="line"><span class="comment">// （这被称为指针算术）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(x_ptr + <span class="number">1</span>)); <span class="comment">// =&gt; 打印 19</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x_array[<span class="number">1</span>]); <span class="comment">// =&gt; 打印 19</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以通过标准库函数malloc来实现动态分配</span></span><br><span class="line"><span class="comment">// 这个函数接受一个代表容量的参数，参数类型为`size_t`</span></span><br><span class="line"><span class="comment">// 系统一般会从堆区分配指定容量字节大小的空间</span></span><br><span class="line"><span class="comment">// （在一些系统，例如嵌入式系统中这点不一定成立,C标准对此未置一词。）</span></span><br><span class="line"><span class="keyword">int</span> *my_ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*my_ptr) * <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (xx=<span class="number">0</span>; xx&lt;<span class="number">20</span>; xx++) &#123;</span><br><span class="line">    *(my_ptr + xx) = <span class="number">20</span> - xx; <span class="comment">// my_ptr[xx] = 20-xx</span></span><br><span class="line">&#125; <span class="comment">// 初始化内存为 20, 19, 18, 17... 2, 1 (类型为int）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc分配的区域需要手动释放</span></span><br><span class="line"><span class="comment">// 否则没人能够再次使用这块内存，直到程序结束为止</span></span><br><span class="line"><span class="built_in">free</span>(my_ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串通常是字符数组，但是经常用字符指针表示</span></span><br><span class="line"><span class="comment">// 一个优良的习惯是使用`const char *`来引用一个字符串字面量，</span></span><br><span class="line"><span class="comment">// 因为字符串字面量不应当被修改（即"foo"[0] = 'a'犯了大忌）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* my_str = <span class="string">"This is my very own string"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, *my_str); <span class="comment">// =&gt; 'T'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果字符串是数组，（多半是用字符串字面量初始化的）</span></span><br><span class="line"><span class="comment">// 情况就不一样了，字符串位于可写的内存中</span></span><br><span class="line"><span class="keyword">char</span> foo[] = <span class="string">"foo"</span>;</span><br><span class="line">foo[<span class="number">0</span>] = <span class="string">'a'</span>; <span class="comment">// 这是合法的，foo现在包含"aoo"</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数是按值传递的。当调用一个函数的时候，传递给函数的参数</span></span><br><span class="line"><span class="comment">是原有值的拷贝（数组除外）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以通过指针来传递引用，这样函数就可以更改值</span></span><br><span class="line"><span class="comment">例子：字符串本身翻转</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为void的函数没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_reverse</span><span class="params">(<span class="keyword">char</span> *str_in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(str_in); <span class="comment">// `strlen()`` 是C标准库函数</span></span><br><span class="line">    <span class="keyword">for</span>(ii = <span class="number">0</span>; ii &lt; len / <span class="number">2</span>; ii++)&#123;</span><br><span class="line">        tmp = str_in[ii];</span><br><span class="line">        str_in[ii] = str_in[len - ii - <span class="number">1</span>]; <span class="comment">// 从倒数第ii个开始</span></span><br><span class="line">        str_in[len - ii - <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果引用函数之外的变量，必须使用extern关键字</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 使用外部变量 i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用static确保external变量为源文件私有</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 其他使用 testFunc()的文件无法访问变量i</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**你同样可以声明函数为static**</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在运行时，函数本身也被存放到某块内存区域当中</span></span><br><span class="line"><span class="comment">函数指针就像其他指针一样（不过是存储一个内存地址） 但却可以被用来直接调用函数,</span></span><br><span class="line"><span class="comment">并且可以四处传递回调函数</span></span><br><span class="line"><span class="comment">但是，定义的语法初看令人有些迷惑</span></span><br><span class="line"><span class="comment">例子：通过指针调用str_reverse</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_reverse_through_pointer</span><span class="params">(<span class="keyword">char</span> *str_in)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数指针 f. </span></span><br><span class="line">    <span class="keyword">void</span> (*f)(<span class="keyword">char</span> *); <span class="comment">// 签名一定要与目标函数相同</span></span><br><span class="line">    f = &amp;str_reverse; <span class="comment">// 将函数的地址在运行时赋给指针</span></span><br><span class="line">    (*f)(str_in); <span class="comment">// 通过指针调用函数</span></span><br><span class="line">    <span class="comment">// f(str_in); // 等价于这种调用方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户自定义类型和结构"><a href="#用户自定义类型和结构" class="headerlink" title="用户自定义类型和结构"></a>用户自定义类型和结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typedefs可以创建类型别名，不同于define</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> my_type;</span><br><span class="line">my_type my_type_var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct是数据的集合，成员依序分配，按照</span></span><br><span class="line"><span class="comment">// 编写的顺序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 一般而言，以下断言不成立：</span></span><br><span class="line"><span class="comment">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span></span><br><span class="line"><span class="comment">//这是因为structure成员之间可能存在潜在的间隙（为了对齐）请看下文介绍</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">my_rec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 . 来访问结构中的数据</span></span><br><span class="line">    my_rec.<span class="built_in">width</span> = <span class="number">10</span>;</span><br><span class="line">    my_rec.<span class="built_in">height</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你也可以声明指向结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> *<span class="title">my_rec_ptr</span> = &amp;<span class="title">my_rec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过取消引用来改变结构体的成员...</span></span><br><span class="line">    (*my_rec_ptr).<span class="built_in">width</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 或者用 -&gt; 操作符作为简写提高可读性</span></span><br><span class="line">    my_rec_ptr-&gt;<span class="built_in">height</span> = <span class="number">10</span>; <span class="comment">// Same as (*my_rec_ptr).height = 10;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以用typedef来给一个结构体起一个别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">rect</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="built_in">rect</span> r)</span></span>&#123;<span class="comment">//&lt;--非指针传递</span></span><br><span class="line">    <span class="keyword">return</span> r.<span class="built_in">width</span> * r.<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果struct较大，你可以通过指针传递，避免</span></span><br><span class="line"><span class="comment">// 复制整个struct。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">const</span> <span class="built_in">rect</span> *r)</span></span>&#123;<span class="comment">//&lt;--指针传递</span></span><br><span class="line">    <span class="keyword">return</span> r-&gt;<span class="built_in">width</span> * r-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><p>普遍来说</p><p>是以几个字节为单位的内存对齐</p><p>如微机中8086若从偶地址读8字节，可以一个周期读完，而</p><h1 id="空指针-野指针-无类型指针"><a href="#空指针-野指针-无类型指针" class="headerlink" title="空指针 野指针 无类型指针"></a>空指针 野指针 无类型指针</h1><ul><li>空指针是被赋值为NULL的指针</li><li>野指针是没有被初始化的指针。</li><li>无类型指针，是指void定义的指针，没有确定类型，可以转化为其他类型，适用场景更广泛。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/yaouser/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何阅读内核代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的基础复习&lt;/p&gt;
&lt;p&gt;C语言：数组、函数、指针、内存对齐模式、大小端问题、野指针、内存
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://shenqiy.cn/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://shenqiy.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>如何背单词</title>
    <link href="https://shenqiy.cn/2020/07/17/2020-07-17-How-to-memorize-words/"/>
    <id>https://shenqiy.cn/2020/07/17/2020-07-17-How-to-memorize-words/</id>
    <published>2020-07-17T14:39:21.000Z</published>
    <updated>2020-07-17T16:25:47.670Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/07/17/2020-07-17-How-to-memorize-words/image-20200717225340394.png" alt="image-20200717225340394"></p><a id="more"></a><p>今年3月底，我用了10天背完了一本六级绿宝书，2700+单词，其中大部分都是生词。</p><p>这里分享一下是怎么背的。</p><blockquote><p>注意：此方法不是捷径，无投机取巧，只有提供了一个科学可行的方案<del>（科学的时间管理）</del>。🚀</p><p>适用于不知如何记忆单词的和我一样的菜鸡，大佬一笑而过就好🤣</p></blockquote><h1 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h1><p>这个方法来自 <a href="/download/17GRE.pdf" ">《17天搞定GRE单词》——杨鹏</a></p><blockquote><p>书主要内容不多，一两小时能读完主要内容。</p><p>实在没时间，可以直接看：第二章第一节的<strong>17天背词法</strong> 、以及第一章第五节的<strong>复习点的确定</strong></p></blockquote><p>其原理：</p><ul><li>根据<code>艾宾浩斯遗忘曲线</code>来规划记忆的时间安排（封面图）</li><li>记忆要点：<code>重复</code>、<code>重复</code>、<code>重复</code>~（整个周期结束每个单词约能重复28次+）</li></ul><p>方法，用一个有30个List的单词书举例说明要点：</p><ul><li>3个list约为200~400词，每天背3个新的list</li><li>一天花<code>3个小时背下3个新的List</code>，一个List用时1小时。复习3个list的时间大约为<code>45分钟~1小时</code> </li><li>大概前两天每天需要3小时多、中期需要6~8小时、后期渐渐减少。</li><li>全本书首次背完用时10天，加上后面复习总用时35天。</li><li>记忆周期为：<ul><li>首次背完、12小时、1天、2天、4天、7天、15天。（新版17天GRE）</li><li>首次背完、12小时、1天、2天、4天、7天、10天。（旧版17天GRE）</li></ul></li></ul><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><p>下面直接贴上原书<strong>第二章第一节的17天背词法</strong>原文：</p><p><strong>步骤一</strong>：首先是红宝书List 1的第1页，共9 个单词，用不到5分钟来背第一遍； </p><p><strong>步骤二</strong>：此时5分钟的记忆周期已到，请先不要看第2页，立即迅速复习第1页。复习的标准为“试图回忆起该单词的意思”； </p><p><strong>步骤三</strong>：到了红宝书的第2～3页和第4～5页。 这四页的内容，每背一页都要重复刚才的步骤一和步骤二（即：每一页都花大约5分钟来背，然后在背下一页单词前立即回到该页的第一个单词来复习，复习后再开始背下一页的单词。 ）</p><p><strong>步骤四</strong>：对于第6页单词，仍然重复步骤一和步骤二，不同的是，在该页单词背完之后，请先不要背第7页，而是立即进行步骤五； </p><p><strong>步骤五</strong>：由于距记忆第一个单词的时间已经有30分钟，所以立即回到第1页，迅速地把1～6页复习一遍； </p><p><strong>步骤六</strong>：剩下的半个List（7～12页），仍然在半个小时内，重复步骤一到步骤五。整个List共用约一个小时。 </p><p><strong>其后的复习模式请按照前面所讲的方法继续，分别在1天后，再隔2天、4天、7 天、15天后复习。</strong>这里的天数是指时间间隔的天数，而不是指第几天。也就是说，如果10月1日早晨背的新单词，这天的晚上要复习，2日、4日、8日、15日、30 日要各做一次复习。等到这个大循环结束之后，背词者对单词的记忆就相当熟练 了，因为每一个单词他都至少背过9遍。此后，背词者只需每天花上45分钟左右复习3个List，就可以对所有的红宝书单词保持“牢不可破”的记忆。</p><h1 id="计划表"><a href="#计划表" class="headerlink" title="计划表"></a>计划表</h1><p>整个背单词的过程需要背词者有一个周密的计划。</p><p>已经有热心网友做好了网页程序，可以很方便的生成计划表并下载，在此十分感谢！</p><ul><li><a href="https://exam4.us/" target="_blank" rel="noopener">exam4.us</a>   新版17天GRE</li><li><a href="https://17gre.github.io/17GRE/" target="_blank" rel="noopener">17gre.github.io/17GRE/</a> （旧版17天GRE）</li></ul><p>一个计划表的例子如下</p><p><img src="/2020/07/17/2020-07-17-How-to-memorize-words/image-20200717234133461.png" alt="image-20200717234133461"></p><p>以下上<strong>作者的原文介绍</strong>：</p><p>说明：上表是以模拟日历的形式做出来的。其中每个单元格上方的黑体数字代表天数，共有7列，代表一周中的7天。此日历为方便起见，把开始背单词的日期放在了1号，读者可以根据自己背单词的实际日期把上表中的天数转换为真正的日历。 前17天的每个单元格中的不带星号的第一行是每天新背的单词，如List 7～9指List 7、List 8和List 9这3个词表。下面带有星号的单词是以前背过的、需要 复习的单词。 </p><p><strong>分析一下这个时间表。</strong></p><p>前3天和第18天之后任务量相对较小。第4天至第7天每天要花3个小时背新单词，3个小时复习以前的单词，加在一起是6个小时；第8 天至第14天每天要花7个小时；</p><p>第15、16、17这3天的任务量最大，每天要花8个小 时。到了第17天之后，不需要再背任何新单词，而且背词者对于红宝书中的80%以上的单词已经复习了很多遍，十分熟练了，同时复习的任务量也大幅度地下降，所以整个背单词的任务也就只剩下扫尾的工作了。</p><p>也就是说，如果想要17天内把这些单词基本搞定，从第8天到第17天这中间的十天是关键。这十天能否咬牙挺住，决定了 这场与单词的搏斗能否胜利。</p><p>至于这种<strong>背词法的效果</strong>，相信读者只要对上面的时间表稍做研究，对其可行性就不会再怀疑。</p><h1 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h1><p>其实3月背完，到四月复习完之后，个人对整本绿宝书90%以上的单词<strong>能达到阅读能反应的程度</strong></p><p>经过两个月（5~6月）专注于课业考试，大概还是能有一定的记忆水平。</p><p>认为一句话说的很好，虽然不一定正确，但揭示了重复记忆的内涵。</p><div><center style="color:red">每次记忆都是神经新突触的形成。<center></center></center></div><p>在做完计划表之后，记得</p><ul><li><p>每天花上45分钟左右复习3个List，保持长期的记忆。</p></li><li><p>OR，花时间阅读英语文章，如果能在文章中碰到背的词，单词的场景就扩展了，记忆会更深。</p></li></ul><p>一些想法：</p><ul><li><p>由于选择了10天过完新单词的老计划，而且还有课业压力。作息没调整好，所以每天基本都熬夜，3点起步。</p></li><li><p>再就是庆幸当时选了3List一天的计划，不然2List一天战线拉长，我肯定顶不住的。</p></li><li><p>上课期搞这个计划不可取，推荐还是找个空闲的暑假寒假搞好些。</p></li><li><p>为什么我大一不知道这个方法？？？</p></li><li><p><strong>背单词虽重要，身体健康更重要。把握好与吃饭的冲突问题，睡眠质量问题，不要伤到颈椎了。</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/07/17/2020-07-17-How-to-memorize-words/image-20200717225340394.png&quot; alt=&quot;image-20200717225340394&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="英语" scheme="https://shenqiy.cn/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="https://shenqiy.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>不要试图说服别人</title>
    <link href="https://shenqiy.cn/2020/07/14/2020-07-14-essay-1/"/>
    <id>https://shenqiy.cn/2020/07/14/2020-07-14-essay-1/</id>
    <published>2020-07-13T16:19:27.000Z</published>
    <updated>2020-07-13T16:39:29.792Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/07/14/2020-07-14-essay-1/image-20200714003508714.png" alt="image-20200714003508714"></p><a id="more"></a><h3 id="为什么永远不要试着说服别人？"><a href="#为什么永远不要试着说服别人？" class="headerlink" title="为什么永远不要试着说服别人？"></a>为什么永远不要试着说服别人？</h3><p>我认为，这句话适用于大多数成年人。</p><p>儿童，一张白纸，性格、为人处事仍有很大的可塑性。</p><p>而随着年龄递增，这张白纸的基色逐渐稳定，往后也难以改变。</p><p>观察几个人之后，我越发觉得这句话的正确性。</p><p>数十年的习惯，只言片语怎可改变？</p><p>再正确的道理，也抵不过思维的定势。</p><p>被劝说的人或是装睡，或是看不真切。</p><p>但都一样。毕竟那些年才是真的，他人只是路过罢了。</p><p>又谈何被说服呢？</p><p>希望自己意识到这句话之后，能多反省反省自身。</p><p>虽然逃不出，但能多改一点就是进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/07/14/2020-07-14-essay-1/image-20200714003508714.png&quot; alt=&quot;image-20200714003508714&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://shenqiy.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://shenqiy.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>信息隐藏</title>
    <link href="https://shenqiy.cn/2020/07/08/2020-07-08-Steganography/"/>
    <id>https://shenqiy.cn/2020/07/08/2020-07-08-Steganography/</id>
    <published>2020-07-08T04:39:02.000Z</published>
    <updated>2020-07-09T12:17:13.308Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。</br> Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。</br> Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码。</br> Hey, password is required here." /><label>加密文章，需要输入密码。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="da7e90057b3140bbfce570b79c26e1c411175f8545d2a6d3833fc423dc4a9cde">bbbb22e1e2503541a77611f6c73ce2a791d14c3af5831a41f5885d41d28d0a95e9847b14b62edd7b2d34bc0869e04212d5bc1d6b26a00c23475adb238324666fa2b79942a78321d4d574e8542039a67d34cda85da3e6ef1049cf0e35c0f98db7b21430d9860db86c28b20e189e8eb0dc9242566f95dc4c31e6cdf7273ca8c06e50f15a05a56cc23454bdf87ac00a81d786567e30a8b738b612ed4b61e127343f51800638fa3e12e71481cf5125ec17338fd3b31fc1eaaf7035fa4367ba1eac40330407fd3dbdfa6246872b1050ffcacd4d16ef478bb4544f8b4de11fac0e0d375a8b7bf8c1d5b26f56dea7c02806a280f0ef9392746d38ec5e02e602d579083a7bc2ed9359329129f91fb72484a3df5c29b8e5994e45cf0f8c9376b82e016a92ad2d33fade256a9d8abd8ccba54e79ee1adeb016f527d9c9faa4601c02bce7d2179ed758a894f490a4cf26a5899f796fdba5312cc1567838307b1772b2ff1cf63b6d98699179ae84c14e9804817c0ca6522dc3f5bf7634d6324ef7b68e7dd2a62f6c3b001024de39b64730b8aa02c38705ce35e5aa2527799325b84f85573f49929dbbb36d7d57cc30ac046f4e739377340daabcc40c022f86eeaf0acc34ccb377ba9e5d387ec93af6b3f5d7241d51f33dce4caaa419d4d7a7e263fffd91546e300a4f6674c47de982349ed5a55b7bba1e2e99c66649ac0670e9a242dfb28b29d5891a75bc023b66382a5a1c40c24fe75d1f4a5d6808ca93bdf919d879507da802ab8e5af5c332849fda40ad2413d3070546bfa548a3a11c43ce43015b7a5f9c86dbc63140e0ad9669250dea7bafb85790a3d50e2a8557069b01351db79076a92044e19e0e879935327d4c1ab281f75b1bf033ce592f804ebe533b2282f07d8273c1f1985e15dd6fd3e48ef695f7dee477019c2530cd9db3785ec328c30c20054097091441f349bb42a1e79161a3a6598b1a69bd6b3f1faa3a9692d5354ddd75cf08dd2a27824fc9af740462f97d75bda8e5530f1ab17d5d726238f42112f5b2f962f4a49f475bc8d34f8fe5e763cf52307459938f9e7be31b354d90adee98e68dbaf073ccadbc9d1233446ff2ef894b8b22f5bcbeae24e92f475a0950909110cf4b90ef400b9e0f008a3105d0efd3261bed3c63a3280a258c49ebd87e8e58748c18efad1b5d8fc7fbab084c42cc0d3896a52897d506d6f7ac0aed3e8dc57defbd51ece420792d866234a376dc5da67a88a09541412f35c6dab7d0a3f9b70a1edd691c4fd407993f45b3cf5fe1f28b8d6043c43e5c7a2e6bcf35524081b652b6fb195eddd0d89d69096f2b0c8e1afc24a7d8f2abd5bbfea50b1f2580459fbd125f78ff6ec04c81f588a46c067cc421d8d52160b7a479248a16c15cd8d60d7b6d4ffe1d426ac1338abd4a8b030b023272d0644d854208be6f22bfb72833dd34f8236508c68d28f225ca25523981649e2cb02ca7258bbc48d96b4c4f83ce84e8f86098891c88cf7b91055ec4442b1dbf46ee26837a7a4f0a10e0993dfdb6da7ca38685ab420fd75fdcf575b4269dc542b37bdc1d5ecdedda2f6bec55af5aab0268d4024cf733a0decc7b230827816b344eaa1b5bfea26b368e309cdaffa9b2f4ab97eb4c53112ae6485c3e2fa1402d587f1a9a2f02e31f81e08b3c4fc23a57a8427c77e66af0743a97de92a1e9b06f0f39e4d0b845888d71189bc6947e4e8ed2629dd807ca01064550ae5ca1bb72d309c258168bb7d2a6b6a888fd4e987ba80bfd094dc83c467f8b3f2ecf6b4c2d19ea3c132e8e7c095dd868f846f602d14dcc90740b96c8613750593b40f51895111226faf3d466d5e111e6cd293bf0bc005d0aff3d2c6da1e8dc53a765f764fd89f6e4310b6ddc19b6be99f73a63915d92986b5b849451e30640582461addf36b76654535583c1cb2b50852872f7695660bdf8df019f4828353ae371c8bbf29895b3e2fa57d1c3fcc91ebcf7a66a4886c80c3cc0259d7a779af91fbadfbba10ee39cc50b5bd1ac36c3c40b204ed61ad0cdce5887f17f5d567f0fe01189b5c71e147985537cdf1b39356126dc975169540df65b52d4ccad5f414d60ec0bffca5d74ea8134c61069ba4e4068ea056ef249ba78032c0a745dd7cc8dbb1c8fa261265de574774b7a2afad9a8750da4c7d4a022791035ee67851de4db8c4a0fdf97484d0e72f68f4b349e201b235c47eae1f1ea1a31b7d9790b5e7546d3dfdd5f2c8151f5ac303b085618870bd96d1cf806747a18e9b41d9776ead9ebc2c2f42f0d31cace1de25fb61e2319ac890538a3bc7cf6cce29d75c2642b2881428b4ae3fe38bd53649ed55507d9055fda0194bf17d5b52244509235e1c177f3f9dfafa75a7082240c94a508364d6de11f7a42f0dc2d8df84841d148a736b31a561615167b14feceab8f30b54847ee0f3d53a0d5b59e455381dcbcdc05513dcb4493837792788fc691c9dc6aef811d93ca97097f950f87c5a2764e9789ec3cca53d69e307eb5c28ffa63d1a7ae80a53aac0760165eb5df21d2dfc72df9911eb24f35f8612628a70ff512319a5957966c3be9a0b9ac6d7bcc106750a4ddb38726fabfff9e5b36ec3d4385e58f102a7671376738791e9de18d952e7764f70d844c659c744f890983dc0800ba9abf42c890ca2b4415d193e1a062367c6d3676150e04e97918ebb3c93f53f655608598fefdb990f10f591d83e509b57aa932ed13f70dd2e494a9a5a37a5a648801840ab73e1c726f07e2fd2273f42a2fc32a94824b151cb1a3da5499b7b04ac9a727f499ebdcb42e0a035f867e766408eadac51dc734ab8c7193b857cb4d51a4a3f11671617980a42a0a5967ffd94bd7de2b613307d4ceb4c9b0a0d4bcb201747a8972b18d51977a17b4ff665c84347015900043430198f2d10e29bbf420df06b3c584bf66e41fdc2bb623c6204e2edcaee7f3182fab9823817a2ac367eb29ab3fb18a30a3f5f2077a4cd94fb361bec52c45112e282bf341f1630b8c7227b2c00e975b43d4597a927e30dc6aa7e6380d828a581d7fedb0bd87ad4b40849662d5e2d0b4b2426c8a5e6c883d1e67bbc5e90fd0ae905de742445fa94be8bfd1a058b9d1d8f3abaa872a4bd2137fbb5fa875c341d5f0a5dad19a4c669d4ee72e6787d3b78354a8a768314951180c02c2e6db730b3f8652b53cdbadbd14f1ad9c0ca174642469ae0460137e60228a87176a7ce73845f7ed3611d4641fa5ef51622b827149dcebb7bc6207e0ff6b1c090e875fe999d2590009c6ab2a25706d5265c35bdc4849d8c006555bb72be6c3e3a4c815a0cdd671aef785d1f78f10b61c3540bbe237a711d473bbcd61625ee083b03a949d5ed9d92516886861f110fb569295462f09d403927cf483adeb372490d58a7be5910b8445a28475c2460273cbec0d992cb780f07d4f8ab5484ad6e4a2fc6368821622370398c0c900fbec249c86d42fbb0e429d6c859e09f47567dea87d84815dc0ebfc18ba6cacb5323bd0a107adeed0c9ddecda50ea6840658a5fe6093f925dda9b5c9e0976ef79200198bb610cd52e7f70bddb04613a0179b1c27080fa7719b4e6405199066a6d92dee81a3dcf4b1f1d52d1a9c9cbe252158bdfbd5b1a1be968e0bfce209fa238bc404d1e29ac25bffb23d17a96e7dba3ab230a8a155f41eaa48c9d4c9a6290178ee7f2e472e1105339bf43c3f138eedb9059fddc5a608ea372d8bf276223f0e41dc5f67d3ae2e59e7faab35db2e60c103fd55e7461ae04438be9a6fe0627c2c4640f465af747ca73d91d830ab3ef7782c6fbf85f79f9dd8bbcb75167a66c3014131a79fa8e23200c99377740e43ccbc07390ea9b5902164e6ea61e42599b505de0d0bd9f0b41e3b3287ac13e7fd2f6e6048821b262996e9c9c1902789ad2348ad072c89019af1cfc0e27dcf1059cfef8c2fd4662ad747117649fcb8d9e7223900b5604ca8d4836edb051e830772b8bb3ce411aca6199eb637f15cda8cac51e9fb454d57947fed2a5a24c8ad741e6299d619247556e21e8d35d40620e4ad4f6ad54a08609859c329be4c5b10d148d89c6acb67a42aaab23a68e1147c495834d33a71133b8f1a89bdb1a6c2a557b426ac5cb7f944f1737a8f2bc5018033ecf2db12a818c9e6664ee19b248853d8df986a4b194327ab860f0a873f4879d37341a129fe4e81e92371947f4cc70f115b61a09da1ac7306c9bc3308d6f166fb8cafa441b41ac483d12f7a6ca37b8d2a690ff8d4cfb6069c38a2c54524853f6775f3d91f6d9c43f411f847c33b8056f9e674fa9a22d42f78da15f3e770ad68b06a939abe7883eda3ac33f529be6d17cc6e6feafe3b2cba46846c9541ccf668ecc20300d9e1f0b8e90d3416c07b8e673c9f01b28284a994d04825be501ebe1cfdbd95167c8682dcfac18f4feb675b9b27de07601e07f38ecde0384c6b21a6f7a6f101c21da3f7ad352540b1f7c197980915aced1b5f093dbb447080c879f707fcf3a288668e67e05ae2f6a46a430b60f7e9f1ca7fef719cfc907b1cd0b9dd68015b294f94de84c9429529d92c00beb12170ecf741b7a9f953a679d5616666d4c85dfc2fc527729ae9081db880bdddbc010701681c51b8b12cd4ae869d33810594e7963d68aa302e552916b0912872259174e72f4ead50b03f52905c77c5000db451d7fdbafd4dabdca1ada8aacde1c04fcbe39128d9271962846938e4980b718b7b44199dbc3c4a380e36b318d3ca42c66d63891f3077428592c83bf4823244048fff219a7195fa6e24e18dfe5824e472b811024248f1e445d96d2e7222cafa16e0055241e63c2f043b10f3478e4fbc0ef88bb770f418207ab95d21b270a8d50161c8dc9a78f3022ed6155ec7a16560e0378339d5fb8c656daa4b81a70720eda4bc990980bb2604422c2c86d06feae02223b189e18b199e6f4cfe0af4cec31a80e4bb249bbef313c486460f559304ee724a0cf2a3758ab1ad13aece35f9f25d9e52f7d6ca24e9feb30b189ab70725ab8cd8ab8aaaba25719e34e6fc3a4acf69968cfb7a40edb148f57e5a7205c452acbb097868c661d737faf2cab5742852fcc45ee7e470b68c73c3527fcd4d78186f07b709928af87b5d4af32f266d4bd28f0d8e6d6cc2a1692e29aff62207ac2abd728c4d3b878f3b998eb4f2bc0262d1fe4c12220fb677c01ba594b4d5f4fcfcc6a192305171c5264aae6b73d80cf3d3eee0b6086fbffb0230064edcd6493d25f4f26e88161a496d3b9c7fd8339211eb12eaabf5bf5b1a9cd802734d0f5efbea431e46625e0cef72b473d</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这篇文章加密了，请输入密码。&lt;/br&gt; Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
    
      <category term="密文" scheme="https://shenqiy.cn/tags/%E5%AF%86%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>算法复习</title>
    <link href="https://shenqiy.cn/2020/07/07/2020-07-07-algorithm/"/>
    <id>https://shenqiy.cn/2020/07/07/2020-07-07-algorithm/</id>
    <published>2020-07-07T10:46:48.000Z</published>
    <updated>2020-07-13T16:47:53.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述1——排序，算法复杂度"><a href="#概述1——排序，算法复杂度" class="headerlink" title="概述1——排序，算法复杂度"></a>概述1——排序，算法复杂度</h1><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617203727265.png" alt="image-20200617203727265"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617203751549.png" alt="image-20200617203751549"></p><h3 id="合并排序-Θ-nlog-n"><a href="#合并排序-Θ-nlog-n" class="headerlink" title="合并排序  Θ(nlog^n^)"></a>合并排序  Θ(nlog^n^)</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204606235.png" alt="image-20200617204606235"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617230232234.png" alt="image-20200617230232234"></p><h3 id="选择排序-Θ-n-2"><a href="#选择排序-Θ-n-2" class="headerlink" title="选择排序   Θ(n^2^)"></a>选择排序   Θ(n^2^)</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204423709.png" alt="image-20200617204423709"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204456644.png" alt="image-20200617204456644"></p><h3 id="插入排序-Θ-n-2"><a href="#插入排序-Θ-n-2" class="headerlink" title="插入排序  Θ(n^2^)"></a>插入排序  Θ(n^2^)</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204517210.png" alt="image-20200617204517210"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204538007.png" alt="image-20200617204538007"></p><h2 id="O-上界-✍"><a href="#O-上界-✍" class="headerlink" title="O 上界  ✍"></a>O 上界  ✍</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205321300.png" alt="image-20200617205321300"></p><p><strong>不等于∞，其实就是当n趋近于无穷时，f(n)不大于cg(n)</strong></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205331994.png" alt="image-20200617205331994"></p><h2 id="Ω下界"><a href="#Ω下界" class="headerlink" title="Ω下界"></a>Ω下界</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205622879.png" alt="image-20200617205622879"></p><p><strong>不等于0，其实就是当n趋近于无穷时，f(n)仍大于cg(n)</strong></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205631847.png" alt="image-20200617205631847"></p><h5 id="Θ紧确界"><a href="#Θ紧确界" class="headerlink" title="Θ紧确界"></a><strong>Θ紧确界</strong></h5><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205735762.png" alt="image-20200617205735762"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205749193.png" alt="image-20200617205749193"></p><h5 id="o上界"><a href="#o上界" class="headerlink" title="o上界"></a><strong>o上界</strong></h5><p><strong>等于0，其实就是当n趋近于无穷时，f(n)<em>远远</em>小于cg(n)</strong></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205905097.png" alt="image-20200617205905097"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619124823913.png" alt="image-20200619124823913"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>传递性</li><li>自反性</li><li>对称性</li><li>倒置对称性</li></ul><h1 id="概述2——算法复杂度估计"><a href="#概述2——算法复杂度估计" class="headerlink" title="概述2——算法复杂度估计"></a>概述2——算法复杂度估计</h1><p>空间复杂度不可能超过时间复杂度S(n)=O(T(n))</p><h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617214000566.png" alt="image-20200617214000566"></p><h2 id="Master-定理Theorem"><a href="#Master-定理Theorem" class="headerlink" title="Master 定理Theorem"></a>Master 定理Theorem</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617215312663.png" alt="image-20200617215312663"></p><h1 id="概述3——堆、堆排序"><a href="#概述3——堆、堆排序" class="headerlink" title="概述3——堆、堆排序"></a>概述3——堆、堆排序</h1><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617215645882.png" alt="image-20200617215645882"></p><h2 id="比较-堆操作-——堆排序：makeH-n-delete-gt-O-nlogn"><a href="#比较-堆操作-——堆排序：makeH-n-delete-gt-O-nlogn" class="headerlink" title="(比较)堆操作 ——堆排序：makeH()+n*delete()=&gt; O(nlogn)"></a>(比较)堆操作 ——堆排序：makeH()+n*delete()=&gt; O(nlogn)</h2><ul><li>辅助运算Sift-up 。主要思想：就是不断的和父节点比，直到为根节点或比父节点小时停止<ul><li>如果比父节点大，就互相替换，继续往上比。 <strong>O(logn)</strong></li></ul></li><li>辅助运算Sift-down。主要思想：就是不断的和子节点比，直到为叶子节点或比子节点都大时停止<ul><li>如果比子节点小，就替换一个较大的子节点（左右相比），继续往下比。 <strong>O(logn)</strong></li></ul></li><li>insert(H,x)：插入元素x到堆H中。插入元素到堆尾，然后调用辅助运算Sift-up。 <strong>O(logn)</strong></li><li>delete(H,i)。删除当前元素，将堆尾元素替上来，然后辅助运算Sift-down。 <strong>O(logn)</strong></li><li>delete-max(H)。删除根元素。<strong>O(logn)</strong></li><li>make-heap(A): 从数组A创建堆。<ul><li>方法1：从一个空堆开始，逐步插入A中的每个元素。<strong>O(nlogn)</strong></li><li>方法2：遍历【n/2】-&gt;【1】，每个都要遍历Sift-down(A[i])，使以A[i]为根节点的子树调整成为堆。 <strong>O(nlogn)</strong> 比方法1略微划算一些</li></ul></li></ul><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617224058787.png" alt="image-20200617224058787"></p><h2 id="非比较-计数排序-——O-n-k-k-θ-n-的时候就是O-n"><a href="#非比较-计数排序-——O-n-k-k-θ-n-的时候就是O-n" class="headerlink" title="(非比较)计数排序 ——O(n+k),k=θ(n)的时候就是O(n)"></a>(非比较)计数排序 ——O(n+k),k=θ(n)的时候就是O(n)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617221841295.png" alt="image-20200617221841295"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617221824334.png" alt="image-20200617221824334"></p><h2 id="非比较-基数排序-——Θ-kn-Θ-n"><a href="#非比较-基数排序-——Θ-kn-Θ-n" class="headerlink" title="(非比较)基数排序 ——Θ(kn)=Θ(n)"></a>(非比较)基数排序 ——Θ(kn)=Θ(n)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617221323955.png" alt="image-20200617221323955"></p><h1 id="二、分治"><a href="#二、分治" class="headerlink" title="二、分治"></a>二、分治</h1><h2 id="合并排序算法-——O-nlogn-，加上θ-n-的空间复杂度"><a href="#合并排序算法-——O-nlogn-，加上θ-n-的空间复杂度" class="headerlink" title="合并排序算法 ——O(nlogn)，加上θ(n)的空间复杂度"></a>合并排序算法 ——O(nlogn)，加上θ(n)的空间复杂度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Algorithm: MERGESORT(A[low…high])</span><br><span class="line">输入：待排序数组A[low,...high]</span><br><span class="line">输出：A[low…high]按非降序排列</span><br><span class="line">1. if low&lt;high then</span><br><span class="line">2.   mid←(low+high)&#x2F;2</span><br><span class="line">3.   MERGESORT(A, low, mid)</span><br><span class="line">4.   MERGESORT(A, mid+1, high)</span><br><span class="line">5.   MERGE(A, low, mid, high)</span><br><span class="line">6. end if</span><br><span class="line"></span><br><span class="line">Algorithm: MERGE(A, p, q, r):</span><br><span class="line">输入：数组A[p...q]和A[q+1...r], 各自按升序排列</span><br><span class="line">输出：将A[p...q]和A[q+1...r]合并成一个升序排序的新数组</span><br><span class="line">1. s←p; t←q+1; k←p; &#123;s, t, p 分别指向A[p...q],A[q+1...r]和B&#125;</span><br><span class="line">2. while s≤q and t≤r</span><br><span class="line">3.    if A[s] ≤A[t] then </span><br><span class="line">4.       B[k]←A[s]</span><br><span class="line">5.       s ←s+1</span><br><span class="line">6.   else</span><br><span class="line">7.       B[k]←A[t]</span><br><span class="line">8.       t←t+1</span><br><span class="line">9.   end if</span><br><span class="line">10. k←k+1</span><br><span class="line">11.end while</span><br><span class="line">12.if s&#x3D;q+1 then B[k...r] ←A[t...r]</span><br><span class="line">13.   else B[k...r] ←A[s...q]</span><br><span class="line">14. end if</span><br><span class="line">15. A[p...q] ←B[p...q]</span><br></pre></td></tr></table></figure><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617230222046.png" alt="image-20200617230222046"></p><h2 id="分治的思想"><a href="#分治的思想" class="headerlink" title="分治的思想"></a>分治的思想</h2><ul><li><strong>划分</strong>：把规模较大的问题(n)分解为若干（通常为2）个<u>规模较小</u>的子问题（&lt;n）， 这些子问题<u>相互独立</u>且与<u>原问题同类</u>; (该子问题的规模减小到一定的程度就可以容易地解决)</li><li><strong>治理</strong>：依次求出这些子问题的解</li><li><strong>组合</strong>：把这些子问题的解组合起来得到原问题的解。<br>由于子问题与原问题是同类的,故分治法可以很自然地应用递归。 </li></ul><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617230546415.png" alt="image-20200617230546415"></p><p><strong>设计模式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">divide_and_conquer(P)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span>(|P|&lt;=n0)   </span><br><span class="line">            direct_process(P);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">            divide P into smaller subinstances P1,P2,…,Pa</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">                 yi=divide_and_conquer(Pi);</span><br><span class="line">            merge(y1,y2,…,ya);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序——Θ-nlogn"><a href="#快速排序——Θ-nlogn" class="headerlink" title="快速排序——Θ(nlogn)"></a>快速排序——Θ(nlogn)</h2><p>具体是</p><ul><li>选定一个中心元素之后，就要将小于他的排在其后，大于他的排在其前</li><li>对分开的两个数组继续如上操作，不断分治（划分、治理）。组合</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Algorithm: QUICKSORT(A[low…high])</span><br><span class="line">输入: n个元素的数组A[low…high]</span><br><span class="line">输出：按非降序排列的数组A[low…high]</span><br><span class="line"><span class="number">1.</span>  <span class="keyword">if</span> low&lt;high then</span><br><span class="line"><span class="number">2.</span>     w ← SPLIT(A[low…high])  &#123;w为基准元素A[low]的新位置&#125;</span><br><span class="line"><span class="number">3.</span>     quicksort(A, low, w<span class="number">-1</span>)</span><br><span class="line"><span class="number">4.</span>     quicksort(A, w+<span class="number">1</span>, high)</span><br><span class="line"><span class="number">5.</span>  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i=left;j=right;<span class="keyword">int</span> temp=a[left];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;<span class="comment">//从右向左找第1个小于中心元素的位置j</span></span><br><span class="line"><span class="keyword">while</span>( a[j] &gt; temp &amp;&amp; i&lt;j)       j--;</span><br><span class="line"><span class="keyword">if</span>(i&lt;j)</span><br><span class="line">&#123;a[  i ]   =    a[  j ];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从左向右找第1个大于中心元素的位置i</span></span><br><span class="line"><span class="keyword">while</span>(a[i]&lt;temp &amp;&amp; i&lt;j ) i++;</span><br><span class="line"><span class="keyword">if</span>(i&lt;j)</span><br><span class="line">&#123;a[j]=a[i];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(i&lt;j);</span><br><span class="line">a[i]=temp;  <span class="comment">//将中心元素t填入最终位置</span></span><br><span class="line">w=i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> left = leftIndex; </span><br><span class="line">    <span class="keyword">int</span> right = rightIndex; </span><br><span class="line">    <span class="keyword">int</span> key = arr[left]; <span class="comment">//待排序的第一个元素作为基准值 </span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;<span class="comment">//从左右两边交替扫描，直到left = right </span></span><br><span class="line">        <span class="keyword">while</span> (right &gt; left &amp;&amp; arr[right] &gt;= key)  &#123; </span><br><span class="line">            right--;<span class="comment">//从右往左扫描，找到第一个比基准值小的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];<span class="comment">//找到这种元素将arr[right]放入arr[left]中 </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key) &#123; </span><br><span class="line">            left++;<span class="comment">//从左往右扫描，找到第一个比基准值大的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];<span class="comment">//找到这种元素将arr[left]放入arr[right]中 </span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = key;<span class="comment">//基准值归位 </span></span><br><span class="line">    quickSort(arr, leftIndex, left - <span class="number">1</span>);<span class="comment">//对基准值左边的元素进行递归排序 </span></span><br><span class="line">    quickSort(arr, right + <span class="number">1</span>, rightIndex);<span class="comment">//对基准值右边的元素进行递归排序。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>设A,B是两个n×n的矩阵，求C=AB.</p><ul><li><p>方法1: 直接相乘法   O(n^3)</p></li><li><p>方法2: 分块矩阵法(直接应用分治策略)   O(n^3)</p></li><li><p>方法3: Strassen算法(改进的分治策略)    O(n^log^2^7^)=O(n^2.81) </p></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><p>排列问题</p><ul><li>已知集合R={r1, r2,…, rn}，请设计一个算法生成集合R 中n 个元素的全排列</li><li>很简单，分治递归就好了</li></ul></li><li><p>寻找中项和第k小元素  Tn=Θ(n)</p><ul><li><p>寻找中项是寻找第k小元素的一个特列。如果能解决寻找第k小元素的问题，那么当k= ⎡ n/2 ⎤时，解决的就是寻找中项问题。</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618000823253.png" alt="image-20200618000823253"></p></li></ul></li><li><p>最接近点对问题</p><ul><li><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001135406.png" alt="image-20200618001135406"></p></li><li><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001105447.png" alt="image-20200618001105447"></p></li><li><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001121031.png" alt="image-20200618001121031"></p></li></ul></li><li><p>棋盘覆盖问题</p><ul><li><p>在一个2k×2k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一<strong>特殊方格**</strong>(<strong>红色表示</strong>)**，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001000290.png" alt="image-20200618001000290"></p></li></ul></li></ul><h1 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h1><p>借助于变量存储中间计算结果，消除重复计算。</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001324885.png" alt="image-20200618001324885"></p><p>基本思想</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002627455.png" alt="image-20200618002627455"></p><p>动态规划基本步骤</p><ul><li><p>找出最优解的性质，并刻划其结构特征。</p></li><li><p>递归地定义最优值。</p></li><li><p>以<strong>自底向上</strong>的方式计算出最优值。</p></li><li><p>根据计算最优值时得到的信息，构造最优解。</p></li></ul><h2 id="矩阵链相乘-——Θ-n-3"><a href="#矩阵链相乘-——Θ-n-3" class="headerlink" title="矩阵链相乘  ——Θ(n^3^)"></a>矩阵链相乘  ——Θ(n^3^)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002116437.png" alt="image-20200618002116437">    可以递归地定义C[i,j]为：</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002153871.png" alt="image-20200618002153871"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002229245.png" alt="image-20200618002229245"></p><h2 id="0-1背包问题-✍"><a href="#0-1背包问题-✍" class="headerlink" title="0-1背包问题  ✍"></a>0-1背包问题  ✍</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002737940.png" alt="image-20200618002737940"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002710822.png" alt="image-20200618002710822"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002851946.png" alt="image-20200618002851946"></p><p>可是一维数组又会导致，前面更新的值，影响后面的值</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002946332.png" alt="image-20200618002946332"></p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给定两个定义在字符集<strong>∑</strong>上的字符串A和 B，长度分别为n和m，现在要求它们的最长公共子序列的长度值(最优值)，以及对应的子序列(最优解) 。</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005033825.png" alt="image-20200618005033825"></p><h2 id="其他问题-1"><a href="#其他问题-1" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><p>钢条切割问题：<img src="/2020/07/07/2020-07-07-algorithm/image-20200618004917079.png" alt="image-20200618004917079"></p></li><li><p>最大子数组问题sum[i+1] = max(sum[i]+a[i+1], a[i+1])</p></li><li><p>爬楼梯（第二个楼梯就有两种走法。）：dp[i] = dp[i-1]+dp[i-2]</p></li><li><p>最长连续有效括号长度：</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005426781.png" alt="image-20200618005426781"></p></li></ul><h1 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h1><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005649956.png" alt="image-20200618005649956"></p><h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005723278.png" alt="image-20200618005723278"></p><h2 id="小数背包问题"><a href="#小数背包问题" class="headerlink" title="小数背包问题"></a>小数背包问题</h2><p>计算每种物品的<strong>单位重量-价值</strong>作为贪心选择的依据指标，选择<strong>单位重量-价值最高</strong>的物品，将尽可能多的该物品装入背包，依此策略一直地进行下去，直到背包装满为止。<img src="/2020/07/07/2020-07-07-algorithm/image-20200618005909341.png" alt="image-20200618005909341"></p><h2 id="Dijkstra单源最短路径问题-✍"><a href="#Dijkstra单源最短路径问题-✍" class="headerlink" title="Dijkstra单源最短路径问题  ✍"></a>Dijkstra单源最短路径问题  ✍</h2><p>给定带权有向图G =(V,E)，其中每条边的权是非负实数。另外，还给定V中的一个顶点，称为<strong>源</strong>。现在要计算从源到所有其他各顶点的<strong>最短长度</strong>。这里路的长度是指路上各边权之和。这个问题通常称为<strong>单源最短路径</strong>问题。 </p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618010401065.png" alt="image-20200618010401065"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618010537461.png" alt="image-20200618010537461"></p><h2 id="单源最短路径（存在？）：Bellman-Ford"><a href="#单源最短路径（存在？）：Bellman-Ford" class="headerlink" title="单源最短路径（存在？）：Bellman-Ford"></a>单源最短路径（存在？）：Bellman-Ford</h2><ul><li>推理：如果在|V|-1 次循环后，d[v]不能收敛，则存在权重为负的环路</li></ul><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618011326388.png" alt="image-20200618011326388"></p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618011551452.png" alt="image-20200618011551452"></p><h3 id="Prim算法-——避圈法-Θ-n-2-✍🆗"><a href="#Prim算法-——避圈法-Θ-n-2-✍🆗" class="headerlink" title="Prim算法  ——避圈法  Θ(n^2^)  ✍🆗"></a>Prim算法  ——避圈法  Θ(n^2^)  ✍🆗</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618012144452.png" alt="image-20200618012144452"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618012437116.png" alt="image-20200618012437116"></p><h3 id="Kruskal算法-——避圈法-O-mlogm-n-✍🆗"><a href="#Kruskal算法-——避圈法-O-mlogm-n-✍🆗" class="headerlink" title="Kruskal算法    ——避圈法 O(mlogm+n)  ✍🆗"></a>Kruskal算法    ——避圈法 O(mlogm+n)  ✍🆗</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618011725626.png" alt="image-20200618011725626"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618012448158.png" alt="image-20200618012448158"></p><h3 id="破圈法-（”-圈”指的是回路）"><a href="#破圈法-（”-圈”指的是回路）" class="headerlink" title="破圈法  （” 圈”指的是回路）"></a>破圈法  （” 圈”指的是回路）</h3><p>求最小生成树有两种方法，一种是破圈法，另一种是避圈法（Kruskal,Prim也是求MST的算法）。</p><p>破圈法是“见圈破圈”，即如果看到图中有一个圈，就将这个圈的边去掉一条，直至图中再无一圈为止。</p><p>步骤如下：</p><ol><li>在图中找一个回路</li><li>去掉该回路中权值最大的边，但要保持图仍为连通。</li><li>反复此过程，直至图中再无回路（但仍保持连通），得到最小生成树。</li></ol><p>最后结果根据操作选取不同可能不唯一，但图的权值和（生成树的代价）相同，均为最小值。</p><p>避圈法则采取先将图中的点都取出来，然后，逐渐向上面添边，并保证后添入的边不与以前添上的边构成圈就可以了，这个过程直到将边集中能加入的边（加入后不够成圈）都加完为止。参见词条“Prim算法”和“Kruskal算法”。</p><h2 id="其他问题-2"><a href="#其他问题-2" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li>找硬币，最少找硬币数</li><li>霍夫曼编码：（编码）将每个码字连接起来。最低频的两个字符在最优编码树中，一定是深度最深的两个叶子</li><li>孩子分糖，最多满足孩子数，从最容易满足的孩子找最小的糖</li></ul><h1 id="四、图的遍历"><a href="#四、图的遍历" class="headerlink" title="四、图的遍历"></a>四、图的遍历</h1><h2 id="深度优先搜索树-⭐"><a href="#深度优先搜索树-⭐" class="headerlink" title="深度优先搜索树 ⭐"></a>深度优先搜索树 ⭐</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618170234724.png" alt="image-20200618170234724"></p><ul><li><p><strong>predfn（先序号）</strong>：在图的深度优先搜索生成树(森林)中顶点的先序号，是指按照先序方式访问该生成树，该顶点的序号。</p></li><li><p><strong>postdfn（后序号）</strong>：在图的深度优先搜索生成树(森林)中顶点的后序号，是指按照后序方式访问该生成树，该顶点的序号。</p></li></ul><p><strong>无向图只有两条边——树边、回边</strong> （由于前向边、横跨边的定义） </p><p>*<em>有向图情形 ——四种边 *</em> Θ(n^2^ ) 使用邻接矩阵</p><blockquote><p>广度优先中：</p><p>在无向图中，边分为：树边或者是横跨边。(横跨边没有父子关系)</p><p>在有向图中，边分为：树边，回边及横跨边。不存在前向边。</p></blockquote><ul><li><p>树边(Tree edges)－ 深度优先搜索生成树中的边：探测边(v,w)时，w是 “unvisited”状态，则边(v,w)是树边。</p></li><li><p>回边(Back edges)－在迄今为止所构建的深度优先搜索生成树中，w是v的祖先，并且在探测(v,w)时，w已经被标记为”visited”,则(v,w)为回边。 </p></li><li><p>前向边(Forward edges)－在迄今为止所构建的深度优先搜索生成树中，w是v的后裔，并且在探测(v,w)时，w已经被标记为”visited”,则(v,w)为前向边。 </p></li><li><p>横跨边(Cross edges)－所有其他的边。</p></li></ul><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618170207228.png" alt="image-20200618170207228"></p><h2 id="广度优先搜索树"><a href="#广度优先搜索树" class="headerlink" title="广度优先搜索树"></a>广度优先搜索树</h2><p>在无向图中，边分为：树边或者是横跨边。</p><p>在有向图中，边分为：树边，回边及横跨边。不存在前向边。</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618175112082.png" alt="image-20200618175112082"></p><h2 id="图的无回路性判定-有向-无向图"><a href="#图的无回路性判定-有向-无向图" class="headerlink" title="图的无回路性判定  有向/无向图"></a>图的无回路性判定  有向/无向图</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174030579.png" alt="image-20200618174030579"></p><h2 id="拓扑排序-——有向图"><a href="#拓扑排序-——有向图" class="headerlink" title="拓扑排序  ——有向图"></a>拓扑排序  ——有向图</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174500149.png" alt="image-20200618174500149"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174445964.png" alt="image-20200618174445964"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174428002.png" alt="image-20200618174428002">    </p><h2 id="强连通分支-——有向图-✍"><a href="#强连通分支-——有向图-✍" class="headerlink" title="强连通分支 ——有向图  ✍"></a>强连通分支 ——有向图  ✍</h2><p>有向图G=(V,E)，强连通集为顶点的极大集。<strong>在该集合中，每一对顶点都存在一条路径</strong>。</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174607857.png" alt="image-20200618174607857"></p><ul><li>首先深度优先搜索，得到postdfn后序号</li><li>颠倒G中边的方向，构成一个新的图G’</li><li>图G’从最大的postdfn开始执行深搜，如果不能达到所有节点，换一个顶点继续</li><li>最后得到的森林中，每棵树对应一个强连通分支</li></ul><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174801988.png" alt="image-20200618174801988"></p><h1 id="五、回溯法"><a href="#五、回溯法" class="headerlink" title="五、回溯法"></a>五、回溯法</h1><p>节点是由<strong>深度优先搜索方法生成</strong>的。<strong>不需要存储整棵搜索树，只需要存储根到当前活动节点的路径</strong>。</p><ul><li>活节点：正常节点</li><li>扩展节点：当前节点，正在对此节点进行搜索</li><li>死节点：不可行节点，无需对其下面的节点进行搜索</li></ul><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618180648879.png" alt="image-20200618180648879"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618180641217.png" alt="image-20200618180641217"></p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618183544530.png" alt="image-20200618183544530"></p><p>递归回溯</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618183408900.png" alt="image-20200618183408900"></p><p>迭代回溯</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618183418523.png" alt="image-20200618183418523"></p><h2 id="皇后问题"><a href="#皇后问题" class="headerlink" title="皇后问题"></a>皇后问题</h2><p>所以，尽管在最坏情况下要用O(n^n^)时间来求解，然而大量实际经验表明，它在有效性上远远超过蛮力方法O(n!)。例如在4 皇后问题中，只搜索了341个节点中的27个就找到了解。 </p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618181044719.png" alt="image-20200618181044719"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618181024810.png" alt="image-20200618181024810"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618181018188.png" alt="image-20200618181018188"></p><h2 id="分支界限法-与-回溯法的区别（旅行商TSP）"><a href="#分支界限法-与-回溯法的区别（旅行商TSP）" class="headerlink" title="分支界限法 与 回溯法的区别（旅行商TSP）"></a>分支界限法 与 回溯法的区别（旅行商TSP）</h2><p>分支限界法与回溯法的<strong>搜索方式</strong>不同</p><ul><li><p>回溯法：深度优先</p></li><li><p>分支限界法：广度优先或最小耗费（最大收益）优先</p></li></ul><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618184212297.png" alt="image-20200618184212297"></p><p>两种分支限界法：</p><ul><li><p>队列式(FIFO)分支限界法(宽度优先)：按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</p></li><li><p><strong>优先队列式分支限界法</strong>(最小耗费或是最大收益优先)：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</p><ul><li>最大优先队列：使用最大堆，体现最大收益优先</li><li>最小优先队列：使用最小堆，体现最小耗费优先</li></ul></li></ul><h3 id="旅行商"><a href="#旅行商" class="headerlink" title="旅行商"></a>旅行商</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185211728.png" alt="image-20200618185211728"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185122634.png" alt="image-20200618185122634"></p><h1 id="第六章、NP问题"><a href="#第六章、NP问题" class="headerlink" title="第六章、NP问题"></a>第六章、NP问题</h1><p><strong>如果对一个问题∏存在一个算法，时间复杂性为O(n^k^)，其中n是问题规模，k是一个非负整数，则称问题∏存在多项式时间算法。</strong>这类算法在可以接受的时间内实现问题求解</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185259193.png" alt="image-20200618185259193"></p><h2 id="1-P、NP、NPC、co-NP"><a href="#1-P、NP、NPC、co-NP" class="headerlink" title="1. P、NP、NPC、co-NP"></a>1. P、NP、NPC、co-NP</h2><p>P属于NP，人们猜测P ≠ NP，但是否成立，至今未得到证明。</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190959962.png" alt="image-20200618190959962"></p><h3 id="1-P类问题"><a href="#1-P类问题" class="headerlink" title="1 P类问题"></a><strong>1 P类问题</strong></h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185944301.png" alt="image-20200618185944301"></p><h3 id="2-NP类问题"><a href="#2-NP类问题" class="headerlink" title="2 NP类问题"></a><strong>2 NP类问题</strong></h3><p>非确定性算法：就是说，能以猜测和验证的方式工作，而且两个步骤都能在多项式时间内完成。</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190230249.png" alt="image-20200618190230249"></p><p>np问题：即每个实例都可以用非确定性算法得出一个yes/no的答案。</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190115671.png" alt="image-20200618190115671"></p><h3 id="3-NPC问题"><a href="#3-NPC问题" class="headerlink" title="3 NPC问题"></a><strong>3 NPC问题</strong></h3><ul><li>证明问题A是NP问题</li><li>证明一个已证的NPC问题可多项式输入转化为问题A，而其俩的输出可以相互转化。s</li></ul><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190709531.png" alt="image-20200618190709531"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190941751.png" alt="image-20200618190941751"></p><h3 id="4-NP-Hard"><a href="#4-NP-Hard" class="headerlink" title="4 NP-Hard"></a>4 NP-Hard</h3><p>NP-Hard不是NP问题，但是和NPC一样难</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618192130504.png" alt="image-20200618192130504"></p><h3 id="5-co-NP问题"><a href="#5-co-NP问题" class="headerlink" title="5 co-NP问题"></a>5 co-NP问题</h3><p>就是说，NP的猜测和验证只需要进行到某个x正确就结束了。co-NP的猜测和验证必须要全遍历全部x吗?</p><p>我是纠结在了，co-NP也是猜测和验证上的hh，现在看来确实不一样</p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618191247412.png" alt="image-20200618191247412"></p><h2 id="2-最大团-SAT∝poly团-⭐"><a href="#2-最大团-SAT∝poly团-⭐" class="headerlink" title="2. 最大团  (SAT∝poly团) ⭐"></a>2. 最大团  (SAT∝<del>poly</del>团) ⭐</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618191635190.png" alt="image-20200618191635190"></p><h2 id="3-三元可满足性问题3SAT-SAT∝poly3SAT"><a href="#3-三元可满足性问题3SAT-SAT∝poly3SAT" class="headerlink" title="3. 三元可满足性问题3SAT     (SAT∝poly3SAT)"></a>3. 三元可满足性问题3SAT     (SAT∝<del>poly</del>3SAT)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618191833664.png" alt="image-20200618191833664"></p><h2 id="4-顶点覆盖问题-3SAT∝polyVC-重点看📕"><a href="#4-顶点覆盖问题-3SAT∝polyVC-重点看📕" class="headerlink" title="4. 顶点覆盖问题  (3SAT∝polyVC) 重点看📕"></a>4. 顶点覆盖问题  (3SAT∝<del>poly</del>VC) 重点看📕</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618192412490.png" alt="image-20200618192412490"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619121945353.png" alt="image-20200619121945353"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619122459457.png" alt="image-20200619122459457"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619125859905.png" alt="image-20200619125859905"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130009272.png" alt="image-20200619130009272"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619125921925.png" alt="image-20200619125921925"></p><h2 id="第二章-动态规划"><a href="#第二章-动态规划" class="headerlink" title="第二章 动态规划"></a>第二章 动态规划</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619125942195.png" alt="image-20200619125942195"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130057070.png" alt="image-20200619130057070"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619131851675.png" alt="image-20200619131851675"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CHESS_COIN</span><span class="params">(c)</span>:</span></span><br><span class="line">    lenc=len(c)</span><br><span class="line">    OPT=[lenc][lenc]</span><br><span class="line"><span class="comment">#这是上半部分初始化最高行的代码：</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):    <span class="comment">#遍历最高行(y)的每列(x)，从0~n-1</span></span><br><span class="line"> OPT(i,lenc<span class="number">-1</span>)=(i,lenc<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#这是下半部分遍历计算的代码：</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(lenc<span class="number">-1</span>:<span class="number">0</span>):  <span class="comment">#遍历行(y)，从n-2~0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):  <span class="comment">#遍历列(x)，从0~n-1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> : <span class="comment">#最左列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">elif</span> i==n<span class="number">-1</span>:<span class="comment">#最右列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#其余列</span></span><br><span class="line">            OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">    <span class="keyword">return</span> OPT</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work_arrange</span><span class="params">(w)</span></span></span><br><span class="line">OPT=[len(w)]</span><br><span class="line">    <span class="keyword">if</span> len(w)&gt;=<span class="number">1</span>: <span class="comment">#一天（含）以上的OPT安排</span></span><br><span class="line">        OPT[<span class="number">0</span>]=w[<span class="number">0</span>]  <span class="comment">#w[0]是工作第0天工作的工资，为零</span></span><br><span class="line">        OPT[<span class="number">1</span>]=w[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> len(w)&gt;=<span class="number">2</span>: <span class="comment">#两天（含）以上的OPT安排</span></span><br><span class="line">        OPT[<span class="number">2</span>]=w[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:<span class="comment">#三天（含）以上的OPT安排</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">3</span> to len(w):  <span class="comment">#对于三天以上的每天，都有三种情况</span></span><br><span class="line">            OPT[i]=max(OPT[i<span class="number">-1</span>],OPT[i<span class="number">-2</span>]+w[i],OPT[i<span class="number">-3</span>]+w[i<span class="number">-1</span>]+w[i]) </span><br><span class="line">    <span class="keyword">return</span> OPT</span><br></pre></td></tr></table></figure><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130115423.png" alt="image-20200619130115423"></p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130132348.png" alt="image-20200619130132348"></p><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619131155873.png" alt="image-20200619131155873"></p><h2 id="第五章-回溯法"><a href="#第五章-回溯法" class="headerlink" title="第五章 回溯法"></a>第五章 回溯法</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130151111.png" alt="image-20200619130151111"></p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619121945353.png" alt="image-20200619121945353"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述1——排序，算法复杂度&quot;&gt;&lt;a href=&quot;#概述1——排序，算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;概述1——排序，算法复杂度&quot;&gt;&lt;/a&gt;概述1——排序，算法复杂度&lt;/h1&gt;&lt;h3 id=&quot;二分搜索&quot;&gt;&lt;a href=&quot;#二分搜索&quot;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://shenqiy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shenqiy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
