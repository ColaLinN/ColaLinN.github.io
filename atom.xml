<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神奇小站</title>
  
  <subtitle>这里总有神奇的东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://colalinn.github.io/"/>
  <updated>2020-04-02T11:22:59.859Z</updated>
  <id>https://colalinn.github.io/</id>
  
  <author>
    <name>ColaLinN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020-04-02-inforamtion-security-exp-2</title>
    <link href="https://colalinn.github.io/2020/04/02/2020-04-02-inforamtion-security-exp-2/"/>
    <id>https://colalinn.github.io/2020/04/02/2020-04-02-inforamtion-security-exp-2/</id>
    <published>2020-04-02T11:17:42.000Z</published>
    <updated>2020-04-02T11:22:59.859Z</updated>
    
    <content type="html"><![CDATA[<p>#coding = gbk</p><p>第六周ppt</p><p>搜狗词库，码一下,适用于初学者</p><p>编码方式要一致，再码一下</p><p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/DWRZTOS7$G%60%60G_@MT7IMR$T.png" alt="img"></p><p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200402191850157.png" alt="image-20200402191850157"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#coding = gbk&lt;/p&gt;
&lt;p&gt;第六周ppt&lt;/p&gt;
&lt;p&gt;搜狗词库，码一下,适用于初学者&lt;/p&gt;
&lt;p&gt;编码方式要一致，再码一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/02/2020-04-02-inforamtion-security-exp-2
      
    
    </summary>
    
    
      <category term="exp" scheme="https://colalinn.github.io/categories/exp/"/>
    
    
      <category term="exp" scheme="https://colalinn.github.io/tags/exp/"/>
    
  </entry>
  
  <entry>
    <title>2020-03-25-information-security-exp-1</title>
    <link href="https://colalinn.github.io/2020/03/25/2020-03-25-information-security-exp-1/"/>
    <id>https://colalinn.github.io/2020/03/25/2020-03-25-information-security-exp-1/</id>
    <published>2020-03-25T13:01:15.000Z</published>
    <updated>2020-04-02T15:10:41.163Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>IDE：pycharm</p><p>python版本：anacoda-&gt;python3.7</p><h1 id="实验1-1-requests库"><a href="#实验1-1-requests库" class="headerlink" title="实验1.1-requests库"></a>实验1.1-requests库</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200327164527042.png" alt="image-20200327164527042"></p><p>安装requests库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160841956.png" alt="image-20200402160841956"></p><h2 id="1-获取状态码"><a href="#1-获取状态码" class="headerlink" title="1.获取状态码"></a>1.获取状态码</h2><p>配置Python环境，使用通用代码框架爬取网站，并获取状态码。 爬取网址请自行选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()  <span class="comment"># 如果状态不是200，引发error异常</span></span><br><span class="line">        r.encoding=r.apparent_encoding <span class="comment">#获取网页正确的编码格式</span></span><br><span class="line">        <span class="keyword">return</span> r.status_code  <span class="comment">#返回状态码</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    url=<span class="string">"https://www.baidu.com/"</span></span><br><span class="line">    print(getHTMLText(url))</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160846431.png" alt="image-20200402160846431"></p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160853276.png" alt="image-20200402160853276"></p><h2 id="2-使用post-方法"><a href="#2-使用post-方法" class="headerlink" title="2.使用post()方法"></a>2.使用post()方法</h2><p>使用requests库中的post()方法，向<a href="http://httpbin.org/post" target="_blank" rel="noopener">http://httpbin.org/post</a> 增加字段，其中your_name和ID，请使用自己的姓名及学号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">payload = &#123;<span class="string">'name'</span>: <span class="string">'LFL'</span>, <span class="string">'ID'</span>: <span class="string">'2017301500076'</span>&#125;</span><br><span class="line">r=requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160901843.png" alt="image-20200402160901843"></p><h2 id="3-实例1-2-3-4"><a href="#3-实例1-2-3-4" class="headerlink" title="3.实例1/2/3/4"></a>3.实例1/2/3/4</h2><p>完成实例1/2/3/4，其中实例1中的浏览器版本、实例2中搜索关键、实例3中下载图片、实例4 中的IP地址请自行选择。</p><h3 id="1-亚马逊网站商品页面爬取"><a href="#1-亚马逊网站商品页面爬取" class="headerlink" title="1-亚马逊网站商品页面爬取"></a>1-亚马逊网站商品页面爬取</h3><p>直接访问亚马逊会返回503访问异常错误</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160906535.png" alt="image-20200402160906535"></p><p>所以在头部加上浏览器版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">hd=&#123;<span class="string">'user-agent'</span>:<span class="string">'Chrome/66.0'</span>&#125;</span><br><span class="line"><span class="comment"># r=requests.request('post','https://www.amazon.com/',headers=hd)</span></span><br><span class="line">r=requests.get(<span class="string">"https://www.amazon.com"</span>,headers=hd)</span><br><span class="line">print(r.status_code)</span><br></pre></td></tr></table></figure><p>返回码200正确</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160911519.png" alt="image-20200402160911519"></p><h3 id="2-搜索引擎搜索关键词提交"><a href="#2-搜索引擎搜索关键词提交" class="headerlink" title="2-搜索引擎搜索关键词提交"></a>2-搜索引擎搜索关键词提交</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_2</span><span class="params">()</span>:</span></span><br><span class="line">    keyword = <span class="string">"WHU"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        kv = &#123;<span class="string">'wd'</span>: keyword,<span class="string">'user-agent'</span>:<span class="string">'Chrome/66.0'</span>&#125;</span><br><span class="line">        r = requests.get(<span class="string">"http://www.baidu.com/s"</span>,params=kv)</span><br><span class="line">        print(r.request.url)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        print(r.text[<span class="number">1</span>:<span class="number">1000</span>])</span><br><span class="line">    <span class="comment"># 结果太长，打印前1000个字符</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_2()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160916924.png" alt="image-20200402160916924"></p><h3 id="3-网络图片的爬取和存储"><a href="#3-网络图片的爬取和存储" class="headerlink" title="3-网络图片的爬取和存储"></a>3-网络图片的爬取和存储</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="keyword">import</span> os  <span class="comment"># OS库提供了使用各种操作系统功能的接口。</span></span><br><span class="line">    url = <span class="string">"https://colalinn.github.io/2020/02/28/2020-02-28-algorithm-class/image-20200228174457509.png"</span></span><br><span class="line">    root = <span class="string">""</span></span><br><span class="line">    path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">            print(<span class="string">"就是py下的目录啦！"</span>)</span><br><span class="line">            <span class="comment"># os.mkdir(root)  # 用于以数字权限模式创建目录</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">            print(<span class="string">"客官文件不存在哦,我们保存一下！"</span>)</span><br><span class="line">            r = requests.get(url)</span><br><span class="line">            <span class="keyword">with</span> open(path, <span class="string">'wb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">                f.write(r.content)</span><br><span class="line">                f.close()</span><br><span class="line">                print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 写代码时注意缩进</span></span><br><span class="line">            print(<span class="string">"文件已存在"</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160921928.png" alt="image-20200402160921928"></p><h3 id="4-ip地址的查询"><a href="#4-ip地址的查询" class="headerlink" title="4-ip地址的查询"></a>4-ip地址的查询</h3><p>原ppt链接的网站会有一个弹窗，这里暂不改动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_4</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="comment"># url="http://www.ip138.com/ips138.asp?ip=" #这个链接不能用了</span></span><br><span class="line">    url = <span class="string">"https://ipchaxun.com/"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        hd = &#123;<span class="string">'user-agent'</span>: <span class="string">'Chrome/66.0'</span>&#125;</span><br><span class="line">        r = requests.get(url + <span class="string">'220.181.38.148'</span>,headers=hd)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        print(r.text[<span class="number">1900</span>:<span class="number">2400</span>])  <span class="comment"># 输出最后2000个字符</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_4()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161147165.png" alt="image-20200402161147165"></p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161207830.png" alt="image-20200402161207830"></p><h1 id="实验1-2-BeautifulSoup库"><a href="#实验1-2-BeautifulSoup库" class="headerlink" title="实验1.2-BeautifulSoup库"></a>实验1.2-BeautifulSoup库</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过转换器实现文档导航、查找、修改。</p><p>安装        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><p>解析器</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161235158.png" alt="image-20200402161235158"></p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul><li>参考实例2，爬取百度搜索风云榜 <a href="http://top.baidu.com/" target="_blank" rel="noopener">http://top.baidu.com/</a> 任一榜单，搜索结果按顺序逐行输出（含编号），榜单自选。</li><li>自行编码完成实例3，并回答思考题。</li><li>爬取当当图书排行榜（榜单自选），格式：爬取结果包含但不限于[排名 书名 作者]， 注意输出格式对齐。</li></ul><h2 id="1-爬取百度搜索风云榜"><a href="#1-爬取百度搜索风云榜" class="headerlink" title="1-爬取百度搜索风云榜"></a>1-爬取百度搜索风云榜</h2><p>使用审查可以看到百度搜索风云榜的标签都是a标签，属性是“list-title”</p><p>所以我们使用以下方式即可获取所有人物串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'a'</span>, <span class="string">'list-title'</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161241441.png" alt="image-20200402161241441"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_2</span><span class="params">()</span>:</span></span><br><span class="line">    r = requests.get(<span class="string">"http://top.baidu.com/buzz?b=257&amp;fr=topboards"</span>)</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    demo = r.text</span><br><span class="line">    soup = BeautifulSoup(demo, <span class="string">'html.parser'</span>)</span><br><span class="line">    ulist = []</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>, <span class="string">'list-title'</span>):</span><br><span class="line">        ulist.append(tag.string)  <span class="comment"># Xlist.append()在列表X尾部增加一个新的元素</span></span><br><span class="line">        print(ulist.index(tag.string) + <span class="number">1</span>, ulist[ulist.index(tag.string)])</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># instance_1()</span></span><br><span class="line">    instance_2()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160825591.png" alt="image-20200402160825591"></p><h2 id="2-爬取中国大学排行榜-扩展"><a href="#2-爬取中国大学排行榜-扩展" class="headerlink" title="2-爬取中国大学排行榜+扩展"></a>2-爬取中国大学排行榜+扩展</h2><p>一开始我们的代码如下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            ulist.append([tr.td.string, tds[<span class="number">1</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>]))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>)  <span class="comment"># 20 univs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3()</span><br></pre></td></tr></table></figure><p>结果是不对齐的，这是因为当中文字符宽度不够时，采用西文字符填充；中西文字符占用宽度不同</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402162153169.png" alt="image-20200402162153169"></p><p>之后我们将printUnivList函数改成如下，排列对齐了</p><p>tplt为定义的输出格式模板变量：</p><ul><li>^代表居中</li><li>4/12/10代表输出宽度（当输出数据超过该数字时，以实际输出为准）</li><li>{3}代表打印输出时，我们使用chr(12288)中文空格对齐（全角Unicode空格）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList_A</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^4&#125;\t&#123;1:&#123;3&#125;^12&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402162058589.png" alt="image-20200402162058589"></p><h3 id="扩展1-url改为2017"><a href="#扩展1-url改为2017" class="headerlink" title="扩展1-url改为2017"></a>扩展1-url改为2017</h3><p>将实例2中url改为软科中国最好大学排名2017？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2017.html'</span></span><br></pre></td></tr></table></figure><p>会报错 <code>排名</code>找不到</p><p>我们将ulist打印出来，发现排名为none，说明没有获取到排名的值</p><p>而我在chrome上审查，2017和2016的排名处格式是相同的</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402164344702.png" alt="image-20200402164344702"></p><p>而在代码中使用<code>soup.prettify()</code>打印出来代码后发现排名处格式没有<code>&lt;td&gt;&lt;/td&gt;</code>的闭合，这里估计是用了javascript渲染时做了手脚使得td标签变了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">print(soup.prettify())</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402164103572.png" alt="image-20200402164103572"></p><p>由图上可知，第一个td标签包含了所有内容，包括排名，所以无法通过<code>tds[0]</code>找到</p><p>解决方案：</p><p>使用contends</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tds[<span class="number">0</span>].contents[<span class="number">0</span>]   <span class="comment">#这个就是排名了</span></span><br><span class="line">tds[<span class="number">0</span>].get_text(<span class="string">" "</span>).split(<span class="string">" "</span>)[<span class="number">0</span>]  <span class="comment">#这个也可以,get_text()清空所有html标签元素</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402183232902.png" alt="image-20200402183232902"></p><p>总代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="comment"># print(soup.prettify())</span></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            <span class="comment"># tds[0].get_text(" ").split(" ")[0]也可以</span></span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].contents[<span class="number">0</span>], tds[<span class="number">1</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList_A</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^4&#125;\t&#123;1:&#123;3&#125;^12&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2017.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList_A(uinfo, <span class="number">20</span>)  <span class="comment"># 20 univs</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3()</span><br></pre></td></tr></table></figure><p>最终结果</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402183419220.png" alt="image-20200402183419220"></p><h3 id="扩展2-url改为软科排名2016"><a href="#扩展2-url改为软科排名2016" class="headerlink" title="扩展2-url改为软科排名2016"></a>扩展2-url改为软科排名2016</h3><p>将实例2中url改为软科世界大学学术排名 2016：<a href="http://www.zuihaodaxue.cn/ARWU2016.html" target="_blank" rel="noopener">http://www.zuihaodaxue.cn/ARWU2016.html</a><br>该如何修改代码？</p><p>可以看到没有多大的变化，只是大学名、国家\地区有些不同    </p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402165756192.png" alt="image-20200402165756192"></p><p>对之前的代码稍加修改可得结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3_2</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/ARWU2016.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            uinfo.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].a.string, tds[<span class="number">3</span>].string])</span><br><span class="line">    tplt = <span class="string">"&#123;0:^4&#125;\t&#123;1:&#123;3&#125;^12&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        u = uinfo[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3_2()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402170840117.png" alt="image-20200402170840117"></p><h2 id="3-爬取当当图书排行榜（榜单自选）"><a href="#3-爬取当当图书排行榜（榜单自选）" class="headerlink" title="3.爬取当当图书排行榜（榜单自选）"></a>3.爬取当当图书排行榜（榜单自选）</h2><p>格式：爬取结果包含但不限于[排名 书名 作者]， 注意输出格式对齐。</p><p>我这里爬取 <code>信息安全</code>类书籍的销量排行榜</p><p><a href="http://bang.dangdang.com/books/bestsellers/01.54.19.00.00.00-24hours-0-0-1-1" target="_blank" rel="noopener">http://bang.dangdang.com/books/bestsellers/01.54.19.00.00.00-24hours-0-0-1-1</a></p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402171057952.png" alt="image-20200402171057952"></p><p>可以看到<code>html</code>结构如下</p><p>先从<code>class</code>为<code>bang_list clearfix bang_list_mode</code>中的<code>ul</code>遍历<code>li</code></p><p>再从<code>li</code>中找出</p><ul><li>排名</li><li>名字</li><li>现在的价格</li><li>之前的价格</li><li>链接</li></ul><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402171331034.png" alt="image-20200402171331034"></p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_4</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://bang.dangdang.com/books/bestsellers/01.54.19.00.00.00-24hours-0-0-1-1'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="comment"># print(soup.prettify())</span></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> soup.find(<span class="string">'ul'</span>,attrs=&#123;<span class="string">"class"</span>:re.compile(<span class="string">'bang_list clearfix bang_list_mode'</span>)&#125;).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(li, bs4.element.Tag):</span><br><span class="line">            div_array = li(<span class="string">'div'</span>)</span><br><span class="line">            rank=div_array[<span class="number">0</span>].string</span><br><span class="line">            name=div_array[<span class="number">1</span>].a.img.attrs[<span class="string">'title'</span>]</span><br><span class="line">            price_n=div_array[<span class="number">6</span>].p.contents[<span class="number">1</span>].string</span><br><span class="line">            prince_before=div_array[<span class="number">6</span>].p.contents[<span class="number">3</span>].string</span><br><span class="line">            url=div_array[<span class="number">1</span>].a.attrs[<span class="string">'href'</span>]</span><br><span class="line">            uinfo.append([rank,name,price_n,prince_before,url])</span><br><span class="line">    tplt = <span class="string">"&#123;0:^3&#125;\t&#123;1:&#123;5&#125;^15&#125;\t&#123;2:^5&#125;\t&#123;3:^5&#125;\t&#123;4:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"书名"</span>, <span class="string">"之前的价格"</span>,<span class="string">"当前价格"</span>,<span class="string">"URL"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        u = uinfo[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>],u[<span class="number">3</span>],u[<span class="number">4</span>],chr(<span class="number">12288</span>)))</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    instance_4()</span><br></pre></td></tr></table></figure><p>结果如下！！！</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402175720833.png" alt="image-20200402175720833"></p><h1 id="实验2-1-正则式"><a href="#实验2-1-正则式" class="headerlink" title="实验2.1-正则式"></a>实验2.1-正则式</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>正则表达式（Regular Expression，简写为regex或RE），使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402184401030.png" alt="image-20200402184401030"></p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402200458302.png" alt="image-20200402200458302"></p><p>re库主要的方法如下</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402204550930.png" alt="image-20200402204550930"></p><p>match对象包含了关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402204649960.png" alt="image-20200402204649960"></p><p>只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402204939305.png" alt="image-20200402204939305"></p><h2 id="尝试爬取淘宝商品的数据"><a href="#尝试爬取淘宝商品的数据" class="headerlink" title="尝试爬取淘宝商品的数据"></a>尝试爬取淘宝商品的数据</h2><ul><li><p>扫码登陆淘宝</p></li><li><p>搜索某个商品</p></li><li><p>发现商品分页的规律——如下，</p><p>第1页<code>https://s.taobao.com/search</code> <code>?q=airpodspro</code> <code>&amp;s=0</code></p><p>第2页<code>https://s.taobao.com/search</code> <code>?q=airpodspro</code> <code>&amp;s=44</code></p><p>第3页<code>https://s.taobao.com/search</code> <code>?q=airpodspro</code> <code>&amp;s=88</code></p><p>可以看出每页的s都是44累加的，这样我们想要遍历分页只需要遍历s即可</p></li></ul><p>由于淘宝有反爬虫机制，我们要将手动登陆后的Cookies、agent复制到header中</p><ul><li>扫码登陆淘宝</li><li>搜索商品，Chrome  下 F12打开审查</li><li>点击Network-&gt;Doc类型-&gt;search……-&gt;复制cookie、user-agent</li><li>将cookie、user-agent放到请求中，具体方式看代码</li></ul><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402215404788.png" alt="image-20200402215404788"></p><p>编写程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># AFAEF728105FFA95263125A9E0A097DC</span></span><br><span class="line">        hd = &#123;<span class="string">'cookie'</span>: <span class="string">'t=31555440a71b4d3ae330f044081146f9; cna=eaagFpxdLAUCAdrFmScIIYcw; thw=cn; cookie2=1bdfd953450db1890a4960bafedf8169; v=0; _tb_token_=eefe396e49733; _samesite_flag_=true; sgcookie=Edo1lgxwoK2bRfYVahZOe; unb=2522367083; uc3=lg2=UIHiLt3xD8xYTw%3D%3D&amp;id2=UU2w7Hb9dvcsIQ%3D%3D&amp;nk2=tw%2F9XZuWLTE%3D&amp;vt3=F8dBxdAW4LSdjQGNkyg%3D; csg=dbe09bde; lgc=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; cookie17=UU2w7Hb9dvcsIQ%3D%3D; dnk=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; skt=d262960506d154ef; existShop=MTU4NTgzMjY2OQ%3D%3D; uc4=nk4=0%40tXwweg7zi7bxIxNwomsc8lmKSw%3D%3D&amp;id4=0%40U2%2F32UM%2BC1YLt9wuKmGuJsNzMVo7; tracknick=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; _cc_=VT5L2FSpdA%3D%3D; _l_g_=Ug%3D%3D; sg=%E5%A5%873f; _nk_=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; cookie1=AHnU1YHbYbkYLGQxilkANOpn3Y133DLACku%2BjBXRjNk%3D; enc=q3Gwz15Bq6QwoLkeceXsesqtD8wfeR5rLdWz%2BffQweZA9DT9jrnDbu8nmeCLcdc0X%2BE9JypMae6noiYZzph68g%3D%3D; tfstk=cEPhBo_vJJkCDiI_-HGQy2BO73GhalBEA7Pa_WoWKw4ovdFZ8sDJQKWBJNmLx7p5.; mt=ci=113_1; uc1=cookie16=URm48syIJ1yk0MX2J7mAAEhTuw%3D%3D&amp;cookie21=VFC%2FuZ9aiKCaj7AzMHh1&amp;cookie15=Vq8l%2BKCLz3%2F65A%3D%3D&amp;existShop=false&amp;pas=0&amp;cookie14=UoTUP2oWHktHHQ%3D%3D; l=dBEymxamQbBz3b0YBOfgqDezDdbOXBRflsPr9GLh3IB19u53HdBqEHweIlleI3QQEt134eKrjGibiRQeC3fRwxDDB3h2q_5xnxf..; isg=BIOD_uxF2W-mR5UgKRuxH2xxEkct-Bc6Bw5VXrVg3-JZdKOWPcinimHi7gQ6VG8y'</span></span><br><span class="line">              ,<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>,headers=hd)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(ilt, html)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        plt = re.findall(<span class="string">r'\"view_price\"\:\"[\d\.]*\"'</span>, html) <span class="comment">#匹配价格</span></span><br><span class="line">        tlt = re.findall(<span class="string">r'\"raw_title\"\:\".*?\"'</span>, html)  <span class="comment">#匹配标题</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plt)):</span><br><span class="line">            price = eval(plt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])  <span class="comment">#对搜索结果进行分割，以“：”为分割点</span></span><br><span class="line">            title = eval(tlt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])  <span class="comment">#eval将字符串当成有效的表达式来求值并返回计算结果</span></span><br><span class="line">            ilt.append([price, title])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGoodsList</span><span class="params">(ilt)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"序号"</span>, <span class="string">"价格"</span>, <span class="string">"商品名称"</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> ilt:</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="comment"># print((tplt.format(count, g[0], g[1])+"\n"))</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"taobao-airpods pro.txt"</span>, <span class="string">"a+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write((tplt.format(count, g[<span class="number">0</span>], g[<span class="number">1</span>])+<span class="string">"\n"</span>)) <span class="comment"># 这句话自带文件关闭功能，不需要再写f.close()</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    goods = <span class="string">'airpodspro'</span></span><br><span class="line">    depth = <span class="number">100</span></span><br><span class="line">    start_url = <span class="string">'https://s.taobao.com/search?q='</span> + goods</span><br><span class="line">    infoList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(depth):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url = start_url + <span class="string">'&amp;s='</span> + str(<span class="number">44</span> * i)</span><br><span class="line">            html = getHTMLText(url)</span><br><span class="line">            <span class="comment"># print(html)</span></span><br><span class="line">            parsePage(infoList, html)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    printGoodsList(infoList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>功能说明：</p><ul><li><code>main()</code>主程序用于遍历商品页输出</li><li><code>getHTMLText()</code>用于获得html</li><li><code>parsePage()</code>用正则式搜索商品名称和价格</li><li><code>printGoodsList()</code> 用于向命令行输出</li></ul><p>这里写入txt——用python向txt文件中写数据时的追加和覆盖，我们使用a+</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"test.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"这是个测试！"</span>) <span class="comment">#这句话自带文件关闭功能，不需要再写f.close()</span></span><br><span class="line">r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</span><br><span class="line">r+：打开一个文件用于读写。文件指针将会放在文件的开头。 </span><br><span class="line">w：打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</span><br><span class="line">w+：打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</span><br><span class="line">a：打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</span><br><span class="line">a+：打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</span><br></pre></td></tr></table></figure><p>我爬取的是airpodspro的相关信息，爬取100页，具体的数据会存储到txt中</p><p>运行程序，成功</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402213933616.png" alt="image-20200402213933616"></p><p>爬取的过程中出现了编码问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeEncodeError: <span class="string">'gbk'</span> codec can<span class="string">'t encode character '</span>\xae<span class="string">' in position 17: illegal multibyte sequence</span></span><br></pre></td></tr></table></figure><p>处理一下exception就好了</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402222101748.png" alt="image-20200402222101748"></p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402223510719.png" alt="image-20200402223510719"></p><h1 id="实验2-2-用srapy框架爬取任意网站的内容"><a href="#实验2-2-用srapy框架爬取任意网站的内容" class="headerlink" title="实验2.2-用srapy框架爬取任意网站的内容"></a>实验2.2-用srapy框架爬取任意网站的内容</h1><p>要求：（不少于50条）</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><h3 id="1-Scrapy与request"><a href="#1-Scrapy与request" class="headerlink" title="1.Scrapy与request"></a>1.Scrapy与request</h3><ul><li>相同点：两者都可以进行页面请求和爬取，Python爬虫的两个重要技术路线两者可用性都好，文档丰富，入门简单两者都没有处理js、提交表单、应对验证码等功能（可扩展）</li><li>不同点：<ul><li>Requests 页面级爬虫，功能库，并发性考虑不足，性能较差，重点在于页面下载。定制灵活，上手十分简单 。</li><li>Scrapy<br>网站级爬虫 框架，并发性好，性能较高， 重点在于爬虫结构。 一般定制灵活，深度定制困难， 入门稍难。</li></ul></li></ul><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402222443363.png" alt="image-20200402222443363"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Engine从Spider处获得爬取请求(Request)</span><br><span class="line">Engine将爬取请求转发给Scheduler，用于调度</span><br><span class="line">Engine从Scheduler处获得下一个要爬取的请求</span><br><span class="line">Engine将爬取请求通过中间件发送给Downloader</span><br><span class="line">爬取网页后，Downloader形成响应（Response）通过中间件发给Engine</span><br><span class="line">Engine将收到的响应通过中间件发送给Spider处理 </span><br><span class="line">Spider处理响应后产生爬取项（scraped Item）和新的爬取请求（Requests）给Engine</span><br><span class="line">Engine将爬取项发送给Item Pipeline（框架出口）</span><br><span class="line">Engine将爬取请求发送给Scheduler</span><br></pre></td></tr></table></figure><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><ul><li><p>安装lxml： pip install lxml</p></li><li><p>下载对应版本的Twisted</p><p>我下面的方法没成功，是在pycharm下下载的</p><p>%%%%%%%%%%%%%%%%%%%%</p><p>++++++++++++++++++++++++</p><p>​       <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a> </p><p>​        <img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402222827956.png" alt="image-20200402222827956"></p><p>​       pip3 install C:\Users\78290\Desktop\Twisted-20.3.0-cp38-cp38-win_amd64.whl</p><p>​        (下载好的twisted模块的whl文件路径)</p><p>​    %%%%%%%%%%%%%%%%%%</p></li><li><p>安装scrapy：pip install scrapy</p></li><li><p>安装关联模块pypiwin32：pip install pypiwin32 </p></li></ul><h3 id="3-创建一个scrapy"><a href="#3-创建一个scrapy" class="headerlink" title="3.创建一个scrapy"></a>3.创建一个scrapy</h3><p>Scrapy常用命令</p><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402224714359.png" alt="image-20200402224714359"></p><p>1.创建项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject tutorial</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402225249765.png" alt="image-20200402225249765"></p><p>2.定义Item</p><p>编辑 tutorial 目录中的 items.py 文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    link = scrapy.Field()</span><br><span class="line">    desc = scrapy.Field()</span><br></pre></td></tr></table></figure><p>3.编写spider </p><p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。<br>为了创建一个Spider，必须继承 scrapy.Spider 类， 且定义三个属性：</p><ul><li>name: 用于区别Spider。 该名字必须是唯一的，不可以为不同的Spider设定相同的名字。</li><li>start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li><li>parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在项目中生成 spider 文件的两种方法:</span><br><span class="line">命令行输入 Scrapy genspider domain domain.com</span><br><span class="line">tutorial&#x2F;spiders&#x2F;目录下创建domain.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#爬取网页的内容</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">W3schoolSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'w3school'</span></span><br><span class="line">    allowed_domains = [<span class="string">'w3school.com.cn'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://www.w3school.com.cn/cssref/css_selectors.asp'</span>,</span><br><span class="line">                  <span class="string">'http://www.w3school.com.cn/xpath/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        filename = response.url.split(<span class="string">"/"</span>)[<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.body)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>4.执行spider</p><p>进入项目的根目录，执行下列命令启动spider    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl w3school</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402231037199.png" alt="image-20200402231037199"></p><h1 id="使用GooSeeker爬取数据"><a href="#使用GooSeeker爬取数据" class="headerlink" title="使用GooSeeker爬取数据"></a>使用GooSeeker爬取数据</h1><p><a href="https://www.jianshu.com/p/62bb53e07544" target="_blank" rel="noopener">https://www.jianshu.com/p/62bb53e07544</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h1&gt;&lt;p&gt;IDE：pycharm&lt;/p&gt;
&lt;p&gt;python版本：anacoda-&amp;gt;python3.7
      
    
    </summary>
    
    
      <category term="信息内容安全" scheme="https://colalinn.github.io/categories/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="实验" scheme="https://colalinn.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>2020-3-22-plan-A</title>
    <link href="https://colalinn.github.io/2020/03/22/2020-03-22-plan-A/"/>
    <id>https://colalinn.github.io/2020/03/22/2020-03-22-plan-A/</id>
    <published>2020-03-21T16:27:24.000Z</published>
    <updated>2020-03-31T13:05:31.416Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>日期</th><th align="left">进度</th></tr></thead><tbody><tr><td>2020-3-17</td><td align="left">了解</td></tr><tr><td>2020-3-22</td><td align="left">①√</td></tr><tr><td>2020-3-23</td><td align="left">②√</td></tr><tr><td>2020-3-24</td><td align="left">③√</td></tr><tr><td>2020-3-25</td><td align="left">④√开始艰难</td></tr><tr><td>2020-3-26</td><td align="left">⑤√今天很累，搞到3：30</td></tr><tr><td>2020-3-27</td><td align="left">⑥√</td></tr><tr><td>2020-3-28</td><td align="left">⑦√</td></tr><tr><td>2020-3-29</td><td align="left">⑧√</td></tr><tr><td>2020-3-30</td><td align="left">⑨只完成了新词的背诵。。</td></tr><tr><td>2020-3-31</td><td align="left">⑩</td></tr><tr><td>说实话，上课期间脱产学这个还是很难顶的，一天花7、8个小时在这上面，人都搞没了</td><td align="left"></td></tr></tbody></table><p>2020-3-28</p><p>说一下第7天的感受吧，这周基本都在熬夜，每天3点起步。</p><p>现在我完全是在用身体健康换词汇量，已经有些吃不消了。</p><p>由于家里没有合适的书桌，长时间的保持一个姿势，颈椎已经有些问题了。</p><p>现在就是在期待大后天，期待4月1日背完整本书的曙光，才能坚持的下来。</p><p>还好当时选了3List一天的计划，要不然2List一天，战线拉长了，我肯定顶不住的。</p><p>这种上课期间脱产搞这个的计划不可取，推荐还是找个空闲的暑假寒假搞好些（所以为什么我大一不知道这个方法？？？）。</p><p>总的来说上课期间背影响有以下几点</p><ul><li>有时候背着背着，想到这周的作业没写，DDL将近，心情很烦躁，影响背单词、听课质量。</li><li>与吃饭和上课时间的冲突问题。</li><li>睡眠问题。每天都要到3点多才能结束。</li></ul><p>2020-3-29</p><p>背到深夜有些痛苦</p><p>2020-3-30</p><p>今天特别疲倦</p><p>2020-3-31</p><p>终于，有些尴尬的背完了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日期&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;进度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;2020-3-17&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;了解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;

      
    
    </summary>
    
    
      <category term="-英语" scheme="https://colalinn.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="plan" scheme="https://colalinn.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>网络安全实验1</title>
    <link href="https://colalinn.github.io/2020/03/16/2020-03-16-Network-Security-Experiment-1/"/>
    <id>https://colalinn.github.io/2020/03/16/2020-03-16-Network-Security-Experiment-1/</id>
    <published>2020-03-16T08:56:30.000Z</published>
    <updated>2020-03-21T16:25:47.838Z</updated>
    
    <content type="html"><![CDATA[<p>课程名称：网络安全实验</p><p>实验名称：网络侦查</p><p>实验学时：02:30:00</p><h1 id="1-实验描述"><a href="#1-实验描述" class="headerlink" title="1.实验描述"></a>1.实验描述</h1><p>随着时代的发展和网络的普及，在世界各国、各层次的计算机网络中，储存着大量公开资料和机密资料，由于网络漏洞的存在，为“黑客”入侵计算机网络系统获取机密资料提供了很多便利，这些资料引起了各国军事情报部门的重视，都大力开展利用计算机网络系统来获取情报资料的研究和尝试，这便是网络侦察。</p><p>网络侦查是指黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标主机的所有探测活动。网络侦查有时也被称为“踩点”。通常“踩点”包括以下内容：目标主机的域名、IP地址、操作系统类型、开放了哪些端口，以及这些端口后面运行着什么样的应用程序，这些应用程序有没有漏洞等。那么如何收集信息呢？可以利用与技术无关的“社会工程学”、搜索引擎以及扫描工具。</p><p>本实验旨在通过在企业复杂网络场景下的网络侦查应用实战，让学生深刻理解网络侦查的概念、特性和原理，掌握网络侦查相关技术，具备对网络进行侦查、渗透、敏感信息获取以及防网络侦查的技术能力，这对于学生的信息安全技术能力提升、国家网络空间安全战略实施，都有非常重要的意义。</p><p>本实验内容共包含4个子任务，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">任务一 使用nmap、ettercap进行网络侦查和密码嗅探；</span><br><span class="line">任务二 使用crunch、hydra暴力破解ssh服务登陆密码；</span><br><span class="line">任务三 使用ssh登录目标机，获得敏感信息；</span><br><span class="line">任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息。</span><br></pre></td></tr></table></figure><h1 id="2实验目的"><a href="#2实验目的" class="headerlink" title="2实验目的"></a>2实验目的</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.了解网络侦查、信息收集、漏洞挖掘和利用的基本概念以及常用的信息收集和安全漏洞扫描工具，认知常见的网络侦查手段和企业网络安全漏洞。</span><br><span class="line">2.掌握nmap工具的功能和操作方法，并能够分析检侧结果，能够运用这些工具解决目标网络信息探测、漏洞挖掘等常见的安全问题。</span><br><span class="line">3.了解ettercap嗅探工具的基本功能，掌握常见的嗅探相关服务和应用的用户名和密码的方法。</span><br><span class="line">4.了解crunch的基本功能，掌握利用crunch生成密码字典文件的方法。</span><br><span class="line">5.了解hydra密码爆破工具的基本功能和使用方法，掌握常见的爆破服务和应用的用户名和密码的方法。 </span><br><span class="line">6.熟悉网站wenshell的概念，理解上传webshell、获取webshell权限的意义和方法，掌握获取webshell权限基础上控制目标机的方法。</span><br></pre></td></tr></table></figure><p>通过nmap、ettercap、crunch和hydra等工具的学习和使用，能够融会贯通，掌握相关服务如ftp、web等漏洞挖掘、渗透、攻击和利用的原理和方法，掌握自主学习和实践主流企业网络扫描工具的功能、操作技巧、检测结果分析、网络侦查、漏洞挖掘的常用方法，具备企业复杂网络信息安全管理的职业能力和终身学习能力。</p><h1 id="3实验工具"><a href="#3实验工具" class="headerlink" title="3实验工具"></a>3实验工具</h1><ul><li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nmap" target="_blank" rel="noopener">Nmap</a>（集成于kali linux）</li><li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ettercap" target="_blank" rel="noopener">ettercap</a>（集成于kali linux）</li><li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:crunch" target="_blank" rel="noopener">crunch</a>（集成于kali linux）</li><li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:hydra" target="_blank" rel="noopener">hydra</a>（集成于kali linux）</li><li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:firefox" target="_blank" rel="noopener">Firefox</a>（54.2.0）</li><li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:rdesktop" target="_blank" rel="noopener">Rdesktop</a></li></ul><h1 id="4实验环境"><a href="#4实验环境" class="headerlink" title="4实验环境"></a>4实验环境</h1><table><thead><tr><th>操作系统</th><th>IP地址</th><th>服务器角色</th><th>登录账户密码</th></tr></thead><tbody><tr><td>kali Linux</td><td>192.168.1.2</td><td>操作机</td><td>用户名：root；密码：Simplexue123</td></tr><tr><td>Ubuntu12</td><td>192.168.1.3</td><td>目标机</td><td>用户名：root；密码：Simplexue123</td></tr><tr><td>Windows2012</td><td>192.168.1.4</td><td>目标机</td><td>用户名：administrator；密码：Simplexue123</td></tr></tbody></table><p>实验拓扑图如下</p><p><img src="/2020/03/16/2020-03-16-Network-Security-Experiment-1/image-20200316171551313.png" alt="image-20200316171551313"></p><h1 id="5-实验内容及原理"><a href="#5-实验内容及原理" class="headerlink" title="5.实验内容及原理"></a>5.实验内容及原理</h1><h2 id="5-1-网络侦察实验"><a href="#5-1-网络侦察实验" class="headerlink" title="5.1 网络侦察实验"></a>5.1 网络侦察实验</h2><h3 id="5-1-1实验描述"><a href="#5-1-1实验描述" class="headerlink" title="5.1.1实验描述"></a>5.1.1实验描述</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">利用kali集成的扫描工具nmap，对网络进行探测，收集目标网络存活的主机信息，收集主机开放的服务信息。</span><br><span class="line">利用kali集成的嗅探工具ettercap，对FTP服务进行嗅探，获取目标主机的ftp登录密码（提交嗅探到的ftp登录密码）。</span><br></pre></td></tr></table></figure><p>通过完成本实验任务，要求学生掌握利用nmap进行网络探测并获取目标主机开放的服务等关键信息的方法；掌握通过ettercap实现对目标主机的服务如ftp进行嗅探的流程、方法和技巧，为完成后续网络侦查和漏洞利用实验任务奠定坚实的网络探测技术基础。</p><h3 id="5-1-2实验目标"><a href="#5-1-2实验目标" class="headerlink" title="5.1.2实验目标"></a>5.1.2实验目标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">了解网络侦查、信息收集、漏洞挖掘和利用的基本概念以及常用的信息收集和安全漏洞扫描工具，认知常见的网络侦查手段和企业网络安全漏洞。</span><br><span class="line">掌握nmap工具的功能和操作方法，并能够分析检侧结果，能够运用这些工具解决目标网络信息探测、漏洞挖掘等常见的安全问题。</span><br><span class="line">了解ettercap嗅探工具的基本功能，掌握常见的嗅探相关服务和应用的用户名和密码的方法。</span><br></pre></td></tr></table></figure><p>通过nmap、ettercap等工具的学习和使用，能够举一反三，掌握自主学习企业级网络扫描工具功能、操作技巧、检测结果分析、网络侦查、漏洞挖掘的常用方法，最终具备企业复杂网络侦查、漏洞挖掘和信息系统安全管理的职业能力。</p><h3 id="5-1-3实验工具"><a href="#5-1-3实验工具" class="headerlink" title="5.1.3实验工具"></a>5.1.3实验工具</h3><ul><li><a href="[http://210.42.123.2:8088/doku.php?id=%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B7%A5%E5%85%B7:nmap](http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nmap)">nmap</a>（集成于kali linux）</li><li><a href="[http://210.42.123.2:8088/doku.php?id=%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B7%A5%E5%85%B7:ettercap](http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ettercap)">ettercap</a>（集成于kali linux）</li></ul><h3 id="5-1-4实验步骤"><a href="#5-1-4实验步骤" class="headerlink" title="5.1.4实验步骤"></a>5.1.4实验步骤</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>在Kali linux操作系统中打开操作终端，并使用nmap命令扫描192.168.1.0网段的存活主机，并探测该网段存活主机的开放端口、服务、操作系统及版本信息。</p><blockquote><p>可以使用Kali linux集成的nmap工具来完成操作步骤1.1，也可以通过操作机自行上传其他工具来完成。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#使用Nmap实现网段内的IP发现：</span><br><span class="line">nmap -sP ip&#x2F;mask</span><br><span class="line">nmap -sP 192.168.1.0&#x2F;24</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/2020-03-16-Network-Security-Experiment-1/image-20200316183326844.png" alt="image-20200316183326844"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#探测开放端口及服务</span><br><span class="line">快速端口扫描</span><br><span class="line">nmap -F -v 192.168.1.0&#x2F;24</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/2020-03-16-Network-Security-Experiment-1/image-20200316183738031.png" alt="image-20200316183738031"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#版本扫描</span><br><span class="line">nmap -sV -v taget_ip</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -v 192.168.1.3</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/2020-03-16-Network-Security-Experiment-1/image-20200316184802094.png" alt="image-20200316184802094"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -v 192.168.1.4</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/2020-03-16-Network-Security-Experiment-1/image-20200316185228476.png" alt="image-20200316185228476"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#操作系统扫描</span><br><span class="line">nmap -O -v target_ip</span><br><span class="line">nmap -O -v 192.168.1.3</span><br><span class="line">nmap -O -v 192.168.1.4</span><br></pre></td></tr></table></figure><p>nmap -O -v 192.168.1.3</p><p>no exact OS matches for host</p><p><img src="/2020/03/16/2020-03-16-Network-Security-Experiment-1/image-20200316185543332.png" alt="image-20200316185543332"></p><p>nmap -O -v 192.168.1.4</p><p><img src="/2020/03/16/2020-03-16-Network-Security-Experiment-1/image-20200316185822712.png" alt="image-20200316185822712"></p><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>使用嗅探工具对目标机的vsftpd服务进行嗅探。通过设置监听网卡、主机、开启arp欺骗、启动嗅探等步骤来嗅探网络内的数据包，获取ftp用户名和密码。</p><blockquote><p>提示：可以使用Kali linux集成的ettercap工具来完成操作步骤1.2，也可以通过操作机自行上传其他工具来完成。</p></blockquote><h3 id="5-1-5实验结果提交"><a href="#5-1-5实验结果提交" class="headerlink" title="5.1.5实验结果提交"></a>5.1.5实验结果提交</h3><p>将嗅探到的ftp登陆密码作为实验结果提交，提交成功后该实验任务完成。</p><h2 id="5-2-XXX实验"><a href="#5-2-XXX实验" class="headerlink" title="5.2 XXX实验"></a>5.2 XXX实验</h2><h1 id="6-实验步骤"><a href="#6-实验步骤" class="headerlink" title="6.实验步骤"></a>6.实验步骤</h1><h1 id="7-实验结果及分析"><a href="#7-实验结果及分析" class="headerlink" title="7.实验结果及分析"></a>7.实验结果及分析</h1><h1 id="8-实验结论"><a href="#8-实验结论" class="headerlink" title="8.实验结论"></a>8.实验结论</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程名称：网络安全实验&lt;/p&gt;
&lt;p&gt;实验名称：网络侦查&lt;/p&gt;
&lt;p&gt;实验学时：02:30:00&lt;/p&gt;
&lt;h1 id=&quot;1-实验描述&quot;&gt;&lt;a href=&quot;#1-实验描述&quot; class=&quot;headerlink&quot; title=&quot;1.实验描述&quot;&gt;&lt;/a&gt;1.实验描述&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="网络安全" scheme="https://colalinn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="实验" scheme="https://colalinn.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="网络安全" scheme="https://colalinn.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="课程" scheme="https://colalinn.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2020-03-08-anki-1</title>
    <link href="https://colalinn.github.io/2020/03/08/2020-03-08-anki-1/"/>
    <id>https://colalinn.github.io/2020/03/08/2020-03-08-anki-1/</id>
    <published>2020-03-07T17:03:03.000Z</published>
    <updated>2020-03-07T17:30:45.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="anki卡片的难度划分"><a href="#anki卡片的难度划分" class="headerlink" title="anki卡片的难度划分"></a>anki卡片的难度划分</h1><p>生疏/错误 困难/模糊 犹豫/想起 顺利/正确</p><p>1、生疏/错误：这个是级别简单得说就是你一看到就知道自己没见过或者见过也忘了。<br>2、困难/模糊：这个是级别简单得说就是你用力想能记起来一点，但不完全。<br>3、犹豫/想起：这个是级别简单得说就是你仔细想，还是能够回忆出来。<br>4、顺利/正确：这个是级别简单得说就是没什么难度，基本熟悉了。<br>5、轻松/容易：这个是级别简单得说就是条件反射、一看便知。</p><p>在学习时Anki有一个按钮，如果记忆对象实在太简单了，你可以点击排除按钮将卡片排除在今后复习之外（你如果忍无可忍还可以删除该条）。实际上第5个级别只在学习新卡片时出现，所以常用的级别就是1-4。</p><p>生疏/错误选项，Anki认为是学习失败，失败的这张卡片在接下来几分钟或本次学习的末尾还会出现，失败次数达到某个值会变为记忆难点（决定于你的设置）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;anki卡片的难度划分&quot;&gt;&lt;a href=&quot;#anki卡片的难度划分&quot; class=&quot;headerlink&quot; title=&quot;anki卡片的难度划分&quot;&gt;&lt;/a&gt;anki卡片的难度划分&lt;/h1&gt;&lt;p&gt;生疏/错误 困难/模糊 犹豫/想起 顺利/正确&lt;/p&gt;
&lt;p&gt;1、生
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2020-03-07-beatuy-of-mathematics</title>
    <link href="https://colalinn.github.io/2020/03/07/2020-03-07-beatuy-of-mathematics/"/>
    <id>https://colalinn.github.io/2020/03/07/2020-03-07-beatuy-of-mathematics/</id>
    <published>2020-03-07T08:09:08.000Z</published>
    <updated>2020-03-07T13:41:20.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学之美"><a href="#数学之美" class="headerlink" title="数学之美"></a>数学之美</h1><p>《数学之美》是人民邮电出版社于2012年5月出版的图书，作者吴军，2014年再版。书中将高深的数学原理讲得更加通俗易懂，让非专业读者也能领略数学的魅力。通过具体实例教会读者在解决问题时如何化繁为简，如何用数学去解决工程问题，如何跳出固有思维不断去思考创新等。</p><h3 id="第九章-图论和网络爬虫"><a href="#第九章-图论和网络爬虫" class="headerlink" title="第九章 图论和网络爬虫"></a>第九章 图论和网络爬虫</h3><h4 id="图论定义"><a href="#图论定义" class="headerlink" title="图论定义"></a>图论定义</h4><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307165641288.png" alt="image-20200307165641288"></p><p>七桥问题：一个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。</p><p>后来大数学家欧拉把它转化成一个几何问题——一笔画问题。在解答问题的同时，开创了数学的一个新的分支——图论与几何拓扑，也由此展开了数学史上的新历程。</p><p>PS：连通图可以一笔画的充要条件是：奇点的数目不是0 个就是2 个。</p><h4 id="BFS广度优先遍历"><a href="#BFS广度优先遍历" class="headerlink" title="BFS广度优先遍历"></a>BFS广度优先遍历</h4><p>爬虫用到了图论的遍历（Traverse）算法</p><p>BFS广度优先遍历（Breadth-First Search）算法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 初始只有一个已有节点</span><br><span class="line">2. 遍历当前已有节点的邻接节点，加入已有节点</span><br><span class="line">3. 重复步骤（2）直到不再有新的已有节点</span><br></pre></td></tr></table></figure><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307162611791.png" alt="image-20200307162611791"></p><p>广度遍历的次序图（从北京开始）</p><h4 id="DFS深度优先遍历"><a href="#DFS深度优先遍历" class="headerlink" title="DFS深度优先遍历"></a>DFS深度优先遍历</h4><p>DFS深度优先遍历（Depth-First Search）算法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 初始只有一个未被标记节点</span><br><span class="line">2. 查找未标记的节点的邻接节点A，找到节点A被标记</span><br><span class="line">3. 进入该节点A第一个未标记的邻接节点B,将其设为A</span><br><span class="line">4. 回到2直到所有节点遍历完</span><br></pre></td></tr></table></figure><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307163047990.png" alt="image-20200307163047990"></p><p>深度遍历的次序图（从北京开始）</p><h4 id="网络爬虫-Web-Crawlers）定义"><a href="#网络爬虫-Web-Crawlers）定义" class="headerlink" title="网络爬虫(Web Crawlers）定义"></a>网络爬虫(Web Crawlers）定义</h4><ul><li>互联网-就是一张大<code>网</code>（图）</li><li>一个<code>网页</code>为一个<code>节点</code> node</li><li>网页中的<code>超链接</code>是一条<code>边</code> edge，连向其他<code>节点</code>（网页）</li><li>网络爬虫正是<code>遍历</code>（访问）这张网并且<code>下载网页</code>（获得信息）的程序</li><li>使用<code>哈希表</code>（Hash Table）来记录一个网页是否被访问</li><li>现在的Google等公司使用的爬虫程序都是<code>并行的</code>、<code>多设备</code>，需要好的<code>并行算法</code></li></ul><h4 id="搭建爬虫工程要点"><a href="#搭建爬虫工程要点" class="headerlink" title="搭建爬虫工程要点"></a>搭建爬虫工程要点</h4><ul><li>用什么<code>遍历</code>算法？</li><li>页面的分析和URL的提取？</li><li>URL记录表 <code>已遍历哈希表</code>的并行问题</li></ul><p>1.用什么遍历算法？</p><p>一般来说，为了快速遍历重要的网址（比如腾讯主页中URL），用<code>BFS</code></p><p>而为了减少目标服务器消耗（如TCP连接的握手次数过多，下载效率降低），用<code>DFS</code></p><p>但是一般都没这么简单，需要一个复杂的复杂的<code>调度系统</code>Scheduler，工程上使用<code>优先级队列</code>与<code>BFS</code>类似</p><p>2.页面的分析和URL的提取？</p><p>由于很多网页HTML都是用脚本语言<code>javascript</code>来生成的（或逻辑控制，数据嵌入），所以一个HTML中的URL并不是显而易见的，需要通过浏览器渲染（运行javascript），所以一个好的爬虫需要熟悉浏览器内核的人来编写。</p><p>3.URL记录表 <code>已遍历哈希表</code></p><p>由于一个URL可能被很多网页超链接。</p><p>如果爬虫足够大，爬取URL太多，那么在上千台服务器中，这个<code>遍历哈希表</code>就会变得相当大，维护很困难。这里的维护指的是哈希表的<code>同步</code>（避免重复下网页发生冲突）、<code>存储</code>（会大的一台服务器都存不下）</p><p>使用如下两种手段来控制</p><ul><li>明确分工、如指定某个域名由某台机器爬取</li><li>把哈希表存储在一组独立的服务器上</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307172007654.png" alt="image-20200307172007654"></p><h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>之前在数据结构、离散数学中都学过图论，但是当时都是学了一遍便忘了。</p><p>直到近期在做一个项目，设计到了图论的遍历、最短路径问题。</p><p>才知道图论是如此的有意思，而这次看爬虫也是图论，算是再复习下吧，数学不愧是万物之源啊。</p><h3 id="第十章-PageRank（网页排名）"><a href="#第十章-PageRank（网页排名）" class="headerlink" title="第十章 PageRank（网页排名）"></a>第十章 PageRank（网页排名）</h3><p>网页排名是对搜索结果的分析，使那些更具“重要性”的网页在搜索结果中的排名获得提升，从而提高搜索结果的相关性和质量。</p><h4 id="Google的page-rank"><a href="#Google的page-rank" class="headerlink" title="Google的page rank"></a>Google的page rank</h4><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个网页被其他网页所链接（投票），说明其受到了普遍的承认和信赖，那么此网页的Rank排名就高。</span><br></pre></td></tr></table></figure><h4 id="算法细化"><a href="#算法细化" class="headerlink" title="算法细化"></a>算法细化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对每个网页的 投票权重 做区分（就如股东大会的表决权）</span><br></pre></td></tr></table></figure><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307173646445.png" alt="image-20200307173646445"></p><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>将<code>Pagerank</code>用<strong>向量</strong>表示，并且用<strong>矩阵相乘</strong>的方法来<strong>迭代</strong>计算<code>Pagerank</code>。</p><p>初始的排名从哪来？全部设为1/n</p><p>（够暴力吧，理论证明，无论<strong>初值</strong>如何取，这种算法都能保证网页排名能收敛到<strong>真实值</strong>，无需人工干预）</p><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307183507652.png" alt="image-20200307183507652"></p><h4 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h4><p>矩阵过于大计算量大，使用<strong>稀疏矩阵</strong>的计算技巧。</p><h4 id="目前的发展"><a href="#目前的发展" class="headerlink" title="目前的发展"></a>目前的发展</h4><p>当今影响搜索引擎的质量的有如下几点：</p><ul><li><p>好的<strong>索引库</strong>，如果一个URL没被索引，它就不可能被查到。</p></li><li><p>网页的<strong>质量的度量</strong>，如pagerank。</p><p>目前的搜索引擎算法对网页质量的衡量复杂多了，是全方位的，质量的衡量以考用户点击等数据。</p><p>顺带一提：因为google拥有的庞大数据积累，使得后来的搜索引擎无法超过他。而当年google刚成立时，pagerank算法的专利保护很好的保护了它度过了前期的<strong>数据积累</strong>时期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据也是一种资本，这导致了，即使你现在做一个比百度还好的算法，却不可能替代它在国内的地位了。</span><br></pre></td></tr></table></figure></li><li><p><strong>用户偏好</strong>。用户的喜好不同推送不同的内容。</p><p>目前的B站、知乎、淘宝的推荐都是用机器学校来判断你的喜好类型。这里批评一下，目前的推荐都是单调（只有个人的喜好）、且更新过于恶心（新<code>类型</code>的权重会很大，导致下次刷新都是该类型）。</p></li><li><p>与用户搜索的相关性。如果是做个人站的搜索，用TF-IDF就可以满足要求，而大公司的相关性判断则复杂的多。</p><p><strong>TF-IDF</strong>（term frequency–inverse document frequency）是一种用于信息检索与数据挖掘的常用加权技术。<strong>TF</strong>意思是词频(Term Frequency)，<strong>IDF</strong>意思是逆文本频率指数(Inverse Document Frequency)。</p><p>一篇文章的相关性分数：TF*IDF。</p></li></ul><h3 id="第十八章-搜索引擎反作弊及搜索结果权威性"><a href="#第十八章-搜索引擎反作弊及搜索结果权威性" class="headerlink" title="第十八章 搜索引擎反作弊及搜索结果权威性"></a>第十八章 搜索引擎反作弊及搜索结果权威性</h3><h4 id="搜索引擎的反作弊"><a href="#搜索引擎的反作弊" class="headerlink" title="搜索引擎的反作弊"></a>搜索引擎的反作弊</h4><p>作弊<strong>SEO</strong>是伴随着搜索引擎排名产生的。搜索结果排名靠前的不一定是高质量的相关网站。</p><p>常见的<strong>作弊手段</strong>：针对<code>tf-idf</code>的<code>重复关键词</code>、针对<code>PageRank</code>的<code>链接站</code>（专业买卖链接URL）。</p><p>关于<strong>落地页</strong>（LandinPage），其内容质量高，但是里面暗藏js跳转，一进去就跳转到一个商业网站。</p><p><strong>反作弊的哲学</strong>：一般小的搜索引擎没有作弊不是因为他们反作弊很好，而是因为作弊商看不上这些小站。</p><h4 id="如何反作弊"><a href="#如何反作弊" class="headerlink" title="如何反作弊"></a>如何反作弊</h4><p>抓作弊成为了“<strong>猫捉老鼠</strong>”的游戏，没有一劳永逸的方法（信息安全也是如此）。</p><p>透过具体问题，看本质和动机，解决问题。反作弊也是如此，需要“道”。<strong>术即是表层，道即事物本质。</strong></p><p>而通信模型对于搜索反作弊依然适用。在通信中解决噪声干扰问题的基本思路有两条。</p><ul><li>从信息源出发，加强通信（编码）自身的抗干扰能力。</li><li>从传输来看，过滤掉噪声，还原信息。</li></ul><p>如下图，原始的信号混入噪声，在数学上表现为他们两个做了卷积，消除噪声的过程就是解卷积的过程。</p><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307184140323.png" alt="image-20200307184140323"></p><h4 id="反作弊中”道“的扩展"><a href="#反作弊中”道“的扩展" class="headerlink" title="反作弊中”道“的扩展"></a>反作弊中”道“的扩展</h4><p>一个判断<code>链接站</code>的思路：</p><p>将网站的出链（其指向的URL）作为一个向量，它是这个网站的固有特征。</p><p>而通过对两个网站的向量计算余弦距离，若两个网站的出链URL几乎相同，则其出链向量的余弦距离为几近于1。</p><p>另一个判断<code>链接站</code>的思路：</p><p>由于<code>链接站</code>普遍两两链接，所以使用<code>图论</code>来寻找这些互联网中的<code>闭环</code>，就可以找到<code>链接站</code>。</p><p>可以看到，这两个思路都用到了数学，赞美数学！</p><h4 id="搜索结果的权威性"><a href="#搜索结果的权威性" class="headerlink" title="搜索结果的权威性"></a>搜索结果的权威性</h4><p>权威性：例如医疗方面的问题，需要判断搜索结果是否完全可信，这就是权威性的判断。</p><p>如何判断权威性呢？</p><p>一个概念 “<strong>提及</strong>”（Mention）。</p><p>如果一个主题中的信息页中，有某个机构普遍、多次被“<strong>提及</strong>”，那就有理由判断其是权威的。</p><p>计算权威有两个难点：</p><ul><li>“<strong>提及</strong>”需要<strong>自然语言处理</strong>NLP（natural language processing），得知文本内容的意思。</li><li>权威是与领域相关的，一个机构在医学领域是权威的，但其在其他领域不一定相关。</li></ul><h4 id="权威性计算"><a href="#权威性计算" class="headerlink" title="权威性计算"></a>权威性计算</h4><ol><li><code>句法分析</code>，寻找涉及主题短语、对信息源的描述。</li><li>利用<code>互信息</code>，寻找道主题短语和信息源的相关性。</li><li>对主题短语进行<code>聚类</code>，这里需要用到NLP，比如”吸烟的危害“和”香烟的危害“是相同的。</li><li>一个网站也要分成不同的领域来判断。</li></ol><p>（句法分析、互信息、聚类后面都是数学!）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然先前都有了学习，但是看了这几章，还是不得不赞叹数学、信息论的力量。</p><p>从网络爬虫中的图论知识，到PageRank中的矩阵运算，TF-IDF、反作弊中余弦、闭环的巧妙运用等等。</p><p>都是数学的应用体现，<del>麻麻再也不担心我讨厌数学了</del>。</p><p>收获还是有的吧，爬虫和pagerank课上都学过了，这里权当复习了。</p><p>而互联网为啥叫网，我终于清晰的了解了。反作弊我还是第一次学习到，很有趣。</p><p>在互联网时代，学这些是有好处的，毕竟网络已经无处不在，学这些有利于“生存”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学之美&quot;&gt;&lt;a href=&quot;#数学之美&quot; class=&quot;headerlink&quot; title=&quot;数学之美&quot;&gt;&lt;/a&gt;数学之美&lt;/h1&gt;&lt;p&gt;《数学之美》是人民邮电出版社于2012年5月出版的图书，作者吴军，2014年再版。书中将高深的数学原理讲得更加通俗易懂，让非
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://colalinn.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://colalinn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="爬虫" scheme="https://colalinn.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>2020-03-06-algorithm-2</title>
    <link href="https://colalinn.github.io/2020/03/06/2020-03-06-algorithm-2/"/>
    <id>https://colalinn.github.io/2020/03/06/2020-03-06-algorithm-2/</id>
    <published>2020-03-06T06:29:50.000Z</published>
    <updated>2020-03-06T08:20:22.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>定义：堆是一个完全的二叉树，每个节点都满足（任一父节点的键值都不小于子节点的键值）</p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143043099.png" alt="image-20200306143043099"></p><p>非升序排列的二叉树</p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143353432.png" alt="image-20200306143353432"></p><p>存储的方式</p><ul><li>根节点存在H[1]</li><li>节点H[i]左右子节点存在H[2i]、H[2i+1]</li><li>节点H[j]父节点为</li></ul><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143720731.png" alt="image-20200306143720731"></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h3><ul><li><p>make-heap   nlog(n) 即</p><p>insert</p><p>shift-down</p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306151812583.png" alt="image-20200306151812583"></p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306152913995.png" alt="image-20200306152913995"></p></li><li><p>insert(H,x)   插入所需时间为O(logn)树的高度</p></li><li><p>delete(H,i)</p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306145933371.png" alt="image-20200306145933371"></p></li><li><p>delete-max(H)</p></li></ul><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143909302.png" alt="image-20200306143909302"></p><h3 id="辅助运算"><a href="#辅助运算" class="headerlink" title="辅助运算"></a>辅助运算</h3><ul><li>Shift-up</li><li>Shift-down</li><li></li></ul><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306144102573.png" alt="image-20200306144102573"></p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306144632289.png" alt="image-20200306144632289"></p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306145341282.png" alt="image-20200306145341282"></p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306145535439.png" alt="image-20200306145535439"></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306153013519.png" alt="image-20200306153013519"></p><ul><li>创建最大堆</li><li>把根节点与最后一个节点交换</li><li>再创建最大堆</li><li>再交换</li></ul><h2 id="不相交集-Disjoint-Sets"><a href="#不相交集-Disjoint-Sets" class="headerlink" title="不相交集(Disjoint Sets)"></a>不相交集(Disjoint Sets)</h2><h3 id><a href="#" class="headerlink" title></a></h3><ul><li>每个元素不相同</li><li>可以用树表示</li></ul><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306155841259.png" alt="image-20200306155841259"></p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306160011900.png" alt="image-20200306160011900"></p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306160421170.png" alt="image-20200306160421170"></p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306161050838.png" alt="image-20200306161050838"></p><p>路径压缩师，秩不会变</p><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306162018074.png" alt="image-20200306162018074"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h2&gt;&lt;p&gt;定义：堆是一个完全的二叉树，每个节点都满足（任一父节点的键值都不小于子节点的键值）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/03/06/202
      
    
    </summary>
    
    
      <category term="算法_algorithm" scheme="https://colalinn.github.io/categories/%E7%AE%97%E6%B3%95-algorithm/"/>
    
    
      <category term="算法" scheme="https://colalinn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java笔记2-spring</title>
    <link href="https://colalinn.github.io/2020/03/03/2020-03-03-JAVA-complement-2/"/>
    <id>https://colalinn.github.io/2020/03/03/2020-03-03-JAVA-complement-2/</id>
    <published>2020-03-03T15:18:15.000Z</published>
    <updated>2020-03-05T13:20:33.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-EE"><a href="#JAVA-EE" class="headerlink" title="JAVA EE"></a>JAVA EE</h1><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>上手参考：<a href="https://www.zybuluo.com/wuxin1994/note/1430332" target="_blank" rel="noopener">https://www.zybuluo.com/wuxin1994/note/1430332</a></p><p> <strong>DAO: Data Access Object 数据访问对象</strong></p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>(1).隔离业务逻辑代码和数据访问代码,位于业务逻辑和持久化数据之间，实现对持久化数据的访问。<br>(2).隔离不同数据库的实现。</p><h3 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h3><p>(1).DAO接口<br>(2).DAO实现类<br>(3).实体类<br>(4).数据库连接和关闭工具类</p><h3 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h3><p>(1).DAO接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;public interface DAO &#123;    void findeAll();&#125;</span><br></pre></td></tr></table></figure><p>(2).DAO实现类(实体类略去)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: wufan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UerDao implements DAO &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void findeAll() &#123;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        Statement st &#x3D; null;</span><br><span class="line">        ResultSet rs &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1. 获取连接对象</span><br><span class="line">            conn &#x3D; JDBCUtil.getConnection();</span><br><span class="line">            &#x2F;&#x2F;2. 创建statement对象</span><br><span class="line">            st &#x3D; conn.createStatement();</span><br><span class="line">            String sql &#x3D; &quot;select * from user&quot;;</span><br><span class="line">            rs &#x3D; st.executeQuery(sql);</span><br><span class="line">            while(rs.next())&#123;</span><br><span class="line">                String phone &#x3D; rs.getString(&quot;phone&quot;);</span><br><span class="line">                int id &#x3D; rs.getInt(&quot;uid&quot;);</span><br><span class="line">                System.out.print(id+&quot;\t&quot;+phone);</span><br><span class="line">                System.out.println(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            JDBCUtil.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UerDao ud &#x3D; new UerDao();</span><br><span class="line">        ud.findeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4).数据库连接和关闭工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: wufan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JDBCUtil &#123;</span><br><span class="line">    private static String driverClass;</span><br><span class="line">    private static String url;</span><br><span class="line">    private static String username;</span><br><span class="line">    private static String password;</span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Properties properties &#x3D; new Properties();</span><br><span class="line">            &#x2F;&#x2F;InputStream is &#x3D; JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;JDBC.properties&quot;);</span><br><span class="line">            InputStream is &#x3D; new FileInputStream(&quot;P:\\Java\\Database\\src\\JDBC.properties&quot;); &#x2F;&#x2F;对应文件位于工程根目录</span><br><span class="line">            properties.load(is);</span><br><span class="line">            driverClass &#x3D; properties.getProperty(&quot;driverClass&quot;);</span><br><span class="line">            url &#x3D; properties.getProperty(&quot;url&quot;);</span><br><span class="line">            username &#x3D; properties.getProperty(&quot;username&quot;);</span><br><span class="line">            password &#x3D; properties.getProperty(&quot;password&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取连接</span><br><span class="line">    public static Connection getConnection() &#123;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">            conn &#x3D; DriverManager.getConnection(url, username, password);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;释放资源</span><br><span class="line">    public static void release(Connection conn, Statement pstmt, ResultSet rs) &#123;</span><br><span class="line">        if (rs !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pstmt !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                pstmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (conn !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="spring上手"><a href="#spring上手" class="headerlink" title="spring上手"></a>spring上手</h1><h2 id="挖坑中…-新的坑，新的挑战"><a href="#挖坑中…-新的坑，新的挑战" class="headerlink" title="# 挖坑中….新的坑，新的挑战"></a># 挖坑中….新的坑，新的挑战</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA-EE&quot;&gt;&lt;a href=&quot;#JAVA-EE&quot; class=&quot;headerlink&quot; title=&quot;JAVA EE&quot;&gt;&lt;/a&gt;JAVA EE&lt;/h1&gt;&lt;h2 id=&quot;JDBC&quot;&gt;&lt;a href=&quot;#JDBC&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="java" scheme="https://colalinn.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://colalinn.github.io/tags/java/"/>
    
      <category term="spring" scheme="https://colalinn.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>2020-03-02-Software-security-notebook(1)</title>
    <link href="https://colalinn.github.io/2020/03/02/2020-03-02-Software-security-notebook-1/"/>
    <id>https://colalinn.github.io/2020/03/02/2020-03-02-Software-security-notebook-1/</id>
    <published>2020-03-02T15:46:59.000Z</published>
    <updated>2020-03-03T12:38:06.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="a"><a href="#a" class="headerlink" title="a)"></a>a)</h3><p>Q：恶意软件如何在系统重启、系统重装、以及硬盘更换之后继续获得控制权？</p><p>A：</p><ul><li>重启：BIOS、MBR、DBR、NTLDR、自启动项（文件病毒）。</li><li>重装：BIOS、MBR。</li><li>硬盘更换：BIOS引导。</li></ul><h3 id="b"><a href="#b" class="headerlink" title="b)"></a>b)</h3><p>Q：给出在系统重启时恶意软件可以获得控制权的至少5种启动方式（并实践）。哪些方式不需要系统管理员权限？</p><p>A：Bios、MBR、DBR、NTLDR、自启动项。</p><h3 id="c"><a href="#c" class="headerlink" title="c)"></a>c)</h3><p>Q：每个进程可用4GB内存空间，但有的电脑内存才2G！系统如何做到的？</p><p>A：虚拟地址转换物理地址</p><h3 id="d"><a href="#d" class="headerlink" title="d)"></a>d)</h3><p>Q：两个进程的可执行程序映像加载地址都是00400000H，但同一地址对应的数据却不一样，为什么？</p><p>A：因为是虚拟地址转换成物c理地址，他们的00400000H转换成的物理地址都</p><p>不一样（cr3、页目录不一样）</p><h3 id="e"><a href="#e" class="headerlink" title="e)"></a>e)</h3><p>Q：PAE模式下，虚拟地址依然只有32位地址，为何可以寻址64G范围内的物理内存?</p><ul><li>i.内存管理：物理地址扩展（PAE）分页机制<a href="https://blog.csdn.net/trochiluses/article/details/12853027" target="_blank" rel="noopener">https://blog.csdn.net/trochiluses/article/details/12853027</a></li><li>ii.PAE分页模式详解：<a href="https://www.cnblogs.com/ck1020/p/6078214.html" target="_blank" rel="noopener">https://www.cnblogs.com/ck1020/p/6078214.html</a> </li></ul><p>A：分页的方式不同，PAE下，使用32位（2+9+9+12+4个内存目录项）。</p><h3 id="f"><a href="#f" class="headerlink" title="f)"></a>f)</h3><p>Q：如果硬盘分区表被完全破坏，如何重构分区表？</p><p>A：根据FAT表，以及数据的分布。</p><h3 id="g"><a href="#g" class="headerlink" title="g)"></a>g)</h3><p>Q：FAT32系统下文件被删除时，系统具体做了哪些修改？</p><p>A：（1）回收箱，文件名首字节变为E5<br>        （2）shift+deltete，文件首字节E5，FAT簇号高位归零，FAT簇链归零</p><h3 id="h"><a href="#h" class="headerlink" title="h)"></a>h)</h3><p>Q：数据擦写（安全删除）的原理什么？</p><p>A：由于磁盘可以重复使用，前面的数据被后面的数据覆盖后，前面的数据被还原的可能性就大大降低了，随着被</p><p>覆盖次数的增多，能够被还原的可能性就趋于 0，但相应的时间支出也就越多。密级要求的高低对应着不同的标</p><p>准，低密级要求的就是一次性将磁盘全部覆盖；高密级要求则须进行多次多规则覆盖。覆盖是指使用预先定义的格</p><p>式——无意义、无规律的信息来覆盖硬盘上原先存储的数据。</p><h3 id="i"><a href="#i" class="headerlink" title="i)"></a>i)</h3><p>Q：在使用数据恢复软件时，为什么标准格式文件（如doc、jpg等）比非格式文件更容易被恢复？</p><p>A：应该是，标准文件每部分都有固定的格式，可以方便恢复簇</p><h3 id="j"><a href="#j" class="headerlink" title="j)"></a>j)</h3><p>Q：在进行数据恢复时，为何有时候恢复出来的大文件只有前半部分是正确的？</p><p>A：因为簇链不连续。</p><h3 id="k"><a href="#k" class="headerlink" title="k)"></a>k)</h3><p>Q：恶意代码一定要在文件系统中以文件的方式出现么？它还可以隐藏在哪些区域以躲避被发现和查杀？</p><p>A：不一定以文件形式存在。可以隐藏在MBR、bios这些之中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思考题&quot;&gt;&lt;a href=&quot;#思考题&quot; class=&quot;headerlink&quot; title=&quot;思考题&quot;&gt;&lt;/a&gt;思考题&lt;/h1&gt;&lt;h3 id=&quot;a&quot;&gt;&lt;a href=&quot;#a&quot; class=&quot;headerlink&quot; title=&quot;a)&quot;&gt;&lt;/a&gt;a)&lt;/h3&gt;&lt;p&gt;Q
      
    
    </summary>
    
    
      <category term="信安" scheme="https://colalinn.github.io/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="笔记" scheme="https://colalinn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2020-02-28-algorithm-class</title>
    <link href="https://colalinn.github.io/2020/02/28/2020-02-28-algorithm-class/"/>
    <id>https://colalinn.github.io/2020/02/28/2020-02-28-algorithm-class/</id>
    <published>2020-02-28T09:12:19.000Z</published>
    <updated>2020-03-06T08:45:44.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200228174457509.png" alt></p><a id="more"></a><h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h3 id="算法是啥？"><a href="#算法是啥？" class="headerlink" title="算法是啥？"></a>算法是啥？</h3><ol><li><p>为解决某一问题定义的计算过程。</p></li><li><p>是通过一个有限的指令序列集合对特定问题进行求解的一种计算执行描述。</p></li></ol><h3 id="算法的性质"><a href="#算法的性质" class="headerlink" title="算法的性质"></a>算法的性质</h3><ul><li><p>可行性：可通过基本运算有限次执行来实现。</p></li><li><p>有穷性：算法的运行步数是有穷（即能运行完出结果的算法，运行不完没有结果有你有何用）</p></li><li><p>确定性：无二义性。</p></li><li><p>有输入输出：存在数据处理</p></li></ul><h3 id="程序与算法的区别"><a href="#程序与算法的区别" class="headerlink" title="程序与算法的区别"></a>程序与算法的区别</h3><p>算法的概念与程序十分相似,但实际上有很大不同。程序并不都满足算法所要求的上述特征, 例如有限性特征。算法代表了对特定问题的求 解,而程序则是算法在计算机上的实现。</p><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><ul><li>O；f/g=/=∞</li><li></li><li></li></ul><p>举例</p><p>二分搜索复杂度为：O(logn)</p><p>合并两已排序表：O(n)  n/2-&gt;n-1</p><p>选择排序：O(n^2)        n(n-1)/2</p><p>插入排序：O(n^2)       最好n-1次，最坏n(n-1)/2</p><p>合并排序算法：O(nlogn)</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306125945288.png" alt="image-20200306125945288"></p><h4 id="（1）O符号-上界"><a href="#（1）O符号-上界" class="headerlink" title="（1）O符号-上界"></a>（1）O符号-上界</h4><p>G越小越好</p><p>假设： f (n) 和g(n) 是从<strong>自然数集到非负实数集</strong>里的两个函数</p><p>定义1 (O)：如果存在正的常数C和自然数n0，使得当n≥n0时， 有f(n)≤C·g(n)，则称函数f (n) 在n 充分大</p><p>时有上有界，且g(n) 是它的一个上界，记做f (n) = O(g(n))</p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130222135.png" alt="image-20200306130222135"></p><h4 id="（2）Ω符号-下界"><a href="#（2）Ω符号-下界" class="headerlink" title="（2）Ω符号-下界"></a>（2）Ω符号-下界</h4><p>G越小大越好</p><p>定义2(Ω)： 如果存在正的常数C 和自然数n0 ， 使得当n ≥ n0时， 有f(n)≥C·g(n)，则称函数f (n) 在n 充分大时有下有界，且g(n) 是它的一个下界，记做f (n) = Ω(g(n))</p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130400180.png" alt="image-20200306130400180"></p><h4 id="（3）Θ符号-渐进紧确界"><a href="#（3）Θ符号-渐进紧确界" class="headerlink" title="（3）Θ符号-渐进紧确界"></a>（3）Θ符号-渐进紧确界</h4><p>最棒的表述，比O，Ω好</p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130554033.png" alt="image-20200306130554033"></p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130607267.png" alt="image-20200306130607267"></p><h4 id="（4）o符号"><a href="#（4）o符号" class="headerlink" title="（4）o符号"></a>（4）o符号</h4><p>与大O符号类似，但是大O符号对于某个大于零的常量c成立，而小o符号则对所有常量c&gt;0成立</p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130832478.png" alt="image-20200306130832478"></p><h4 id="（5）性质"><a href="#（5）性质" class="headerlink" title="（5）性质"></a>（5）性质</h4><p>传递性：f&lt;g&lt;h；自反性：f=f；对称性：Θ相同；转置对称：f&lt;g==g&gt;f</p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130920867.png" alt="image-20200306130920867"></p><h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>就是说不能说至少</p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306131333799.png" alt="image-20200306131333799"></p><h2 id="估计算法时间复杂度"><a href="#估计算法时间复杂度" class="headerlink" title="估计算法时间复杂度"></a>估计算法时间复杂度</h2><ul><li>估计迭代次数</li><li>频度分析</li><li>使用递归方程</li></ul><h2 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h2><ul><li>数学基础</li><li>证明方法<ul><li>直接证明、间接证明</li><li>反证法</li><li>数学归纳法</li></ul></li><li>递归方程求解（*）</li><li>Master定理（*）</li><li>基本数据结构</li></ul><h3 id="（1）证明方法"><a href="#（1）证明方法" class="headerlink" title="（1）证明方法"></a>（1）证明方法</h3><h4 id="反证法"><a href="#反证法" class="headerlink" title="反证法"></a>反证法</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306131942409.png" alt="image-20200306131942409"></p><h4 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306131921482.png" alt="image-20200306131921482"></p><h3 id="（2）递归方程求解"><a href="#（2）递归方程求解" class="headerlink" title="（2）递归方程求解"></a>（2）递归方程求解</h3><h4 id="常系数递归方程求解"><a href="#常系数递归方程求解" class="headerlink" title="常系数递归方程求解"></a>常系数递归方程求解</h4><p>T有n个就是n-1阶</p><p>T(n)=T(n-1)+T(n-2)有2阶</p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132041333.png" alt="image-20200306132041333"></p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132117637.png" alt="image-20200306132117637"></p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><ol><li>先弄出二阶方程、算出两个根</li><li>选择T（n）的<strong>表示法</strong></li><li>根据题目给的两个T（n）的值计算C1、C2</li><li>最后代入（2）算出T（n）的<strong>表达式</strong>\即时间复杂度</li></ol><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132456701.png" alt="image-20200306132456701"></p><h3 id="（3）Master定理"><a href="#（3）Master定理" class="headerlink" title="（3）Master定理"></a>（3）Master定理</h3><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132705476.png" alt="image-20200306132705476"></p><h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132740874.png" alt="image-20200306132740874"></p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132820314.png" alt="image-20200306132820314"></p><p>3/4*Log(n/4)&lt;c *log(n)（c&lt;1，随便取）</p><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306134213863.png" alt="image-20200306134213863"></p><p>S(n)=O(n^(1/2-E))    E&gt;0  E取0到1/2</p><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306134353096.png" alt="image-20200306134353096"></p><p>S(n)=欧米伽(n^(1/2+E))    E&gt;0   E取0到1/2</p><p>2*n/4&lt; c *n   c&lt;1   取1/2&lt;c&lt;1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/02/28/2020-02-28-algorithm-class/image-20200228174457509.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://colalinn.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="-算法" scheme="https://colalinn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 补全笔记(1)</title>
    <link href="https://colalinn.github.io/2020/02/26/2020-02-26-JAVA-complement-1/"/>
    <id>https://colalinn.github.io/2020/02/26/2020-02-26-JAVA-complement-1/</id>
    <published>2020-02-26T15:52:09.000Z</published>
    <updated>2020-03-04T13:28:42.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这系列文章会讲什么？"><a href="#这系列文章会讲什么？" class="headerlink" title="这系列文章会讲什么？"></a>这系列文章会讲什么？</h1><p>首先，我打算将java作为我的主语言去学。</p><p>之前确实是看过书<code>java核心技术</code>，但是也没细细阅览，有些不用基本都忘了。</p><p>所以吧，我将渐渐的补全java所涉及的知识，<del>绝不咕咕</del></p><p>首先声明，这篇文章绝大部分只是我 <code>个人</code> 的java知识点收集笔记。</p><p>并不是从入门到大佬的内容，水平有限，难免有错。</p><p>参考：<a href="https://dunwu.github.io/java-tutorial/#javacore" target="_blank" rel="noopener">https://dunwu.github.io/java-tutorial/#javacore</a></p><h1 id="java、jvm、jdk、jre、java-EE是什么？"><a href="#java、jvm、jdk、jre、java-EE是什么？" class="headerlink" title="java、jvm、jdk、jre、java EE是什么？"></a>java、jvm、jdk、jre、java EE是什么？</h1><p>这些名词也许会让初学的你感到十分疑惑，希望我能让你明白。</p><p><strong>Java</strong> 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。</p><p>Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。</p><p><strong>jvm</strong>  即Java Virtual Machine（java虚拟机），由于jvm的特性，java可以一处编译处处运行。（但是win下写的</p><p>java并不能在android上运行，这是因为android的jvm与java的jvm不一样。）</p><p><strong>jdk</strong> 即Java Development Kit（java软件开发工具包），用于编译Java程序（指java源码.java文件），jdk中也包含</p><p>了jre用于运行Java程序（指class或jar或其它归档文件）。</p><p><strong>jre</strong>  即Java Runtime Environment（java运行环境），JRE的内部有一个Java虚拟机（Java Virtual Machine，</p><p>JVM）以及一些标准的类别函数库（Class Library）。</p><p><strong>jdk的版本:SE、EE、ME</strong> </p><p>SE(JavaSE)，standard edition，标准版，是我们通常用的一个版本，从JDK 5.0开始，改名为Java SE。</p><p>EE(JavaEE)，enterprise edition，企业版，使用这种JDK开发J2EE应用程序，从JDK 5.0开始，改名为Java EE。</p><p>ME(J2ME)，micro edition，主要用于移动设备、嵌入式设备上的java应用程序，从JDK 5.0开始，改名为Java ME。</p><h1 id="java知识的体系结构"><a href="#java知识的体系结构" class="headerlink" title="java知识的体系结构"></a>java知识的体系结构</h1><p>这里放一个比较好的汇总贴（墙裂建议阅读）</p><p><a href="https://dunwu.github.io/java-tutorial/#javacore" target="_blank" rel="noopener">https://dunwu.github.io/java-tutorial/#javacore</a></p><h1 id="java-serlvet-jsp-tomcat"><a href="#java-serlvet-jsp-tomcat" class="headerlink" title="java serlvet\jsp\tomcat"></a>java serlvet\jsp\tomcat</h1><h3 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h3><p>Servlet（Server Applet），即小服务程序或服务连接器。Servlet 是 Java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 Web 内容。</p><ul><li>狭义的 Servlet 是指 Java 实现的一个接口。</li><li>广义的 Servlet 是指任何实现了这个 Servlet 接口的类。</li></ul><p>Servlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。</p><h3 id="Servlet-任务"><a href="#Servlet-任务" class="headerlink" title="Servlet 任务"></a>Servlet 任务</h3><p>Servlet 执行以下主要任务：</p><ul><li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li><li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li><li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li><li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li><li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li></ul><h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="#Servlet 生命周期"></a><a href="https://dunwu.github.io/java-tutorial/javaee/javaee-servlet.html#servlet-生命周期" target="_blank" rel="noopener">#</a>Servlet 生命周期</h3><p><img src="http://www.runoob.com/wp-content/uploads/2014/07/Servlet-LifeCycle.jpg" alt="img"></p><p>Servlet 生命周期如下：</p><ol><li><strong>加载</strong> - 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。容器通过类加载器使用 Servlet 类对应的文件加载 servlet；</li><li><strong>初始化</strong> - Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。</li><li><strong>服务</strong> - Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li><strong>销毁</strong> - Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。</li><li><strong>卸载</strong> - Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ol><h3 id="Servlet-包"><a href="#Servlet-包" class="headerlink" title="Servlet 包"></a>Servlet 包</h3><p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。</p><p>Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。</p><p>Java Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。</p><h3 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h3><h4 id="init-方法"><a href="#init-方法" class="headerlink" title="init() 方法"></a>init() 方法</h4><p>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。</p><p>Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。</p><p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</p><p>init 方法的定义如下：i</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service-方法"><a href="#service-方法" class="headerlink" title="service() 方法"></a>service() 方法</h4><p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p><p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p><p>下面是该方法的特征：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ServletResponse response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。</p><p>doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。</p><h4 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet() 方法"></a>doGet() 方法</h4><p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                  HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doPost-方法"><a href="#doPost-方法" class="headerlink" title="doPost() 方法"></a>doPost() 方法</h4><p>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                   HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法destroy-方法"><a href="#方法destroy-方法" class="headerlink" title="方法destroy() 方法"></a>方法destroy() 方法</h4><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。</p><p>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 终止化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://dunwu.github.io/java-tutorial/javaee/javaee-servlet.html#servlet-简介" target="_blank" rel="noopener">java-servelt</a></p><h1 id="java-基础"><a href="#java-基础" class="headerlink" title="java 基础"></a>java 基础</h1><h3 id="Java中只有值传递"><a href="#Java中只有值传递" class="headerlink" title="Java中只有值传递"></a>Java中只有值传递</h3><ul><li>对于基本类型,直接拷贝值传递过去</li><li>对于对象,拷贝当前对象的引用地址,然后把该地址传递过去,所以也是值传递</li></ul><p>参考：图解Java中的参数传递  <a href="https://zhuanlan.zhihu.com/p/24556934?refer=dreawer" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24556934?refer=dreawer</a></p><h3 id="holder实现”传址“"><a href="#holder实现”传址“" class="headerlink" title="holder实现”传址“"></a>holder实现”传址“</h3><p>用于使传入方法后值改变可被保存</p><p>源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Copyright (c) 2005, 2010, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line"> * ORACLE PROPRIETARY&#x2F;CONFIDENTIAL. Use is subject to license terms.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">package javax.xml.ws;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Holds a value of type &lt;code&gt;T&lt;&#x2F;code&gt;.</span><br><span class="line"> *</span><br><span class="line"> * @since JAX-WS 2.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final class Holder&lt;T&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 2623699057546497185L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The value contained in the holder.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public T value;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates a new holder with a &lt;code&gt;null&lt;&#x2F;code&gt; value.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Holder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create a new holder with the specified value.</span><br><span class="line">     *</span><br><span class="line">     * @param value The value to be stored in the holder.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Holder(T value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：Java基础系列18：Holder技术的实现原理分析  <a href="https://www.zifangsky.cn/734.html" target="_blank" rel="noopener">https://www.zifangsky.cn/734.html</a></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在当时学方法的时候，可把我弄晕了，不过这是很基础的，必须要弄懂。</p><p>参考：<a href="https://dunwu.github.io/javacore/basics/java-method.html#default" target="_blank" rel="noopener">深入理解java方法</a></p><h5 id="1-访问控制符"><a href="#1-访问控制符" class="headerlink" title="1.访问控制符"></a>1.访问控制符</h5><p>访问权限控制的等级，从最大权限到最小权限依次为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &gt; protected &gt; 包访问权限（没有任何关键字）&gt; private</span><br></pre></td></tr></table></figure><ul><li><code>public</code> - 表示任何类都可以访问；</li><li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li><li><code>protected</code> - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。</li><li><code>private</code> - 表示其它任何类都无法访问。</li></ul><h5 id="2-各种方法"><a href="#2-各种方法" class="headerlink" title="2.各种方法"></a>2.各种方法</h5><p>一览：<code>staic</code>  <code>final</code>   <code>default</code>  <code>abstract</code>  <code>synchronized</code>  <code>main</code>  <del>finalize()</del></p><h6 id="1-static"><a href="#1-static" class="headerlink" title="(1)static"></a><strong>(1)static</strong></h6><p><strong>被 <code>static</code> 修饰的方法被称为静态方法。</strong></p><p>静态方法相比于普通的实例方法，主要有以下区别：</p><ul><li>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象名.方法名</code> 的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</li><li><strong>静态方法在访问本类的成员时，只允许访问静态成员</strong>（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li></ul><h6 id="2-final"><a href="#2-final" class="headerlink" title="(2)final"></a><strong>(2)final</strong></h6><ul><li>被 <code>final</code> 修饰的方法不能被子类覆写（Override）。</li></ul><h6 id="3-default"><a href="#3-default" class="headerlink" title="(3)default"></a><strong>(3)default</strong></h6><ul><li><p><code>default</code> 方法只能出现在接口 <code>Interface</code> 中。</p><p>（JDK8 开始，支持在接口 <code>Interface</code> 中定义 <code>default</code> 方法。）</p></li><li><p>接口中被 <code>default</code> 修饰的方法被称为<strong>默认方法</strong>，实现此接口的类如果没 Override 此方法，则直接继承这个方法，不再强制必须实现此方法。</p></li></ul><h6 id="4-abstract"><a href="#4-abstract" class="headerlink" title="(4)abstract"></a><strong>(4)abstract</strong></h6><p>被 <code>abstract</code> 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。</p><h6 id="5-synchronized"><a href="#5-synchronized" class="headerlink" title="(5)synchronized"></a><strong>(5)synchronized</strong></h6><ul><li><p><code>synchronized</code> 用于并发编程。被 <code>synchronized</code> 修饰的方法在一个时刻，只允许一个线程执行。</p></li><li><p>在 Java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。</p></li></ul><h6 id="6-main-方法"><a href="#6-main-方法" class="headerlink" title="(6)main 方法"></a>(6)main 方法</h6><p>Java 中的 main 方法是一种特殊的静态方法，因为所有的 Java 程序都是由 <code>public static void main(String[] args)</code> 方法开始执行。</p><p>有很多新手虽然一直用 main 方法，却不知道 main 方法中的 args 有什么用。实际上，这是用来接收<strong>接收命令行输入参数</strong>的。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arg = ["</span> + arg + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次执行（直接在类名后面空格隔开输入参数即可，也是多个元素<strong>用空格分割</strong>，加不加双引号都可以）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac MainMethodDemo.java</span><br><span class="line">java MainMethodDemo A B C</span><br></pre></td></tr></table></figure><p>控制台会打印输出参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arg &#x3D; [A]</span><br><span class="line">arg &#x3D; [B]</span><br><span class="line">arg &#x3D; [C]</span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="1-异常基本概念"><a href="#1-异常基本概念" class="headerlink" title="1.异常基本概念"></a>1.异常基本概念</h4><h5 id="Throwable（异常超类）"><a href="#Throwable（异常超类）" class="headerlink" title="Throwable（异常超类）"></a>Throwable（异常超类）</h5><p><code>Throwable</code> 包含了其线程创建时线程执行堆栈的快照，它提供了 <code>printStackTrace()</code> 等接口用于获取堆栈跟踪数据等信息。</p><h5 id="Error（Throwable子类）"><a href="#Error（Throwable子类）" class="headerlink" title="Error（Throwable子类）"></a>Error（Throwable子类）</h5><p><code>Error</code> 是 <code>Throwable</code> 的一个子类。<strong><code>Error</code> 表示合理的应用程序不应该尝试捕获的严重问题</strong>。大多数此类错误都是异常情况。<strong>编译器不会检查 <code>Error</code></strong>。</p><h5 id="Exception（Throwable子类）"><a href="#Exception（Throwable子类）" class="headerlink" title="Exception（Throwable子类）"></a>Exception（Throwable子类）</h5><p><code>Exception</code> 是 <code>Throwable</code> 的一个子类。<strong><code>Exception</code> 表示合理的应用程序可能想要捕获的条件。</strong></p><p>编译器会检查 <code>Exception</code> 异常。此类异常，要么通过 <code>throws</code> 进行声明抛出，要么通过 <code>try catch</code> 进行捕获处理，否则不能通过编译。</p><h5 id="RuntimeException（Exception子类）"><a href="#RuntimeException（Exception子类）" class="headerlink" title="RuntimeException（Exception子类）"></a>RuntimeException（Exception子类）</h5><p><code>RuntimeException</code> 是 <code>Exception</code> 的一个子类。<code>RuntimeException</code> 是那些可能在 Java <strong>虚拟机正常运行期间</strong>抛出的异常的超类。</p><p>编译器不会检查 <code>RuntimeException</code> 异常。当程序中可能出现这类异常时，倘若既没有通过 <code>throws</code> 声明抛出它，也没有用 <code>try catch</code> 语句捕获它，程序还是会编译通过。</p><h4 id="2-捕获异常-gt-处理"><a href="#2-捕获异常-gt-处理" class="headerlink" title="2.捕获异常-&gt;处理"></a>2.捕获异常-&gt;处理</h4><p><strong>使用 try 和 catch 关键字可以捕获异常</strong>。try catch 代码块放在异常可能发生的地方。</p><p>它的语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型Exception</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception2 e2) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型Exception2</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都将执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>try</code> - <strong><code>try</code> 语句用于监听。将要被监听的代码(可能抛出异常的代码)放在 <code>try</code> 语句块之内，当 <code>try</code> 语句块内发生异常时，异常就被抛出。</strong></p></li><li><p><code>catch</code> - <code>catch</code> 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，<code>try</code> 后面的 <code>catch</code> 块就会被检查。</p></li><li><p><code>finally</code> - <strong><code>finally</code> 语句块总是会被执行，无论是否出现异常。</strong></p><ul><li><code>finally</code> 中的 <code>return</code> 会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句，所以 Java <strong>不建议在 <code>finally</code> 中使用 <code>return</code> 语句</strong>。</li><li>此外 <code>finally</code> 中的 <code>throw</code> 语句也会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句。</li></ul></li></ul><h4 id="3-抛出异常throw-s"><a href="#3-抛出异常throw-s" class="headerlink" title="3.抛出异常throw(s)"></a>3.抛出异常throw(s)</h4><p>如果想在程序中明确地抛出异常，需要用到 <code>throw</code> 和 <code>throws</code> 。</p><p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 <code>throws</code> 关键字来声明。<code>throws</code> 关键字放在方法名字的尾部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThrowDemo &#123;</span><br><span class="line">    public static void f() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            throw new RuntimeException(&quot;抛出一个异常&quot;);######</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException&#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h4><p><strong>自定义一个异常类，只需要继承 <code>Exception</code> 或 <code>RuntimeException</code> 即可。</strong></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        throw new MyException("自定义异常");##### 自定义需要 抛出，抛出的异常由调用者处理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; io.github.dunwu.javacore.exception.MyExceptionDemo$MyException: 自定义异常</span><br><span class="line">at io.github.dunwu.javacore.exception.MyExceptionDemo.main(MyExceptionDemo.java:9)</span><br></pre></td></tr></table></figure><h4 id="5-异常链"><a href="#5-异常链" class="headerlink" title="5. 异常链"></a>5. 异常链</h4><p>异常链是以一个异常对象为参数构造新的异常对象，新的异常对象将包含先前异常的信息。</p><p>我们有两种方式做异常链：</p><ul><li>一是 throws 抛出<strong>交给上级处理</strong>。</li><li>二是 try…catch <strong>做具体处理</strong>。而为了构造异常链，try…catch 的 catch 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 throws 继续抛出该方法异常（交给上层处理）。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</li></ul><p>参考：<a href="[https://dunwu.github.io/javacore/basics/java-exception.html#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8](https://dunwu.github.io/javacore/basics/java-exception.html#捕获异常)">异常处理</a></p><h3 id="JSON处理"><a href="#JSON处理" class="headerlink" title="JSON处理"></a>JSON处理</h3><ul><li>只有两种结构：对象内的键值对集合结构和数组，对象用 <code>{}</code> 表示、内部是”key”:”value”，数组用 <code>[]</code> 表示，不同值用逗号分开</li><li>基本数值有 7 个： false / null / true / object / array / number / string</li><li>再加上结构可以嵌套，进而可以用来表达复杂的数据</li><li>一个简单实例：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"Image"</span>: &#123;</span><br><span class="line">  <span class="attr">"Width"</span>: <span class="number">800</span>,</span><br><span class="line">  <span class="attr">"Height"</span>: <span class="number">600</span>,</span><br><span class="line">  <span class="attr">"Title"</span>: <span class="string">"View from 15th Floor"</span>,</span><br><span class="line">  <span class="attr">"Thumbnail"</span>: &#123;</span><br><span class="line">   <span class="attr">"Url"</span>: <span class="string">"http://www.example.com/image/481989943"</span>,</span><br><span class="line">   <span class="attr">"Height"</span>: <span class="number">125</span>,</span><br><span class="line">   <span class="attr">"Width"</span>: <span class="string">"100"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"IDs"</span>: [<span class="number">116</span>, <span class="number">943</span>, <span class="number">234</span>, <span class="number">38793</span>]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Jackson-应用"><a href="#Jackson-应用" class="headerlink" title="Jackson 应用"></a>Jackson 应用</h4><blockquote><p>扩展阅读：更多 API 使用细节可以参考 <a href="https://github.com/FasterXML/jackson-databind" target="_blank" rel="noopener">jackson-databind 官方说明</a></p></blockquote><h4 id="3-1-添加-maven-依赖"><a href="#3-1-添加-maven-依赖" class="headerlink" title="3.1. 添加 maven 依赖"></a>3.1. 添加 maven 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-Jackson-API"><a href="#3-2-Jackson-API" class="headerlink" title="3.2. Jackson API"></a>3.2. Jackson API</h4><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//如下三种方法构造mapper_json</span></span><br><span class="line">mapper.writeValue(<span class="keyword">new</span> File(<span class="string">"result.json"</span>), myResultObject);<span class="comment">//myResultObject是存入对象</span></span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line"><span class="keyword">byte</span>[] jsonBytes = mapper.writeValueAsBytes(myResultObject);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">String jsonString = mapper.writeValueAsString(myResultObject);</span><br></pre></td></tr></table></figure><h4 id="反格式化"><a href="#反格式化" class="headerlink" title="反格式化"></a>反格式化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//如下三种方法提取mapper_json</span></span><br><span class="line">MyValue value = mapper.readValue(<span class="keyword">new</span> File(<span class="string">"data.json"</span>), MyValue<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//Myvuale是类</span></span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">value = mapper.readValue(<span class="keyword">new</span> URL(<span class="string">"http://some.com/api/entry.json"</span>), MyValue<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">value = mapper.readValue(<span class="string">"&#123;\"name\":\"Bob\", \"age\":13&#125;"</span>, MyValue<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="泛型容器的格式化和反格式化"><a href="#泛型容器的格式化和反格式化" class="headerlink" title="泛型容器的格式化和反格式化"></a>泛型容器的格式化和反格式化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">22</span>);</span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">"Mary"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">persons.add(p);</span><br><span class="line">persons.add(p2);</span><br><span class="line">persons.add(p3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"persons"</span>, persons);<span class="comment">//把person List放到map中</span></span><br><span class="line"></span><br><span class="line">String json = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> json = mapper.writeValueAsString(map);<span class="comment">//把map放进json中</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h3><p>Cookie和Session都是用于会话追踪的，即用户登陆状态的维持。</p><p>Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议,要跟踪该会话，必须引入一种机制。</p><h4 id="1-Cookie机制"><a href="#1-Cookie机制" class="headerlink" title="1.Cookie机制"></a>1.Cookie机制</h4><p>在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p><p>Cookie实际上是一小段的文本信息。</p><p>客户端请求服务器，如果服务器需要记录该用户状态，就使用<code>response</code>向客 户端浏览器颁发一个Cookie。</p><p>客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服</p><p>务器。服务器检查该Cookie，以此来辨认用户状态。</p><p>服务器还可以根据需要修改Cookie的内容。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p><h4 id="2-Session机制"><a href="#2-Session机制" class="headerlink" title="2.Session机制"></a>2.Session机制</h4><p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客</p><p>户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</p><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。</p><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就Session。客户端浏览</p><p>器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上</p><p>的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户案，客户来访的时候只需要查询</p><p>客户档案表就可以了。</p><h3 id="Junit测试"><a href="#Junit测试" class="headerlink" title="Junit测试"></a>Junit测试</h3><p>参考：Junit的基本使用（详解）<a href="https://blog.csdn.net/fulishafulisha/article/details/80158392" target="_blank" rel="noopener">https://blog.csdn.net/fulishafulisha/article/details/80158392</a>    </p><p>什么是Junit?</p><p>Junit是xUnit的一个子集，在c++,paython,java语言中测试框架的名字都不相同</p><p>xUnit是一套基于测试驱动开发的测试框架</p><p>其中的断言机制：将程序预期的结果与程序运行的最终结果进行比对，确保对结果的可预知性</p><h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h3><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;这系列文章会讲什么？&quot;&gt;&lt;a href=&quot;#这系列文章会讲什么？&quot; class=&quot;headerlink&quot; title=&quot;这系列文章会讲什么？&quot;&gt;&lt;/a&gt;这系列文章会讲什么？&lt;/h1&gt;&lt;p&gt;首先，我打算将java作为我的主语言去学。&lt;/p&gt;
&lt;p&gt;之前确实是看过书&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="https://colalinn.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://colalinn.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2020-2-13-ZSRW-Development-record</title>
    <link href="https://colalinn.github.io/2020/02/13/2020-02-13-ZSRW-Development-record/"/>
    <id>https://colalinn.github.io/2020/02/13/2020-02-13-ZSRW-Development-record/</id>
    <published>2020-02-13T12:29:51.000Z</published>
    <updated>2020-02-25T15:49:40.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020-2-14"><a href="#2020-2-14" class="headerlink" title="2020.2.14"></a>2020.2.14</h1><p>我是菜狗</p><p>今天终于弄明白了微信的登陆机制kkkk</p><p>总之微信的登陆，就是不把用户的openid、unionid(比openid大一些)放出来直接发给用户，而是用户只能得到</p><p>session已经加密的个人数据，然后将此发给后台(指开发公司)，后台才能解密获得数据（下次一定详细）。</p><h1 id="2020-2-25"><a href="#2020-2-25" class="headerlink" title="2020.2.25"></a>2020.2.25</h1><p>距离2.14已经过去了一阵子，这阵子我在干啥呢。</p><p>当然是开学了QAQ。但是在开学前我用了两天时间完成了UI组设计好的8个页面（创业项目原因不便把界面放出</p><p>来），我得好好夸夸我自己，真棒！</p><p>应该说这次项目还没进展多少，我就已经有收获了。记得之前大一下学网页程序设计，老师html\css\js一起讲</p><p>的，然而他推荐我们用dreamweaver???</p><p>然而那个时候的我还很傻很天真，大一下才学c语言。也没有人来带带我，我自己也没有重视动手的实践。</p><p>加上老师只是讲ppt，所以我没有一种html\css\js串起来的感觉，想实现一个页面还得自己冥思苦想好久。</p><p>最后课设还是临时靠学bootstrap，也就是大名鼎鼎的动态响应栅格样式做了一个大作业。</p><p>然而看到其他人都是自己在网上下的网页当大作业，我的心酸的不得了。(凭什么！！！)</p><p>后来当然是通过这件事见识到了大作业的可笑性，但是话说回来，自己动手也能促进自己的动手能力就是了。</p><p>不过如果不用bootstrap，我就啥都调页面都调不出来了，自此留下心理阴影(我好菜啊QAQ)。</p><p>这个阴影直到这次项目才消去。得知要一个人做小程序页面的我，表示非常蛋疼。但是还是决定接下这个项目。</p><p>不能轻言放弃。于是，我恶补(实际没多少)了css的盒模型、四类position、以及flex布局。</p><p>一开始还是在一边翻教程一边做页面，思考怎么排出这个样式。</p><p>后来越来越得心应手，做页面突然变成工作量的问题了(也和做来作去就那几种布局有关)。</p><p>这是我第一次突破了技术上的心理难关(并没多大难度)，给予了我莫大的勇气，感谢这次项目！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2020-2-14&quot;&gt;&lt;a href=&quot;#2020-2-14&quot; class=&quot;headerlink&quot; title=&quot;2020.2.14&quot;&gt;&lt;/a&gt;2020.2.14&lt;/h1&gt;&lt;p&gt;我是菜狗&lt;/p&gt;
&lt;p&gt;今天终于弄明白了微信的登陆机制kkkk&lt;/p&gt;
&lt;p&gt;总之微
      
    
    </summary>
    
    
      <category term="项目记录" scheme="https://colalinn.github.io/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="项目记录" scheme="https://colalinn.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>开始你的语法秀，记他记他</title>
    <link href="https://colalinn.github.io/2020/02/06/2020-02-06-English-grammar-show/"/>
    <id>https://colalinn.github.io/2020/02/06/2020-02-06-English-grammar-show/</id>
    <published>2020-02-06T15:38:30.000Z</published>
    <updated>2020-02-26T16:26:26.770Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic4.zhimg.com/v2-bcc0b26d8818df00f6417fa84f44d28f_b.jpg" alt="img"></p><center>"语法秀"儿童班</center><a id="more"></a><p>一直以来，都没有系统的整理过英语语法，所以也学的不咋地，这次让我们做个了结吧！</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="英语的时态"><a href="#英语的时态" class="headerlink" title="英语的时态"></a>英语的时态</h1><h3 id="时态是什么？"><a href="#时态是什么？" class="headerlink" title="时态是什么？"></a>时态是什么？</h3><p>时态=时+态，分别如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时-时间：过去、现在、将来、过去将来</span><br><span class="line">态-状态：一般、进行、完成、完成进行</span><br></pre></td></tr></table></figure><h3 id="时态有几种？"><a href="#时态有几种？" class="headerlink" title="时态有几种？"></a>时态有几种？</h3><p>16种，即上面的时和态排列组合，最终能获得4X4=16种</p><h3 id="时态都组合起来都叫什么？"><a href="#时态都组合起来都叫什么？" class="headerlink" title="时态都组合起来都叫什么？"></a>时态都组合起来都叫什么？</h3><ul><li><p>1-4 《过去时》</p></li><li><p><code>过去时</code>+<code>一般态</code>=<code>一般过去时</code></p></li><li><p><code>过去时</code>+<code>进行态</code>=<code>过去进行时</code></p></li><li><p><code>过去时</code>+<code>完成态</code>=<code>过去完成时</code></p></li><li><p><code>过去时</code>+<code>完成进行态</code>=<code>过去完成进行时</code></p></li><li><p>5-8《现在时》</p></li><li><p><code>现在时</code>+<code>一般态</code>=<code>一般现在时</code></p></li><li><p><code>现在时</code>+<code>进行态</code>=<code>现在进行时</code></p></li><li><p><code>现在时</code>+<code>完成态</code>=<code>现在完成时</code></p></li><li><p><code>现在时</code>+<code>完成进行态</code>=<code>现在完成进行时</code></p></li><li><p>8-12《将来时》</p></li><li><p><code>将来时</code>+<code>一般态</code>=<code>一般将来时</code></p></li><li><p><code>将来时</code>+<code>进行态</code>=<code>将来进行时</code></p></li><li><p><code>将来时</code>+<code>完成态</code>=<code>将来完成时</code></p></li><li><p><code>将来时</code>+<code>完成进行态</code>=<code>将来完成进行时</code></p></li><li><p>13-16《过去将来时》</p></li><li><p><code>过去将来时</code>+<code>一般态</code>=<code>一般过去将来时</code></p></li><li><p><code>过去将来时</code>+<code>进行态</code>=<code>过去将来进行时</code></p></li><li><p><code>过去将来时</code>+<code>完成态</code>=<code>过去将来完成时</code></p></li><li><p><code>过去将来时</code>+<code>完成进行态</code>=<code>过去将来完成进行时</code></p></li></ul><h3 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h3><p>作者：因为数学爱上<em>英语</em><br>链接：<a href="https://zhuanlan.zhihu.com/p/88680858" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88680858</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>I often watch TV.<br>我经常看电视<br><strong>一般现在时</strong>：发生在现在，不强调动作<br>do+do=do（watch看，用动词原形）</p><p>I watched TV just now.</p><p>我刚刚在看电视<br><strong>一般过去时</strong>：发生在过去，不强调动作<br>do+did=did（watched看，过去式）</p><p>I am watching TV.<br>我正在看电视<br><strong>现在进行时</strong>：发生在现在，正在进行的动作<br>do+be doing=be doing（an watching正在看）</p><p>I was watching TV when you came in.<br><strong>过去进行时</strong>：发生在过去，正在进行的动作<br>did+be doing=was/were doing（was watching）</p><p>Yestday he told me he would go to the zoo next Sunday.<br>他昨天告诉我他下周天会去动物园.<br><strong>一般过去将来时</strong>：主体动作发生在过去，客体动作是将来可能要发生的动作<br>do+would=would do（主体动作told，did形式）</p><p>I have finished my homework.<br>我完成了我的作业.<br><strong>现在完成时</strong>：截止到现在已经完成了的动作对现在造成的影响.<br>do+have done= have done（have finished）</p><p>He had lived here for 20 years by the end of last year.<br>截止到去年末，他已经在这里居住了20年了<br><strong>过去完成时</strong>：过去的过去发生的动作对过去赵成的影响<br>did+have done=had done</p><p>The students have been being taught by me for 10 years.<br>我教这些学生已经十年了。<br><strong>现在完成进行时</strong>：（既强调动作又强调影响）截止到现在已经完成且未来还会进行的动作<br>do+have been doing=have been doing</p><p>I had been teaching here before you came to the city.<br>在你来这个城市之前我就在这教学了<br><strong>过去完成进行时</strong>：did+have been doing=had been doing</p><p>We will be having a meeting at this time next Sunday.<br>下周天的这个时候我们将正在开会<br><strong>将来进行时</strong>：发生在将来，正在进行的动作<br>will+be doing=will be doing</p><p>He said we would be having a meeting at this time next Sunday.</p><p>他说下星期天这个时候我们要开会。<br><strong>过去将来进行时</strong>：would+be doing=would be doing</p><p>I will have finished the book by the end of this year.<br>我将在今年年底前完成这本书。<br><strong>将来完成时</strong>：将来以前发生的动作对将来造成的影响<br>will+have done=will have done</p><p>He told us that he would have finished the book by the end of this year.<br>他告诉我们他将在今年年底完成这本书。<br><strong>过去将来完成时</strong>：would have done</p><p>By next summer，he will have been teaching here for 30 years.<br>到明年夏天，他将在这里教书30年。<br><strong>将来完成进行时</strong>：will+have been doing=will have been doing</p><p>He told us he would been teaching here for 30 years by next summer.<br>他告诉我们到明年夏天他将在这里教书30年。<br><strong>过去将来完成进行时</strong>：would+have been doing=would have been doing</p><hr><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>英语时态<em>（三张A4纸解决</em>英语中的16种时态）</p><p><a href="https://zhuanlan.zhihu.com/p/88680858" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88680858</a></p><h1 id="英语的情态动词"><a href="#英语的情态动词" class="headerlink" title="英语的情态动词"></a>英语的情态动词</h1><h3 id="1-can、could；may、might"><a href="#1-can、could；may、might" class="headerlink" title="1.can、could；may、might"></a>1.can、could；may、might</h3><p><strong>can、could如下</strong>    can&gt;could，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">can&#x2F;could&#x2F;be able to   表示现在&#x2F;过去的能力(这里could是can的过去式)</span><br><span class="line">can&#x2F;could   表示客观可能性(can可能性大于could)</span><br><span class="line">can&#x2F;could   表示请求和允许(could比较委婉)</span><br><span class="line"></span><br><span class="line">1.He can &#x2F;could&#x2F;is able to swim.</span><br><span class="line">2.He can&#x2F;could come tomorrow.</span><br><span class="line">3.Can&#x2F;could I stay here?</span><br></pre></td></tr></table></figure><p><strong>may、might如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">may&#x2F;might  表示可能性 (may&gt;might、might可能性很小)</span><br><span class="line">may&#x2F;might  表示请求和允许(might更委婉)</span><br><span class="line"></span><br><span class="line">1.He may&#x2F;might come here by bus</span><br><span class="line">2.-May&#x2F;might I join you?</span><br><span class="line">  -&gt;Yes，please.&#x2F;&#x2F;通用回答</span><br><span class="line">  -&gt;No,you can&#39;t.</span><br><span class="line">   &gt;No,you mustn&#39;t.</span><br></pre></td></tr></table></figure><p>论表达请求的委婉性：might&gt;may&gt;could&gt;can</p><h3 id="2-must、have-to"><a href="#2-must、have-to" class="headerlink" title="2.must、have to"></a>2.must、have to</h3><p>must、have to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">must   表示主观多一些</span><br><span class="line">have to   表示客观多一些（有时态和数量的变化）</span><br><span class="line">我一定要打王者是主观，我要写作业是客观</span><br><span class="line">肯定：</span><br><span class="line">You must get up early. 你一定得早起（说话人的主观）</span><br><span class="line">It&#39;s going to rain,I have to go home now.表示说话人被迫</span><br><span class="line"></span><br><span class="line">否定形式：</span><br><span class="line">You mustn&#39;t go. 你不准去</span><br><span class="line">You don&#39;t have to go. 你不必去</span><br></pre></td></tr></table></figure><p>should、ought to</p><p>《should好像是shall的过去式》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">should&#x2F;ought to 表示劝告、建议、命令（should主观、ought to客观）</span><br><span class="line">疑问句种用should代替ought to</span><br><span class="line"></span><br><span class="line">1.You should&#x2F;ought to do the job right now.（should是主观应该，ought to是客观应该）</span><br><span class="line">2.Should they stay here now?</span><br></pre></td></tr></table></figure><h3 id="3-need"><a href="#3-need" class="headerlink" title="3. need"></a>3. need</h3><p>need</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">做情态动词</span><br><span class="line">1.He need come here early.</span><br><span class="line">2.He needn&#39;t come here early.</span><br><span class="line">3.Need he come here early?</span><br><span class="line">-Yes,he need. No,he needn&#39;t</span><br><span class="line"></span><br><span class="line">做实义动词，又第三人称单数和时态的变化，后面可以带to的不定式</span><br><span class="line">1.He needs to come here early.</span><br><span class="line">2.He does&#39;t need to come here early.</span><br><span class="line">3.Does he need to come here early?</span><br><span class="line">-Yes,he does. No,he doesn&#39;t.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回答must和have to的提问句</span><br><span class="line">must I come here early?</span><br><span class="line">Yes,you must.</span><br><span class="line">-No,you needn&#39;t.No,you don&#39;t have to.(意为不需要)</span><br></pre></td></tr></table></figure><h3 id="4-had-better、would-rather"><a href="#4-had-better、would-rather" class="headerlink" title="4.had better、would rather"></a>4.had better、would rather</h3><p>have better</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最好做某事(had不表示时态变化，had better是一个短语)</span><br><span class="line">否定 had better not（最好不）</span><br><span class="line">例句</span><br><span class="line">1.He had better eat more.</span><br><span class="line">2.You&#39;d better finish it right now.</span><br></pre></td></tr></table></figure><p>would rather</p><p>《would 好像是will的过去式》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宁愿、宁可、最好、还是...为好(比had better要轻)</span><br><span class="line">否定 would rather not(还是不)</span><br><span class="line">You would rather deal with it now.</span><br></pre></td></tr></table></figure><h3 id="5-used-to、would"><a href="#5-used-to、would" class="headerlink" title="5.used to、would"></a>5.used to、would</h3><p>used to、would</p><p>表示过去习惯性动作，可翻译成过去常常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">used to 可指过去的状态或情况，动作的反复性，动作已经结束了不会再发生</span><br><span class="line">would 不可指过去的状态或情况，动作的反复性，动作还可以发发生</span><br><span class="line">1.The novel used to be popular.</span><br><span class="line">2.He used to live in Beijing.</span><br><span class="line">  He would practise English every week.</span><br><span class="line">3.People used to think that the earth was flat.</span><br><span class="line">  He would go to the park as soon as he was free.</span><br></pre></td></tr></table></figure><h3 id="6-情态动词-否定、疑问"><a href="#6-情态动词-否定、疑问" class="headerlink" title="6.情态动词 否定、疑问"></a>6.情态动词 否定、疑问</h3><p>否定 （一般是情态动词+not+v原形）</p><p>特殊如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">can&#39;t 不能</span><br><span class="line">may not 可能不</span><br><span class="line">mustn&#39;t 不准</span><br><span class="line">doesn&#39;t have to 不必</span><br><span class="line">（因为have后面加了to，所以have是实义动词，have有时态变化，需要助动词否定）</span><br></pre></td></tr></table></figure><p>疑问（一般是情态动词+主语+v原形）</p><p>特殊如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回答must和have to的提问句</span><br><span class="line">must I come here early?</span><br><span class="line">Yes,you must.</span><br><span class="line">-No,you needn&#39;t.No,you don&#39;t have to.(意为不需要)</span><br></pre></td></tr></table></figure><h3 id="7-情态动词-完成时"><a href="#7-情态动词-完成时" class="headerlink" title="7.情态动词+完成时"></a>7.情态动词+完成时</h3><p>情态动词+have+p.p (过去分词) (对过去事实的描述)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.表达过去事实、推测的含义（组动词should除外）-》可能已经</span><br><span class="line">2.should+完成时-》本应该</span><br><span class="line">  needn&#39;t+完成时-》本不需要</span><br><span class="line">3.must+完成时-》准是已经</span><br><span class="line">  can&#39;t+完成时-》不可能已经（是 must+完成时 的否定）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.He can&#x2F;could have arrived.可能已经(推测性第二、三）###########这里could有被动式的意思嘛？</span><br><span class="line">  He may&#x2F;might have arrived.可能已经(推测性第四、五)</span><br><span class="line">  He must have arrived.     准是已经(推测性第一)</span><br><span class="line">2.He should have arrived.他本来应该到了，但是没到</span><br><span class="line">  You needn&#39;t have done so.你本不需要</span><br><span class="line">3.He must have arrived.他准是已经到了</span><br><span class="line">  He can&#39;t have arrived.</span><br></pre></td></tr></table></figure><h1 id="被动语态"><a href="#被动语态" class="headerlink" title="被动语态"></a>被动语态</h1><h3 id="1-被动语态的概念"><a href="#1-被动语态的概念" class="headerlink" title="1.被动语态的概念"></a>1.被动语态的概念</h3><p>英语的语态有两种，主动语态和被动语态。</p><p>主动语态表示主语是动作的执行者，被动语态表示主语是动作的承受者。</p><p>使用动词的被动语态作谓语。</p><h3 id="2-被动语态怎么构成"><a href="#2-被动语态怎么构成" class="headerlink" title="2.被动语态怎么构成"></a>2.被动语态怎么构成</h3><p>be+动词的过去分词(p.p.)+…+by sb.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">He is taken to America by his mother.</span><br></pre></td></tr></table></figure><h3 id="3-被动语态的各种时态"><a href="#3-被动语态的各种时态" class="headerlink" title="3.被动语态的各种时态"></a>3.被动语态的各种时态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般现在时   The information is needed by us.</span><br><span class="line">过去进行时   The book was being read by him.</span><br><span class="line">现在完成时   The computer has been used by her.</span><br><span class="line">一般将来时   The room wiil be cleaned.</span><br><span class="line">过去完成时   The computer could have been used by them. ######疑惑</span><br></pre></td></tr></table></figure><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200210231022370.png" alt="image-20200210231022370"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200210233814393.png" alt="image-20200210233814393"></p><h3 id="4-情态动词-被动语态"><a href="#4-情态动词-被动语态" class="headerlink" title="4.情态动词+被动语态"></a>4.情态动词+被动语态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">can&#x2F;could+be+动词的过去分词(p.p.)</span><br><span class="line">右边同can  (may&#x2F;might、must&#x2F;have to、should &#x2F;ought to、had better&#x2F;would rather、used to &#x2F;would )</span><br></pre></td></tr></table></figure><p>need特殊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">need+doing+p.p  ;   need+to+be+p.p</span><br></pre></td></tr></table></figure><p>例句</p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211002828402.png" alt="image-20200211002828402"></p><h3 id="5-by-行为者省略的情况"><a href="#5-by-行为者省略的情况" class="headerlink" title="5.by+行为者省略的情况"></a>5.by+行为者省略的情况</h3><p>动作的行为者不分明，或不重要，或上下文中提到了行为者时，”by+行为者“可以省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The information is needed.</span><br><span class="line">The book is being read.</span><br><span class="line">The door was opened.</span><br></pre></td></tr></table></figure><h3 id="6-被动语态疑问句"><a href="#6-被动语态疑问句" class="headerlink" title="6.被动语态疑问句"></a>6.被动语态疑问句</h3><p>一般疑问句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">助动词+主语+(其他助动词)+p.p...?</span><br><span class="line">1.Is the information needed by him?</span><br><span class="line">  - Yes,it is. No,it isn&#39;t.</span><br><span class="line">2.Has the compter been used by her?</span><br><span class="line">  - Yes,it has. No,it hasn&#39;t.</span><br><span class="line">3.Will the room be cleaned?</span><br><span class="line">  - Yes,it will. No it won&#39;t.</span><br></pre></td></tr></table></figure><p>特殊疑问句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">疑问词+助动词+主语+(其他助动词)+p.p...?</span><br><span class="line">即：疑问词+一般疑问句</span><br><span class="line">1.The information is needed by them.</span><br><span class="line">  -&gt;What is the information needed by them.</span><br><span class="line">2.The girl is taken to Shanghai.</span><br><span class="line">  -&gt;Where is the girl taken to?</span><br><span class="line">3.The book has been read by three times.</span><br><span class="line">  -&gt;How many times has the book been read?</span><br></pre></td></tr></table></figure><h1 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h1><h3 id="1-非谓语动词类型-动词不定式-动名词"><a href="#1-非谓语动词类型-动词不定式-动名词" class="headerlink" title="1.非谓语动词类型=动词不定式+动名词"></a>1.非谓语动词类型=动词不定式+动名词</h3><p><strong>to+动词原形-&gt;动词不定式</strong></p><p>可以做主语、宾语、宾补、定语、表语和状语 (除谓语之外所有成分)</p><p>可以把动词不定式看成一个名词，所以什么都能做</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主语：(To get there by bike ) will take us an hour.</span><br><span class="line">宾语：The driver failed (to see the car) in time.</span><br><span class="line">宾补：We believe him (to be guilty).</span><br><span class="line">定语：The next train (to arrive) is from seoul.</span><br><span class="line">表语：My suggestion is (to put off the meeting).（位于be系动词后做表语）</span><br><span class="line">状语：I come here only (to say goodbye to you).</span><br></pre></td></tr></table></figure><p><strong>动词原形+ing-&gt;动名词</strong></p><p>可做名词用,具有动词的特征、变化形式，但在句子中的用法及功能类似名词</p><p>在句子中可以作主语、宾语、表语、定语。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主语：(Reading) is an art.</span><br><span class="line">宾语：They went on (walking) and never stopped (talking).</span><br><span class="line">表语：Your task is quickly (cleaning the windows).</span><br><span class="line">定语：This is (reading) room.</span><br></pre></td></tr></table></figure><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211141908191.png" alt="image-20200211141908191"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211163012630.png" alt="image-20200211163012630"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211163145386.png" alt="image-20200211163145386"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211163208085.png" alt="image-20200211163208085"></p><p>不定式和动名词的具体区分未来会讲##############################</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1） 动名词与不定式的区别：</span><br><span class="line">动名词表达的是：状态,性质,心境,抽象,经常性,已发生的　不定式表达的是：目的,结果,原因,具体,一次性,将发生的</span><br><span class="line">2） 接不定式或动名词,意义相同.</span><br><span class="line">3)在下列情况下,一般要用不定式：</span><br><span class="line">①hate,like,love前有would(should)时,如：I&#39;d like to have a cup of coffee.</span><br><span class="line">②当谓语动词begin,continue,start等是进行式时,如：Thestudents are starting to work on the di fficult maths problem.</span><br><span class="line">③begin,continue,start与know,understand等状态动词连用时,如：I soon began to understand what was happening.</span><br><span class="line">⒋advise,allow,encourage,forbid,permit等动词后接动名词作宾语,或带不定式作宾语补足语.如：</span><br><span class="line">Our teachers don&#39;t permit our swimming in the lake.</span><br><span class="line">Our teachers don&#39;t permit us to swim in the lake.</span><br><span class="line">4） 部分动词后接不定式或动名词时,意义差别较大,应根据句子语境选择使用.</span><br><span class="line">①forget,remember,regret后接不定式,表示现在或未来的动作,接动名词表示动作已经发生.如：</span><br><span class="line">Don&#39;t forget fo post the letter for me.</span><br><span class="line">Have you forgotten meeting her in Beijing Airport?</span><br><span class="line">Remember to close the windows before you leave.</span><br><span class="line">I remember writing him a letter a year ago.</span><br><span class="line">We regret to tell you that all of you are not invited toattend the meeting.</span><br><span class="line">They regretted ordering these books from abroad.</span><br><span class="line">动名词与不定式语义不同的有11 组：</span><br><span class="line">1　stop to do　　　　　stop doing　　　</span><br><span class="line">2 forget to do　　　　 forget doing</span><br><span class="line">3　remember to do　　　remember doing　　　　　　</span><br><span class="line">4 regret to do　　　　 regret doing</span><br><span class="line">5　cease to do　　　　 cease doing　　　　　　　　</span><br><span class="line">6 try to do　　　　　　try doing</span><br><span class="line">7　go on to do　　　　 go on doing　　　　　　　　</span><br><span class="line">8 afraid to do　　　　 afraid doing</span><br><span class="line">9　interested to do　　interested doing　</span><br><span class="line">10 mean to do　　　　　 mean doing</span><br><span class="line">11 begin&#x2F; start to do　 begin&#x2F; start doing</span><br><span class="line">非谓语动词的用法是英语语法的一大难点,你最好全面对比一下不定式、动名词、现在分词、过去分词以及独立主格结构的用法!</span><br><span class="line">---------------------------------from 百度知道https:&#x2F;&#x2F;www.zybang.com&#x2F;question&#x2F;8d8679b341dfe4a16ae781fe4387f682.html</span><br></pre></td></tr></table></figure><h3 id="2-真假-形式-主语-宾语"><a href="#2-真假-形式-主语-宾语" class="headerlink" title="2.真假(形式)主语/宾语"></a>2.真假(形式)主语/宾语</h3><p>（1）不定式/动名词可以在主语的位置上，淡</p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211141428728.png" alt="image-20200211141428728"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211141726786.png" alt="image-20200211141726786"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211141825548.png" alt="image-20200211141825548"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211141838671.png" alt="image-20200211141838671"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211162932342.png" alt="image-20200211162932342"></p><h3 id="3-动词不定式引导目的状语从句"><a href="#3-动词不定式引导目的状语从句" class="headerlink" title="3.动词不定式引导目的状语从句"></a>3.动词不定式引导目的状语从句</h3><p>表示  “目的”   习惯上有以下两种形式（只有to+动词也行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in order to+动词  (引导的目的状语，置于句首、句尾均可)</span><br><span class="line">so as    to+动词  (引导的目的状语，只能置于句尾)</span><br><span class="line">例句</span><br><span class="line">1.I‘ve written it down （in order to） remember it.</span><br><span class="line">  -In order to remenber it ，I‘ve written it down.</span><br><span class="line">2.He shouted and waved (so as to) be noticed。</span><br></pre></td></tr></table></figure><p>否定形式，在to前加not</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in order not to+动词</span><br><span class="line">so as not to+动词</span><br></pre></td></tr></table></figure><h3 id="3-常见不定式和动名词的固定结构"><a href="#3-常见不定式和动名词的固定结构" class="headerlink" title="3.常见不定式和动名词的固定结构"></a>3.常见不定式和动名词的固定结构</h3><p>(1)too…to…：太…以至于不能…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The room is (too small to) live.</span><br></pre></td></tr></table></figure><p>(2)enough+n+to+v  / adj+enough+to+v：足够…可以…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There is (enough food to eat).</span><br><span class="line">The box is (big enough to contain) six apples.</span><br></pre></td></tr></table></figure><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211154916313.png" alt="image-20200211154916313"></p><p>(3)On+动名词：一…就…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(On seeing) the snake,The girl was very frightened.（On doing引导做状语）</span><br></pre></td></tr></table></figure><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211155204487.png" alt="image-20200211155204487"></p><p>(4)There is no hope of + 动名词：没希望</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(There is no hope of seeing) him.</span><br></pre></td></tr></table></figure><p>(5)feel like+动名词：想要、喜欢做某事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I (feel like eating) ice cream now.</span><br></pre></td></tr></table></figure><p>(6)have a hard time+ 动名词：做~艰难</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">They (have a hard time solving the problem themselves).</span><br></pre></td></tr></table></figure><h3 id="4-现在-过去-分词、分词句"><a href="#4-现在-过去-分词、分词句" class="headerlink" title="4.现在/过去 分词、分词句"></a>4.现在/过去 分词、分词句</h3><p>(1)v+ing 可称为动名词（gerund）、现在分词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动名词：(Writing books) is his job.动名词做主语</span><br><span class="line">   He likes (drinking cooffe).动名词做宾语</span><br><span class="line">现在分词：He is Writing a book.</span><br></pre></td></tr></table></figure><p>(2)p.p（present participle动词）可称为动词过去分词，用于完成时和被动语态当中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">完成时：  He has written the homework.</span><br><span class="line">被动语态：The homework is written.</span><br></pre></td></tr></table></figure><p>(3)分词句：包含现在分词和过去分词的分句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在分词：The students went out of the classroom,laughing and talking.</span><br><span class="line">过去分词：Accompanied by his friend,he went to railway staion.</span><br><span class="line">这两句都是现在&#x2F;过去分词引导的伴随状语从句</span><br></pre></td></tr></table></figure><h1 id="原形不定式"><a href="#原形不定式" class="headerlink" title="原形不定式"></a>原形不定式</h1><p>动词前不再加to</p><h3 id="1-使役动词"><a href="#1-使役动词" class="headerlink" title="1.使役动词"></a>1.使役动词</h3><p>（1）have/make/let +宾语+v （使役动词，表示“使/让”）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">He made me laugh.</span><br><span class="line">I let him go.</span><br><span class="line">Please have him come here.</span><br></pre></td></tr></table></figure><p>(2)get、help都做使役动词，</p><p>get的使役动词句为：get+宾语+to+v    (使/让的意思)</p><p>help的使役动词为：help+宾语+（to）+v   (帮助)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I can&#39;t get anyone to do the work properly.</span><br><span class="line">I helped him (to) repair the car.</span><br></pre></td></tr></table></figure><p>(3)以上所有   使役动词+宾语+过去分词（表示“让某物/人被别人…”）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.I must (get my hair cut).</span><br><span class="line">2.He couldn&#39;t (make himself heard).</span><br><span class="line">3.Can you (get the work finished) in time?</span><br></pre></td></tr></table></figure><h3 id="2-感官动词"><a href="#2-感官动词" class="headerlink" title="2.感官动词"></a>2.感官动词</h3><p>感官动词：see/watch/observe/hear/smell/taste/feel</p><p>眼看 see/watch/observe   耳听hear   鼻闻smell  品尝taste   手触feel  《五官》</p><p>(1)  感官动词+宾语+动词原形/现在分词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1...+动词原形，表示动作的真实性</span><br><span class="line">2...+现在分词，表示动作的真实性、连续性和进行性</span><br><span class="line">例句</span><br><span class="line">1.I (saw him work) in the garden yesterday.</span><br><span class="line">2.I (saw him working) in the garden yesterday.</span><br><span class="line">  I (watched a dog running) in the garden yesterday.</span><br></pre></td></tr></table></figure><p>（2）感官动词+宾语+过去分词   （表被动）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">John saw the man knocked down by the car.（他被车撞）</span><br></pre></td></tr></table></figure><h1 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h1><h3 id="1-if只表示单纯条件的假设（与现在事实相反？）"><a href="#1-if只表示单纯条件的假设（与现在事实相反？）" class="headerlink" title="1.if只表示单纯条件的假设（与现在事实相反？）"></a>1.if只表示单纯条件的假设（与现在事实相反？）</h3><p>“if”引导的条件状语从句。规则如下</p><p>1.主句为一般将来时，从句一般现在时，译作“如果…就”<br>2.从句可放可放句尾(句前强调条件,句尾强调结果 from baidu)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.If you get up early,you will catch up with the train.</span><br><span class="line">2.She will be upset if you fail the axam.</span><br></pre></td></tr></table></figure><h3 id="2-if与现在事实相反的虚拟语气"><a href="#2-if与现在事实相反的虚拟语气" class="headerlink" title="2.if与现在事实相反的虚拟语气"></a>2.if与现在事实相反的虚拟语气</h3><p>“if”引导的从句式一种虚拟的条件或假设，和现在事实相反。</p><p>从句：用过去式，（be必须用were）</p><p>主句：would/could/should/might+动词原形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.If I were you,I would join them.</span><br><span class="line">2.She would come with you if you invited her.</span><br></pre></td></tr></table></figure><h3 id="3-if与过去事实相反的虚拟语气"><a href="#3-if与过去事实相反的虚拟语气" class="headerlink" title="3.if与过去事实相反的虚拟语气"></a>3.if与过去事实相反的虚拟语气</h3><p>“if”引导的从句式一种虚拟的条件或假设，和过去事实相反。</p><p>从句：had+动词过去分词（过去完成时）</p><p>主句：would/could/should/might+have+动词过去分词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.If I (had got) there earlier,I (should have met) her.</span><br><span class="line">2.If he (had taken) my advice,he (would not have made) such a mistake.</span><br></pre></td></tr></table></figure><p>if 与将来事实相反呢####################################</p><h3 id="4-wish、as-if的假设"><a href="#4-wish、as-if的假设" class="headerlink" title="4.wish、as if的假设"></a>4.wish、as if的假设</h3><p>(1)wish 表示愿望、希望、“希望…就好了“，是不可能实现的假设。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.从句表示现在事实相反的愿望(一般过去时)</span><br><span class="line">2.从句表示过去事实相反的愿望(过去完成时)</span><br><span class="line">3.从句表示将来不大可能实现的愿望(would&#x2F;should&#x2F;could+v原)</span><br><span class="line">主句按时态正常表示</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.I wish I (were) as tall as you.</span><br><span class="line">2.He wished he (hadn&#39;t said) that.（wished表示过去时愿望）</span><br><span class="line">3.I wish it (would rain) tomorrow.</span><br></pre></td></tr></table></figure><p>(2)as if表示“看起来好像…“，是不可能实现的假设。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.从句表示现在事实相反的愿望(一般过去时)</span><br><span class="line">2.从句表示过去事实相反的愿望(过去完成时)</span><br><span class="line">3.从句表示将来不大可能实现的愿望(would&#x2F;should&#x2F;could+v原)</span><br><span class="line">主句按时态正常表示</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.You looks as if you (didn&#39;t) care.</span><br><span class="line">2.He talks about Rome as if he (had been) there before.</span><br><span class="line">3.He opened his mouth as if he (would say) something.</span><br></pre></td></tr></table></figure><h1 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h1><h3 id="1-定语从句是啥？"><a href="#1-定语从句是啥？" class="headerlink" title="1.定语从句是啥？"></a>1.定语从句是啥？</h3><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211203542506.png" alt="image-20200211203542506"></p><h3 id="2-定语从句关系代词"><a href="#2-定语从句关系代词" class="headerlink" title="2.定语从句关系代词?"></a>2.定语从句关系代词?</h3><p>the girl 为先行词，whom/that 为关系代词</p><p>先行词和关系代词是一致的</p><p>主格主语、宾格宾语、属格属语属于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The girl (whom&#x2F;that I spoke to) is my cousin.</span><br><span class="line">whom&#x2F;that I spoke to为定语从句，i spoke to XX,这里XX作宾语，故使用whom&#x2F;that作为关系词</span><br></pre></td></tr></table></figure><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211203748837.png" alt="image-20200211203748837"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211205122045.png" alt="image-20200211205122045"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211205701086.png" alt="image-20200211205701086"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211205531186.png" alt="image-20200211205531186"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211210009310.png" alt="image-20200211210009310"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211210937482.png" alt="image-20200211210937482"></p><h3 id="（非）限制性定语从句-of-which"><a href="#（非）限制性定语从句-of-which" class="headerlink" title="（非）限制性定语从句 of which???"></a>（非）限制性定语从句 of which???</h3><h3 id="定语从句的时态"><a href="#定语从句的时态" class="headerlink" title="定语从句的时态"></a>定语从句的时态</h3><h3 id="3-定语从句-关系副词"><a href="#3-定语从句-关系副词" class="headerlink" title="3.定语从句-关系副词"></a>3.定语从句-关系副词</h3><p>天气会更好的下一周</p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211211631348.png" alt="image-20200211211631348"></p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211211851931.png" alt="image-20200211211851931"></p><h1 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h1><h3 id="1-宾语从句是啥？"><a href="#1-宾语从句是啥？" class="headerlink" title="1.宾语从句是啥？"></a>1.宾语从句是啥？</h3><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211214212896.png" alt="image-20200211214212896"></p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>that可省</p><p><img src="/2020/02/06/2020-02-06-English-grammar-show/image-20200211214621884.png" alt="image-20200211214621884"></p><h1 id="比较级和最高级"><a href="#比较级和最高级" class="headerlink" title="比较级和最高级"></a>比较级和最高级</h1><h3 id="1-比较级、最高级变化"><a href="#1-比较级、最高级变化" class="headerlink" title="1.比较级、最高级变化"></a>1.比较级、最高级变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.通常在形容词和副词后面加“er”、&quot;est&quot;   (hard-harder-the hardest)</span><br><span class="line">2.词尾是不发音的单音节e时，加&quot;r&quot;、&quot;st&quot;   (nice-nicer-the nicest)</span><br><span class="line">3.词尾是“辅音+y”的双音节时，去掉“y”加“ier”    (dry-drier-the driest)</span><br><span class="line">4.以辅音结尾的重读闭音节时，双写最后一个字母，加“er”、&quot;est&quot;   (hot-hotter-the hottest)</span><br><span class="line">5.多音节和双音节，在形容词和副词前加“more”、&quot;the most&quot; \ “less”、&quot;the least&quot;</span><br><span class="line">interesting-more interesting-the most interesting</span><br><span class="line">   -less interesting-the least interesting</span><br><span class="line">6.不规则变化</span><br><span class="line">good-better-the best</span><br><span class="line">many-more-the most</span><br><span class="line">little-less-the least</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开音节：元音+辅音+e、辅音加元音</span><br><span class="line">重度闭音节：单词结尾式元音+辅音（可接无数个？）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">练习</span><br><span class="line">1.high-higher-the highest</span><br><span class="line">2.late-later-the latest</span><br><span class="line">3.heavy-heavier-the heaviest</span><br><span class="line">4.thin-thinner-the thinnest</span><br><span class="line">5.famous-more famous-the most famous</span><br><span class="line">6.little-less-the least</span><br></pre></td></tr></table></figure><h3 id="2-比较级、最高级使用"><a href="#2-比较级、最高级使用" class="headerlink" title="2.比较级、最高级使用"></a>2.比较级、最高级使用</h3><p>（1）形容词或副词的比较级：“比较…”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">He is taller than his brother.</span><br><span class="line">The book is more expensive than the pan.</span><br><span class="line">Her English is better than his.</span><br><span class="line">My articles is better than theirs.</span><br></pre></td></tr></table></figure><p>（2）最高级(在后面用一个介词短语来表示范围)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">He is the tallest in his class.</span><br><span class="line">This pair of chopsticks is the most expensive of the three pairs.</span><br><span class="line">The bowl is the biggest of them all.</span><br><span class="line">I am the tallest among the three.</span><br></pre></td></tr></table></figure><center>    2020.2.11，奥里给，谢谢老师！    </center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bcc0b26d8818df00f6417fa84f44d28f_b.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;center&gt;&quot;语法秀&quot;儿童班&lt;/center&gt;
    
    </summary>
    
    
      <category term="English_grammar" scheme="https://colalinn.github.io/categories/English-grammar/"/>
    
    
      <category term="English" scheme="https://colalinn.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>2020-2-4-pRide-current-search</title>
    <link href="https://colalinn.github.io/2020/02/04/2020-02-04-pRide-current-search/"/>
    <id>https://colalinn.github.io/2020/02/04/2020-02-04-pRide-current-search/</id>
    <published>2020-02-04T15:00:13.000Z</published>
    <updated>2020-02-26T16:25:54.220Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233855033.png" alt="image-20200204233855033"></p><center>这是一篇关于pRIDE所用技术的检索结果</center><a id="more"></a><h1 id="1-路网嵌入（ROAD-NETWORK-ENBEDDING）"><a href="#1-路网嵌入（ROAD-NETWORK-ENBEDDING）" class="headerlink" title="1.路网嵌入（ROAD NETWORK ENBEDDING）"></a>1.路网嵌入（ROAD NETWORK ENBEDDING）</h1><p>目前的思路是自己从百度地图(google地图)查，然后存下来</p><p>至于用什么形式存，555我也不清楚</p><h1 id="2-同态加密"><a href="#2-同态加密" class="headerlink" title="2.同态加密"></a>2.同态加密</h1><p>pRIDE论文有提到两个链接，我觉得挺好的，应该可以直接用</p><ul><li><p>github-上的代码-jPaillier    <a href="https://github.com/kunerd/jpaillier" target="_blank" rel="noopener">https://github.com/kunerd/jpaillier</a></p><p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233652918.png" alt="image-20200204233652918"></p></li><li><p>论文还提到一个JDBC（不知道是用来干啥的）</p><p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233714656.png" alt="image-20200204233714656"></p></li></ul><h1 id="3-混淆电路Garbled-Circuit"><a href="#3-混淆电路Garbled-Circuit" class="headerlink" title="3.混淆电路Garbled Circuit"></a>3.混淆电路Garbled Circuit</h1><ul><li><p>混淆电路介绍，知乎上的，讲的海星</p><p><a href="https://zhuanlan.zhihu.com/p/41172002" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41172002</a></p></li><li><p>pRIDE论文里提到了他们用的是一篇论文提出的加速版安全双方计算混淆电路</p><p><strong>Faster Secure Two-Party Computation Using Garbled Circuits</strong></p><p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233855033.png" alt="image-20200204233855033"></p></li><li><p>github的搜索结果  <a href="https://github.com/search?q=Garbled-Circuits" target="_blank" rel="noopener">https://github.com/search?q=Garbled-Circuits</a></p><p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233627276.png" alt="image-20200204233627276"></p></li><li><p>github-某个java仓库，我觉得挺好的</p><p> <a href="https://github.com/thanosba/Yao-Garbled-Circuits![image-20200204233556551](2020-02-04-pRide-current-search/image-20200204233556551.png)" target="_blank" rel="noopener">https://github.com/thanosba/Yao-Garbled-Circuits![image-20200204233556551](2020-02-04-pRide-current-search/image-20200204233556551.png)</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/02/04/2020-02-04-pRide-current-search/image-20200204233855033.png&quot; alt=&quot;image-20200204233855033&quot;&gt;&lt;/p&gt;
&lt;center&gt;这是一篇关于pRIDE所用技术的检索结果&lt;/center&gt;
    
    </summary>
    
    
      <category term="pRIDE" scheme="https://colalinn.github.io/categories/pRIDE/"/>
    
    
      <category term="pRIDE" scheme="https://colalinn.github.io/tags/pRIDE/"/>
    
  </entry>
  
  <entry>
    <title>1-10 leetcode题解</title>
    <link href="https://colalinn.github.io/2020/01/26/2020-01-26-leetcode/"/>
    <id>https://colalinn.github.io/2020/01/26/2020-01-26-leetcode/</id>
    <published>2020-01-26T12:10:26.000Z</published>
    <updated>2020-03-03T12:06:11.372Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/26/2020-01-26-leetcode/1-10.jpg" alt="1-10截图"></p><a id="more"></a><h1 id="1-两数之合"><a href="#1-两数之合" class="headerlink" title="1.两数之合"></a>1.两数之合</h1><ul><li><p>题目</p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p></li><li><p>解题思路</p><p>主要的做题思路是遍历每个对象，如果target减去当前的值A得到的B在map中，那就找到了！</p><p>就把这两个位置(一个map中，一个当前位置)返回去。</p><p>如果没有找到，就把遍历到的（位置，值）放到map中</p><p>//以下为一个战胜100%的java代码，99%之类的用的是Map，看来以下这样写的效率应该高一点点</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> maxValue = <span class="number">2048</span>;<span class="comment">//样例中nums数组的大小应该不比2048大</span></span><br><span class="line">       <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue];<span class="comment">//和Hashmap一样的作用，存入的值是（位置，值）</span></span><br><span class="line">       <span class="keyword">int</span> tool = maxValue - <span class="number">1</span>;<span class="comment">//2的11次方减1，大概是用于做hash的作用</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;<span class="comment">//遍历每个对象</span></span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">int</span> pos = map[(target - num) &amp; tool];</span><br><span class="line">            <span class="keyword">if</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果target减去当前的值A得到的B在map中，那就找到了</span></span><br><span class="line">                <span class="comment">//就把这两个位置(一个map中，一个当前位置)返回去                </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pos - <span class="number">1</span>, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map[num &amp; tool] = i + <span class="number">1</span>;<span class="comment">//如果没有找到，就把遍历到的（位置，值）放到map中</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><ul><li><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure></li><li><p>题解很简单，就是遍历两个链表，设置一个carry作为进位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;//这是定义了链表的节点</span></span><br><span class="line"><span class="comment"> *     int val;//节点有值</span></span><br><span class="line"><span class="comment"> *     ListNode next;//节点指向的下个节点</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;//节点的构造器，初始化val为传入x</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result=<span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//做一个0值头指针</span></span><br><span class="line">        ListNode resultA=result;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;<span class="comment">//进位值</span></span><br><span class="line">        <span class="keyword">int</span> i1,i2;<span class="comment">//遍历链表的值</span></span><br><span class="line">        <span class="keyword">int</span> sum;<span class="comment">//总数</span></span><br><span class="line">        <span class="comment">//carry!=0（carry=）是为了链表节点数一样，但是有进位的情况</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>|l2!=<span class="keyword">null</span>|carry!=<span class="number">0</span>)<span class="comment">//链表还有下一个节点、或者还有下个进位就继续</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里是为了判断链表数不一样的情况</span></span><br><span class="line">            i1=l1!=<span class="keyword">null</span>?l1.val:<span class="number">0</span>;</span><br><span class="line">            i2=l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>;</span><br><span class="line">            System.out.print(i1);        </span><br><span class="line">            sum=i1+i2+carry;</span><br><span class="line">            carry=sum/<span class="number">10</span>;<span class="comment">//把sum的进位留到下一个节点</span></span><br><span class="line">            ListNode newNode=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);<span class="comment">//余数就放在当前新建节点       </span></span><br><span class="line">            result.next=newNode;</span><br><span class="line">            result=newNode;</span><br><span class="line">            l1=l1!=<span class="keyword">null</span>?l1.next:<span class="keyword">null</span>;<span class="comment">//遍历链表1</span></span><br><span class="line">            l2=l2!=<span class="keyword">null</span>?l2.next:<span class="keyword">null</span>;<span class="comment">//遍历链表2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultA.next;<span class="comment">//返回0值头指针所指向的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><ul><li><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure></li><li><p>主要的思路，就是遍历字符串的每个字符。</p><p>每个字符串从中间往外面寻找是否是回文，是的话继续寻找，直到两边字符不再相同，就停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length_s=s.length(),length_Palin=<span class="number">1</span>;</span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> first,second,first_next,second_next;</span><br><span class="line">        <span class="keyword">if</span>(length_s==<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//判断是否为一个字符，直接返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(length_s&gt;<span class="number">1</span>) result=s.substring(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//把第一个字符放进来，使得最少为一个字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用两个指针遍历</span></span><br><span class="line">        <span class="keyword">for</span>(first=<span class="number">0</span>,second=<span class="number">1</span>;second&lt;length_s;first++,second++)&#123;</span><br><span class="line">            <span class="comment">//这是两个指针判断的回文</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(first)==s.charAt(second))&#123;</span><br><span class="line">                first_next=first;second_next=second;</span><br><span class="line">                    <span class="keyword">while</span>(first_next-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; second_next+<span class="number">1</span>&lt;length_s &amp;&amp; s.charAt(first_next-<span class="number">1</span>)==s.charAt(second_next+<span class="number">1</span>))&#123;</span><br><span class="line">                    first_next--;</span><br><span class="line">                    second_next++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result.length()&lt;second_next-first_next+<span class="number">1</span>)&#123;</span><br><span class="line">                    result=s.substring(first_next, second_next+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//这是一个指针判断的两侧回文</span></span><br><span class="line">            <span class="keyword">if</span>(second&lt;=length_s-<span class="number">2</span>&amp;&amp;s.charAt(second-<span class="number">1</span>)==s.charAt(second+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                first_next=second-<span class="number">1</span>;second_next=second+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(first_next-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; second_next+<span class="number">1</span>&lt;length_s &amp;&amp; s.charAt(first_next-<span class="number">1</span>)==s.charAt(second_next+<span class="number">1</span>))&#123;</span><br><span class="line">                    first_next--;</span><br><span class="line">                    second_next++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result.length()&lt;second_next-first_next+<span class="number">1</span>)&#123;</span><br><span class="line">                    result=s.substring(first_next, second_next+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number/</a></p><ul><li><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></li><li><p>主要是借鉴了评论区高赞老哥的思路，因为x是int型,若逆序后(即12345-&gt;54321)溢出则不是回文序列。</p><p>分三种情况</p><p>1)x为负数,false<br>2)x逆序后,与原来x不同,溢出或非回文,false<br>3)x逆序后与原来x相同,回文,true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x_origin=x;</span><br><span class="line">        <span class="keyword">long</span> reserve=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            reserve=reserve*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)reserve!=x_origin) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/01/26/2020-01-26-leetcode/1-10.jpg&quot; alt=&quot;1-10截图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://colalinn.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://colalinn.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>搭建机场简易教程shadowsocks centos7 vutlr bbr</title>
    <link href="https://colalinn.github.io/2020/01/26/2020-01-26-shadowsocks-centos7-vutlr-bbr/"/>
    <id>https://colalinn.github.io/2020/01/26/2020-01-26-shadowsocks-centos7-vutlr-bbr/</id>
    <published>2020-01-26T11:40:57.000Z</published>
    <updated>2020-02-03T09:46:28.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）"><a href="#1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）" class="headerlink" title="1.获得vutlr服务器后(包含ip、用户名和密码)使用Xshell连接（其他连接器请自行百度）"></a>1.获得vutlr服务器后(包含ip、用户名和密码)使用Xshell连接（其他连接器请自行百度）</h2><h2 id="2-依次输入以下代码安装shadowsocks"><a href="#2-依次输入以下代码安装shadowsocks" class="headerlink" title="2.依次输入以下代码安装shadowsocks"></a>2.依次输入以下代码安装shadowsocks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><h4 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget –no-check-certificate -O shadowsocks.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.sh</span><br></pre></td></tr></table></figure><h4 id="获取shadowsocks-sh读取权限"><a href="#获取shadowsocks-sh读取权限" class="headerlink" title="获取shadowsocks.sh读取权限"></a>获取shadowsocks.sh读取权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shadowsocks.sh</span><br></pre></td></tr></table></figure><h4 id="设置个人shadowsocks密码和端口号"><a href="#设置个人shadowsocks密码和端口号" class="headerlink" title="设置个人shadowsocks密码和端口号"></a>设置个人shadowsocks密码和端口号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p>然后依次输入你的密码password、端口号(就是ss服务的端口号，后面连接使用)、加密模式(很多人推荐7 aes-256-cfb)</p><p>按任意键开始配置press any key to start，如果是第一次配置需要几分钟</p><h4 id="配置完之后可以看到用四行红字"><a href="#配置完之后可以看到用四行红字" class="headerlink" title="配置完之后可以看到用四行红字"></a>配置完之后可以看到用四行红字</h4><p>这个就是我们shadowsocks的连接信息了,其中除了ip是服务器自带的，端口、密码、加密模式都是我们自选的</p><h2 id="3-安装拥塞控制BBR加速上网"><a href="#3-安装拥塞控制BBR加速上网" class="headerlink" title="3.安装拥塞控制BBR加速上网"></a>3.安装拥塞控制BBR加速上网</h2><h4 id="安装BBR"><a href="#安装BBR" class="headerlink" title="安装BBR"></a>安装BBR</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br></pre></td></tr></table></figure><h4 id="获得读取权限"><a href="#获得读取权限" class="headerlink" title="获得读取权限"></a>获得读取权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x bbr.sh</span><br></pre></td></tr></table></figure><h4 id="启动BBR安装"><a href="#启动BBR安装" class="headerlink" title="启动BBR安装"></a>启动BBR安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bbr.sh</span><br></pre></td></tr></table></figure><p>这步安装也蛮久的</p><p>按任意键安装，完成之后提示是否重启，输入y确定重启</p><p>重启之后</p><p>输入以下的指令查看BBR是否启动，若提示tcp_bbr则成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><h2 id="4-在客户端重启ss，享受你的丝滑ss吧"><a href="#4-在客户端重启ss，享受你的丝滑ss吧" class="headerlink" title="4.在客户端重启ss，享受你的丝滑ss吧"></a>4.在客户端重启ss，享受你的丝滑ss吧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service shadowsocks restart</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><p>1.使用vultr(vps)搭建ss并开启BBR快速上网教程 超简单10分钟搞定</p><p><a href="https://wistbean.github.io/vultr-vps-bbr-ss.html" target="_blank" rel="noopener">https://wistbean.github.io/vultr-vps-bbr-ss.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）&quot;&gt;&lt;a href=&quot;#1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="shadowsocks" scheme="https://colalinn.github.io/categories/shadowsocks/"/>
    
    
      <category term="shadowsocks" scheme="https://colalinn.github.io/tags/shadowsocks/"/>
    
      <category term="vpn" scheme="https://colalinn.github.io/tags/vpn/"/>
    
      <category term="centos" scheme="https://colalinn.github.io/tags/centos/"/>
    
      <category term="vutlr" scheme="https://colalinn.github.io/tags/vutlr/"/>
    
  </entry>
  
  <entry>
    <title>pRide具体方案</title>
    <link href="https://colalinn.github.io/2020/01/23/2020-01-23-pRide-optimized-construction/"/>
    <id>https://colalinn.github.io/2020/01/23/2020-01-23-pRide-optimized-construction/</id>
    <published>2020-01-23T08:05:04.000Z</published>
    <updated>2020-02-26T16:24:42.596Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162426100.png" alt="图1"></p><center>这是一篇pRide具体方案的翻译简化版</center><a id="more"></a><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>初始方案暂且不谈，先说优化方案。</p><p>一：地图分块，减少计算量</p><p>二：把路网嵌入向量打包起来，使得加密等操作可以一步完成</p><h3 id="步骤：Setup、Location-update、Ride-request、Ride-matching"><a href="#步骤：Setup、Location-update、Ride-request、Ride-matching" class="headerlink" title="步骤：Setup、Location-update、Ride-request、Ride-matching"></a>步骤：Setup、Location-update、Ride-request、Ride-matching</h3><p>为了保证分块后的精度，我们首先寻找与乘客所处区域α的最近司机，再以乘客到该司机的距离为半径来判断区域α周围的区域是否划入范围（就是看以该距离为半径的圆是否“触”到了周围区域）</p><h3 id="使用技术："><a href="#使用技术：" class="headerlink" title="使用技术："></a>使用技术：</h3><p>路网嵌入（ROAD NETWORK ENBEDDING），用于提高最短距离计算效率</p><p>同态加密 （Homomorphic），用于提供密文状态下的加法（及乘法）同步到明文中</p><p>混淆电路（Garbled Circuit），用于提供CP（Crypto Provider）和ORH服务器的安全两方计算、有点像零知识证明</p><h3 id="一、初始化-Setup"><a href="#一、初始化-Setup" class="headerlink" title="一、初始化   Setup"></a>一、初始化   Setup</h3><p>1.ORH   地图分块(如图1所示)</p><p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162426100.png" alt="图1"></p><p>​                                                                                  图  1</p><p>2.ORH   计算  地图道路的   路网嵌入向量</p><p>3.CP   初始化同态加密公钥并分发</p><h3 id="二、司机-位置更新-Location-update"><a href="#二、司机-位置更新-Location-update" class="headerlink" title="二、司机 位置更新   Location-update"></a>二、司机 位置更新   Location-update</h3><p>此步骤主要用于司机上传自己的位置信息（在pRide里是上传自己的路网嵌入信息）</p><p>1.司机端   计算自己的路网嵌入变量S</p><p>根据从服务器获取的地图道路路网嵌入向量、来在本地计算自己的路网嵌入向量S（这在路网嵌入已经讲过了）</p><p>2.司机端   把S打包成一个变量P</p><p>就是像进制位一样叠加维度S(如图2)</p><p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162003661.png" alt="图2"></p><p>​                                                                                  图  2</p><p>3.司机端   把P用从CP获得的公钥加密成[P(b)]，把这个[P(b)]和所处区域Zα上传到ORH</p><p>4.ORH   随机生成一个路网嵌入向量u，并加密之成[P(u)]</p><p>5.ORH   使用[P(b)]-[P(u)]=&gt;[P(b‘)]</p><h3 id="三、乘客-乘车请求-Ride-request"><a href="#三、乘客-乘车请求-Ride-request" class="headerlink" title="三、乘客 乘车请求   Ride-request"></a>三、乘客 乘车请求   Ride-request</h3><p>1.乘客端   把自己的坐标x、y加密为[x]、[y]</p><p>2.乘客端   计算自己的路网嵌入向量S、打包、加密之得到[P(a)]</p><p>3.乘客端 上传[P(a)]、[x]、[y]、所处区域Zα给ORH</p><p>4.ORH   随机生成两随机数ηx、ηy，把其当做一个坐标值，计算其的网嵌入向量S、打包、加密之得到[P(η)]</p><p>5.ORH   计算    [P(η)]-[P(a)]=》[P(a’)]       ;        [x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]</p><p>《第五步是为了在4.2提高匹配精度的阶段判断坐标，所以把坐标也放到了距离向量中[P(a)]》</p><h3 id="四、ORH-乘车匹配-Ride-matching"><a href="#四、ORH-乘车匹配-Ride-matching" class="headerlink" title="四、ORH 乘车匹配   Ride-matching"></a>四、ORH 乘车匹配   Ride-matching</h3><h4 id="4-1-乘客所属区域zα匹配-Local-Zone-matching"><a href="#4-1-乘客所属区域zα匹配-Local-Zone-matching" class="headerlink" title="4.1.乘客所属区域zα匹配    Local Zone matching"></a>4.1.乘客所属区域zα匹配    Local Zone matching</h4><p>1.ORH   计算   [P(d)’]=[P(a)]-[P(b‘)]=[P(a)]-[P(b)]+[P(u)]</p><p>2.ORH   将 [P(d)’]发给CP</p><p>3.CP   解密 [P(d)’]得到 P(d)’、并且获得其混淆值 ~P(d)’   《这里的混淆电路还不太明白怎么操作的》</p><p>4.ORH   通过1-out-of-2 OT protocol 获得[P(u)]的混淆值  ~[P(u)]</p><p>5.通过算法2(如图3)判断两个司机哪个离乘客近</p><p>算法注释：</p><p>第一、二步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p><p>第三、四步同上计算第二个司机到该乘客的最近距离</p><p>第五步是判断哪个司机离乘客近</p><p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123170731309.png" alt="图3"></p><p>​                                                            图  3   上为算法、下为混淆电路</p><h4 id="4-2-提高匹配精度-Refinement"><a href="#4-2-提高匹配精度-Refinement" class="headerlink" title="4.2.提高匹配精度   Refinement"></a>4.2.提高匹配精度   Refinement</h4><p>1.ORH   把4.1中计算出来的，乘客所处区域zα与最近司机的[P(d)’] (4.1.1中计算)、</p><p>与[x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]都发给CP</p><p>2.CP   将其解密并获得混淆值 <del>P(d)’、</del>[x’]、~[y’]</p><p>3.ORH   通过1-out-of-2 OT protocol 获得~[P(η)]    ;        ~[ηx]    ;        ~[ηy]</p><p>4.通过如下图算法3(如图4)判断其他八块区域za1, za2, za3, za4, za5, za6, za7,za8（具体见图1）是否有需要计算的必要</p><p>算法注释：</p><p>第四步是计算乘客的坐标x、y</p><p>第五、六步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p><p>第七步是计算Γ   Γ是一个8位的二进制数，每一位指示一个区域是否该计算（就是看以该距离为半径的圆是否“触”到了周围区域，具体看图1）</p><p>第八步是判断 区域zα4是否该计算，后面9到15步同理，是很简单的距离判断（见图一）</p><p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123171733353.png" alt="图4"></p><p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123171824965.png" alt="图4"></p><p>​                                                            图  4   上为算法、下为混淆电路</p><p>5.通过算法3获得有需要计算得必要的其他区域、</p><p>然后通过4.1Local Zone matching算法计算该区域中离乘客最近的司机，若该司机到乘客的距离B比乘客到本区域最短距离A小，就刷新最短距离A。最终我们得到距离最近的司机，并且将乘客位置信息发送给他………</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162426100.png&quot; alt=&quot;图1&quot;&gt;&lt;/p&gt;
&lt;center&gt;这是一篇pRide具体方案的翻译简化版&lt;/center&gt;
    
    </summary>
    
    
      <category term="大创" scheme="https://colalinn.github.io/categories/%E5%A4%A7%E5%88%9B/"/>
    
    
      <category term="pRide" scheme="https://colalinn.github.io/tags/pRide/"/>
    
  </entry>
  
  <entry>
    <title>路网嵌入 ROAD NETWORK EMBEDDING</title>
    <link href="https://colalinn.github.io/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/"/>
    <id>https://colalinn.github.io/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/</id>
    <published>2020-01-22T09:51:25.000Z</published>
    <updated>2020-02-26T16:25:22.902Z</updated>
    
    <content type="html"><![CDATA[<p>路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。</p><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。</p><blockquote><p>Road Network Embedding (RNE), proposed by Shahabi et al.* [12], is an approach to compute shortest path distance in road networks, which bases on the LLR embedding techniques [19]. RNE transforms a road network into a higher dimensional space by assigning a sketch (i.e., a vector) to every node such that the distance between any two nodes can be efficiently approximated using only their sketches.</p></blockquote><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>(1) 设G=(V,E)为路网（road network）</p><p>V代表道路之间的交叉节点，E（edge）代表道路。</p><p>(2)  V有n个，把V分成<strong>n个子集</strong>如下</p><p>V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}</p><blockquote><p>Let n = |V | be the size of the node set V . Define R as a set of O(log2n) reference sets, which are subsets of V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}, where α = O(log n) and β = O(log n).</p><p> Each subset Vi,ji is defined as a random subset of <em>V</em> with 2<em>i</em> nodes randomly chosen from <em>V</em> . </p></blockquote><p>(3) 一个节点到一个子集Vij的距离即该节点到这个子集的最近距离所有节点距离的最小值</p><blockquote><p>The distance between node v and subset Vi,j is defined as dist(v, Vi,j ) = minw∈Vi,j dist(v, w)</p></blockquote><p>(4) 对于一个节点，把其到每个子集的最短距离记录下来，构成一个S集，这个S集就是该节点的<strong>路网嵌入向量</strong>，然后我们把所有的向量放在一起，构成路网嵌入数据集。</p><p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212143074.png" alt="4图"></p><p>(5) 假设一个点u，处于节点s和t之间，该节点u到某个子集Vij之间的距离可以如下公式计算，</p><p>dist(u，s)为点u到节点s的距离,dist(u,t)同理。</p><p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212358662.png" alt="aaa"></p><p>(6) 根据上面的分析，对于该点u，我们也可以得到一个<strong>路网嵌入向量</strong>如下</p><p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212654581.png" alt="6图"></p><p>(7) 最终，我们可以计算任意两点a,b的最短距离</p><p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212907442.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大创" scheme="https://colalinn.github.io/categories/%E5%A4%A7%E5%88%9B/"/>
    
    
      <category term="pRide" scheme="https://colalinn.github.io/tags/pRide/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用配置记录</title>
    <link href="https://colalinn.github.io/2020/01/20/2020-01-20-hexo/"/>
    <id>https://colalinn.github.io/2020/01/20/2020-01-20-hexo/</id>
    <published>2020-01-20T02:31:50.000Z</published>
    <updated>2020-03-03T16:27:47.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的hexo命令"><a href="#简单的hexo命令" class="headerlink" title="简单的hexo命令"></a>简单的hexo命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.文章的生成及编辑</span><br><span class="line">hexo new “文章标题”</span><br><span class="line">博客所在路径\source_posts\”下生成一个md文件，文件名称为上面命令行所输入的文章标题</span><br><span class="line"></span><br><span class="line">2.文件发布</span><br><span class="line">hexo g generate</span><br><span class="line"></span><br><span class="line">3.本地测试</span><br><span class="line">hexo s </span><br><span class="line">访问localhost:4000来查看变化</span><br><span class="line"></span><br><span class="line">4.同步到github</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line">5.Hexo更换主题并发布到github</span><br><span class="line">安装hexo-deployer-git自动部署发布工具</span><br><span class="line">npm install hexo-deployer-git  --save</span><br><span class="line">发布到GitHub</span><br><span class="line">输入如下命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line">6.如何一键式发布</span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br><span class="line">可用以下简化（注意事项：下面的命令中 E:\github_repo\hexo_blog 是我博客的文件夹路径，请替换为你自己博客的路径，在git bash中输入命令）以后可以用hexo fuck来发布了</span><br><span class="line">git config --global alias.fuck &#39;!cd E:\github_repo\hexo_blog;hexo clean;hexo g;hexo d&#39;</span><br><span class="line">git fuck</span><br><span class="line">取消别名</span><br><span class="line">git config --global --unset alias.fuck</span><br></pre></td></tr></table></figure><h1 id="简单的markdown语法"><a href="#简单的markdown语法" class="headerlink" title="简单的markdown语法"></a>简单的markdown语法</h1><p><img src="/2020/01/20/2020-01-20-hexo/markdown-program.jpg" alt="markdown语法"></p><hr><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>1.GitHub+Hexo搭建个人博客（包括更改主题）真·从git、node.js从头教起必看</p><p><a href="https://blog.csdn.net/qq_37651252/article/details/97024874" target="_blank" rel="noopener">https://blog.csdn.net/qq_37651252/article/details/97024874</a> </p><p>2.通过hexo更新github pages博客</p><p><a href="https://www.jianshu.com/p/5fe8e618002d" target="_blank" rel="noopener">https://www.jianshu.com/p/5fe8e618002d</a></p><p>3.更换主题并且发布</p><p><a href="https://www.jianshu.com/p/20e1431abb83" target="_blank" rel="noopener">https://www.jianshu.com/p/20e1431abb83</a></p><p>4.Hexo的Next主题详细配置</p><p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p><p>5.初级看板娘</p><p><a href="https://blog.csdn.net/weixin_33738982/article/details/89621120" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33738982/article/details/89621120</a></p><p>6.进阶版看板娘</p><p><a href="https://blog.csdn.net/qq_39610915/article/details/90679768" target="_blank" rel="noopener">https://blog.csdn.net/qq_39610915/article/details/90679768</a></p><p>7.Hexo NexT 代码块复制功能</p><p><a href="https://www.jianshu.com/p/3e9d614c1e77" target="_blank" rel="noopener">https://www.jianshu.com/p/3e9d614c1e77</a></p><p>8.Hexo写博客时的图片问题</p><p><a href="https://blog.csdn.net/TimeJjc/article/details/86707165" target="_blank" rel="noopener">https://blog.csdn.net/TimeJjc/article/details/86707165</a></p><p>9.Hexo NexT主题中集成gitalk评论系统</p><p><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/01/20/gitalk/</a></p><p>10.Hexo博客提交百度和Google收录</p><p><a href="https://www.jianshu.com/p/f8ec422ebd52" target="_blank" rel="noopener">https://www.jianshu.com/p/f8ec422ebd52</a></p><p>Hexo优化:创建sitemap站点地图并向Google站长工具提交</p><p><a href="https://blog.csdn.net/MobiusStrip/article/details/87258612" target="_blank" rel="noopener">https://blog.csdn.net/MobiusStrip/article/details/87258612</a></p><p>Google sitemap 不允许的网址的解决办法</p><p><a href="https://alanlee.fun/2017/12/30/google-sitemap/" target="_blank" rel="noopener">https://alanlee.fun/2017/12/30/google-sitemap/</a></p><p>11.markdown语法简介</p><p><a href="http://www.markdown.cn/" target="_blank" rel="noopener">http://www.markdown.cn/</a></p><p>12.更多优化如加载进度条等</p><p><a href="https://zhuanlan.zhihu.com/p/85037898" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85037898</a></p><p>13.Hexo添加字数统计、阅读时长</p><p><a href="https://blog.csdn.net/weixin_33753003/article/details/86257475" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33753003/article/details/86257475</a></p><p>14.Hexo博客NexT主题美化之自定义文章底部版权声明</p><p><a href="https://www.jianshu.com/p/93170e7413e9" target="_blank" rel="noopener">https://www.jianshu.com/p/93170e7413e9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单的hexo命令&quot;&gt;&lt;a href=&quot;#简单的hexo命令&quot; class=&quot;headerlink&quot; title=&quot;简单的hexo命令&quot;&gt;&lt;/a&gt;简单的hexo命令&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://colalinn.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://colalinn.github.io/tags/hexo/"/>
    
      <category term="others" scheme="https://colalinn.github.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>test2</title>
    <link href="https://colalinn.github.io/2020/01/15/2020-01-15-jottings/"/>
    <id>https://colalinn.github.io/2020/01/15/2020-01-15-jottings/</id>
    <published>2020-01-15T11:40:22.000Z</published>
    <updated>2020-02-25T16:00:15.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>别来无恙啊</p><h3 id="2020-1-21"><a href="#2020-1-21" class="headerlink" title="2020.1.21"></a>2020.1.21</h3><p>今天武汉不明肺炎又进一步扩散了，讨论甚多</p><h3 id="2020-1-25-“大年初一，百病不侵”"><a href="#2020-1-25-“大年初一，百病不侵”" class="headerlink" title="2020.1.25  “大年初一，百病不侵”"></a>2020.1.25  “大年初一，百病不侵”</h3><p>大年初一，2019ncov已经严重到湖北禁省，各省份一级公共卫生响应。武汉将建两座“小汤山”医院，火神山、雷神山，今年春节愿我们百病不侵</p><h3 id="2020-1-27"><a href="#2020-1-27" class="headerlink" title="2020.1.27"></a>2020.1.27</h3><p>今天做了一道leetcode的最长回文子串</p><h3 id="2020-1-28-“成固欣然、败亦可喜”"><a href="#2020-1-28-“成固欣然、败亦可喜”" class="headerlink" title="2020.1.28  “成固欣然、败亦可喜”"></a>2020.1.28  “成固欣然、败亦可喜”</h3><p>今天疫情确诊人数突增2000+人，应该是试剂盒增加的原因，我有预感很快就能控制住。</p><p>今天Hexo做好了文章的图片，还有评论功能，leetcode做了一道Z”字符串”</p><h3 id="2020-1-30"><a href="#2020-1-30" class="headerlink" title="2020.1.30"></a>2020.1.30</h3><p>今天突增3000+人，今日配tensorflow环境，刷了两道题，无事发生</p><h3 id="2020-02-02-“对称日”"><a href="#2020-02-02-“对称日”" class="headerlink" title="2020.02.02 “对称日”"></a>2020.02.02 “对称日”</h3><p>这两日对确诊人数的增长已经麻木，只是身边的同学家里受到影响，很难受。</p><p>一直以为疫情还离自己很远，可当灾难来临时，降临到了身边的人时。</p><p>才知道灾难有多无情，才知道自己有多无力。</p><h3 id="2020-02-10-“奥里给”"><a href="#2020-02-10-“奥里给”" class="headerlink" title="2020.02.10 “奥里给”"></a>2020.02.10 “奥里给”</h3><p>没有什么是简单的</p><h3 id="2020-02-20-“还得继续加油”"><a href="#2020-02-20-“还得继续加油”" class="headerlink" title="2020.02.20 “还得继续加油”"></a>2020.02.20 “还得继续加油”</h3><p>这么久来，大创终于向前进了一步，还是希望自己能挺住吧，别轻易放弃</p><h3 id="2020-02-25-“壁立千仞，无欲则刚”"><a href="#2020-02-25-“壁立千仞，无欲则刚”" class="headerlink" title="2020.02.25 “壁立千仞，无欲则刚”"></a>2020.02.25 “壁立千仞，无欲则刚”</h3><p>今天，我制作了简历，给内推的学长看了。</p><p>结果学长表示java技术细节列的太少，做后端得知道操作系统、springMVC、springboot的应用及原理。</p><p>最好是源码级的，所以，我的眼前，又延伸出一条路，总的来说，还是略有迷茫。</p><p>壁立千仞，无欲则刚。</p><p>咱们    走着瞧。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;随笔&quot;&gt;&lt;a href=&quot;#随笔&quot; class=&quot;headerlink&quot; title=&quot;随笔&quot;&gt;&lt;/a&gt;随笔&lt;/h1&gt;&lt;p&gt;别来无恙啊&lt;/p&gt;
&lt;h3 id=&quot;2020-1-21&quot;&gt;&lt;a href=&quot;#2020-1-21&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://colalinn.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="-随笔" scheme="https://colalinn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
