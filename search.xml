<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pRide具体方案</title>
    <url>/2020/01/23/2020-1-23-pRide-optimized-construction/</url>
    <content><![CDATA[<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>初始方案暂且不谈，先说优化方案。</p>
<p>一：地图分块，减少计算量</p>
<p>二：把路网嵌入向量打包起来，使得加密等操作可以一步完成</p>
<h3 id="步骤：Setup、Location-update、Ride-request、Ride-matching"><a href="#步骤：Setup、Location-update、Ride-request、Ride-matching" class="headerlink" title="步骤：Setup、Location-update、Ride-request、Ride-matching"></a>步骤：Setup、Location-update、Ride-request、Ride-matching</h3><p>为了保证分块后的精度，我们首先寻找与乘客所处区域α的最近司机，再以乘客到该司机的距离为半径来判断区域α周围的区域是否划入范围（就是看以该距离为半径的圆是否“触”到了周围区域）</p>
<h3 id="使用技术："><a href="#使用技术：" class="headerlink" title="使用技术："></a>使用技术：</h3><p>路网嵌入（ROAD NETWORK ENBEDDING），用于提高最短距离计算效率</p>
<p>同态加密 （Homomorphic），用于提供密文状态下的加法（及乘法）同步到明文中</p>
<p>混淆电路（Garbled Circuit），用于提供CP（Crypto Provider）和ORH服务器的安全两方计算、有点像零知识证明</p>
<h3 id="一、初始化-Setup"><a href="#一、初始化-Setup" class="headerlink" title="一、初始化   Setup"></a>一、初始化   Setup</h3><p>1.ORH   地图分块(如图1所示)</p>
<p><img src="/.com//2020-1-23-pRide-optimized-construction%5Cimage-20200123162426100.png" alt="图1"></p>
<p>​                                                                                  图  1</p>
<p>2.ORH   计算  地图道路的   路网嵌入向量</p>
<p>3.CP   初始化同态加密公钥并分发</p>
<h3 id="二、司机-位置更新-Location-update"><a href="#二、司机-位置更新-Location-update" class="headerlink" title="二、司机 位置更新   Location-update"></a>二、司机 位置更新   Location-update</h3><p>此步骤主要用于司机上传自己的位置信息（在pRide里是上传自己的路网嵌入信息）</p>
<p>1.司机端   计算自己的路网嵌入变量S</p>
<p>根据从服务器获取的地图道路路网嵌入向量、来在本地计算自己的路网嵌入向量S（这在路网嵌入已经讲过了）</p>
<p>2.司机端   把S打包成一个变量P</p>
<p>就是像进制位一样叠加维度S(如图2)</p>
<p><img src="/.com//2020-1-23-pRide-optimized-construction%5Cimage-20200123162003661.png" alt="图2"></p>
<p>​                                                                                  图  2</p>
<p>3.司机端   把P用从CP获得的公钥加密成[P(b)]，把这个[P(b)]和所处区域Zα上传到ORH</p>
<p>4.ORH   随机生成一个路网嵌入向量u，并加密之成[P(u)]</p>
<p>5.ORH   使用[P(b)]-[P(u)]=&gt;[P(b‘)]</p>
<h3 id="三、乘客-乘车请求-Ride-request"><a href="#三、乘客-乘车请求-Ride-request" class="headerlink" title="三、乘客 乘车请求   Ride-request"></a>三、乘客 乘车请求   Ride-request</h3><p>1.乘客端   把自己的坐标x、y加密为[x]、[y]</p>
<p>2.乘客端   计算自己的路网嵌入向量S、打包、加密之得到[P(a)]</p>
<p>3.乘客端 上传[P(a)]、[x]、[y]、所处区域Zα给ORH</p>
<p>4.ORH   随机生成两随机数ηx、ηy，把其当做一个坐标值，计算其的网嵌入向量S、打包、加密之得到[P(η)]</p>
<p>5.ORH   计算    [P(η)]-[P(a)]=》[P(a’)]       ;        [x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]</p>
<p>《第五步是为了在4.2提高匹配精度的阶段判断坐标，所以把坐标也放到了距离向量中[P(a)]》</p>
<h3 id="四、ORH-乘车匹配-Ride-matching"><a href="#四、ORH-乘车匹配-Ride-matching" class="headerlink" title="四、ORH 乘车匹配   Ride-matching"></a>四、ORH 乘车匹配   Ride-matching</h3><h4 id="4-1-乘客所属区域zα匹配-Local-Zone-matching"><a href="#4-1-乘客所属区域zα匹配-Local-Zone-matching" class="headerlink" title="4.1.乘客所属区域zα匹配    Local Zone matching"></a>4.1.乘客所属区域zα匹配    Local Zone matching</h4><p>1.ORH   计算   [P(d)’]=[P(a)]-[P(b‘)]=[P(a)]-[P(b)]+[P(u)]</p>
<p>2.ORH   将 [P(d)’]发给CP</p>
<p>3.CP   解密 [P(d)’]得到 P(d)’、并且获得其混淆值 ~P(d)’   《这里的混淆电路还不太明白怎么操作的》</p>
<p>4.ORH   通过1-out-of-2 OT protocol 获得[P(u)]的混淆值  ~[P(u)]</p>
<p>5.通过算法2(如图3)判断两个司机哪个离乘客近</p>
<p>算法注释：</p>
<p>第一、二步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p>
<p>第三、四步同上计算第二个司机到该乘客的最近距离</p>
<p>第五步是判断哪个司机离乘客近</p>
<p><img src="/.com//2020-1-23-pRide-optimized-construction%5Cimage-20200123170731309.png" alt="图3"></p>
<p>​                                                            图  3   上为算法、下为混淆电路</p>
<h4 id="4-2-提高匹配精度-Refinement"><a href="#4-2-提高匹配精度-Refinement" class="headerlink" title="4.2.提高匹配精度   Refinement"></a>4.2.提高匹配精度   Refinement</h4><p>1.ORH   把4.1中计算出来的，乘客所处区域zα与最近司机的[P(d)’] (4.1.1中计算)、</p>
<p>与[x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]都发给CP</p>
<p>2.CP   将其解密并获得混淆值 <del>P(d)’、</del>[x’]、~[y’]</p>
<p>3.ORH   通过1-out-of-2 OT protocol 获得~[P(η)]    ;        ~[ηx]    ;        ~[ηy]</p>
<p>4.通过如下图算法3(如图4)判断其他八块区域za1, za2, za3, za4, za5, za6, za7,za8（具体见图1）是否有需要计算的必要</p>
<p>算法注释：</p>
<p>第四步是计算乘客的坐标x、y</p>
<p>第五、六步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p>
<p>第七步是计算Γ   Γ是一个8位的二进制数，每一位指示一个区域是否该计算（就是看以该距离为半径的圆是否“触”到了周围区域，具体看图1）</p>
<p>第八步是判断 区域zα4是否该计算，后面9到15步同理，是很简单的距离判断（见图一）</p>
<p><img src="/.com//2020-1-23-pRide-optimized-construction%5Cimage-20200123171733353.png" alt="图4"></p>
<p><img src="/.com//2020-1-23-pRide-optimized-construction%5Cimage-20200123171824965.png" alt="图4"></p>
<p>​                                                            图  4   上为算法、下为混淆电路</p>
<p>5.通过算法3获得有需要计算得必要的其他区域、</p>
<p>然后通过4.1Local Zone matching算法计算该区域中离乘客最近的司机，若该司机到乘客的距离B比乘客到本区域最短距离A小，就刷新最短距离A。最终我们得到距离最近的司机，并且将乘客位置信息发送给他………</p>
]]></content>
      <categories>
        <category>大创</category>
      </categories>
      <tags>
        <tag>pRide</tag>
      </tags>
  </entry>
  <entry>
    <title>路网嵌入 ROAD NETWORK EMBEDDING</title>
    <url>/2020/01/22/2020-1-22-ROAD-NETWORK-EMBEDDING/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。</p>
<blockquote>
<p>Road Network Embedding (RNE), proposed by Shahabi et al.* [12], is an approach to compute shortest path distance in road networks, which bases on the LLR embedding techniques [19]. RNE transforms a road network into a higher dimensional space by assigning a sketch (i.e., a vector) to every node such that the distance between any two nodes can be efficiently approximated using only their sketches.</p>
</blockquote>
<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>(1) 设G=(V,E)为路网（road network）</p>
<p>V代表道路之间的交叉节点，E（edge）代表道路。</p>
<p>(2)  V有n个，把V分成<strong>n个子集</strong>如下</p>
<p>V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}</p>
<blockquote>
<p>Let n = |V | be the size of the node set V . Define R as a set of O(log2n) reference sets, which are subsets of V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}, where α = O(log n) and β = O(log n).</p>
<p> Each subset Vi,ji is defined as a random subset of <em>V</em> with 2<em>i</em> nodes randomly chosen from <em>V</em> . </p>
</blockquote>
<p>(3) 一个节点到一个子集Vij的距离即该节点到这个子集的最近距离所有节点距离的最小值</p>
<blockquote>
<p>The distance between node v and subset Vi,j is defined as dist(v, Vi,j ) = minw∈Vi,j dist(v, w)</p>
</blockquote>
<p>(4) 对于一个节点，把其到每个子集的最短距离记录下来，构成一个S集，这个S集就是该节点的<strong>路网嵌入向量</strong>，然后我们把所有的向量放在一起，构成路网嵌入数据集。</p>
<p><img src="/.com//image-20200122212143074.png" alt="4图"></p>
<p>(5) 假设一个点u，处于节点s和t之间，该节点u到某个子集Vij之间的距离可以如下公式计算，</p>
<p>dist(u，s)为点u到节点s的距离,dist(u,t)同理。</p>
<p><img src="/.com//image-20200122212358662.png" alt="aaa"></p>
<p>(6) 根据上面的分析，对于该点u，我们也可以得到一个<strong>路网嵌入向量</strong>如下</p>
<p><img src="/.com//image-20200122212654581.png" alt="6图"></p>
<p>(7) 最终，我们可以计算任意两点a,b的最短距离</p>
<p><img src="/.com//image-20200122212907442.png" alt></p>
]]></content>
      <categories>
        <category>大创</category>
      </categories>
      <tags>
        <tag>pRide</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用配置记录</title>
    <url>/2020/01/20/20-1-20/</url>
    <content><![CDATA[<h1 id="从简单的hexo命令开始"><a href="#从简单的hexo命令开始" class="headerlink" title="从简单的hexo命令开始"></a>从简单的hexo命令开始</h1><h4 id><a href="#" class="headerlink" title></a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.文章的生成及编辑</span><br><span class="line">hexo new “文章标题”</span><br><span class="line">博客所在路径\source_posts\”下生成一个md文件，文件名称为上面命令行所输入的文章标题</span><br><span class="line"></span><br><span class="line">2.文件发布</span><br><span class="line">hexo g generate</span><br><span class="line"></span><br><span class="line">3.本地测试</span><br><span class="line">hexo s </span><br><span class="line">访问localhost:4000来查看变化</span><br><span class="line"></span><br><span class="line">4.同步到github</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line">5.Hexo更换主题并发布到github</span><br><span class="line">安装hexo-deployer-git自动部署发布工具</span><br><span class="line">npm install hexo-deployer-git  --save</span><br><span class="line">发布到GitHub</span><br><span class="line">输入如下命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line">6.如何一键式发布</span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br><span class="line">可用以下简化（注意事项：下面的命令中 C:\blog_backup 是我博客的文件夹路径，请替换为你自己博客的路径，在git bash中输入命令）以后可以用hexo fuck来发布了</span><br><span class="line">git config --global alias.fuck &#39;!cd C:\blog_backup;hexo clean;hexo g -d&#39;</span><br><span class="line">git fuck</span><br><span class="line">取消别名</span><br><span class="line">git config --global --unset alias.fuck</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>1.GitHub+Hexo搭建个人博客（包括更改主题）真·从git、node.js从头教起必看</p>
<p><a href="https://blog.csdn.net/qq_37651252/article/details/97024874" target="_blank" rel="noopener">https://blog.csdn.net/qq_37651252/article/details/97024874</a> </p>
<p>2.通过hexo更新github pages博客</p>
<p><a href="https://www.jianshu.com/p/5fe8e618002d" target="_blank" rel="noopener">https://www.jianshu.com/p/5fe8e618002d</a></p>
<p>3.更换主题并且发布</p>
<p><a href="https://www.jianshu.com/p/20e1431abb83" target="_blank" rel="noopener">https://www.jianshu.com/p/20e1431abb83</a></p>
<p>4.Hexo的Next主题详细配置</p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p>5.初级看板娘</p>
<p><a href="https://blog.csdn.net/weixin_33738982/article/details/89621120" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33738982/article/details/89621120</a></p>
<p>6.进阶版看板娘</p>
<p><a href="https://blog.csdn.net/qq_39610915/article/details/90679768" target="_blank" rel="noopener">https://blog.csdn.net/qq_39610915/article/details/90679768</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>test2</title>
    <url>/2020/01/15/%E2%80%98test2/</url>
    <content><![CDATA[<h1 id="第二篇测试"><a href="#第二篇测试" class="headerlink" title="第二篇测试"></a>第二篇测试</h1><p>别来无恙啊</p>
<p>2020.1.21 今天武汉不明肺炎又进一步扩散了，讨论甚多</p>
<p>2020.1.25  大年初一，2019ncov已经严重到湖北禁省，各省份一级公共卫生响应，武汉将建两座“小汤山”医院，火神山、雷神山，今年春节愿我们百病不侵</p>
]]></content>
      <tags>
        <tag>test-tag</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2020/01/15/hello-world/</url>
    <content><![CDATA[<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world!"></a>hello world!</h1><h1 id="github-ColaLinN"><a href="#github-ColaLinN" class="headerlink" title="github: ColaLinN"></a>github: ColaLinN</h1>]]></content>
      <categories>
        <category>hello world!</category>
      </categories>
      <tags>
        <tag>hello world!</tag>
      </tags>
  </entry>
</search>
